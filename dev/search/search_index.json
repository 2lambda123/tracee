{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Overview","text":"<p>Before moving on, make sure to give us a star at the GitHub Project if you liked it. That is important for us. Thank you!</p> <p> </p>"},{"location":"#tracee-runtime-security-and-forensics-using-ebpf","title":"Tracee: Runtime Security and Forensics using eBPF","text":"<p>Tracee is a runtime security and forensics tool for Linux based cloud deployments. It uses eBPF to trace the host OS and applications at runtime, and analyzes collected events in order to detect suspicious behavioral patterns. It can be run as a daemon-set in your kubernetes environment, but is flexible to be run for many purposes on any Linux based hosts. It can be delivered via Helm, as a docker container, or as a small set of static binaries.</p> <p>The goal of Tracee is to serve as an easy to use and effective solution for learning  when cloud native attacks occur in your environment. By leveraging Aqua's advanced  security research, performant eBPF based detection, and cloud native first approach Tracee makes runtime detection accesible, powerful, and effective.</p> <p>Watch a quick video demo of Tracee:</p> <p></p> <p>Check out the Tracee video hub for more videos.</p>"},{"location":"#quickstart-kubernetes","title":"Quickstart (Kubernetes)","text":"<p>Tracee is designed to monitor hosts in kubernetes clusters. To see this in action check out the quickstart here.</p>"},{"location":"#quickstart-docker","title":"Quickstart (docker)","text":"<p>To get a closer feel for what tracee accomplishes, you can run tracee on your local machine. Follow along to the quickstart here</p>"},{"location":"#components","title":"Components","text":"<p>Tracee is composed of the following sub-projects, which are hosted in the aquasecurity/tracee repository:</p> <ul> <li>Tracee-eBPF - Linux Tracing and Forensics using eBPF</li> <li>Tracee-Rules - Runtime Security Detection Engine</li> </ul> <p>Tracee is an Aqua Security open source project. Learn about our open source work and portfolio Here. Join the community, and talk to us about any matter in GitHub Discussion or Slack.</p>"},{"location":"contributing/guidelines/","title":"Source Code Guidelines","text":""},{"location":"contributing/guidelines/#style-guide-for-contributors","title":"Style Guide for Contributors","text":"<p>For those willing to contribute to Tracee, this repository has code formatting guidelines being enforced. It is recommended that, before commiting your changes, you run the following command:</p> <ol> <li>Check for formatting issues</li> </ol> <p>Check-fmt</p> <pre><code>$ make check-fmt\nChecking C and eBPF files and headers formatting...\nChecking golang files formatting...\n</code></pre> <p>This will make sure PRs won't fail due to same checks being enforced.</p> <ol> <li>Fix Go and C source files formatting</li> </ol> <p>Fix-fmt</p> <pre><code>$ make fix-fmt\n\nFixing C and eBPF files and headers formatting...\nFormatting ./pkg/ebpf/c/missing_definitions.h\nFormatting ./pkg/ebpf/c/struct_flavors.h\nFormatting ./pkg/ebpf/c/tracee.bpf.c\nFormatting ./pkg/ebpf/c/vmlinux.h\n\nFixing golang files formatting...\npatching file pkg/ebpf/tracee.go\n\n$ git status -s\n M Makefile\n M builder/Makefile.checkers\n M pkg/ebpf/c/missing_definitions.h\n M pkg/ebpf/c/struct_flavors.h\n M pkg/ebpf/c/tracee.bpf.c\n M pkg/ebpf/c/vmlinux.h\n</code></pre> <ol> <li>Static Check Go and C source files</li> </ol> <p>Code-check</p> <pre><code>$ make code-check\n\nChecking Golang vet...\nmake[2]: warning: jobserver unavailable: using -j1.  Add '+' to parent make rule.\nGOOS=linux CC=clang GOARCH=amd64 CGO_CFLAGS=\"-I/home/rafaeldtinoco/work/ebpf/tracee-review/dist/libbpf\" CGO_LDFLAGS=\"-lelf -lz /home/rafaeldtinoco/work/ebpf/tracee-review/dist/libbpf/libbpf.a\" \\\ngo vet \\\n    -tags core,ebpf \\\n    ./...\n\nChecking Golang with StaticChecker...\nmake[2]: warning: jobserver unavailable: using -j1.  Add '+' to parent make rule.\nGOOS=linux CC=clang GOARCH=amd64 CGO_CFLAGS=\"-I/home/rafaeldtinoco/work/ebpf/tracee-review/dist/libbpf\" CGO_LDFLAGS=\"-lelf -lz /home/rafaeldtinoco/work/ebpf/tracee-review/dist/libbpf/libbpf.a\" \\\nstaticcheck -f stylish \\\n    -tags core,ebpf \\\n    ./...\n \u2716 0 problems (0 errors, 0 warnings, 0 ignored)\n</code></pre>"},{"location":"contributing/overview/","title":"Overview","text":""},{"location":"contributing/overview/#contributing","title":"Contributing","text":"<p>Thank you for taking interest in contributing to Tracee! This document covers our working practices and conventions.</p>"},{"location":"contributing/overview/#issues-and-discussions","title":"Issues and Discussions","text":"<p>We encourage open discussion and collaboration using both GitHub Issues and Discussions.  </p> <ul> <li>Discussions are free-style conversational tool, we use them for conversations.</li> <li>Issues are project management tool, we use them to keep track on who's working on what and plan ahead.</li> </ul> <p>If you have a suggestion, question, or a general comment - please use Discussions. If there's a clear work item (including bugs) - you can open an Issue.</p>"},{"location":"contributing/overview/#discussions","title":"Discussions:","text":"<ul> <li>We have the following discussion topics: <ol> <li>Announcements: One way communication from the team to the community. Consider this like our mini blog</li> <li>Questions and Help: For help and support. Consider this similar to StackOverflow.</li> <li>Development: For discussing potential features, and collaborating on their design.</li> </ol> </li> </ul>"},{"location":"contributing/overview/#issues","title":"Issues:","text":"<ol> <li>Every issue needs to be actionable and assignable. Consider the scope of the issue if assigned to one person, and break down if necessary.</li> <li>Be clear and definitive when composing issues. For bug reports, include detailed error messages and environment description. For features, include a clear scope and acceptance criteria.</li> <li>Since we have different projects under the same monorepo, use labels to denote areas that the issue relates to:<ol> <li><code>tracee-ebpf</code></li> <li><code>tracee-rules</code></li> <li><code>signatures</code></li> <li>If non of the labels is relevant don't add any (usually for top-level issues)</li> </ol> </li> <li>We use the following labels to describe the type of issue:<ol> <li><code>bug</code></li> <li><code>good-first-issue</code></li> </ol> </li> <li>Self-assign or request assignment for issues you intend to work on. Don't work on an issue assigned to someone else without checking with them first and reassigning.</li> </ol>"},{"location":"contributing/overview/#pull-requests","title":"Pull Requests","text":"<ol> <li>Every Pull Request should have an associated Issue unless it is a trivial fix.</li> <li>When adding a flag option or other UX related change, make sure the design is explicitly described in the associated issue, and a maintainer approved it.</li> <li>Commit subject should succinctly describe the change:<ol> <li>Max 50 chars.</li> <li>Written in imperative mood: begin with a verb like \"fix\", \"add\", \"improve\", or \"refactor\"; Think \"once applied, this commit will...\".</li> <li>If ambiguous, mention the area that this commit affects (see area labels above).</li> </ol> </li> <li>Optional commit body (separated by empty line from subject) may explain why the change was made and not how. Wrap at 72 chars.</li> <li>Code related information should be in commit message, review related information should be in PR description.</li> <li>For changes that span different areas please try to make each change self contained and independent.</li> </ol>"},{"location":"contributing/overview/#code","title":"Code","text":"<ol> <li>Follow Golang's code review standards: https://github.com/golang/go/wiki/CodeReviewComments.</li> <li>Follow <code>gofmt</code> + <code>govet</code> + <code>goimports</code> formatting.</li> <li>Tests should be included alongside code changes wherever applicable, except for parts that are harder to test and are not currently tested (e.g. eBPF). When modifying already tested code, your changes must be represented in the existing tests.</li> </ol>"},{"location":"contributing/building/building/","title":"Building from the source","text":"<p>Note</p> <p>Consider also visiting the following instructions: 1. docker container as building environment 2. building tracee container images </p> <ol> <li> <p>Building dependencies</p> <ol> <li>kernel readers if no CO-RE is needed</li> <li>clang (12 or 13)</li> <li>golang (1.18)</li> <li>libelf and libelf-dev    (or elfutils-libelf and elfutils-libelf-devel)</li> <li>zlib1g and zlib1g-dev    (or zlib and zlib-devel)</li> </ol> </li> <li> <p>Clone tracee repository</p> <pre><code>$ git clone git@github.com:aquasecurity/tracee\nCloning into 'tracee'...\nremote: Enumerating objects: 13251, done.\nremote: Counting objects: 100% (555/555), done.\nremote: Compressing objects: 100% (240/240), done.\nremote: Total 13251 (delta 343), reused 369 (delta 280), pack-reused 12696\nReceiving objects: 100% (13251/13251), 11.75 MiB | 8.62 MiB/s, done.\nResolving deltas: 100% (8105/8105), done.\n</code></pre> </li> <li> <p>All makefiles have a help target to give you needed instrutions</p> <pre><code>$ make help\n\n# environment\n\n    $ make env                      # show makefile environment/variables\n\n# build\n\n    $ make all                      # build tracee-ebpf, tracee-rules &amp; rules\n    $ make bpf-core                 # build ./dist/tracee.bpf.core.o\n    $ make bpf-nocore               # build ./dist/tracee.bpf.XXX.o\n    $ make tracee-ebpf              # build ./dist/tracee-ebpf\n    $ make tracee-rules             # build ./dist/tracee-rules\n    $ make rules                    # build ./dist/rules\n\n# install\n\n    $ make install-bpf-nocore       # install BPF no CO-RE obj into /tmp/tracee\n    $ make uninstall-bpf-nocore     # uninstall BPF no CO-RE obj from /tmp/tracee\n\n# clean\n\n    $ make clean                    # wipe ./dist/\n    $ make clean-bpf-core           # wipe ./dist/tracee.bpf.core.o\n    $ make clean-bpf-nocore         # wipe ./dist/tracee.bpf.XXX.o\n    $ make clean-tracee-ebpf        # wipe ./dist/tracee-ebpf\n    $ make clean-tracee-rules       # wipe ./dist/tracee-rules\n    $ make clean-rules              # wipe ./dist/rules\n\n# test\n\n    $ make test-types               # run unit tests for types module\n    $ make test-unit                # run unit tests\n    $ make test-integration         # run integration tests\n    $ make test-rules               # opa test (tracee-rules)\n\n# flags\n\n    $ STATIC=1 make ...                 # build static binaries\n    $ BTFHUB=1 STATIC=1 make ...        # build static binaries, embed BTF\n    $ DEBUG=1 make ...                  # build binaries with debug symbols\n</code></pre> </li> <li> <p>Build all targets at once (but bpf-nocore)</p> <pre><code>$ make all\nSubmodule 'libbpf' (https://github.com/libbpf/libbpf.git) registered for path '3rdparty/libbpf'\nCloning into '/home/rafaeldtinoco/tracee/3rdparty/libbpf'...\nmkdir -p dist/rules\nGOOS=linux CC=clang GOARCH=amd64 CGO_CFLAGS= CGO_LDFLAGS= go build \\\n    --buildmode=plugin \\\n    -o dist/rules/builtin.so \\\n    signatures/golang/export.go signatures/golang/kubernetes_api_connection.go signatures/golang/stdio_over_socket.go\n</code></pre> </li> <li> <p>Build a static binary by setting <code>STATIC=1</code></p> <pre><code>$ STATIC=1 make all\nCC=\"clang\" \\\n    CFLAGS=\"\"-fPIC\"\" \\\n    LD_FLAGS=\"\" \\\n    make \\\n    -C ./3rdparty/libbpf/src \\\n    BUILD_STATIC_ONLY=1 \\\n    DESTDIR=/home/rafaeldtinoco/tracee/dist/libbpf \\\n    OBJDIR=/home/rafaeldtinoco/tracee/dist/libbpf/obj \\\n    INCLUDEDIR= LIBDIR= UAPIDIR= prefix= libdir= \\\n    install install_uapi_headers\n...\n</code></pre> </li> <li> <p>Build a static binary with BTFHUB Support</p> <pre><code>$ BTFHUB=1 STATIC=1 make all\nCloning into '/home/rafaeldtinoco/tracee/3rdparty/btfhub'...\nremote: Enumerating objects: 205, done.\nremote: Counting objects: 100% (16/16), done.\nremote: Compressing objects: 100% (12/12), done.\nremote: Total 205 (delta 4), reused 10 (delta 3), pack-reused 189\nReceiving objects: 100% (205/205), 10.59 MiB | 7.56 MiB/s, done.\nResolving deltas: 100% (73/73), done.\nCloning into '/home/rafaeldtinoco/tracee/3rdparty/btfhub-archive'...\nremote: Enumerating objects: 1993, done.\nremote: Counting objects: 100% (28/28), done.\nremote: Compressing objects: 100% (23/23), done.\nReceiving objects:  15% (301/1993), 154.97 MiB | 15.72 MiB/s\n</code></pre> <p>Note</p> <p>BTFHUB support will embed several very small files (BTF files) into your final binary. Those files will allow tracee-ebpf binary to be executed in kernels that doesn't have embedded BTF information (the ones described at the BTFHUB repository)</p> <p>Attention</p> <p>compiling <code>tracee-rules</code> with STATIC=1 won't allow you to use golang based signatures as plugins, only as built-ins:</p> <pre><code>2021/12/13 13:27:21 error opening plugin /tracee/dist/rules/builtin.so:\nplugin.Open(\"/tracee/dist/rules/builtin.so\"): Dynamic loading not supported\n</code></pre> </li> <li> <p>Build a debuggable binary with DWARF generation by setting <code>DEBUG=1</code></p> <pre><code>$ DEBUG=1 make\n...\nGOOS=linux CC=clang GOARCH=amd64 CGO_CFLAGS=\"-I/home/gg/code/tracee/dist/libbpf\" CGO_LDFLAGS=\"-lelf  -lz  /home/gg/code/tracee/dist/libbpf/libbpf.a\" go build \\\n-tags core,ebpf \\\n-ldflags=\" \\\n    -extldflags \\\"\\\" \\\n    -X main.version=\\\"v0.8.0-107-g121efeb\\\" \\\n    \" \\\n-v -o dist/tracee-ebpf \\\n./cmd/tracee-ebpf\n</code></pre> </li> </ol>"},{"location":"contributing/building/containers/","title":"Creating Tracee Container Images","text":"<p>These instructions are meant to describe how to build the official tracee containers images, instead of just downloading them from the Docker Hub.</p> <p>If you would like to have a local building and execution environment, read this instead.</p>"},{"location":"contributing/building/containers/#generating-tracee-containers","title":"Generating Tracee Containers","text":"<p>Tracee containers come in 2 flavors:</p> <ol> <li> <p>tracee:latest</p> <p>Contains an executable binary with an embedded eBPF CO-RE enabled object that makes it portable against multiple environments and kernel versions.</p> <pre><code>$ BTFHUB={0,1} make -f builder/Makefile.tracee-container build-tracee\n</code></pre> </li> <li> <p>tracee:full</p> <p>Contains tracee source tree and required toolchain in order to, during the startup time, compile a eBPF non CO-RE object, to your specific running environment, and make the executable to use on execution time.</p> <pre><code>$ BTFHUB={0,1} make -f builder/Makefile.tracee-container build-tracee-full\n</code></pre> <p>Note</p> <p><code>BTFHUB=1</code> adds support to some older kernels so user doesn't need to build specific non CO-RE eBPF objects to them.</p> </li> </ol>"},{"location":"contributing/building/containers/#running-tracee-containers","title":"Running Tracee Containers","text":"<p>Containers are supposed to be executed through docker cmdline directly, from the official built images. Nevertheless, during the image building process, it may be useful to execute them with correct arguments to see if they're working.</p> <p>User may execute built containers through <code>Makefile.tracee-container</code> file with the \"run\" targets:</p> <ol> <li> <p>To run the tracee:latest container:</p> <pre><code>$ make -f builder/Makefile.tracee-container run-tracee\n</code></pre> </li> <li> <p>To run the tracee:full container:</p> <pre><code>$ make -f builder/Makefile.tracee-container run-tracee-full\n</code></pre> <p>Note</p> <p>Tracee-ebpf arguments are passed through the <code>ARG</code> variable: <pre><code>$ make -f builder/Makefile.tracee-container run-tracee ARG=\"--help\"\n</code></pre></p> </li> </ol>"},{"location":"contributing/building/containers/#running-tracee-ebpf-only","title":"Running Tracee-eBPF Only","text":"<p>Generated containers allow user to run Tracee, as a complete security solution (tracee-ebpf passes events to tracee-rules and tracee-rules process events based on existing security signatures) or to run tracee-ebpf only, as an introspection tool.</p> <ol> <li>To run the <code>tracee:latest</code> container with tracee-ebpf only:</li> </ol> <pre><code>$ make -f builder/Makefile.tracee-container run-tracee-ebpf\n</code></pre> <ol> <li>To run the <code>tracee:full</code> container with tracee-ebpf only:</li> </ol> <pre><code>$ make -f builder/Makefile.tracee-container run-tracee-ebpf-full\n</code></pre> <p>Note</p> <p>Tracee-ebpf arguments are passed through the <code>ARG</code> variable:</p> <pre><code>$ make -f builder/Makefile.tracee-container run-tracee-ebpf ARG=\"--log debug\"\n</code></pre>"},{"location":"contributing/building/environment/","title":"Creating a local building environment","text":"<p>These instructions are meant to describe how to create a local building and execution environment. If you would like to build tracee container(s) image(s), read this instead.</p> <p>Note</p> <p>A building environment will let you build and execute tracee inside a docker container, containing all needed tools to build and execute it. If you're using an OSX environment, for example, you can install gmake (<code>brew install gmake</code>) and configure such environment by using Docker.</p> <p>Attention</p> <p>If you want to build tracee on your local machine read this.</p>"},{"location":"contributing/building/environment/#quick-steps-impatient-readers","title":"Quick steps (impatient readers)","text":"<p>Example</p> <ul> <li> <p>Build and execute tracee-ebpf:</p> <pre><code>$ make -f builder/Makefile.tracee-make alpine-prepare\n$ make -f builder/Makefile.tracee-make alpine-shell\n\ntracee@f64bb4a2f0b1[/tracee]$ make clean\ntracee@f64bb4a2f0b1[/tracee]$ make tracee-ebpf\ntracee@f64bb4a2f0b1[/tracee]$ sudo ./dist/tracee-ebpf \\\n    -o option:parse-arguments \\\n    --trace comm=bash \\\n    --trace follow\n</code></pre> </li> </ul> <p>Now, in your host's bash shell, execute a command. You will see all events (except scheduler ones) being printed, in \"table format\", to stdout.</p> <ul> <li> <p>Build and execute tracee:</p> <pre><code>$ make -f builder/Makefile.tracee-make alpine-prepare\n$ make -f builder/Makefile.tracee-make alpine-shell\n\ntracee@f64bb4a2f0b1[/tracee]$ make clean\ntracee@f64bb4a2f0b1[/tracee]$ make all\ntracee@f64bb4a2f0b1[/tracee]$ sudo ./dist/tracee-ebpf \\\n    -o format:json \\\n    -o option:parse-arguments \\\n    --trace comm=bash \\\n    --trace follow | \\\n    ./dist/tracee-rules \\\n    --input-tracee file:stdin \\\n    --input-tracee format:json\n</code></pre> </li> </ul> <p>Now, in your host's bash shell, execute: <code>sudo strace /bin/ls</code> and observe tracee warning you about a possible risk (with its Anti-Debugging signature).</p> <p>Now, for more patient readers ...</p>"},{"location":"contributing/building/environment/#how-to-build-and-use-the-environment","title":"How to build and use the environment","text":"<p>In order to have a controlled building environment for tracee, tracee provides a <code>Makefile.tracee-make</code> file that allows you to create and use a docker container environment to build &amp; test tracee-ebpf and tracee-rules.</p> <p>Two different environments are maintained for building tracee:</p> <ul> <li>Alpine</li> <li>Ubuntu</li> </ul> <p>The reason for that is that Alpine Linux is based in the musl C standard library, while the Ubuntu Linux uses glibc. By supporting both building environments we can always be sure that the project builds (and executes) correctly in both environments.</p> <p>Attention</p> <p>Locally created containers, called <code>alpine-tracee-make</code> or <code>ubuntu-tracee-make</code>, share the host source code directory. This means that, if you build tracee binaries using <code>alpine</code> distribution, binaries tracee-ebpf and tracee-rules might not be compatible to the Linux distribution from your host OS.</p>"},{"location":"contributing/building/environment/#creating-a-builder-environment","title":"Creating a builder environment","text":"<ul> <li> <p>To create an alpine-tracee-make container:</p> <pre><code>$ make -f builder/Makefile.tracee-make alpine-prepare\n</code></pre> </li> <li> <p>To create an ubuntu-tracee-make container:</p> <pre><code>$ make -f builder/Makefile.tracee-make ubuntu-prepare\n</code></pre> </li> </ul>"},{"location":"contributing/building/environment/#executing-a-builder-environment","title":"Executing a builder environment","text":"<ul> <li> <p>To execute an alpine-tracee-make shell:</p> <pre><code>$ make -f builder/Makefile.tracee-make alpine-shell\n</code></pre> </li> <li> <p>To execute an ubuntu-tracee-make shell:</p> <pre><code>$ make -f builder/Makefile.tracee-make ubuntu-shell\n</code></pre> </li> </ul>"},{"location":"contributing/building/environment/#using-build-environment-as-a-make-replacement","title":"Using build environment as a make replacement","text":"<p>Instead of executing a builder shell, you may use <code>alpine-tracee-make</code>, or <code>ubuntu-tracee-make</code>, as a replacement for the <code>make</code> command:</p> <pre><code>$ make -f builder/Makefile.tracee-make ubuntu-prepare\n$ make -f builder/Makefile.tracee-make ubuntu-make ARG=\"help\"\n$ make -f builder/Makefile.tracee-make ubuntu-make ARG=\"clean\"\n$ make -f builder/Makefile.tracee-make ubuntu-make ARG=\"bpf-core\"\n$ make -f builder/Makefile.tracee-make ubuntu-make ARG=\"tracee-ebpf\"\n$ make -f builder/Makefile.tracee-make ubuntu-make ARG=\"all\"\n</code></pre> <p>And, after the compilation, run the commands directly in your host:</p> <pre><code>$ sudo ./dist/tracee-ebpf \\\n    -o option:parse-arguments \\\n    --trace comm=bash \\\n    --trace follow\n</code></pre> <p>Note: the generated binary must be compatible to your host (depending on glibc version, for example).</p> <p>If you don't want to depend on host's libraries versions, or if you are using the <code>alpine-tracee-make</code> container as a replacement for <code>make</code>, and your host is not an Alpine Linux, then you may set <code>STATIC=1</code> variable so you can run compiled binaries in your host:</p> <pre><code>$ make -f builder/Makefile.tracee-make alpine-prepare\n$ make -f builder/Makefile.tracee-make alpine-make ARG=\"help\"\n$ STATIC=1 make -f builder/Makefile.tracee-make alpine-make ARG=\"all\"\n</code></pre> <p>and execute the static binary from your host:</p> <pre><code>$ ldd dist/tracee-ebpf\n  not a dynamic executable\n</code></pre> <p>Attention</p> <p>compiling tracee-rules with STATIC=1 won't allow you to use golang based signatures:</p> <pre><code>2021/12/13 13:27:21 error opening plugin /tracee/dist/rules/builtin.so:\nplugin.Open(\"/tracee/dist/rules/builtin.so\"): Dynamic loading not supported\n</code></pre>"},{"location":"contributing/building/macosx/","title":"Building Tracee in OSX","text":"<p>Attention</p> <p>Building Tracee in an OSX environment is for development purposes only and experimental only.</p>"},{"location":"contributing/building/macosx/#requirements","title":"Requirements","text":"<ul> <li>Docker desktop</li> <li>brew</li> <li>findutils (<code>brew install findutils</code>)</li> <li>make (<code>brew install make</code>)</li> </ul>"},{"location":"contributing/building/macosx/#creating-a-local-building-enviroment","title":"Creating a local building enviroment","text":"<p>Just like as described at building environment, under OSX you may create your local building environment by using the same make targets:</p> <pre><code>$ gmake -f builder/Makefile.tracee-make alpine-prepare\n$ gmake -f builder/Makefile.tracee-make alpine-shell\n</code></pre> <pre><code>$ gmake -f builder/Makefile.tracee-make ubuntu-prepare\n$ gmake -f builder/Makefile.tracee-make ubuntu-shell\n</code></pre>"},{"location":"contributing/building/macosx/#executing-tracee-in-the-building-environment","title":"Executing tracee in the building environment","text":"<p>Tracee isn't meant to run in OSX but, with Docker, you're able to test building it. If you try to run it from the building environment you may get the following error:</p> <pre><code>tracee@5fb7cc667842[/tracee]$ sudo ./dist/tracee-ebpf\nBPF: open /tmp/tracee/tracee.bpf.5_10_104-linuxkit.v0_8_0-rc-1-24-g72e0d02.o: no such file or directory\nBPF: ATTENTION:\nBPF: It seems tracee-ebpf can't load CO-RE eBPF obj and could not find\nBPF: the non CO-RE object in /tmp/tracee. You may build a non CO-RE eBPF\nBPF: obj by using the source tree and executing \"make install-bpf-nocore\".\n</code></pre> <p>That happens because the virtual machine supporting docker desktop containers, in OSX, does not have a kernel that supports eBPF CO-RE (it does not contain a kernel with BTF information embedded on it).</p> <p>In order for you to run tracee in OSX, it is recommended that you either use Vagrant and the provided Vagrantfile, use a virtual machine emulator (Parallels, VMware Fusion, ...) OR check the next section about how to obtain docker kernel headers installed if you want a \"Docker only experience\".</p>"},{"location":"contributing/building/macosx/#obtaining-docker-kernel-headers","title":"Obtaining Docker Kernel Headers","text":"<p>Docker for Mac does not come with Kernel headers. You need to do the following to execute non CO-RE Tracee:</p> <ol> <li> <p>Identify your docker version:</p> <pre><code>$ dockerver=$(docker version | grep  Version | head -n 1 | cut -d ':' -f 2 | xargs)\n</code></pre> </li> <li> <p>Run a container with Docker CLI, while mounting to the host path:</p> <pre><code>$ docker run -it -v /:/host \\\n    -v /var/run/docker.sock:/var/run/docker.sock \\\n    docker:$dockerver /bin/sh\n</code></pre> </li> <li> <p>Get the Kernel Header files from the linuxkit Docker image and copy it to the    host /usr/src path:</p> <pre><code>$ mkdir /host/kheader\n$ cd /host/kheader\n$ linux_version=\"${VERSION:-$(uname -r | cut -d - -f 1)}\"\n$ docker pull \"linuxkit/kernel:$linux_version\"\n$ docker save \"linuxkit/kernel:$linux_version\" &gt; \"linuxkit.tar\"\n$ tar -xf \"linuxkit.tar\"\n$ layertar=$(find . -name layer.tar)\n$ tar -xf \"$layertar\"\n$ tar -xf \"kernel-dev.tar\" --directory /host/\n</code></pre> </li> <li> <p>You can now run Tracee on your Docker for Mac</p> </li> </ol>"},{"location":"contributing/building/macosx/#apple-silicon","title":"Apple Silicon","text":"<p>Note</p> <p>Apple Silicon users might need to create their own virtual machine environment until Vagrant fully supports that architecture.</p>"},{"location":"contributing/building/nocore-ebpf/","title":"Running non CO-RE Tracee","text":"<p>These instructions are meant to describe how to build tracee's eBPF object for your running kernel when it does not support CO-RE.</p>"},{"location":"contributing/building/nocore-ebpf/#introduction","title":"Introduction","text":"<p>Introduction</p> <p>As you are probably already aware, Tracee consists of:</p> <p>Tracee-ebpf</p> <ul> <li>Userspace agent  <ol> <li>Handles lifecycle of ebpf programs  </li> <li>Receives events from eBPF programs  </li> </ol> </li> <li>eBPF code  <ol> <li>Programs loaded in the kernel for event collection</li> </ol> </li> </ul> <p>Tracee-rules</p> <ul> <li>OPA signatures</li> <li>Golang signatures</li> <li>Go-Cel signatures (tech-preview)</li> </ul> <p>tracee-ebpf leverages Linux's eBPF technology, which requires some kernel level integration. Tracee supports two eBPF integration modes:</p> <ol> <li> <p>CO-RE: a portable mode, which will seamlessly run on all supported    envs.</p> <p>The portable option, also known as CO-RE (compile once, run everywhere), requires that your operating system support BTF (BPF Type Format). Tracee will automatically run in CO-RE mode if it detects that the environment supports it. The tracee-ebpf binary has a CO-RE eBPF object embedded on it. When executed, it loads the CO-RE eBPF object into the kernel and each of its object's eBPF programs are executed when triggered by kernel probes, or tracepoints, for example.</p> <p>This mode requires no intervention or preparation on your side.  You can manually detect if your environments supports it by checking if the following file exists on your machine: <code>/sys/kernel/btf/vmlinux</code>.</p> </li> <li> <p>non CO-RE: a kernel-specific mode, requiring eBPF object to be built.</p> <p>If you want to run Tracee on a host without BTF support, there are 2 options: 1. to use BTF files from BTFHUB    and provide the TRACEE_BTF_FILE environment variable pointing to the BTF    file of your running kernel. 2. to have <code>../../Makefile</code> build and install the eBPF object for you    (instructions in this file). This will depend on having clang and a    kernel version specific kernel-header package.</p> </li> </ol>"},{"location":"contributing/building/nocore-ebpf/#the-need-for-a-non-co-re-ebpf-object-build","title":"The need for a non CO-RE eBPF object build","text":"<p>Until recently, tracee-ebpf was capable of building a non CO-RE (portable) eBPF object when the running kernel did not support BTF, one of the kernel features needed for eBPF portability among different kernels.</p> <p>That now is changed:</p> <p>It is the user responsibility to have the non CO-RE eBPF object correctly placed in <code>/tmp/tracee</code> directory. Tracee will load it, instead of loading the embedded CO-RE eBPF object, as a last resource if there is no:</p> <ol> <li>BTF file available in running kernel (<code>/sys/kernel/btf/vmlinux</code>).</li> <li>BTF file pointed by <code>TRACEE_BTF_FILE</code> environment variable.</li> <li>BTF file embedded into \"tracee-ebpf\" binary (BTFHUB).</li> </ol> <p>Note</p> <p>Installing the non CO-RE eBPF object in the environment does not mean will will run tracee-ebpf with it by default. If your system supports CO-RE eBPF objects it will be chosen instead. If your system supports CO-RE eBPF but does not contain embedded BTF information, but is support by BTFHUB, then the CO-RE eBPF object will be used by default. The only way you can make sure the non CO-RE eBPF object is used is by always informing the <code>TRACEE_BPF_FILE=...</code> environment variable.</p> <p>Reasoning behind this change</p> <p>With BTFHUB, it is now possible to run tracee-ebpf without compiling the eBPF object to each different kernel, thus removing the automatic builds (although the functionality is still kept through the Makefile).</p>"},{"location":"contributing/building/nocore-ebpf/#install-the-non-co-re-ebpf-object","title":"Install the non CO-RE eBPF object","text":"<p>By running:</p> <pre><code>$ make clean\n$ make all\n$ make install-bpf-nocore\n</code></pre> <p>make installs an eBPF object file under <code>/tmp/tracee</code> for the current running kernel. Example:</p> <pre><code>$ find /tmp/tracee\n/tmp/tracee\n/tmp/tracee/tracee.bpf.5_4_0-91-generic.v0_6_5-80-ge723a22.o\n</code></pre> <p>Note</p> <p>This example, the Ubuntu Focal kernel 5.4.0-91-generic supports CO-RE, but the kernel does not have embedded BTF information available. In cases like this, the user may opt to either use BTFHUB btf files (with an environment variable TRACEE_BTF_FILE=.../5.4.0-91-generic.btf) OR to install the non CO-RE eBPF object and run tracee-ebpf command without an env variable.</p>"},{"location":"contributing/building/nocore-ebpf/#run-non-co-re-tracee-ebpf","title":"Run non CO-RE tracee-ebpf","text":"<p>If you install the non CO-RE eBPF object and run tracee-ebpf in an environment that needs it, then the debug output will look like:</p> <pre><code>$ sudo ./dist/tracee-ebpf --log debug\n{\"level\":\"debug\",\"ts\":1670972052.3996286,\"msg\":\"osinfo\",\"VERSION_CODENAME\":\"focal\",\"KERNEL_RELEASE\":\"5.4.0-91-generic\",\"ARCH\":\"x86_64\",\"VERSION\":\"\\\"20.04.5 LTS (Focal Fossa)\\\"\",\"ID\":\"ubuntu\",\"ID_LIKE\":\"debian\",\"PRETTY_NAME\":\"\\\"Ubuntu 20.04.5 LTS\\\"\",\"VERSION_ID\":\"\\\"20.04\\\"\",\"pkg\":\"urfave\",\"file\":\"urfave.go\",\"line\":53}\n{\"level\":\"debug\",\"ts\":1670972052.3996587,\"msg\":\"RuntimeSockets: failed to register default\",\"socket\":\"crio\",\"error\":\"failed to register runtime socket stat /var/run/crio/crio.sock: no such file or directory\",\"pkg\":\"flags\",\"file\":\"containers.go\",\"line\":45}\n{\"level\":\"debug\",\"ts\":1670972052.3996656,\"msg\":\"RuntimeSockets: failed to register default\",\"socket\":\"podman\",\"error\":\"failed to register runtime socket stat /var/run/podman/podman.sock: no such file or directory\",\"pkg\":\"flags\",\"file\":\"containers.go\",\"line\":45}\n{\"level\":\"debug\",\"ts\":1670972052.3998134,\"msg\":\"osinfo\",\"security_lockdown\":\"none\",\"pkg\":\"urfave\",\"file\":\"urfave.go\",\"line\":116}\n{\"level\":\"debug\",\"ts\":1670972052.400891,\"msg\":\"BTF\",\"bpfenv\":false,\"btfenv\":false,\"vmlinux\":false,\"pkg\":\"initialize\",\"file\":\"bpfobject.go\",\"line\":40}\n{\"level\":\"debug\",\"ts\":1670972052.4009123,\"msg\":\"BPF: no BTF file was found or provided\",\"pkg\":\"initialize\",\"file\":\"bpfobject.go\",\"line\":108}\n{\"level\":\"debug\",\"ts\":1670972052.4009168,\"msg\":\"BPF: trying non CO-RE eBPF\",\"file\":\"/tmp/tracee/tracee.bpf.5_4_0-91-generic.v0_8_0-rc-2-363-g3e73eeb1.o\",\"pkg\":\"initialize\",\"file\":\"bpfobject.go\",\"line\":109}\nTIME             UID    COMM             PID     TID     RET              EVENT                ARGS\n...\n</code></pre> <p>One way of forcing tracee-ebpf to use non CO-RE eBPF object, even in a kernel that supports CO-RE, is by setting the <code>TRACEE_BPF_FILE</code> environment, like this:</p> <pre><code>$ sudo TRACEE_BPF_FILE=/tmp/tracee/tracee.bpf.5_4_0-91-generic.v0_8_0-rc-2-363-g3e73eeb1.o ./dist/tracee-ebpf --log debug -o option:parse-arguments --trace comm=bash --trace follow\n{\"level\":\"debug\",\"ts\":1670972956.7201664,\"msg\":\"osinfo\",\"VERSION_CODENAME\":\"focal\",\"KERNEL_RELEASE\":\"5.4.0-91-generic\",\"ARCH\":\"x86_64\",\"VERSION\":\"\\\"20.04.5 LTS (Focal Fossa)\\\"\",\"ID\":\"ubuntu\",\"ID_LIKE\":\"debian\",\"PRETTY_NAME\":\"\\\"Ubuntu 20.04.5 LTS\\\"\",\"VERSION_ID\":\"\\\"20.04\\\"\",\"pkg\":\"urfave\",\"file\":\"urfave.go\",\"line\":53}\n{\"level\":\"debug\",\"ts\":1670972956.7202075,\"msg\":\"RuntimeSockets: failed to register default\",\"socket\":\"crio\",\"error\":\"failed to register runtime socket stat /var/run/crio/crio.sock: no such file or directory\",\"pkg\":\"flags\",\"file\":\"containers.go\",\"line\":45}\n{\"level\":\"debug\",\"ts\":1670972956.7202215,\"msg\":\"RuntimeSockets: failed to register default\",\"socket\":\"podman\",\"error\":\"failed to register runtime socket stat /var/run/podman/podman.sock: no such file or directory\",\"pkg\":\"flags\",\"file\":\"containers.go\",\"line\":45}\n{\"level\":\"debug\",\"ts\":1670972956.7203856,\"msg\":\"osinfo\",\"security_lockdown\":\"none\",\"pkg\":\"urfave\",\"file\":\"urfave.go\",\"line\":116}\n{\"level\":\"debug\",\"ts\":1670972956.7215962,\"msg\":\"BTF\",\"bpfenv\":true,\"btfenv\":false,\"vmlinux\":false,\"pkg\":\"initialize\",\"file\":\"bpfobject.go\",\"line\":40}\n{\"level\":\"debug\",\"ts\":1670972956.7216172,\"msg\":\"BPF: using BPF object from environment\",\"file\":\"/tmp/tracee/tracee.bpf.5_4_0-91-generic.v0_8_0-rc-2-363-g3e73eeb1.o\",\"pkg\":\"initialize\",\"file\":\"bpfobject.go\",\"line\":52}\nTIME             UID    COMM             PID     TID     RET              EVENT                ARGS\n...\n</code></pre>"},{"location":"contributing/building/nocore-ebpf/#use-the-building-environment","title":"Use the building environment","text":"<p>If you're willing to generate the non CO-RE eBPF object using the <code>tracee-make</code> building environment container, you're able to by doing:</p> <p><pre><code>$ make -f builder/Makefile.tracee-make alpine-prepare\n$ make -f builder/Makefile.tracee-make alpine-shell\n</code></pre> or <pre><code>$ make -f builder/Makefile.tracee-make ubuntu-prepare\n$ make -f builder/Makefile.tracee-make ubuntu-shell\n</code></pre></p> <p>and then, inside the docker container:</p> <pre><code>tracee@f65bab137305[/tracee]$ make clean\ntracee@f65bab137305[/tracee]$ make tracee-ebpf\ntracee@f65bab137305[/tracee]$ make install-bpf-nocore\n\ntracee@f65bab137305[/tracee]$ sudo ./dist/tracee-ebpf --log debug\n{\"level\":\"debug\",\"ts\":1670973357.226559,\"msg\":\"osinfo\",\"VERSION_CODENAME\":\"focal\",\"KERNEL_RELEASE\":\"5.4.0-91-generic\",\"ARCH\":\"x86_64\",\"VERSION\":\"\\\"20.04.5 LTS (Focal Fossa)\\\"\",\"ID\":\"ubuntu\",\"ID_LIKE\":\"debian\",\"PRETTY_NAME\":\"\\\"Ubuntu 20.04.5 LTS\\\"\",\"VERSION_ID\":\"\\\"20.04\\\"\",\"pkg\":\"urfave\",\"file\":\"urfave.go\",\"line\":53}\n{\"level\":\"debug\",\"ts\":1670973357.2265916,\"msg\":\"RuntimeSockets: failed to register default\",\"socket\":\"containerd\",\"error\":\"failed to register runtime socket stat /var/run/containerd/containerd.sock: no such file or directory\",\"pkg\":\"flags\",\"file\":\"containers.go\",\"line\":45}\n{\"level\":\"debug\",\"ts\":1670973357.2266004,\"msg\":\"RuntimeSockets: failed to register default\",\"socket\":\"docker\",\"error\":\"failed to register runtime socket stat /var/run/docker.sock: no such file or directory\",\"pkg\":\"flags\",\"file\":\"containers.go\",\"line\":45}\n{\"level\":\"debug\",\"ts\":1670973357.226606,\"msg\":\"RuntimeSockets: failed to register default\",\"socket\":\"crio\",\"error\":\"failed to register runtime socket stat /var/run/crio/crio.sock: no such file or directory\",\"pkg\":\"flags\",\"file\":\"containers.go\",\"line\":45}\n{\"level\":\"debug\",\"ts\":1670973357.2266123,\"msg\":\"RuntimeSockets: failed to register default\",\"socket\":\"podman\",\"error\":\"failed to register runtime socket stat /var/run/podman/podman.sock: no such file or directory\",\"pkg\":\"flags\",\"file\":\"containers.go\",\"line\":45}\n{\"level\":\"debug\",\"ts\":1670973357.2268527,\"msg\":\"osinfo\",\"security_lockdown\":\"none\",\"pkg\":\"urfave\",\"file\":\"urfave.go\",\"line\":116}\n{\"level\":\"warn\",\"ts\":1670973357.2268791,\"msg\":\"KConfig: could not check enabled kconfig features\",\"error\":\"could not read /boot/config-5.4.0-91-generic: stat /boot/config-5.4.0-91-generic: no such file or directory\"}\n{\"level\":\"warn\",\"ts\":1670973357.2268848,\"msg\":\"KConfig: assuming kconfig values, might have unexpected behavior\"}\n{\"level\":\"debug\",\"ts\":1670973357.2268941,\"msg\":\"BTF\",\"bpfenv\":false,\"btfenv\":false,\"vmlinux\":false,\"pkg\":\"initialize\",\"file\":\"bpfobject.go\",\"line\":40}\n{\"level\":\"debug\",\"ts\":1670973357.2269084,\"msg\":\"BPF: no BTF file was found or provided\",\"pkg\":\"initialize\",\"file\":\"bpfobject.go\",\"line\":108}\n{\"level\":\"debug\",\"ts\":1670973357.2269146,\"msg\":\"BPF: trying non CO-RE eBPF\",\"file\":\"/tmp/tracee/tracee.bpf.5_4_0-91-generic.v0_8_0-rc-2-363-g3e73eeb1.o\",\"pkg\":\"initialize\",\"file\":\"bpfobject.go\",\"line\":109}\n{\"level\":\"debug\",\"ts\":1670973357.3408191,\"msg\":\"Enricher\",\"error\":\"error registering enricher: unsupported runtime containerd\",\"pkg\":\"containers\",\"file\":\"containers.go\",\"line\":64}\n{\"level\":\"debug\",\"ts\":1670973357.3408432,\"msg\":\"Enricher\",\"error\":\"error registering enricher: unsupported runtime crio\",\"pkg\":\"containers\",\"file\":\"containers.go\",\"line\":68}\n{\"level\":\"debug\",\"ts\":1670973357.340847,\"msg\":\"Enricher\",\"error\":\"error registering enricher: unsupported runtime docker\",\"pkg\":\"containers\",\"file\":\"containers.go\",\"line\":72}\n{\"level\":\"debug\",\"ts\":1670973357.561575,\"msg\":\"KConfig: warning: assuming kconfig values, might have unexpected behavior\",\"pkg\":\"initialization\",\"file\":\"kconfig.go\",\"line\":30}\nTIME             UID    COMM             PID     TID     RET              EVENT                ARGS\n...\n</code></pre>"},{"location":"contributing/building/packaging/","title":"Creating Tracee Linux packages","text":"<p>These instructions are meant to describe how to build Linux distributions packages. If you would like to have a local building building and execution environment, read this instead.</p>"},{"location":"contributing/building/packaging/#ubuntu","title":"Ubuntu","text":"<p>You may use <code>builder/Makefile.packaging</code> to generate Ubuntu deb packages. It will use docker containers to generate appropriate packages, so you don't need to install build depencies in your OS.</p> <p>Ubuntu</p> <p>Building</p> <ul> <li>Bionic (LTS)</li> </ul> <pre><code>$ make -f builder/Makefile.packaging ubuntu-bin-bionic\n</code></pre> <ul> <li>Focal (LTS)</li> </ul> <pre><code>$ make -f builder/Makefile.packaging ubuntu-bin-focal\n</code></pre> <ul> <li>Jammy (LTS)</li> </ul> <pre><code>$ make -f builder/Makefile.packaging ubuntu-bin-jammy\n</code></pre> <p>Versioning</p> <p>The ubuntu <code>.deb</code> packages have the following versioning format:</p> <p><code>tracee-{ebpf,rules}_version~ubuntuver~builddate-lastcommit_arch.deb</code></p> <p>Examples:</p> <pre><code># bionic\ntracee-ebpf_0.6.5-111~18.04~2201281255-3a6874a_amd64.deb\ntracee-rules_0.6.5-111~18.04~2201281255-3a6874a_amd64.deb\n\n# focal\ntracee-ebpf_0.6.5-111~20.04~2201281302-3a6874a_amd64.deb\ntracee-rules_0.6.5-111~20.04~2201281302-3a6874a_amd64.deb\n\n...\n</code></pre> <p>This allows upgrades among future releases of tracee AND ubuntu. It also allows you to upgrade to \"in between releases\" versions if a fix is needed.</p> <p>Location</p> <p>The packages will be generated in <code>dist/</code> directory.</p>"},{"location":"contributing/building/packaging/#fedora","title":"Fedora","text":"<p>You may use <code>builder/Makefile.packaging</code> to generate Fedora rpm packages. It will use docker containers to generate appropriate packages, so you don't need to install build depencies in your OS.</p> <p>Fedora</p> <p>Building</p> <ul> <li>35 (still mantained)</li> </ul> <pre><code>make -f builder/Makefile.packaging fedora-bin-35\n</code></pre> <ul> <li>36 (latest)</li> </ul> <pre><code>make -f builder/makefile.packaging fedora-bin-36\n</code></pre> <ul> <li>37 (devel)</li> </ul> <pre><code>make -f builder/makefile.packaging fedora-bin-37\n</code></pre> <p>Versioning</p> <p>The fedora <code>.rpm</code> packages have the following versioning format:</p> <p><code>tracee-{ebpf,rules}-version-f{34,35,36}.builddate.lastcommit.arch.rpm</code></p> <p>Examples:</p> <pre><code># f35\ntracee-ebpf-0.6.5.163-f35.2202140512.ef35306d.x86_64.rpm\ntracee-rules-0.6.5.163-f35.2202140512.ef35306d.x86_64.rpm\n\n# f36\ntracee-ebpf-0.6.5.163-f36.2202140514.ef35306d.x86_64.rpm\ntracee-rules-0.6.5.163-f36.2202140514.ef35306d.x86_64.rpm\n\n# f37\ntracee-ebpf-0.8.0.rc-f37.2207080417.07c8af7.x86_64.rpm\ntracee-rules-0.8.0.rc-f37.2207080417.07c8af7.x86_64.rpm\n...\n</code></pre> <p>This allows upgrades among future releases of tracee AND fedora. It also allows you to upgrade to \"in between releases\" versions if a fix is needed.</p> <p>Location</p> <p>The packages will be generated in <code>dist/</code> directory.</p>"},{"location":"contributing/events/format/","title":"","text":""},{"location":"contributing/events/format/#intro","title":"Intro","text":"<p> - one sentence description of the event"},{"location":"contributing/events/format/#description","title":"Description","text":"<p>Detailed description of the event. Should include: * What is the purpose of the event? * Are there any edge-cases, drawbacks or advantages of using it?</p>"},{"location":"contributing/events/format/#arguments","title":"Arguments","text":"<ul> <li><code>&lt;arg#1&gt;</code>:<code>&lt;type&gt;</code>[] - short description of the argument value. If the type or value might change (like with the <code>parse-arguments</code> flag) it should be elaborated here. <li><code>&lt;arg#2&gt;</code>:<code>&lt;type&gt;</code>[] - ..."},{"location":"contributing/events/format/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available</li> </ul>"},{"location":"contributing/events/format/#hooks","title":"Hooks","text":""},{"location":"contributing/events/format/#_2","title":"","text":""},{"location":"contributing/events/format/#type","title":"Type","text":"<p>Type of probes or hooks used to hook this function. If include more than one, should be in the form of  + ."},{"location":"contributing/events/format/#purpose","title":"Purpose","text":"<p>Why was this function hooked?</p>"},{"location":"contributing/events/format/#_3","title":"<p>...</p>","text":""},{"location":"contributing/events/format/#example-use-case","title":"Example Use Case","text":"<p>Example of a case where this event could be used.  </p>"},{"location":"contributing/events/format/#issues","title":"Issues","text":"<p>If there is an issue with this event, this is the place to write it.</p>"},{"location":"contributing/events/format/#related-events","title":"Related Events","text":"<p>Events connected by logic or interesting to be used in the context of the event.</p>"},{"location":"contributing/events/kprobes/do_sigaction/","title":"do_sigaction","text":""},{"location":"contributing/events/kprobes/do_sigaction/#intro","title":"Intro","text":"<p>do_sigaction - register new signal handler or get information about current one</p>"},{"location":"contributing/events/kprobes/do_sigaction/#description","title":"Description","text":"<p>The event marks that an attempt to get current task signal handler or to change the signal handler of the current task for a specific signal occurred. Signal handler change mark the change of the program behavior, and might indicate an attempt to defy expected signal behavior. This event is relevant for each syscall related to signal handling - <code>rt_sigaction</code>, <code>sigaction</code> and <code>signal</code>.</p>"},{"location":"contributing/events/kprobes/do_sigaction/#arguments","title":"Arguments","text":"<ul> <li><code>sig</code>:<code>int</code>[K] - the signal that its handler is inspected or changed.</li> <li><code>is_sa_initialized</code>:<code>bool</code>[K] - is a new signal handler given. If not, this event marks only inspection of data. If given, this will be the new handler for the event.</li> <li><code>sa_flags</code>:<code>unsigned long</code>[K,OPT] - the flags given for the new signal handler. Passed only if <code>is_sa_initialized</code>=<code>true</code>.</li> <li><code>sa_mask</code>:<code>unsigned long</code> [K,OPT] - the mask given for the new signal handler. Passed only if <code>is_sa_initialized</code>=<code>true</code>.</li> <li><code>sa_handle_method</code>:<code>u8</code>[K,OPT] - the handling method of the new signal handler. Passed only if <code>is_sa_initialized</code>=<code>true</code>.</li> <li><code>sa_handler</code>:<code>void*</code>[K,OPT] - the address of the new signal handling function if method is SIG_HND. Passed only if <code>is_sa_initialized</code>=<code>true</code>.</li> <li><code>is_old_sa_initialized</code>:<code>bool</code>[K] - is an old signal handler given. If given, the old signal handler will be copied back to the caller.</li> <li><code>old_sa_flags</code>:<code>unsigned long</code>[K] - the flags of the old signal handler</li> <li><code>old_sa_mask</code>:<code>unsigned long</code>[K] - the mask of the old signal handler</li> <li><code>old_sa_handle_method</code>:<code>u8</code>[K] - the handling method of the old signal handler</li> <li><code>old_sa_handler</code>:<code>void*</code>[K] - the address of the old signal handling function if method was SIG_HND</li> </ul>"},{"location":"contributing/events/kprobes/do_sigaction/#handle-method","title":"Handle Method","text":"<p>In the kernel, the handle method and the handler are united to one field. To make it more accessible to the user, Tracee split the two apart. Normally, the value can be one of the following: <code>SIG_DFL</code>(0), <code>SIG_IGN</code>(1) or pointer to user-mode handler function. To deal with the case of a user-mode handler, the value <code>SIG_HND</code>(2) is created to specify that the method is by handler.</p>"},{"location":"contributing/events/kprobes/do_sigaction/#hooks","title":"Hooks","text":""},{"location":"contributing/events/kprobes/do_sigaction/#do_sigaction_1","title":"do_sigaction","text":""},{"location":"contributing/events/kprobes/do_sigaction/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"contributing/events/kprobes/do_sigaction/#purpose","title":"Purpose","text":"<p>The function implementing the signal handler inspection/modification for syscalls</p>"},{"location":"contributing/events/kprobes/do_sigaction/#related-events","title":"Related Events","text":"<p><code>rt_sigaction</code>,<code>sigaction</code>,<code>signal</code></p>"},{"location":"contributing/events/kprobes/kallsyms_lookup_name/","title":"kallsyms_lookup_name","text":""},{"location":"contributing/events/kprobes/kallsyms_lookup_name/#intro","title":"Intro","text":"<p>kallsyms_lookup_name - lookup the address for a symbol</p>"},{"location":"contributing/events/kprobes/kallsyms_lookup_name/#description","title":"Description","text":"<p>This event is invoked when the 'kallsyms_lookup_name()' kernel function returns.  It suggests a lookup of kernel symbol address. This function is used mainly by external kernel extensions like kernel modules or BPF programs. It might be interesting in cases where a sensitive kernel symbol is looked-up.</p>"},{"location":"contributing/events/kprobes/kallsyms_lookup_name/#arguments","title":"Arguments","text":"<ul> <li><code>symbol_name</code>:<code>const char*</code>[K] - the symbol that is being looked-up.</li> <li><code>symbol_address</code>:<code>void*</code>[K] - the address of the symbol returned by the function. 0 if not found.</li> <li><code>syscall</code>:<code>int</code>[K] - the id of the syscall that invoked this lookup. If output option <code>parse-arguments</code> was chosen, the value will be transformed to the syscall name as a string type.</li> </ul>"},{"location":"contributing/events/kprobes/kallsyms_lookup_name/#hooks","title":"Hooks","text":""},{"location":"contributing/events/kprobes/kallsyms_lookup_name/#kallsyms_lookup_name_1","title":"kallsyms_lookup_name","text":""},{"location":"contributing/events/kprobes/kallsyms_lookup_name/#type","title":"Type","text":"<p>kprobe + kretprobe</p>"},{"location":"contributing/events/kprobes/kallsyms_lookup_name/#purpose","title":"Purpose","text":"<p>tracing the kallsyms_lookup_name event</p>"},{"location":"contributing/events/kprobes/kallsyms_lookup_name/#example-use-case","title":"Example Use Case","text":"<p><code>./dist/tracee-ebpf -t e=kallsyms_lookup_name</code></p>"},{"location":"contributing/events/kprobes/vfs_read/","title":"vfs_read","text":""},{"location":"contributing/events/kprobes/vfs_read/#intro","title":"Intro","text":"<p>vfs_read - generic FS file read to a buffer</p>"},{"location":"contributing/events/kprobes/vfs_read/#description","title":"Description","text":"<p>An event indicating that a read from a file to a buffer was done. The event is not FS specific, and the hook is on the inner implementation of the <code>read</code> and other buffer read syscalls. Notice that there are more methods for file reading other than this, like <code>vfs_readv</code>, file mapping, etc.</p>"},{"location":"contributing/events/kprobes/vfs_read/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code>[K] - the path of the file read</li> <li><code>dev</code>:<code>dev_t</code>[K] - the device the file resides in</li> <li><code>inode</code>:<code>unsigned long</code>[K] - the inode of the file in the device</li> <li><code>count</code>:<code>size_t</code>[K] - the size requested to be read by this operation</li> <li><code>pos</code>:<code>off_t</code>[K] - the start position for the read</li> </ul>"},{"location":"contributing/events/kprobes/vfs_read/#hooks","title":"Hooks","text":""},{"location":"contributing/events/kprobes/vfs_read/#vfs_read_1","title":"vfs_read","text":""},{"location":"contributing/events/kprobes/vfs_read/#type","title":"Type","text":"<p>kprobe + kretprobe</p>"},{"location":"contributing/events/kprobes/vfs_read/#purpose","title":"Purpose","text":"<p>The implementation of the <code>read</code>, <code>readv</code> syscall after fd resolving.</p>"},{"location":"contributing/events/kprobes/vfs_read/#related-events","title":"Related Events","text":"<p><code>read</code>,<code>vfs_readv</code>,<code>vfs_write</code></p>"},{"location":"contributing/events/kprobes/vfs_readv/","title":"vfs_readv","text":""},{"location":"contributing/events/kprobes/vfs_readv/#intro","title":"Intro","text":"<p>vfs_readv - generic FS file read to a vector</p>"},{"location":"contributing/events/kprobes/vfs_readv/#description","title":"Description","text":"<p>An event indicating that a read from a file to a vector was done. The event is not FS specific, and the hook is on the inner implementation of the <code>readv</code> and other vector read syscalls. Notice that there are more methods for file reading other than this, like <code>vfs_read</code>, file mapping, etc.</p>"},{"location":"contributing/events/kprobes/vfs_readv/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code>[K] - the path of the file read</li> <li><code>dev</code>:<code>dev_t</code>[K] - the device the file resides in</li> <li><code>inode</code>:<code>unsigned long</code>[K] - the inode of the file in the device</li> <li><code>vlen</code>:<code>unsigned long</code>[K] - the amount of buffers requested to be read by this operation to the vector</li> <li><code>pos</code>:<code>off_t</code>[K] - the start position for the read</li> </ul>"},{"location":"contributing/events/kprobes/vfs_readv/#hooks","title":"Hooks","text":""},{"location":"contributing/events/kprobes/vfs_readv/#vfs_readv_1","title":"vfs_readv","text":""},{"location":"contributing/events/kprobes/vfs_readv/#type","title":"Type","text":"<p>kprobe + kretprobe</p>"},{"location":"contributing/events/kprobes/vfs_readv/#purpose","title":"Purpose","text":"<p>The implementation of the <code>readv</code>, <code>preadv</code> and <code>preadv2</code> syscall after fd resolving.</p>"},{"location":"contributing/events/kprobes/vfs_readv/#related-events","title":"Related Events","text":"<p><code>readv</code>,<code>vfs_read</code>,<code>vfs_writev</code></p>"},{"location":"contributing/events/lsm_hooks/security_file_mprotect/","title":"security_file_mprotect","text":""},{"location":"contributing/events/lsm_hooks/security_file_mprotect/#intro","title":"Intro","text":"<p>security_file_mprotect - check permissions before changing the memory access protection of some memory region</p>"},{"location":"contributing/events/lsm_hooks/security_file_mprotect/#description","title":"Description","text":"<p>The event marks an attempt to change the access protection of some memory region, probably by the <code>mprotect</code> or <code>pkey_mprotect</code> syscalls. The event is triggered by the permissions check for the operation, as LSM hook. The event gives insight on the new access protection, as well as information on the memory addresses the attempt operation is on. This is a useful event to tracee memory protection changes originated by a user. Notice that the change of protection is applied to the pages containing the address range given, not only for given range.</p>"},{"location":"contributing/events/lsm_hooks/security_file_mprotect/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code>[K] - the path of the file associated with the memory region.</li> <li><code>prot</code>:<code>int</code>[K] - the new access protection for the memory region. Will be changed to a string representation if <code>parse-args</code> flag was used.</li> <li><code>ctime</code>:<code>unsigned long</code>[K] - the creation time of the file associated with the memory region.</li> <li><code>prev_prot</code>:<code>int</code>[K] - the previous access protection for the memory region. Will be changed to a string representation if <code>parse-args</code> flag was used.</li> <li><code>addr</code>:<code>void*</code>[K] - the start of virtual memory address to change its access protection.</li> <li><code>len</code>:<code>size_t</code>[K] - the length of the memory to apply the new protection on.</li> <li><code>pkey</code>:<code>int</code>[K,OPT] - the protection key used for the operation. Available only if invoking syscall is <code>pkey_mprotect</code>.</li> </ul>"},{"location":"contributing/events/lsm_hooks/security_file_mprotect/#hooks","title":"Hooks","text":""},{"location":"contributing/events/lsm_hooks/security_file_mprotect/#security_file_mprotect_1","title":"security_file_mprotect","text":""},{"location":"contributing/events/lsm_hooks/security_file_mprotect/#type","title":"Type","text":"<p>LSM hook</p>"},{"location":"contributing/events/lsm_hooks/security_file_mprotect/#purpose","title":"Purpose","text":"<p>The LSM hook for the <code>mprotect</code> related syscalls - <code>mprotect</code> and <code>pkey_mprotect</code>.</p>"},{"location":"contributing/events/lsm_hooks/security_file_mprotect/#related-events","title":"Related Events","text":"<p><code>mprotect</code>,<code>pkey_mprotect</code></p>"},{"location":"contributing/events/lsm_hooks/security_socket_setsockopt/","title":"security_socket_setsockopt","text":""},{"location":"contributing/events/lsm_hooks/security_socket_setsockopt/#intro","title":"Intro","text":"<p>security_socket_setsockopt - check permissions before setting the options associated with socket</p>"},{"location":"contributing/events/lsm_hooks/security_socket_setsockopt/#description","title":"Description","text":"<p>The event marks that an attempt to set a socket option occurred, probably by the <code>setsockopt</code> syscall. The event is triggered by the permissions check for the operation, as LSM hook. The event gives insight to the socket details (which differs from the <code>setsockopt</code> syscall event, that only pass the socket fd). However, unlike the <code>setsockopt</code> syscall event, the option value isn't passed.</p>"},{"location":"contributing/events/lsm_hooks/security_socket_setsockopt/#arguments","title":"Arguments","text":"<ul> <li><code>sockfd</code>:<code>int</code>[K] - the file descriptor of the socket.</li> <li><code>level</code>:<code>int</code>[K] - the level that the option should apply to. If the <code>parse-arguments</code> option is on, will be transformed to a string with the level name.</li> <li><code>optname</code>:<code>int</code>[K] - the option that is set. If the <code>parse-arguments</code> option is on, will be transformed to a string with the option name.</li> <li><code>local_addr</code>:<code>struct socketaddr*</code>[K] - the details of the socket (like socket type, local IP and port for TCP/UDP sockets, etc.).</li> </ul>"},{"location":"contributing/events/lsm_hooks/security_socket_setsockopt/#hooks","title":"Hooks","text":""},{"location":"contributing/events/lsm_hooks/security_socket_setsockopt/#security_socket_setsockopt_1","title":"security_socket_setsockopt","text":""},{"location":"contributing/events/lsm_hooks/security_socket_setsockopt/#type","title":"Type","text":"<p>LSM Hook</p>"},{"location":"contributing/events/lsm_hooks/security_socket_setsockopt/#purpose","title":"Purpose","text":"<p>The LSM hook of the <code>setsockopt</code> syscall implementation.</p>"},{"location":"contributing/events/lsm_hooks/security_socket_setsockopt/#related-events","title":"Related Events","text":"<p><code>setsockopt</code>, <code>getsockopt</code></p>"},{"location":"contributing/events/security_alerts/bpf_attach/","title":"bpf_attach","text":""},{"location":"contributing/events/security_alerts/bpf_attach/#intro","title":"Intro","text":"<p>bpf_attach - a BPF program is attached to a probe (kprobe/uprobe/tracepoint)</p>"},{"location":"contributing/events/security_alerts/bpf_attach/#description","title":"Description","text":"<p>An event marking that a BPF program was attached to a probe in the system. It occurs whenever a BPF program is attached to a perf event of the types: kprobe, uprobe or tracepoint. The purpose of the event is to give the user information about the BPF program,  as well as information about the probe itself.</p>"},{"location":"contributing/events/security_alerts/bpf_attach/#arguments","title":"Arguments","text":"<ul> <li><code>prog_type</code>:<code>int</code>[K] - the BPF program type.</li> <li><code>prog_name</code>:<code>const char*</code>[K] - the BPF program type (first 16 bytes only, as this is how it is saved in the kernel).</li> <li><code>perf_symbol</code>:<code>const char*</code>[K] - name/path of the symbol the BPF program is being attached to.</li> <li><code>perf_addr</code>:<code>u64</code>[K] - address/offset of the symbol the BPF program is being attached to.</li> <li><code>prog_write_user</code>:<code>int</code>[K] - whether the BPF program uses the bpf_probe_write_user() helper function.</li> <li><code>perf_type</code>:<code>int</code>[K] - the probe's type.</li> </ul>"},{"location":"contributing/events/security_alerts/bpf_attach/#hooks","title":"Hooks","text":""},{"location":"contributing/events/security_alerts/bpf_attach/#security_file_ioctl","title":"security_file_ioctl","text":""},{"location":"contributing/events/security_alerts/bpf_attach/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"contributing/events/security_alerts/bpf_attach/#purpose","title":"Purpose","text":"<p>Catch the attachment of the BPF program to the perf event</p>"},{"location":"contributing/events/security_alerts/bpf_attach/#security_bpf","title":"security_bpf","text":""},{"location":"contributing/events/security_alerts/bpf_attach/#type_1","title":"Type","text":"<p>kprobe</p>"},{"location":"contributing/events/security_alerts/bpf_attach/#purpose_1","title":"Purpose","text":"<p>Catch the attachment of the BPF program to the perf event</p>"},{"location":"contributing/events/security_alerts/bpf_attach/#security_bpf_prog","title":"security_bpf_prog","text":""},{"location":"contributing/events/security_alerts/bpf_attach/#type_2","title":"Type","text":"<p>kprobe</p>"},{"location":"contributing/events/security_alerts/bpf_attach/#purpose_2","title":"Purpose","text":"<p>save data of the BPF program for when we output the event</p>"},{"location":"contributing/events/security_alerts/bpf_attach/#check_helper_call","title":"check_helper_call","text":""},{"location":"contributing/events/security_alerts/bpf_attach/#type_3","title":"Type","text":"<p>kprobe</p>"},{"location":"contributing/events/security_alerts/bpf_attach/#purpose_3","title":"Purpose","text":"<p>check whether the BPF program uses the bpf_probe_write_user() helper function</p>"},{"location":"contributing/events/security_alerts/bpf_attach/#check_map_func_compatibility","title":"check_map_func_compatibility","text":""},{"location":"contributing/events/security_alerts/bpf_attach/#type_4","title":"Type","text":"<p>kprobe</p>"},{"location":"contributing/events/security_alerts/bpf_attach/#purpose_4","title":"Purpose","text":"<p>check whether the BPF program uses the bpf_probe_write_user() helper function</p>"},{"location":"contributing/events/security_alerts/bpf_attach/#example-use-case","title":"Example Use Case","text":"<p>./tracee-ebpf -t e=bpf_attach</p>"},{"location":"contributing/events/security_alerts/bpf_attach/#issues","title":"Issues","text":"<p>the 'check_helper_call' and 'check_map_func_compatibility' serves the same purpose.  in some kernels one of this symbols would not exist - therefore libbpf will output an error (execution will continue successfully due to the other hook).</p>"},{"location":"contributing/events/security_alerts/bpf_attach/#related-events","title":"Related Events","text":""},{"location":"contributing/events/security_alerts/magic_write/","title":"magic_write","text":""},{"location":"contributing/events/security_alerts/magic_write/#intro","title":"Intro","text":"<p>magic_write - write operation to a file which changed the file's headers</p>"},{"location":"contributing/events/security_alerts/magic_write/#description","title":"Description","text":"<p>An event marking that a new file is written, or an existing file header changed. The event occurs whenever a write operation to a file in offset 0 is done. The purpose of the event is to give the user information about the file's type and other meta-data needed to understand if the file is a threat.</p>"},{"location":"contributing/events/security_alerts/magic_write/#note","title":"Note","text":"<p>The event doesn't occur for FIFO files or other files with no persistent offsets, to reduce spam events.</p>"},{"location":"contributing/events/security_alerts/magic_write/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code>[K] - the path of the file written.</li> <li><code>bytes</code>:<code>bytes</code>[U,TOCTOU] - the first 20 bytes of the file.</li> <li><code>dev</code>:<code>dev_t</code>[K] - the device the file resides in.</li> <li><code>inode</code>:<code>unsigned long</code>[K] - the inode of the file in the FS.</li> </ul>"},{"location":"contributing/events/security_alerts/magic_write/#hooks","title":"Hooks","text":""},{"location":"contributing/events/security_alerts/magic_write/#vfs_write","title":"vfs_write","text":""},{"location":"contributing/events/security_alerts/magic_write/#type","title":"Type","text":"<p>kprobe + kretprobe</p>"},{"location":"contributing/events/security_alerts/magic_write/#purpose","title":"Purpose","text":"<p>Catch write operations to a file using the <code>write</code> syscall</p>"},{"location":"contributing/events/security_alerts/magic_write/#vfs_writev","title":"vfs_writev","text":""},{"location":"contributing/events/security_alerts/magic_write/#type_1","title":"Type","text":"<p>kprobe + kretprobe</p>"},{"location":"contributing/events/security_alerts/magic_write/#purpose_1","title":"Purpose","text":"<p>Catch write operations to a file using the <code>writev</code> syscall</p>"},{"location":"contributing/events/security_alerts/magic_write/#__kernel_write","title":"__kernel_write","text":""},{"location":"contributing/events/security_alerts/magic_write/#type_2","title":"Type","text":"<p>kprobe + kretprobe</p>"},{"location":"contributing/events/security_alerts/magic_write/#purpose_2","title":"Purpose","text":"<p>Catch write operations to a file from within the kernel (written buffer resides in kernel space)</p>"},{"location":"contributing/events/security_alerts/magic_write/#example-use-case","title":"Example Use Case","text":""},{"location":"contributing/events/security_alerts/magic_write/#issues","title":"Issues","text":""},{"location":"contributing/events/security_alerts/magic_write/#related-events","title":"Related Events","text":"<p>write, writev, vfs_write, vfs_writev, __kernel_write, security_file_open</p>"},{"location":"contributing/events/security_alerts/mem_prot_alert/","title":"mem_prot_alert","text":""},{"location":"contributing/events/security_alerts/mem_prot_alert/#intro","title":"Intro","text":"<p>mem_prot_alert - access protection change of some memory region is suspicious for malicious activity or leave it exposed to one.</p>"},{"location":"contributing/events/security_alerts/mem_prot_alert/#description","title":"Description","text":"<p>An event marking that a memory region protection access change is suspicious for malicious activity. Memory access protection changes might expose writeable memory to execution, or hide its possible execution. The specific alert is passed through the event arguments.</p>"},{"location":"contributing/events/security_alerts/mem_prot_alert/#arguments","title":"Arguments","text":"<ul> <li><code>alert</code>:<code>u32</code>[K] - the specific alert rose. Will be changed to a meaningful string with the <code>parse-args</code> flag on.</li> <li><code>addr</code>:<code>void*</code>[K] - the start address of the memory region the alert is on.</li> <li><code>len</code>:<code>size_t</code>[K] - the length of the memory region the alert is on.</li> <li><code>prot</code>:<code>int</code>[K] - the new access protection for the memory region.</li> <li><code>prev_prot</code>:<code>int</code> [K] - the previous access protection of the memory region.</li> <li><code>pathname</code>:<code>const char*</code>[K,OPT] - the path of the file related to the memory region, if there is a related file.</li> <li><code>dev</code>:<code>dev_t</code>[K,OPT] - the device of the file related to the memory region, if there is a related file.</li> <li><code>inode</code>:<code>unsigned long</code>[K,OPT] - the inode of the file related to the memory region, if there is a related file.</li> <li><code>ctime</code>:<code>u64</code>[K,OPT] - the last change time of the file related to the memory region, if there is a related file.</li> </ul>"},{"location":"contributing/events/security_alerts/mem_prot_alert/#alert-argument-values","title":"Alert argument values","text":"<p>The value given can be translated to a meaningful string using the parsing function in the <code>trace</code> package. Here are the current possible values: * \"Mmaped region with W+E permissions!\" - a mmap operation creating a memory that is exposed to dynamic code execution. * \"Protection changed to Executable!\" - the access protection of the memory region expose it to execution, after some different access protection in the past. * \"Protection changed from E to W+E!\" - the access protection of the memory region now enable dynamic modification and execution, enabling dynamic code execution. * \"Protection changed from W+E to E!\" - the access protection of the memory region reduced from dynamic code execution, but still exposed to execution of pre-written code. Might be some evasion attempt.</p>"},{"location":"contributing/events/security_alerts/mem_prot_alert/#hooks","title":"Hooks","text":""},{"location":"contributing/events/security_alerts/mem_prot_alert/#security_mmap_addr","title":"security_mmap_addr","text":""},{"location":"contributing/events/security_alerts/mem_prot_alert/#type","title":"Type","text":"<p>LSM hook</p>"},{"location":"contributing/events/security_alerts/mem_prot_alert/#purpose","title":"Purpose","text":"<p>Catch the mmap of a memory, getting access to its access protection.</p>"},{"location":"contributing/events/security_alerts/mem_prot_alert/#security_file_mprotect","title":"security_file_mprotect","text":""},{"location":"contributing/events/security_alerts/mem_prot_alert/#type_1","title":"Type","text":"<p>LSM hook</p>"},{"location":"contributing/events/security_alerts/mem_prot_alert/#purpose_1","title":"Purpose","text":"<p>Catch the change of access protection of a memory.</p>"},{"location":"contributing/events/security_alerts/mem_prot_alert/#sys_enter","title":"sys_enter","text":""},{"location":"contributing/events/security_alerts/mem_prot_alert/#type_2","title":"Type","text":"<p>raw tracepoint</p>"},{"location":"contributing/events/security_alerts/mem_prot_alert/#purpose_2","title":"Purpose","text":"<p>Extraction information from syscall arguments for deeper hooks oeration.</p>"},{"location":"contributing/events/security_alerts/mem_prot_alert/#related-events","title":"Related Events","text":"<p><code>security_mmap_addr</code>,<code>security_file_mprotect</code>,<code>security_mmap_file</code>,<code>mmap</code>,<code>mprotect</code></p>"},{"location":"contributing/events/security_alerts/symbols_loaded/","title":"symbols_loaded","text":""},{"location":"contributing/events/security_alerts/symbols_loaded/#intro","title":"Intro","text":"<p>symbols_loaded - a shared object which exports a watched symbol was loaded.</p>"},{"location":"contributing/events/security_alerts/symbols_loaded/#description","title":"Description","text":"<p>An event marking that a shared object, which export symbols configured to be watched, was loaded to current process. This event can help in identifying some shared object usage in the system, or inform on the occasion that a shared object tries to override some symbol of another library.</p>"},{"location":"contributing/events/security_alerts/symbols_loaded/#configuring-the-event","title":"Configuring the event","text":"<p>The event is configured using arguments filtering. For each argument, a filter can be used to configure the operation:</p>"},{"location":"contributing/events/security_alerts/symbols_loaded/#symbols","title":"symbols","text":"<p>Configure the watched symbols by the event. Specify the full name of the symbol for each symbol. The use is only with the <code>=</code> operator, and wildcards aren't supported.</p>"},{"location":"contributing/events/security_alerts/symbols_loaded/#library_path","title":"library_path","text":"<p>Whitelist for shared object paths prefixes. The path can be absolute, or just a library name. If only a name is given, then any shared object inside the known libraries directories which starts with the prefix will be whitelisted. The use is only with the <code>!=</code> operator, and wildcards aren't supported.</p>"},{"location":"contributing/events/security_alerts/symbols_loaded/#arguments","title":"Arguments","text":"<ul> <li><code>library_path</code>:<code>const char*</code>[K] - the path of the shared object file loaded.</li> <li><code>symbols</code>:<code>const char*const*</code>[U,TOCTOU] - the watched symbols exported by the shared object.</li> </ul>"},{"location":"contributing/events/security_alerts/symbols_loaded/#dependency-events","title":"Dependency Events","text":""},{"location":"contributing/events/security_alerts/symbols_loaded/#shared_object_loaded","title":"shared_object_loaded","text":"<p>The event of shared object loading triggers this event, and supplies the information on the shared object necessary to examine its shared objects.</p>"},{"location":"contributing/events/security_alerts/symbols_loaded/#sched_process_exec","title":"sched_process_exec","text":"<p>Used by tracee to maintain mount NS cache, used in this event to get to processes file system</p>"},{"location":"contributing/events/security_alerts/symbols_loaded/#example-use-case","title":"Example Use Case","text":"<p>To catch SO which tries to override the <code>fopen</code> function of <code>libc</code>, we can use the event in the following way:</p> <p><code>./dist/tracee-ebpf -t e=symbols_loaded -t symbols_loaded.args.symbols=fopen symbols_loaded.args.library_path!=libc</code></p>"},{"location":"contributing/events/security_alerts/symbols_loaded/#issues","title":"Issues","text":"<p>Because the event is implemented in user-mode, it needs to open and read files. This means that the event is not very performance efficient (although it uses some optimizations). It also means that until the SO file is opened, it could be altered or removed.</p>"},{"location":"contributing/events/security_alerts/symbols_loaded/#related-events","title":"Related Events","text":"<p>shared_object_loaded</p>"},{"location":"docs/overview/","title":"Docs","text":"<p>This documentation details how to use Tracee to access the features listed below.</p>"},{"location":"docs/overview/#features","title":"Features","text":"<ul> <li>Tracing<ul> <li>Tracee event collection capabilities only, without involving the detection engine.</li> </ul> </li> <li>Capturing<ul> <li>Tracee's unique feature that lets you capture interesting artifacts from running applications, using the --capture flag.</li> </ul> </li> <li>Detecting<ul> <li>Tracee is a runtime security detection engine, more than an introspection tool (tracee-ebpf) only. tracee-rules is a rules engine that helps you detect suspicious behavioral patterns in streams of events.</li> </ul> </li> <li>Integrating<ul> <li>Tracee integration with other techonologies, like Prometheus.</li> </ul> </li> <li>Deep Dive<ul> <li>In depth analysis of specific features and core logic to Tracee's various components.</li> </ul> </li> </ul>"},{"location":"docs/capturing/","title":"Getting Started with Capturing","text":"<p>Note</p> <p>This entire section is about running tracee-ebpf only, without piping events to tracee-rules but, instead, capturing artifacts from the environment being traced.</p> <p>Tracee has a unique feature that lets you capture interesting artifacts from running applications, using the <code>--capture</code> flag.</p> <pre><code>$ sudo ./dist/tracee-ebpf --capture help\n$ sudo ./dist/tracee-ebpf --capture xxx\n</code></pre> <p>Tip</p> <p>All captured artifacts are saved in Tracee's \"output directory\", which can be configured using <code>--capture dir:/path/to/dir</code>. You may also use <code>--capture clear-dir</code> if you want contents of the destination directory to be cleared every time you execute tracee.</p>"},{"location":"docs/capturing/#artifacts-types","title":"Artifacts Types","text":"<p>Tracee can capture the following types of artifacts:</p> <ol> <li> <p>Written Files</p> <p>Anytime a file is being written to, the contents of the file  will be captured. Written files can be filtered using an optional path  prefix.</p> <pre><code>$ sudo ./dist/tracee-ebpf \\\n   --output json \\\n   --trace comm=bash \\\n   --trace follow \\\n   --output option:parse-arguments \\\n   --capture dir:/tmp/tracee/ \\\n   --capture write=/tmp/*\n\n$ echo testing 123 &gt; /tmp/testing.txt\n</code></pre> <pre><code>{\"timestamp\":1657321167356748797,\"threadStartTime\":620311624458929,\"processorId\":7,\"processId\":2578238,\"cgroupId\":1,\"threadId\":2578238,\"parentProcessId\":2578237,\"hostProcessId\":2578238,\"hostThreadId\":2578238,\"hostParentProcessId\":2578237,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"bash\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"722\",\"eventName\":\"security_file_open\",\"argsNum\":6,\"returnValue\":0,\"stackAddresses\":null,\"args\":[{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"/tmp/testing.txt\"},{\"name\":\"flags\",\"type\":\"string\",\"value\":\"O_WRONLY|O_CREAT|O_TRUNC|O_LARGEFILE\"},{\"name\":\"dev\",\"type\":\"dev_t\",\"value\":271581185},{\"name\":\"inode\",\"type\":\"unsigned long\",\"value\":1966101},{\"name\":\"ctime\",\"type\":\"unsigned long\",\"value\":1657321027326584850},{\"name\":\"syscall_pathname\",\"type\":\"const char*\",\"value\":\"/tmp/testing.txt\"}]}\n{\"timestamp\":1657321167356729582,\"threadStartTime\":620311624458929,\"processorId\":7,\"processId\":2578238,\"cgroupId\":1,\"threadId\":2578238,\"parentProcessId\":2578237,\"hostProcessId\":2578238,\"hostThreadId\":2578238,\"hostParentProcessId\":2578237,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"bash\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"257\",\"eventName\":\"openat\",\"argsNum\":4,\"returnValue\":3,\"stackAddresses\":null,\"args\":[{\"name\":\"dirfd\",\"type\":\"int\",\"value\":-100},{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"/tmp/testing.txt\"},{\"name\":\"flags\",\"type\":\"string\",\"value\":\"O_WRONLY|O_CREAT|O_TRUNC\"},{\"name\":\"mode\",\"type\":\"mode_t\",\"value\":438}]}\n</code></pre> <p>Note</p> <p>You can read captured files written at <code>/tmp/tracee/out</code>: <pre><code>$ sudo cat /tmp/tracee/out/host/write.dev-271581185.inode-1966101\ntesting 123\n</code></pre></p> </li> <li> <p>Executed Files</p> <p>Anytime a binary is executed, the binary file will be captured. If the  same binary is executed multiple times, it will be captured just once.</p> <pre><code>$ sudo ./dist/tracee-ebpf \\\n   --output json \\\n   --trace comm=bash \\\n   --trace follow \\\n   --output option:parse-arguments \\\n   --capture dir:/tmp/tracee/ \\\n   --capture exec\n\n$ /bin/ls\n</code></pre> <pre><code>{\"timestamp\":1657322300531713371,\"threadStartTime\":620311624458929,\"processorId\":21,\"processId\":2578238,\"cgroupId\":1,\"threadId\":2578238,\"parentProcessId\":2578237,\"hostProcessId\":2578238,\"hostThreadId\":2578238,\"hostParentProcessId\":2578237,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"bash\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"56\",\"eventName\":\"clone\",\"argsNum\":5,\"returnValue\":3331757,\"stackAddresses\":null,\"args\":[{\"name\":\"flags\",\"type\":\"string\",\"value\":\"CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID\"},{\"name\":\"stack\",\"type\":\"void*\",\"value\":\"0x0\"},{\"name\":\"parent_tid\",\"type\":\"int*\",\"value\":\"0x0\"},{\"name\":\"child_tid\",\"type\":\"int*\",\"value\":\"0x7fd7ce0d3a10\"},{\"name\":\"tls\",\"type\":\"unsigned long\",\"value\":0}]}\n{\"timestamp\":1657322300534562489,\"threadStartTime\":620311624458929,\"processorId\":21,\"processId\":2578238,\"cgroupId\":1,\"threadId\":2578238,\"parentProcessId\":2578237,\"hostProcessId\":2578238,\"hostThreadId\":2578238,\"hostParentProcessId\":2578237,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"bash\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"3\",\"eventName\":\"close\",\"argsNum\":1,\"returnValue\":0,\"stackAddresses\":null,\"args\":[{\"name\":\"fd\",\"type\":\"int\",\"value\":3}]}\n</code></pre> <p>Note</p> <p>You will have a copy of each executed file written at <code>/tmp/tracee/out</code>: <pre><code>$ ldd /bin/ls\nlinux-vdso.so.1 (0x00007ffca632c000)\nlibselinux.so.1 =&gt; /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007f9a930d5000)\nlibc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f9a92ead000)\nlibpcre2-8.so.0 =&gt; /lib/x86_64-linux-gnu/libpcre2-8.so.0 (0x00007f9a92e16000)\n/lib64/ld-linux-x86-64.so.2 (0x00007f9a93136000)\n\n$ ldd /tmp/tracee/out/host/exec.1657322052835478987.ls\nlinux-vdso.so.1 (0x00007ffe337fb000)\nlibselinux.so.1 =&gt; /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007feeb1fa5000)\nlibc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007feeb1d7d000)\nlibpcre2-8.so.0 =&gt; /lib/x86_64-linux-gnu/libpcre2-8.so.0 (0x00007feeb1ce6000)\n/lib64/ld-linux-x86-64.so.2 (0x00007feeb2006000)\n\n$ sudo chmod +x /tmp/tracee/out/host/exec.1657322052835478987.ls\n$ /tmp/tracee/out/host/exec.1657322052835478987.ls\n</code></pre></p> </li> <li> <p>Memory Files</p> <p>Anytime a memory unpacker is detected, the suspicious memory region  will be captured. This is triggered when memory protection changes from  Write+Execute to Write.</p> <pre><code>$ sudo ./dist/tracee-ebpf \\\n   --output none \\\n   --trace comm=bash \\\n   --trace follow \\\n   --capture dir:/tmp/tracee/ \\\n   --capture mem\n</code></pre> <p>Note</p> <p>You may opt not to have any output from tracee with <code>--output none</code> command flag is given. This makes tracee to work in capture mode only.</p> </li> <li> <p>Network PCAP Files</p> <p>Anytime a network packet is delivered to a process, traced by tracee,  this packet might be captured into one or multiple pcap files.</p> <p>A good way to test this behavior is to execute:</p> <pre><code>$ sudo ./dist/tracee-ebpf \\\n    --trace event=net_packet_ipv4 \\\n    --capture network\n</code></pre> <p>and observe a single pcap file for all ipv4 packets created:</p> <pre><code>$ find /tmp/tracee/out/pcap/\n/tmp/tracee/out/pcap/\n/tmp/tracee/out/pcap/single.pcap\n</code></pre> <p>You can select only dns packets, for example:</p> <pre><code>$ sudo ./dist/tracee-ebpf \\\n    --trace event=net_packet_dns \\\n    --capture network\n</code></pre> <p>and the file <code>/tmp/tracee/out/pcap/single.pcap</code> would only contain DNS  related packets:</p> <pre><code>$ find /tmp/tracee/out/pcap/\n/tmp/tracee/out/pcap/\n/tmp/tracee/out/pcap/single.pcap\n\n$ sudo tcpdump -n -r /tmp/tracee/out/pcap/single.pcap | head -2\nreading from file /tmp/tracee/out/pcap/single.pcap, link-type NULL (BSD loopback), snapshot length 262144\n16:53:48.870629 IP 127.0.0.1.55569 &gt; 127.0.0.53.53: 33361+ [1au] A? www.uol.com.br. (43)\n16:53:48.870690 IP 127.0.0.1.55569 &gt; 127.0.0.53.53: 25943+ [1au] AAAA? www.uol.com.br. (43) ```\n\nA great thing is that you may have multiple pcap files, divided by:\n\n1. single: a single pcap file containing all packets (the default)\n1. process: one file per process executed, ordered by host and container\n1. container: one file for the host and one pcap file per container\n1. per-command: one file per command executed (even if multiple times)\n\nand you can even have multiple ways at the same time. Example: a ping\ncommand is executed inside a container. You want to summarize captured\ntraffic per container and per command. You will find the same captured\ndata for that ping command inside `commands/container_id/ping.pcap` and\ninside `containers/container_id.pcap`.\n\n```text\n$ sudo ./dist/tracee-ebpf \\\n    --trace event=net_packet_icmp \\\n    --capture network \\\n    --capture pcap:process,container,command\n</code></pre> <pre><code>$ cd /tmp/tracee/out\n$ find pcap\npcap\npcap/commands\npcap/commands/b86533d11f3\npcap/commands/b86533d11f3/ping.pcap\npcap/commands/host\npcap/commands/host/sshd.pcap\npcap/commands/host/zerotier-one.pcap\npcap/commands/host/node.pcap\npcap/commands/fd95a035ce5\npcap/commands/fd95a035ce5/ping.pcap\npcap/processes\npcap/processes/b86533d11f3\npcap/processes/b86533d11f3/ping_1261180_1663772450241192.pcap\npcap/processes/host\npcap/processes/host/node_186708_1573567360495399.pcap\npcap/processes/host/node_1196826_1662656211119567.pcap\npcap/processes/host/zerotier-one_7882_137007714376.pcap\npcap/processes/host/sshd_1196773_1662654999660718.pcap\npcap/processes/fd95a035ce5\npcap/processes/fd95a035ce5/ping_1261163_1663769383806467.pcap\npcap/containers\npcap/containers/host.pcap\npcap/containers/b86533d11f3.pcap\npcap/containers/fd95a035ce5.pcap\n</code></pre> <p>you can see the packets by executing tcpdump on any pcap file:</p> <pre><code>$ tcpdump -r pcap/containers/b86533d11f3.pcap\nreading from file pcap/containers/b86533d11f3.pcap, link-type NULL (BSD loopback), snapshot length 65535\n02:52:00.524035 IP 172.17.0.3 &gt; dns.google: ICMP echo request, id 5, seq 476, length 64\n02:52:00.533145 IP dns.google &gt; 172.17.0.3: ICMP echo reply, id 5, seq 476, length 64\n02:52:01.525455 IP 172.17.0.3 &gt; dns.google: ICMP echo request, id 5, seq 477, length 64\n02:52:01.535414 IP dns.google &gt; 172.17.0.3: ICMP echo reply, id 5, seq 477, length 64\n02:52:02.526715 IP 172.17.0.3 &gt; dns.google: ICMP echo request, id 5, seq 478, length 64\n02:52:02.536444 IP dns.google &gt; 172.17.0.3: ICMP echo reply, id 5, seq 478, length 64\n02:52:03.528739 IP 172.17.0.3 &gt; dns.google: ICMP echo request, id 5, seq 479, length 64\n02:52:03.538622 IP dns.google &gt; 172.17.0.3: ICMP echo reply, id 5, seq 479, length 64\n\n$ tcpdump -r pcap/commands/b86533d11f3/ping.pcap\nreading from file pcap/commands/b86533d11f3/ping.pcap, link-type NULL (BSD loopback), snapshot length 65535\n02:52:00.524035 IP 172.17.0.3 &gt; dns.google: ICMP echo request, id 5, seq 476, length 64\n02:52:00.533145 IP dns.google &gt; 172.17.0.3: ICMP echo reply, id 5, seq 476, length 64\n02:52:01.525455 IP 172.17.0.3 &gt; dns.google: ICMP echo request, id 5, seq 477, length 64\n02:52:01.535414 IP dns.google &gt; 172.17.0.3: ICMP echo reply, id 5, seq 477, length 64\n02:52:02.526715 IP 172.17.0.3 &gt; dns.google: ICMP echo request, id 5, seq 478, length 64\n02:52:02.536444 IP dns.google &gt; 172.17.0.3: ICMP echo reply, id 5, seq 478, length 64\n02:52:03.528739 IP 172.17.0.3 &gt; dns.google: ICMP echo request, id 5, seq 479, length 64\n02:52:03.538622 IP dns.google &gt; 172.17.0.3: ICMP echo reply, id 5, seq 479, length 64\n</code></pre> <p>Note</p> <p>Note that the same packets were written to 2 different pcap files: the pcap file describing the container <code>b86533d11f3</code> (because it was executing a single process: ping) and the pcap file describing ANY ping command executed in that container (commands/b86533d11f3/ping.pcap).</p> <p>The format for the pcap filenames inside <code>output_dir</code> is the following:</p> <ol> <li>single:    ./pcap/single.pcap</li> <li>processes:    ./pcap/processes/<code>container_id</code>/<code>process_comm</code>/<code>host_tid</code>/<code>task_starttime</code>.pcap</li> <li>containers:    ./pcap/containers/<code>container_id</code>.pcap</li> <li>commands:    ./pcap/commands/<code>container_id</code>/<code>process_comm</code>.pcap</li> </ol> <p>Attention</p> <p>By default, all pcap files will contain packets with headers only. That might too little for introspection, since sometimes one might be interested in a few bytes of the captured packet (or event it all). Next item shows how to capture a specific packet payload size.</p> <p>In order to capture a specific payload size you may specify:</p> <pre><code> $ sudo ./dist/tracee-ebpf \\\n     --trace event=net_packet_tcp \\\n     --capture network \\\n     --capture pcap:single,command \\\n     --capture pcap-snaplen:default\n</code></pre> <p>To capture packet headers + 96 bytes of payload. Or replace <code>default</code> by:</p> <ol> <li>headers: capture up to L4 headers only</li> <li>max: full sized packets into pcap. WARNING: big pcap files.</li> <li>256b, 512b, 1024b, ... (any number plus \"b\")</li> <li>16kb, 32kb, 64kb,  ... (any number plus \"kb\")</li> </ol> <p>when specifying a payload size, it refers to the payload AFTER the layer4 headers (and not the entire packet length).</p> </li> <li> <p>Loaded Kernel Modules</p> <p>Anytime a kernel module is loaded, the binary file will be captured.  If the same binary is loaded multiple times, it will be captured just once.</p> <pre><code>$ sudo ./dist/tracee-ebpf \\\n   --output none \\\n   --trace comm=bash \\\n   --trace follow \\\n   --capture clear-dir \\\n   --capture module\n</code></pre> <p>Captured module will be found in tracee destination directory, just like  any other captured file would be:</p> <pre><code>$ sudo ls /tmp/tracee/out/host\n  module.dev-271581185.inode-4071826.pid-3668786.c8b62228208f4bdbf21df09c01046b73dd44733841675bf3c0ff969fbedab616\n</code></pre> <p>AND, the captured module is an exact copy of the loaded module:</p> <pre><code>$ sudo rmmod lkm_example\n$ sudo insmod /tmp/tracee/out/host/module.dev-271581185.inode-4071826.pid-3668786.c8b62228208f4bdbf21df09c01046b73dd44733841675bf3c0ff969fbedab616\n$ lsmod | grep example\nlkm_example            16384  0\n$ sudo rmmod lkm_example\n</code></pre> <p>you can even load/unload it.</p> <p>Note</p> <p>Example kernel module taken from this blog</p> </li> </ol>"},{"location":"docs/deep-dive/architecture/","title":"Architecture","text":""},{"location":"docs/deep-dive/architecture/#tracee-architecture-overview","title":"Tracee Architecture Overview","text":"<p>Overview</p> <ol> <li> <p>Kernel eBPF programs GENERATE Tracee Events to Userland:</p> <ol> <li>Tracepoints</li> <li>Probes</li> <li>Trafic Control Hooks</li> </ol> </li> <li> <p>Userland events are COLLECTED and ENRICHED with more information:</p> <ol> <li>Kernel Events (Syscalls, Tracepoints, Kprobes)</li> <li>OS Events (Running Containers, ...)</li> <li>Derived (from other) Events</li> <li>Network Events</li> </ol> </li> <li> <p>DETECT patterns based on existing signatures:</p> <ol> <li>OPA/Rego signatures</li> <li>Golang signatures</li> <li>Go-CEL signatures (Proof-of-Concept / Experimental)</li> </ol> </li> <li> <p>Let other tools to CONSUME detection events:</p> <ol> <li>Capture Artifacts</li> <li>Postee</li> <li>Falco Sidekick</li> </ol> </li> <li> <p>ENFORCE</p> <ol> <li>Work in Progress</li> </ol> </li> </ol>"},{"location":"docs/deep-dive/architecture/#tracee-pipeline-concept","title":"Tracee Pipeline Concept","text":"<p>Pipeline</p> <ol> <li> <p>Multiple CPUs constantly generate events from the eBPF programs running    inside the kernel (inside an eBPF VM).</p> </li> <li> <p>The eBPF programs are executed whenever the kernel (or network) hooks    they're attached to are triggered.</p> </li> <li> <p>eBPF programs decide whether they should submit the events to    tracee-ebpf or not, based on given filters.</p> </li> <li> <p>Those events are sent to libbpfgo through a shared memory ring buffer    mechanism (called perfbuffer).</p> </li> <li> <p>libbpfgo sends collected events to tracee through golang    channels.</p> </li> <li> <p>tracee-ebpf parses received events and does multiple things:</p> <ol> <li>parse events for argument type conversions if requested</li> <li>enriches the events that need enrichment (containers, network, processes)</li> <li>capture artifacts from collected events into external files</li> </ol> </li> <li> <p>tracee-ebpf writes events to tracee-rules through a mechanism    called printer.</p> </li> <li> <p>tracee-rules receives events and evaluate them using either golang    or rego (or go-cel, as a proof-of-concept) signatures.</p> <ol> <li>Golang signatures are faster and do pretty much anything the language    allows. They might connect (or have cached) external data sources to    evaluate events, for example.</li> </ol> </li> <li> <p>Detections are spit out from tracee-rules if evaluations are    positive.</p> </li> </ol> <p>This mechanism is what we call the tracee pipeline: to receive events from the kernel into userland (tracee-ebpf), then to parse and enrich those events and to submit them to tracee-rules for it to evaluate them looking for detection patterns described as signatures.</p>"},{"location":"docs/deep-dive/caching-events/","title":"Special: Caching Events","text":"<p>Tracee has an events caching (in-memory) mechanism. In order to check latest caching options you may execute:</p> <pre><code>$ ./dist/tracee-ebpf --cache help\n</code></pre> <p>Read</p> <p>Before continuing, please read the architecture page, in order to understand the tracee pipeline concept, AND the performance page, to understand possible pain points.</p> <p></p> <p>The caching happens in userland, it is an in-memory caching, and it helps with workload bursts: if kernel produces more events than userland is capable of processing (considering tracee-ebpf parsing and tracee-rules evaluations) then the events are kept in a sizeable cache (defined by user) so they're not lost (if cache isn't full).</p> <p>The effects of this are the following:</p> <ol> <li> <p>Detections might be delayed because of workload bursts, but not lost (if    cache isn't full).</p> </li> <li> <p>Event losses from the kernel perf/ring buffer will only happen when    cache is full.</p> </li> <li> <p>Any difference in ratio production:consumption (either from    kernel-&gt;tracee-ebpf or tracee-ebpf-&gt;tracee-rules**) can be    mitigated temporarily.</p> </li> </ol>"},{"location":"docs/deep-dive/caching-events/#use-caching","title":"Use caching","text":"<p>Example using 1GB cache, container enrichment in the pipeline, argument parsing so arguments are formatted in a human consumable way, detect syscall that generated the event:</p> <pre><code>$ sudo ./dist/tracee-ebpf \\\n    --cache cache-type=mem \\\n    --cache mem-cache-size=1024 \\\n    --containers -o format:json \\\n    -o option:parse-arguments \\\n    -trace container \\\n    --crs docker:/var/run/docker.sock\n</code></pre> <p>We are using most of the options that could cause latencies in the event pipeline BUT we're not piping the events to tracee-rules.</p> <p>Attention</p> <p>If you pipe tracee-ebpf output to another tool, like <code>jq</code>: <pre><code>| jq -c '. | {cgroupid, processname, containername}'\n</code></pre> You may cause latencies in tracee-ebpf pipeline because the event json processing from <code>jq</code> might not be as fast as how tracee-ebpf is capable of writing events to it (just like tracee-rules could do if being slow evaluating events).</p>"},{"location":"docs/deep-dive/dropping-capabilities/","title":"Special: Environment Capabilities","text":""},{"location":"docs/deep-dive/dropping-capabilities/#introduction-to-capabilities-quoting-parts-of-kernel-docs","title":"Introduction to Capabilities (quoting parts of kernel docs)","text":"<p>For the purpose of performing permission checks, traditional UNIX implementations distinguish two categories of processes: privileged processes (whose effective user ID is 0, referred to as superuser or root), and unprivileged processes (whose effective UID is nonzero). Privileged processes bypass all kernel permission checks, while unprivileged processes are subject to full permission checking based on the process's credentials (usually: effective UID, effective GID, and supplementary group list).</p> <p>Linux divides the privileges traditionally associated with superuser into distinct units, known as capabilities, which can be independently enabled and disabled. Capabilities are a per-thread attribute.</p> <p>Thread capability sets:</p> <ul> <li> <p>Permitted: This is a limiting superset for the effective capabilities that the thread may assume. It is also a limiting superset for the capabilities that may be added to the inheritable set by a thread that does not have the CAP_SETPCAP capability in its effective set.</p> </li> <li> <p>Inheritable: This is a set of capabilities preserved across an execve(2). Inheritable capabilities remain inheritable when executing any program, and inheritable capabilities are added to the permitted set when executing a program that has the corresponding bits set in the file inheritable set.</p> </li> <li> <p>Effective: This is the set of capabilities used by the kernel to perform permission checks for the thread.</p> </li> <li> <p>Bounding: The capability bounding set is a mechanism that can be used to limit the capabilities that are gained during execve(2).</p> </li> </ul>"},{"location":"docs/deep-dive/dropping-capabilities/#tracee-and-capabilities","title":"Tracee and capabilities","text":"<p>tracee-ebpf and tracee-rules both try to reduce their capabilities during their execution. The way they do is through \"protection rings\":</p> <ul> <li>Privileged   (ring 0): all capabilities are Effective (almost never)</li> <li>Required     (ring 1): only required (by events) capabilities are Effective (during config)</li> <li>Requested    (ring 2): single time requested capabilities are Effective (special needs)</li> <li>Unprivileged (ring 3): no capabilities are Effective at all (most of the time)</li> </ul>"},{"location":"docs/deep-dive/dropping-capabilities/#listing-available-capabilities","title":"Listing available capabilities","text":"<p>You may see all available capabilities in the running environment by running:</p> <pre><code>--capabilities help\n</code></pre> <p>command line flag.</p>"},{"location":"docs/deep-dive/dropping-capabilities/#bypass-capabilities-dropping-feature","title":"Bypass capabilities dropping feature","text":"<p>Attention</p> <p>This session is important if you're facing errors while tracee-ebpf is trying to drop its capabilities or any other permissions errors.</p> <p>Some environments won't allow capabilities dropping because of permission issues (for example - AWS Lambdas).</p> <p>It might be a result of seccomp filter for example, restricting syscalls access.</p> <p>Failure in capabilities dropping will result tracee's exit with a matching error, to guarantee that tracee isn't running with excess capabilities without the user agreement.</p> <p>To allow tracee-ebpf to run with high capabilities, and prevent those errors, the <code>--capabilities bypass=1</code> flag can be used. For the docker container users, the environment variable <code>CAPABILITIES_BYPASS=0|1</code> will have the same effect.</p> <p>For tracee-rules, CAPABILITIES_BYPASS=1 will set the \"--allcaps\" command line flag and allow it to run with full capabilities.</p> <p>Note</p> <p>Bypassing the capabilities drop will run tracee-ebpf and/or tracee-rules with all capabilities set as Effective and it is only recommended if you know what you are doing.</p>"},{"location":"docs/deep-dive/dropping-capabilities/#capabilities-errors-missing-or-too-permissive","title":"Capabilities Errors (Missing or Too Permissive)","text":"<p>During development, tracee might have bugs related to capabilities dropping feature: one event might not have its needed capabilities set as a dependency, for example, and you might still want to use that event.</p> <p>One way to have fine grained control of \"execution time\" effective capabilities is to rely on following 2 command line flags:</p> <ul> <li><code>--capabilities add=cap_X,cap_Y</code> (docker env variable CAPABILITIES_ADD)</li> <li><code>--capabilities drop=cap_Y,capZ</code> (docker env variable CAPABILITIES_DROP)</li> </ul> <p>The first will add given capabilities to the Required ring (so events might be able to work). The last will remove the capabilities from that same ring.</p> <p>Tracee-rules do not support adding or removing specific capabilities.</p>"},{"location":"docs/deep-dive/healthz/","title":"Special: Healthz Endpoint","text":"<p>tracee-ebpf and tracee-rules both support a flag <code>--healthz</code> which enable a <code>/healthz</code> endpoint that returns if <code>OK</code> if the process are healthy.</p> <p>Example:</p> <pre><code>$ tracee-ebpf --healthz\n$ curl http://localhost:3366/healthz\n\nOK\n</code></pre> <p>The port used is the default port <code>3366</code> for <code>tracee-ebpf</code> and <code>4466</code> for <code>tracee-rules</code>. It can be customized with the flag <code>--listen-addr</code>. </p> <p>Example:</p> <pre><code>$ tracee-ebpf --healthz --listen-addr=:8080\n$ curl http://localhost:8080/healthz\n\nOK\n</code></pre>"},{"location":"docs/deep-dive/ordering-events/","title":"Special: Ordering Events","text":"<p>Package sorting feature is responsible for sorting incoming events from the BPF programs chronologically.</p> <pre><code>sudo ./dist/tracee-ebpf \\\n    -o format:json \\\n    -o option:parse-arguments \\\n    -o option:sort-events\n</code></pre> <p>Information</p> <p>There are 3 known sources to events sorting issues:</p> <ol> <li> <p>In perf buffer, events are read in round robing order from CPUs buffers      (and not according to invocation time).</p> </li> <li> <p>Syscall events are invoked after internal events of the syscall (though      the syscall happened before the internal events).</p> </li> <li> <p>Virtual CPUs might enter sleep mode by host machine scheduler and send      events after some delay.</p> </li> </ol>"},{"location":"docs/deep-dive/ordering-events/#deep-dive-into-sorting-feature","title":"Deep Dive Into Sorting Feature","text":"<p>To address the events perf buffers issue, the events are divided to queues according to the source CPU. This way the events are almost ordered (except for syscalls). The syscall events are inserted to their right chronological place manually.</p> <p>This way, all events which occurred before the last event of the most delaying CPU could be sent forward with guaranteed order.</p> <p>To make sure syscall events are not missed when sending, a small delay is needed. Lastly, to address the vCPU sleep issue (which might cause up to 2 events received in a delay), the events need to be sent after a delay which is bigger than max possible vCPU sleep time (which is just an increase of the syscall events delay sending).</p>"},{"location":"docs/deep-dive/ordering-events/#algorithm-for-nerds-d","title":"Algorithm for Nerds =D","text":"<p>To summarize the algorithm main logic, here is textual simulation of the operation (assume that 2 scheduler ticks are larger than max possible vCPU sleep time):  </p> <p>Tn = Timestamp (n == TOD) #m = Event's Source CPU  </p> <ol> <li> <p>Initial State</p> <pre><code>       [ CPU 0 ]    [ CPU 1 ]    [ CPU 2 ]\n  HEAD    T1           T2           T4\n          T3           T5\n          T6\n  TAIL    T8\n</code></pre> </li> <li> <p>Scheduler Tick #1</p> <pre><code>Incoming events: T9#1, T11#2, T13#1, T10#2, T12#2\n\nQueues state after insert:\n       [ CPU 0 ]    [ CPU 1 ]    [ CPU 2 ]\n  HEAD    T1           T2           T4\n          T3           T5           T10 +\n          T6           T9  +        T11 +\n  TAIL    T8           T13 +        T12 +\n\n  - No event sent.\n  - Oldest timestamp = T1.\n  - T8 is oldest timestamp in most recent timestamps.\n  - In 2 ticks from now: send all events up to T8.\n  - Bigger timestamps than T8 (+) will be sent in future scheduling.\n</code></pre> </li> <li> <p>Scheduler Tick #2</p> <pre><code>Incoming events: T7#0, T22#1, T23#2, T20#0, T25#1, T24#2, T21#0\n\nQueues state after insert:\n       [ CPU 0 ]    [ CPU 1 ]    [ CPU 2 ]\n  HEAD    T1  ^        T2  ^        T4  ^\n          T3  ^        T5  ^        T10\n          T6  ^        T9           T11\n          T7  +^       T13          T12\n          T8  ^        T22 +        T23 +\n          T20 +        T25 +        T24 +\n  TAIL    T21 +\n\n  - No event sent.\n  - Oldest timestamp = T1.\n  - T21 is oldest timestamp in most recent timestamps.\n  - In 2 ticks from now: send all events up to T21.\n  - T8 is previous oldest timestamp in most recent timestamps.\n  - Next tick: send all events up to T8.\n  - Bigger timestamps than T21 (+) will be sent in future scheduling.\n</code></pre> </li> <li> <p>Scheduler Tick #3</p> <pre><code>Incoming events: T30#0, T34#1, T35#2, T31#0, T36#2, T32#0, T37#2, T33#0, T38#2, T50#1, T51#1\n\nQueues state after insert:\n       [ CPU 0 ]    [ CPU 1 ]    [ CPU 2 ]\n  HEAD    T20 ^        T9  ^        T10 ^\n          T21 ^        T13 ^        T11 ^\n          T30 +        T22          T12 ^\n          T31 +        T23          T24\n          T32 +        T25          T35 +\n          T33 +        T34 +        T36 +\n                       T50 +        T37 +\n   TAIL                T51 +        T38 +\n\n  - Max sent timestamp = T8.\n  - Oldest timestamp = T9.\n  - T33 is oldest timestamp in most recent timestamps.\n  - In 2 ticks from now: send all events up to T33.\n  - T21 is previous oldest timestamp in most recent timestamps.\n  - Next tick: send all events up to T21.\n  - Bigger timestamps than T33 (+) will be sent in future scheduling.\n</code></pre> </li> </ol>"},{"location":"docs/deep-dive/override-os-files/","title":"Special: Overriding OS needed files","text":"<p>Tracee supports eBPF CO-RE (Compile Once - Run Everywhere) technology and, because of that, it might need some information about the Linux OS it is running at. Tracee, through libbpfgo, must have access to /etc/os-release file AND either /boot/config-$(uname-r) OR /proc/config.gz files (KernelConfig API at helpers/kernel_config).</p> <p>Note that, despite having this need, tracee will try to execute as CO-RE eBPF program in any environment it is executed.</p>"},{"location":"docs/deep-dive/override-os-files/#os-release","title":"OS-RELEASE","text":"<p>Tracee will show you collected information about the running Linux OS with the <code>--log debug</code> argument:</p> <pre><code>$ sudo ./dist/tracee-ebpf --log debug --trace uid=1000 --trace pid=new --trace event=execve\n{\"level\":\"debug\",\"ts\":1670976393.7308447,\"msg\":\"osinfo\",\"ARCH\":\"x86_64\",\"PRETTY_NAME\":\"\\\"Manjaro Linux\\\"\",\"ID\":\"manjaro\",\"ID_LIKE\":\"arch\",\"BUILD_ID\":\"rolling\",\"KERNEL_RELEASE\":\"5.15.81-1-MANJARO\",\"pkg\":\"urfave\",\"file\":\"urfave.go\",\"line\":53}\n{\"level\":\"debug\",\"ts\":1670976393.73088,\"msg\":\"RuntimeSockets: failed to register default\",\"socket\":\"containerd\",\"error\":\"failed to register runtime socket stat /var/run/containerd/containerd.sock: no such file or directory\",\"pkg\":\"flags\",\"file\":\"containers.go\",\"line\":45}\n{\"level\":\"debug\",\"ts\":1670976393.730894,\"msg\":\"RuntimeSockets: failed to register default\",\"socket\":\"crio\",\"error\":\"failed to register runtime socket stat /var/run/crio/crio.sock: no such file or directory\",\"pkg\":\"flags\",\"file\":\"containers.go\",\"line\":45}\n{\"level\":\"debug\",\"ts\":1670976393.7309017,\"msg\":\"RuntimeSockets: failed to register default\",\"socket\":\"podman\",\"error\":\"failed to register runtime socket stat /var/run/podman/podman.sock: no such file or directory\",\"pkg\":\"flags\",\"file\":\"containers.go\",\"line\":45}\n{\"level\":\"debug\",\"ts\":1670976393.7310617,\"msg\":\"osinfo\",\"security_lockdown\":\"none\",\"pkg\":\"urfave\",\"file\":\"urfave.go\",\"line\":116}\n{\"level\":\"debug\",\"ts\":1670976393.733237,\"msg\":\"BTF\",\"bpfenv\":false,\"btfenv\":false,\"vmlinux\":true,\"pkg\":\"initialize\",\"file\":\"bpfobject.go\",\"line\":40}\n{\"level\":\"debug\",\"ts\":1670976393.7332687,\"msg\":\"BPF: using embedded BPF object\",\"pkg\":\"initialize\",\"file\":\"bpfobject.go\",\"line\":69}\n{\"level\":\"debug\",\"ts\":1670976393.7355402,\"msg\":\"unpacked CO:RE bpf object file into memory\",\"pkg\":\"initialize\",\"file\":\"bpfobject.go\",\"line\":144}\nTIME             UID    COMM             PID     TID     RET              EVENT                ARGS\n21:06:35:386730  1000   gio-launch-desk  743960  743960  0                execve               pathname: /home/gg/.local/bin/gnome-terminal, argv: [gnome-terminal]\n...\n</code></pre> <p>BUT os-release file might not exist:</p> <p>Because you're running in a distribution that does not have /etc/os-release, or because you're running inside a container that does not support it, you may face the following error:</p> <pre><code>$ sudo ./dist/tracee-ebpf --log debug --trace uid=1000 --trace pid=new --trace event=execve\n{\"level\":\"debug\",\"ts\":1670976530.5685039,\"msg\":\"osinfo\", \"warning: os-release file could not be found\",\"error\",\"open /etc/os-release: no such file or directory\",\"pkg\":\"urfave\",\"file\":\"urfave.go\",\"line\":33}\n...\nTIME             UID    COMM             PID     TID     RET              EVENT                ARGS\n...\n\nEnd of events stream\nStats: {EventCount:1 ErrorCount:0 LostEvCount:0 LostWrCount:0 LostNtCount:0}\n</code></pre> <p>Note</p> <p>But do note that tracee-ebpf shall continue working (informing only the KERNEL_RELEASE OSInfo option).</p> <p>If you need to override the underlaying Linux OS information, because you're running inside a container that already has /etc/os-release file, for example, you may create another os-release file and inform tracee-ebpf by using LIBBPFGO's environment variable <code>LIBBPFGO_OSRELEASE_FILE</code>:</p> <pre><code>$ sudo LIBBPFGO_OSRELEASE_FILE=/etc/os-release.orig ./dist/tracee-ebpf --trace uid=1000 --trace pid=new --trace event=execve\n</code></pre> <p>If you're running tracee inside a docker container, you can simply bind mount /etc/os-release from the host as /etc/os-release-host into the guest and inform that through the <code>LIBBPFGO_OSRELEASE_FILE</code> environment variable.</p>"},{"location":"docs/deep-dive/override-os-files/#kconfig","title":"KCONFIG","text":"<p>Tracee needs access to kconfig file (/proc/config.gz OR /boot/config-$(uname -r)) in order to:</p> <ol> <li>Check if the kernel of your running environment supports needed eBPF features</li> <li>Provide kconfig variables to its eBPF counter-part (so eBPF program take decisions)</li> </ol> <p>Warning</p> <p>Tracee should NOT fail when it cannot find a kconfig file:</p> <pre><code>$ sudo ./dist/tracee-ebpf --log debug --trace uid=1000 --trace pid=new --trace event=execve\n{\"level\":\"debug\",\"ts\":1670976875.7735798,\"msg\":\"osinfo\",\"VERSION\":\"\\\"20.04.5 LTS (Focal Fossa)\\\"\",\"ID\":\"ubuntu\",\"ID_LIKE\":\"debian\",\"PRETTY_NAME\":\"\\\"Ubuntu 20.04.5 LTS\\\"\",\"VERSION_ID\":\"\\\"20.04\\\"\",\"VERSION_CODENAME\":\"focal\",\"KERNEL_RELEASE\":\"5.4.0-91-generic\",\"ARCH\":\"x86_64\",\"pkg\":\"urfave\",\"file\":\"urfave.go\",\"line\":53}\n...\n{\"level\":\"warn\",\"ts\":1670976875.7762284,\"msg\":\"KConfig: could not check enabled kconfig features\",\"error\":\"could not read /boot/config-5.4.0-91-generic: stat /boot/config-5.4.0-91-generic: no such file or directory\"}\n{\"level\":\"warn\",\"ts\":1670976875.7762842,\"msg\":\"KConfig: assuming kconfig values, might have unexpected behavior\"}\n...\n{\"level\":\"debug\",\"ts\":1670976876.0801573,\"msg\":\"KConfig: warning: assuming kconfig values, might have unexpected behavior\",\"pkg\":\"initialization\",\"file\":\"kconfig.go\",\"line\":30}\nTIME             UID    COMM             PID     TID     RET              EVENT                ARGS\n...\n</code></pre> <p>but do have in mind it is assuming some things from the host environment and its behavior might have inconsistencies.</p> <p>If you are running tracee in an environment that does not have a kconfig file (nor /proc/config.gz support), it is recommended that you provide the host kconfig file location to tracee through the <code>LIBBPFGO_KCONFIG_FILE</code> environment variable:</p> <pre><code>$ sudo LIBBPFGO_KCONFIG_FILE=/boot/config-other -E ./dist/tracee-ebpf --log debug --trace uid=1000 --trace pid=new --trace event=execve\n{\"level\":\"debug\",\"ts\":1670979362.3586345,\"msg\":\"osinfo\",\"VERSION_ID\":\"\\\"20.04\\\"\",\"VERSION_CODENAME\":\"focal\",\"KERNEL_RELEASE\":\"5.4.0-91-generic\",\"ARCH\":\"x86_64\",\"VERSION\":\"\\\"20.04.5 LTS (Focal Fossa)\\\"\",\"ID\":\"ubuntu\",\"ID_LIKE\":\"debian\",\"PRETTY_NAME\":\"\\\"Ubuntu 20.04.5 LTS\\\"\",\"pkg\":\"urfave\",\"file\":\"urfave.go\",\"line\":53}\n{\"level\":\"debug\",\"ts\":1670979362.358663,\"msg\":\"RuntimeSockets: failed to register default\",\"socket\":\"containerd\",\"error\":\"failed to register runtime socket stat /var/run/containerd/containerd.sock: no such file or directory\",\"pkg\":\"flags\",\"file\":\"containers.go\",\"line\":45}\n{\"level\":\"debug\",\"ts\":1670979362.3586702,\"msg\":\"RuntimeSockets: failed to register default\",\"socket\":\"docker\",\"error\":\"failed to register runtime socket stat /var/run/docker.sock: no such file or directory\",\"pkg\":\"flags\",\"file\":\"containers.go\",\"line\":45}\n{\"level\":\"debug\",\"ts\":1670979362.3586755,\"msg\":\"RuntimeSockets: failed to register default\",\"socket\":\"crio\",\"error\":\"failed to register runtime socket stat /var/run/crio/crio.sock: no such file or directory\",\"pkg\":\"flags\",\"file\":\"containers.go\",\"line\":45}\n{\"level\":\"debug\",\"ts\":1670979362.3586833,\"msg\":\"RuntimeSockets: failed to register default\",\"socket\":\"podman\",\"error\":\"failed to register runtime socket stat /var/run/podman/podman.sock: no such file or directory\",\"pkg\":\"flags\",\"file\":\"containers.go\",\"line\":45}\n{\"level\":\"debug\",\"ts\":1670979362.3588264,\"msg\":\"osinfo\",\"security_lockdown\":\"none\",\"pkg\":\"urfave\",\"file\":\"urfave.go\",\"line\":116}\n{\"level\":\"debug\",\"ts\":1670979362.3639433,\"msg\":\"BTF\",\"bpfenv\":false,\"btfenv\":false,\"vmlinux\":false,\"pkg\":\"initialize\",\"file\":\"bpfobject.go\",\"line\":40}\n{\"level\":\"debug\",\"ts\":1670979362.363965,\"msg\":\"BPF: no BTF file was found or provided\",\"pkg\":\"initialize\",\"file\":\"bpfobject.go\",\"line\":108}\n{\"level\":\"debug\",\"ts\":1670979362.3639715,\"msg\":\"BPF: trying non CO-RE eBPF\",\"file\":\"/tmp/tracee/tracee.bpf.5_4_0-91-generic.v0_8_0-rc-2-365-g0bac8f68.o\",\"pkg\":\"initialize\",\"file\":\"bpfobject.go\",\"line\":109}\n{\"level\":\"debug\",\"ts\":1670979362.4866858,\"msg\":\"Enricher\",\"error\":\"error registering enricher: unsupported runtime containerd\",\"pkg\":\"containers\",\"file\":\"containers.go\",\"line\":64}\n{\"level\":\"debug\",\"ts\":1670979362.486713,\"msg\":\"Enricher\",\"error\":\"error registering enricher: unsupported runtime crio\",\"pkg\":\"containers\",\"file\":\"containers.go\",\"line\":68}\n{\"level\":\"debug\",\"ts\":1670979362.486717,\"msg\":\"Enricher\",\"error\":\"error registering enricher: unsupported runtime docker\",\"pkg\":\"containers\",\"file\":\"containers.go\",\"line\":72}\nTIME             UID    COMM             PID     TID     RET              EVENT                ARGS\n...\n</code></pre> <p>If you're running tracee inside a docker container, you can simply bind mount /boot/config-$(uname -r) from the host as /boot/config-$(uname -r) into the guest and inform that through the <code>LIBBPFGO_KCONFIG_FILE</code> environment variable.</p> <p>Attention</p> <p>In case no kconfig file is found, tracee takes some decisions blindly and it may give you unexpected errors. Example:</p>"},{"location":"docs/deep-dive/overview/","title":"Overview","text":"<p>This section goes deep explaning Tracee's internals, and how to build Tracee on different platforms for the users interested in contributing.</p>"},{"location":"docs/deep-dive/performance/","title":"Special: Performance","text":"<p>Read</p> <p>Before continuing, please read the architecture page, in order to understand the tracee pipeline concept.</p> <p></p>"},{"location":"docs/deep-dive/performance/#pain-points","title":"Pain Points","text":"<p>From the tracee pipeline concept page, you learned that there might be 2 pain points regarding tracee performance:</p> <ol> <li> <p>Path between kernel and tracee-ebpf (through perfbuffers + golang    channels)</p> <ol> <li>The only way to reduce the amount of events to userland is by bringing    all filters into eBPF programs. There are some problems by doing that:    the eBPF programs can't be too big, or too slow, not to impact the    kernel performance (one of the reasons why eBPF virtual machine    exists: to sandbox eBPF code).</li> </ol> </li> <li> <p>Path between tracee-ebpf and tracee-rules (currently: a pipe,    future: a channel)</p> <ol> <li> <p>Processing, parsing and enriching events in userland needs to be    unblocking AND as fast as possible. Any extra processing in    tracee-ebpf might delay the delivery of events from the kernel    all the way down to tracee-rules signatures.</p> </li> <li> <p>The communication in between tracee-ebpf and tracee-rules needs    to be fast and not to block the consumption of events coming from the    kernel. If this is blocked, then tracee will start loosing    events because it can't catch up with the speed the events are being    created in kernel.</p> </li> <li> <p>tracee-rules processing needs to be as fast as possible. Taking too    long to evaluate a detection from each received event will slow down the    consumption of the pipe in between tracee-ebpf and tracee-rules,    delaying also the path in between the kernel and tracee-ebpf.</p> </li> </ol> </li> </ol>"},{"location":"docs/deep-dive/performance/#addressing-pain-points","title":"Addressing Pain Points","text":"<ol> <li> <p>Path in between kernel and tracee-ebpf:</p> <ol> <li>eBPF programs already do filtering in-kernel but not for all    possible filter inputs (this is being improved for next releases).</li> </ol> </li> <li> <p>Path in betwen tracee-ebpf and tracee-rules:</p> <ol> <li> <p>From measurements, the pipe used in between tracee-ebpf and    tracee-rules processes is NOT a bottleneck BUT the gob output    format (input format for tracee-rules) has better performance.</p> </li> <li> <p>The signatures processing might be a bottleneck. Using golang signatures    in tracee-rules, for evaluating detections, has bigger    performance and should be considered whenever possible.</p> </li> </ol> </li> </ol>"},{"location":"docs/deep-dive/performance/#test-concepts","title":"Test Concepts","text":"<p>Example using container enrichment in the pipeline, argument parsing so arguments are formatted in a human consumable way, detecting syscall that generated the event:</p> <pre><code>$ sudo ./dist/tracee-ebpf \\\n    --containers -o format:json \\\n    -o option:parse-arguments \\\n    -trace container \\\n    --crs docker:/var/run/docker.sock\n</code></pre> <p>We are using most of the options that could cause latencies in the event pipeline BUT we're not piping the events to tracee-rules.</p> <p>Attention</p> <p>If you pipe tracee-ebpf output to another tool, like <code>jq</code>: <pre><code>| jq -c '. | {cgroupid, processname, containername}'\n</code></pre> You may cause latencies in tracee-ebpf pipeline because the event json processing from <code>jq</code> might not be as fast as how tracee-ebpf is capable of writing events to it (just like tracee-rules could do if being slow evaluating events).</p>"},{"location":"docs/deep-dive/secure-tracing/","title":"FAQ - Frequently Asked Questions","text":"<ol> <li> <p>Secure tracing</p> <p>When tracee-ebpf reads information from user programs, it is subject to a race condition where the user program might be able to change the arguments after tracee read them.</p> <p>For example, a program invoked:</p> <pre><code>execve(\"/bin/ls\", NULL, 0)\n</code></pre> <p>Tracee picked that up and will report that, then the program changed the first argument from <code>/bin/ls</code> to <code>/bin/bash</code>, and this is what the kernel will execute.</p> <p>To mitigate this, Tracee also provides \"LSM\" (Linux Security Module) based events, for example, the <code>bprm_check</code> event which can be reported by Tracee and cross-referenced with the reported regular syscall event.</p> </li> </ol>"},{"location":"docs/detecting/","title":"Getting Started with Detecting","text":"<p>Tracee is a runtime security detection engine, more than an introspection tool (tracee-ebpf) only. tracee-rules is a rules engine that helps you detect suspicious behavioral patterns in streams of events. It is primarily made to leverage events collected with tracee-ebpf into a Runtime Security solution.</p> <p>Attention</p> <p>You may sometimes read rules or signatures. Both mean the same thing for tracee: a set of expressions that will define whether there was a security event detection or not.</p> <p>There are 3 basic concepts for tracee-rules:</p> <ol> <li> <p>Inputs - Event sources to be processed.</p> <ol> <li>tracee-ebpf only current supported ource</li> </ol> </li> <li> <p>Rules (a.k.a Signatures) - behavioral pattern to detect from the input    source. Signatures can be authored in:</p> <ol> <li>Golang (high performance, more error prone)</li> <li>Rego (OPA) (high level declarative language)</li> <li>Go-Cel (tech-preview) (good performance, simple)</li> </ol> </li> <li> <p>Outputs - How to communicate detections:</p> <ol> <li>Print to stdout</li> <li>Post to a webhook</li> <li>Integrate with external systems</li> </ol> </li> </ol>"},{"location":"docs/detecting/#getting-started","title":"Getting Started","text":"<p>tracee-rules doesn't have any requirement, but in order to run with tracee-ebpf, make sure you follow the tracee-ebpf prerequisites.</p> <p>Attention</p> <p>You can't customize (yet) tracee-rules execution when executing official tracee container. The official container is configured with a pre-set of signatures already enabled by default. In order to customize it you have to follow building/containers.md instructions and change the default entrypoint and signatures.</p> <p>Check getting tracee in order to understand how to obtain tracee-rules.</p>"},{"location":"docs/detecting/#running-tracee-rules","title":"Running tracee-rules","text":"<ol> <li> <p>Running tracee-rules with trace-ebpf in the simplest possible way:</p> <pre><code>sudo ./dist/tracee-ebpf \\\n-o format:gob \\\n| tracee-rules \\\n--input-tracee file:stdin \\\n--input-tracee format:gob\n</code></pre> <p>This will:</p> <ol> <li>Start tracee-ebpf with the default tracing mode (default events).</li> <li>Configure tracee-ebpf to output events into stdout as gob format.</li> <li>Start tracee-rules with all built-in signatures enabled.</li> </ol> </li> <li> <p>A more realistic example</p> </li> </ol> <p>Example</p> <p>Let's put together all that we learned from the tracing section, together with what we're learning at this section and see how we can trace events and pipe them to tracee-rules so detections occur:</p> <pre><code>$ sudo ./dist/tracee-ebpf \\\n    --output json \\\n    --trace comm=bash \\\n    --trace follow \\\n    --output option:parse-arguments \\\n    --trace event=$(./dist/tracee-rules --list-events) \\\n    | ./dist/tracee-rules \\\n    --input-tracee format:json \\\n    --input-tracee file:stdin\n\nLoaded 14 signature(s): [TRC-1 TRC-13 TRC-2 TRC-14 TRC-3 TRC-11 TRC-9 TRC-4 TRC-5 TRC-12 TRC-6 TRC-10 TRC-7 TRC-15]\n</code></pre> <p>We are:</p> <ol> <li>tracing all executed commands from all existing and new <code>bash</code> processes,</li> <li>detecting syscalls that generated each event (if they're not syscalls),</li> <li>parsing captured event arguments into a human readable format,</li> <li>filtering for ALL events needed by all existing signatures,</li> <li>detecting behaviors described in all existing and loaded tracee-rules signatures.</li> </ol>"},{"location":"docs/detecting/#selecting-signatures","title":"Selecting Signatures","text":"<p>When executing tracee-rules, you're able to select which signatures you would like it to load. Also, in order to make tracee-ebpf only trace for meaningful events (for the loaded signature(s)) you may request from tracee-rules which events are needed for the selected signatures.</p> <ol> <li> <p>List default (all) signatures</p> <pre><code>$ ./dist/tracee-rules --list\nLoaded 14 signature(s): [TRC-1 TRC-13 TRC-2 TRC-14 TRC-3 TRC-11 TRC-9 TRC-4 TRC-5 TRC-12 TRC-6 TRC-10 TRC-7 TRC-15]\nID         NAME                                VERSION DESCRIPTION\nTRC-1      Standard Input/Output Over Socket   0.1.0   Redirection of process's standard input/output to socket\nTRC-13     Kubernetes API server connection detected 0.1.0   A connection to the kubernetes API server was detected. The K8S API server is the brain of your K8S cluster, adversaries may try and communicate with the K8S API server to gather information/credentials, or even run more containers and laterally expand their grip on your systems.\nTRC-2      Anti-Debugging                      0.1.0   Process uses anti-debugging technique to block debugger\nTRC-14     CGroups Release Agent File Modification 0.1.0   An Attempt to modify CGroups release agent file was detected. CGroups are a Linux kernel feature which can change a process's resource limitations. Adversaries may use this feature for container escaping.\nTRC-3      Code injection                      0.1.0   Possible code injection into another process\nTRC-11     Container Device Mount Detected     0.1.0   Container device filesystem mount detected. A mount of a host device filesystem can be exploited by adversaries to perform container escape.\nTRC-9      New Executable Was Dropped During Runtime 0.1.0   An Executable file was dropped in your system during runtime. Usually container images are built with all binaries needed inside, a dropped binary may indicate an adversary infiltrated into your container.\nTRC-4      Dynamic Code Loading                0.1.0   Writing to executable allocated memory region\nTRC-5      Fileless Execution                  0.1.0   Executing a process from memory, without a file in the disk\nTRC-12     Illegitimate Shell                  0.1.0   A program on your server spawned a shell program. Shell is the linux command-line program, server programs usually don't run shell programs, so this alert might indicate an adversary is exploiting a server program to spawn a shell on your server.\nTRC-6      kernel module loading               0.1.0   Attempt to load a kernel module detection\nTRC-10     K8S TLS Certificate Theft Detected  0.1.0   Kubernetes TLS certificate theft was detected. TLS certificates are used to establish trust between systems, the kubernetes certificate is used to to enable secured communication between kubernetes components, like the kubelet, scheduler, controller and API server. An adversary may steal a kubernetes certificate on a compromised system to impersonate kuberentes components within the cluster.\nTRC-7      LD_PRELOAD                          0.1.0   Usage of LD_PRELOAD to allow hooks on process\nTRC-15     Hooking system calls by overriding the system call table entries 0.1.0   Usage of kernel modules to hook system calls\n</code></pre> </li> <li> <p>List events needed by default (all) signatures</p> <pre><code>$ ./dist/tracee-rules --list-events\nclose,dup,dup2,dup3,execve,hooked_syscalls,init_module,magic_write,mem_prot_alert,process_vm_writev,ptrace,sched_process_exec,sched_process_exit,security_bprm_check,security_file_open,security_kernel_read_file,security_sb_mount,security_socket_connect\n</code></pre> </li> <li> <p>List events needed for given signatures only</p> <p>Tip</p> <p>If we chose to load a single signature, we can ask tracee-rules to give us the events needed by that signature. This will allow tracee-ebpf to just listen to those events.</p> <pre><code>$ ./dist/tracee-rules --rules TRC-3 --list-events\nprocess_vm_writev,ptrace,security_file_open\n</code></pre> </li> </ol>"},{"location":"docs/detecting/#tracing-with-selected-signatures","title":"Tracing with Selected Signatures","text":"<p>Example</p> <p>Let's pretend we would like to pick TRC-2 signature only and monitor all new processes happening as childs of all running <code>bash</code> processes.</p> <pre><code>$ sudo ./dist/tracee-ebpf --output json --trace comm=bash --trace follow --output option:parse-arguments --output option:exec-env --trace event=$(./dist/tracee-rules --rules TRC-2 --list-events) | ./dist/tracee-rules --input-tracee format:json --input-tracee file:stdin --rules TRC-2\nLoaded 1 signature(s): [TRC-2]\n\n*** Detection ***\nTime: 2022-07-09T21:42:45Z\nSignature ID: TRC-2\nSignature: Anti-Debugging\nData: map[]\nCommand: strace\nHostname: fujitsu\n</code></pre>"},{"location":"docs/detecting/avd/","title":"Signatures in Aqua Vulnerability Database (AVD)","text":"<p>AVD gives detailed information and remediation guidance for vulnerabilities and weaknesses found in open source applications and cloud native infrastructure. This includes information about common techniques and attack vectors that occur at application runtime.</p> <p>The AVD entries on runtime security are generated from the detection signatures  in Tracee's detection engine, tracee-rules. This includes signatures for  credential access, defense evasion, persistence, and privilege escalation.</p> <p>You can see them at avd.aquasec.com/tracee.</p>"},{"location":"docs/detecting/go-cel/","title":"Signatures written in Go-Cel (POC)","text":"<p>Tracee has introduced, on its last version, a new type of signatures, the Common Expression Language, or Go-Cel, signatures as a PROOF OF CONCEPT.</p> <p>Go-cel</p> <p>The Common Expression Language (CEL) is a non-Turing complete language designed for simplicity, speed, safety, and portability. CEL's C-like syntax looks nearly identical to equivalent expressions in C++, Go, Java, and TypeScript.</p> <p>Proof-of-concept</p> <p>Go-Cel based signatures are experimental and part an on going development proof-of-concept. The feature is not finished and writing signatures in Go-Cel might need tracee code updates such as creation of internal parser helpers and/or event types declaration in a protobuf wrapper internal structure.</p> <p>This feature is enabled by placing CEL signature definition files (.cel, .yaml, .yml) in the  the <code>--rules-dir</code> directory. Sample definition files can be found in the <code>pkg/rules/celsig/testdata/rules/</code> directory.</p> <p>Signature</p> <pre><code>kind: SignaturesConfig\napiVersion: tracee.aquasecurity.github.io/v1alpha1\nsignatures:\n- metadata:\nid: \"Mine-0.1.0\"\nversion: \"0.1.0\"\nname: \"My Own Signature\"\ndescription: \"My Own Signature Detects Stuff\"\ntags:\n- \"linux\"\neventSelectors:\n- source: tracee\nname: openat\nexpression: |-\ninput.eventName == 'openat' &amp;&amp;\ninput.stringArg('pathname').startsWith('/etc/passwd')\n</code></pre> <p>After placing your <code>signature_example.yaml</code> inside <code>dist/rules</code> directory you may execute tracee selecting only the event you just created, if that is what you want:</p> <pre><code>$ sudo ./dist/tracee-ebpf \\\n    --output json \\\n    --trace comm=bash \\\n    --trace follow \\\n    --output option:parse-arguments \\\n    -trace event=$(./dist/tracee-rules --rules Mine-0.1.0 --list-events) \\\n    | ./dist/tracee-rules \\\n    --input-tracee \\\n    format:json \\\n    --input-tracee file:stdin \\\n    --rules Mine-0.1.0\n\nLoaded 1 signature(s): [Mine-0.1.0]\n\n*** Detection ***\nTime: 2022-07-10T05:49:48Z\nSignature ID: Mine-0.1.0\nSignature: My Own Signature\nData: map[]\nCommand: batcat\nHostname: fujitsu\n</code></pre> <p>Experimental</p> <p>Like said previously, Go-Cel signatures are experimental and considered proof-of-concept for now. If you decide to develop Go-Cel signatures you may face some issues:</p> <ol> <li> <p>Go-Cel depends on protobuf and <code>tracee.Event</code> is not yet a protobuf    object. Because of that, there is a wrapper in place converting    <code>tracee.Event</code> into <code>protobuf</code> so the evaluations can happen (check    files inside <code>pkg/rules/celsig/wrapper/</code> directory.</p> </li> <li> <p>When writting your signature, it might happen that the event you're    filtering for does not have all of its arguments types wrapper into    the protobuf wrapper. You may face errors such as:    <pre><code>Unrecognized event arg: eventName: \"openat\" name: \"mode\" type: \"mode_t\" valueType: uint32 value: 0\n</code></pre>    It means you have to add that type to Tracee's go-cel wrapper so it    is able to evaluate it.</p> </li> <li> <p>Your signature might need helpers/macros that don't exist yet. A good    source of an example is <code>pkg/rules/celsig/library.go</code> file and    functions:</p> <ul> <li><code>sockaddrArg</code></li> <li><code>stringArg</code></li> <li><code>argByName</code></li> </ul> </li> </ol>"},{"location":"docs/detecting/golang/","title":"Golang Signatures","text":"<p>There are 2 ways you can get your own golang signatures working with tracee.</p> <ol> <li> <p>Built-In Golang signatures</p> <p>Tip</p> <p>This is the preferred way to get your own golang signatures integrated into Tracee, as you will find in the next part of this page, but it needs a better end-user experience (being worked).</p> <p>In order to get your golang signature compiled with tracee, you can create a file called <code>signatures/golang/signature_example.go</code> and place the following code in it:</p> <p>Signature</p> <pre><code>package main\n\nimport (\n\"fmt\"\n\"strings\"\n\n\"github.com/aquasecurity/tracee/signatures/helpers\"\n\"github.com/aquasecurity/tracee/types/detect\"\n\"github.com/aquasecurity/tracee/types/protocol\"\n\"github.com/aquasecurity/tracee/types/trace\"\n)\n\ntype signatureExample struct {\ncb detect.SignatureHandler\n}\n\nfunc (sig *signatureExample) Init(cb detect.SignatureHandler) error {\nsig.cb = cb\n\nreturn nil\n}\n\nfunc (sig *signatureExample) GetMetadata() (\ndetect.SignatureMetadata,\nerror,\n) {\nreturn detect.SignatureMetadata{\nID:          \"Mine-0.1.0\",\nVersion:     \"0.1.0\",\nName:        \"My Own Signature\",\nDescription: \"My Own Signature Detects Stuff\",\nTags:        []string{\"linux\"},\n}, nil\n}\n\nfunc (sig *signatureExample) GetSelectedEvents() (\n[]detect.SignatureEventSelector,\nerror,\n) {\n\nreturn []detect.SignatureEventSelector{\n{Source: \"tracee\", Name: \"openat\"},\n{Source: \"tracee\", Name: \"execve\"},\n}, nil\n}\n\nfunc (sig *signatureExample) OnEvent(event protocol.Event) error {\nswitch e := event.Payload.(type) {\ncase trace.Event:\nif e.ArgsNum == 0 {\nreturn nil\n}\n\nswitch e.EventName {\ncase \"openat\", \"execve\":\narg, err := helpers.GetTraceeArgumentByName(e, \"pathname\")\nif err != nil {\nreturn err\n}\n\nif s, ok := arg.Value.(string); ok {\nif strings.Contains(s, \"/etc/passwd\") {\nm, _ := sig.GetMetadata()\n\nfound := detect.Finding{\nEvent:       event,\nSigMetadata: m,\n}\n\nsig.cb(found)\n}\n}\n}\ndefault:\nreturn fmt.Errorf(\"failed to cast event's payload\")\n}\n\nreturn nil\n}\n\nfunc (sig *signatureExample) OnSignal(s detect.Signal) error {\nreturn nil\n}\n\nfunc (sig *signatureExample) Close() {}\n</code></pre> <p>Then, edit <code>signatures/golang/export.go</code> and place your new signature there:</p> <pre><code>var ExportedSignatures = []detect.Signature{\n&amp;signatureExample{},\n}\n</code></pre> <p>Follow instructions on how to build Tracee and you will find your new signature included in tracee-rules. You may even select only the signatures you created:</p> <pre><code>$ sudo ./dist/tracee-ebpf \\\n    --output json \\\n    --trace comm=bash \\\n    --trace follow \\\n    --output option:parse-arguments \\\n    -trace event=$(./dist/tracee-rules --rules Mine-0.1.0 --list-events) \\\n    | ./dist/tracee-rules \\\n    --input-tracee \\\n    format:json \\\n    --input-tracee file:stdin \\\n    --rules Mine-0.1.0\n\nLoaded 1 signature(s): [Mine-0.1.0]\n\n*** Detection ***\nTime: 2022-07-10T04:25:44Z\nSignature ID: Mine-0.1.0\nSignature: My Own Signature\nData: map[]\nCommand: batcat\nHostname: fujitsu\n</code></pre> <p>Be creative! You can create signatures that would do pretty much anything! Examples of such signatures would: for every X event, connect to a cached external data-source and return a positive detection for cases A, B or C.</p> </li> <li> <p>Create a golang signature plugin and dynamically load it during runtime</p> <p>Attention</p> <p>Eventually you will find out that Golang Plugins aren't very useful if you consider all the problems that emerge from using it:</p> <ol> <li> <p>Can't use different go versions (need to compile the go plugin    with the exact same version that was used to build Tracee).</p> </li> <li> <p>Both Tracee and your golang plugin signature must be built with the    exact same GOPATH or you will get a \"plugin was built with a    different version of package XXX\" error.</p> </li> <li> <p>Any dependency you have in your plugin should be of the same    version with the dependencies of Tracee.</p> </li> <li> <p>Compiling tracee statically is sometimes useful to have a complete    portable eBPF tracing/detection solution. One good example when    statically compiling tracee is a good idea is to have a single    binary capable of running in GLIBC (most of them) and MUSL (Alpine)    powered Linux distros.</p> </li> </ol> <p>At the end, creating a golang signature plugin won't have the practical effects as a plugin mechanism should have, so it is preferred to have built-in golang signatures (re)distributed with newer binaries (when you need to add/remove signatures from your environment) FOR NOW.</p> </li> </ol>"},{"location":"docs/detecting/rego/","title":"Rego Signatures","text":"<p>Tip</p> <p>Differently than golang built-in signatures, with Rego signatures you are able to add and/or remove signatures to Tracee without the need of recompiling it (or re-distributing the binary) BUT it may come with a performance price to pay.</p> <p>In order to create your own Rego signature you need to create a <code>.rego</code> file in the rules directory that has the following Rego Rules (now, in this context, rules are Rego's language constructs):</p> <p>rego_metadoc</p> <p>A document rule that defines the rule's metadata.</p> <p>Tracee_selected_events</p> <p>A set rule that defines the event selectors.</p> <p>Tracee_match</p> <p>A boolean or a document rule that defines the logic of the signature. If bool is \"returned\", a true evaluation will generate a Finding with no data. If a document is \"returned\", any non-empty evaluation will generate a Finding with the returned document as the Finding's \"Data\".</p> <p>Signature</p> <pre><code>package tracee.Mine\n\nimport data.tracee.helpers\n\n__rego_metadoc__ := {\n    \"id\": \"Mine-0.1.0\",\n    \"version\": \"0.1.0\",\n    \"name\": \"My Own Signature\",\n    \"description\": \"My Own Signature Detects Stuff\",\n    \"tags\": [\"linux\"],\n}\n\neventSelectors := [\n    {\n        \"source\": \"tracee\",\n        \"name\": \"openat\",\n    },\n    {\n        \"source\": \"tracee\",\n        \"name\": \"execve\",\n    },\n]\n\ntracee_selected_events[eventSelector] {\n    eventSelector := eventSelectors[_]\n}\n\ntracee_match {\n    input.eventName == \"openat\"\n    arg_value = helpers.get_tracee_argument(\"pathname\")\n    startswith(arg_value, \"/etc/passwd\")\n}\n\ntracee_match {\n    input.eventName == \"execve\"\n    arg_value = helpers.get_tracee_argument(\"pathname\")\n    startswith(arg_value, \"/etc/passwd\")\n}\n</code></pre> <p>After placing your <code>signature_example.rego</code> inside <code>dist/rules</code> directory you may execute tracee selecting only the event you just created, if that is what you want:</p> <pre><code>$ sudo ./dist/tracee-ebpf \\\n    --output json \\\n    --trace comm=bash \\\n    --trace follow \\\n    --output option:parse-arguments \\\n    -trace event=$(./dist/tracee-rules --rules Mine-0.1.0 --list-events) \\\n    | ./dist/tracee-rules \\\n    --input-tracee format:json \\\n    --input-tracee file:stdin \\\n    --rules Mine-0.1.0\n\nLoaded 1 signature(s): [Mine-0.1.0]\n\n*** Detection ***\nTime: 2022-07-10T05:23:01Z\nSignature ID: Mine-0.1.0\nSignature: My Own Signature\nData: map[]\nCommand: batcat\nHostname: fujitsu\n</code></pre> <p>See signatures/rego for example Rego signatures.</p>"},{"location":"docs/detecting/rules/","title":"Available Rules","text":"<p>Tip</p> <p>To view the list of available rules, run Tracee with the <code>--list</code> flag.</p> <p>Tracee currently distributes fully functional signatures that detect potentially malicous behavior.</p>"},{"location":"docs/detecting/rules/#signatures-in-aqua-vulnerability-database-avd","title":"Signatures in Aqua Vulnerability Database (AVD)","text":"<p>The Aqua Vulnerability Database gives detailed information and remediation guidance for vulnerabilities and weaknesses found in open source applications and cloud native infrastructure. This includes information about common techniques and attack vectors that occur at application runtime, which are generated from the signatures in tracee. You can see them at avd.aquasec.com/tracee and in the table below:</p> Name Description Full Description TRC-101 Process standard input/output over socket detected A process has its standard input/output redirected to a socket. This behaviour is the base of a Reverse Shell attack, which is when an interactive shell being invoked from a target machine back to the attacker's machine, giving it interactive control over the target. Adversaries may use a Reverse Shell to retain control over a compromised target while bypassing security measures like network firewalls. TRC-102 Anti-Debugging detected A process used anti-debugging techniques to block a debugger. Malware use anti-debugging to stay invisible and inhibit analysis of their behavior. TRC-103 Code injection detected using ptrace Possible code injection into another process was detected. Code injection is an exploitation technique used to run malicious code, adversaries may use it in order to execute their malware. TRC-104 Dynamic code loading detected Possible dynamic code loading was detected as the binary's memory is both writable and executable. Writing to an executable allocated memory region could be a technique used by adversaries to run code undetected and without dropping executables. TRC-105 Fileless execution detected Fileless execution was detected. Executing a process from memory instead from a file in the filesystem may indicate that an adversary is trying to avoid execution detection. TRC-106 Cgroups notify_on_release file modification An attempt to modify Cgroup notify_on_release file was detected. Cgroups are a Linux kernel feature which limits the resource usage of a set of processes. Adversaries may use this feature for container escaping. TRC-107 LD_PRELOAD code injection detected LD_PRELOAD usage was detected. LD_PRELOAD lets you load your library before any other library, allowing you to hook functions in a process. Adversaries may use this technique to change your applications' behavior or load their own programs. TRC-108 K8s service account token file read The Kubernetes service account token file was read on your container. This token is used to communicate with the Kubernetes API Server. Adversaries may try to communicate with the API Server to steal information and/or credentials, or even run more containers and laterally extend their grip on the systems. TRC-109 ASLR inspection detected The ASLR (address space layout randomization) configuration was inspected. ASLR is used by Linux to prevent memory vulnerabilities. An adversary may want to inspect and change the ASLR configuration in order to avoid detection. TRC-1010 Cgroups release agent file modification An attempt to modify Cgroup release agent file was detected. Cgroups are a Linux kernel feature which limits the resource usage of a set of processes. Adversaries may use this feature for container escaping. TRC-1011 Core dumps configuration file modification detected Modification of the core dump configuration file (core_pattern) detected. Core dumps are usually written to disk when a program crashes. Certain modifications enable container escaping through the kernel core_pattern feature. TRC-1012 Default dynamic loader modification detected The default dynamic loader has been modified. The dynamic loader is an executable file loaded to process memory and run before the executable to load dynamic libraries to the process. An attacker might use this technique to hijack the execution context of each new process and bypass defenses. TRC-1013 Kubernetes API server connection detected A connection to the kubernetes API server was detected. The K8S API server is the brain of your K8S cluster, adversaries may try and communicate with the K8S API server to gather information/credentials, or even run more containers and laterally expand their grip on your systems. TRC-1014 Container device mount detected Container device filesystem mount detected. A mount of a host device filesystem can be exploited by adversaries to perform container escape. TRC-1015 Hidden executable creation detected A hidden executable (ELF file) was created on disk. This activity could be legitimate; however, it could indicate that an adversary is trying to avoid detection by hiding their programs. TRC-1016 Web server spawned a shell A web-server program on your server spawned a shell program. Shell is the linux command-line program, web servers usually don't run shell programs, so this alert might indicate an adversary is exploiting a web server program to gain command execution on the server. TRC-1017 Kernel module loading detected Loading of a kernel module was detected. Kernel modules are binaries meant to run in the kernel. Adversaries may try and load kernel modules to extend their capabilities and avoid detection by running in the kernel and not user space. TRC-1018 K8s TLS certificate theft detected Theft of Kubernetes TLS certificates was detected. TLS certificates are used to establish trust between systems. The Kubernetes certificate is used to to enable secure communication between Kubernetes components, such as kubelet scheduler controller and API Server. An adversary may steal a Kubernetes certificate on a compromised system to impersonate Kubernetes components within the cluster. TRC-1019 Docker socket abuse detected An attempt to abuse the Docker UNIX socket inside a container was detected. docker.sock is the UNIX socket that Docker uses as the entry point to the Docker API. Adversaries may attempt to abuse this socket to compromise the system. TRC-1020 File operations hooking on proc filesystem detected File operations hooking on proc filesystem detected. The proc filesystem is an interface for the running processes as files. This allows programs like <code>ps</code> and <code>top</code> to check what are the running processes. File operations are the functions defined on a file or directory. File operations hooking includes replacing the default function used to perform a basic task on files and directories like enumerating files. By hooking the file operations of /proc an adversary gains control on certain system function, such as file listing or other basic function performed by the operation system. The adversary may also hijack the execution flow and execute it's own code. File operation hooking is considered a malicious behavior that is performed by rootkits and may indicate that the host's kernel has been compromised. Hidden modules are marked as hidden symbol owners and indicate further malicious activity of an adversary. TRC-1021 Kcore memory file read An attempt to read /proc/kcore file was detected. KCore provides a full dump of the physical memory of the system in the core file format. Adversaries may read this file to get all of the host memory and use this information for container escape. TRC-1022 New executable dropped An Executable file was dropped in the system during runtime. Container images are usually built with all binaries needed inside. A dropped binary may indicate that an adversary infiltrated your container. TRC-1023 Process memory access detected Process memory access detected. Adversaries may access other processes memory to steal credentials and secrets. TRC-1024 Code injection detected through /proc//mem file Possible code injection into another process was detected. Code injection is an exploitation technique used to run malicious code, adversaries may use it in order to execute their malware. TRC-1025 Code injection detected using process_vm_writev syscall Possible code injection into another process was detected. Code injection is an exploitation technique used to run malicious code, adversaries may use it in order to execute their malware. TRC-1026 Rcd modification detected The rcd files were modified. rcd files are scripts executed on boot and runlevel switch. Those scripts are responsible for service control in runlevel switch. Adversaries may add or modify rcd files in order to persist a reboot, thus maintaining malicious execution on the affected host. TRC-1027 Scheduled tasks modification detected The task scheduling functionality or files were modified. Crontab schedules task execution or enables task execution at boot time. Adversaries may add or modify scheduled tasks in order to persist a reboot, thus maintaining malicious execution on the affected host. TRC-1028 Sudoers file modification detected The sudoers file was modified. The sudoers file is a configuration file which controls the permissions and options of the sudo feature. Adversaries may alter the sudoers file to elevate privileges, execute commands as other users or spawn processes with higher privileges. TRC-1029 sched_debug CPU file was read The sched_debug file was read. This file contains information about your CPU and processes. Adversaries may read this file in order to gather that information for their use. TRC-1030 Syscall table hooking detected Syscall table hooking detected. Syscalls (system calls) are the interface between user applications and the kernel. By hooking the syscall table an adversary gains control on certain system function, such as file writing and reading or other basic function performed by the operation system. The adversary may also hijack the execution flow and execute it's own code. Syscall table hooking is considered a malicious behavior that is performed by rootkits and may indicate that the host's kernel has been compromised. Hidden modules are marked as hidden symbol owners and indicate further malicious activity of an adversary. TRC-1031 System request key configuration modification An attempt to modify and activate the System Request Key configuration file was detected. The system request key allows immediate input to the kernel through simple key combinations. Adversaries may use this feature to immediately shut down or restart a system. With read access to kernel logs, host related information such as listing tasks and CPU registers may be disclosed and could be used for container escape. <p>Note</p> <p>And, obviously, you can create your signatures in golang, rego and go-cel.</p>"},{"location":"docs/integrating/container-engines/","title":"Tracee Events Container Enrichment","text":"<p>Tracee is capable of extracting information about running containers. It does that by tracking container namespaces creation kernel events and enriching those events by communicating with the relevant container's runtime and SDK.</p> <p>Experimental</p> <p>This feature is experimental and should be explicitly enabled in tracee-ebpf, by using the <code>--container</code> flag OR, if running tracee container image, setting the <code>CONTAINERS_ENRICHMENT</code> environment flag (see example bellow).</p> <ol> <li> <p>Running tracee-ebpf (with or without tracee-rules) manually</p> <p>If running tracee-ebpf directly (not in a container), it will automatically search for known supported runtimes in their socket's default locations.</p> </li> <li> <p>Running tracee using a docker container</p> <p>When running tracee from a container, the runtime sockets must be manually mounted in order for the enrichment features to work.</p> <p>Using containerd as our runtime for example, this can be done by running tracee like:</p> <pre><code>$ docker run \\\n    --name tracee --rm -it \\\n    --pid=host --cgroupns=host --privileged \\\n    -v /etc/os-release:/etc/os-release-host:ro \\\n    -v /var/run/containerd:/var/run/containerd \\\n    -e LIBBPFGO_OSRELEASE_FILE=/etc/os-release-host \\\n    -e CONTAINERS_ENRICHMENT=1 \\\n    aquasec/tracee:v0.10.0\n</code></pre> <p>Most container runtimes have their sockets installed by default in <code>/var/run</code>. If your system includes multiple container runtimes, tracee can track them all, however one should mount either all their runtime sockets or <code>/var/run</code> in it's entirety to do so.</p> </li> </ol>"},{"location":"docs/integrating/container-engines/#supported-container-runtime-engines","title":"Supported Container Runtime Engines","text":"<p>Currently, tracee will look in the following paths for autodiscovering the listed runtimes:</p> <ol> <li> <p>Docker:     <code>/var/run/docker.sock</code></p> </li> <li> <p>Containerd: <code>/var/run/containerd/containerd.sock</code></p> </li> <li> <p>CRI-O:      <code>/var/run/crio/crio.sock</code></p> </li> <li> <p>Podman:     <code>/var/run/podman/podman.sock</code></p> </li> </ol> <p>Tip</p> <p>Nested environments are somewhat tricky with this feature as evidenced by the docker mounting instructions. Tracee does not auto-discover this nesting and so sockets must be appropriately mounted and set up for tracee to enrich all containers correctly.</p>"},{"location":"docs/integrating/container-engines/#viewing-enrichment-output","title":"Viewing enrichment output","text":"<p>As a user, when container enrichment is enabled the event output will include enriched fields in these cases:</p> <ol> <li> <p>Running tracee-ebpf with a json format will include all container enriched fields      text<code>$ docker run \\         --name tracee --rm -it \\         --pid=host --cgroupns=host --privileged \\         -v /etc/os-release:/etc/os-release-host:ro \\         -v /var/run/docker.sock:/var/run/docker.sock \\         -e LIBBPFGO_OSRELEASE_FILE=/etc/os-release-host \\         aquasec/tracee:v0.10.0 \\         trace --output json --containers</code></p> </li> <li> <p>Running in container tracing mode and with enrichment enabled will add the image name to the table printer     text<code>$ docker run \\         --name tracee --rm -it \\         --pid=host --cgroupns=host --privileged \\         -v /etc/os-release:/etc/os-release-host:ro \\         -v /var/run/containerd:/var/run/containerd \\         -e LIBBPFGO_OSRELEASE_FILE=/etc/os-release-host \\         aquasec/tracee:v0.10.0 \\         trace --trace containers --containers</code></p> </li> </ol>"},{"location":"docs/integrating/falcosidekick/","title":"Detections: Deliver using Falcosidekick","text":"<p>Falcosidekick</p> <p>Falcosidekick is a useful webhook server that can be configured to connect to various \"outputs\" such as: Slack, Mattermost, Teams, Datadog, Prometheus, StatsD, Email, Elasticsearch, Loki, PagerDuty, OpsGenie, and many more.</p> <p>To use Tracee with Falcosidekick:</p> <ol> <li> <p>Obtain connection credentials to the system you want to integrate with.</p> <ol> <li>Consult the system's documentation and look for how to configure an    incoming webhook.</li> </ol> </li> <li> <p>Start the Falcosidekick container, configured with the obtained output    credentials:</p> <ol> <li>See the Falcosidekick Readme for full documentation.</li> </ol> </li> <li> <p>Start Tracee while configuring it to post detections to the Falcosidekick endpoint.</p> <ol> <li>If using Docker, you can use the simple link flag to allow the    containers to communicate</li> <li>Use the webhook flag to point to the Falcosidekick container's endpoint</li> <li>Tracee ships with a built-in template for Falcosidekick</li> </ol> </li> </ol> <p>Example</p> <ol> <li> <p>Start Falcosidekick configured to post to Slack:</p> <pre><code>docker run --name falcosidekick -p 2801:2801 \\\n  -e SLACK_WEBHOOKURL=https://hooks.slack.com/services/XXX/YYY/ZZZ \\\n  falcosecurity/falcosidekick\n</code></pre> </li> <li> <p>Start Tracee, linking it to the Falcosidekick container, and configuring it    to call it on detections:</p> <pre><code>$ docker run \\\n    --name tracee --rm -it \\\n    --pid=host --cgroupns=host --privileged \\\n    -v /etc/os-release:/etc/os-release-host:ro \\\n    -e LIBBPFGO_OSRELEASE_FILE=/etc/os-release-host \\\n    --link falcosidekick aquasec/tracee:0.10.0 \\\n    --webhook-template /tracee/templates/falcosidekick.tmpl \\\n    --webhook-content-type application/json \\\n    --webhook http://FALCOSIDEKICK:2801\n</code></pre> </li> </ol> <p>Also</p> <ol> <li>Deliver using a Webhook</li> <li>Deliver using Postee</li> </ol>"},{"location":"docs/integrating/go-templates/","title":"Detections: Output Format","text":""},{"location":"docs/integrating/go-templates/#configuring","title":"Configuring","text":"<p>When a detection is made by any of the loaded signatures, it will always be printed to stdout. You can customize this output format using a go template.</p> <pre><code>$ ./dist/tracee-rules --output-template /path/to/my.tmpl\n</code></pre> <p>Go-templates</p> <p>The following Go templates are included in the Tracee container image and are available for use under the <code>/tracee/templates/</code> directory in the container:</p> File name Description Content-Type Source rawjson.tmpl Dumps the Finding object as raw JSON <code>application/json</code> source falcosidekick.tmpl For compatibility with [falcosidekick] <code>application/json</code> source <ol> <li> <p>Basic Example: Raw JSON stdout</p> <p>The following example configures Tracee to output detections to stdout as raw JSON:</p> <pre><code>$ docker run \\\n    --name tracee --rm -it \\\n    --pid=host --cgroupns=host --privileged \\\n    -v /etc/os-release:/etc/os-release-host:ro \\\n    -e LIBBPFGO_OSRELEASE_FILE=/etc/os-release-host \\\n    aquasec/tracee:0.10.0 \\\n    --output-template /tracee/templates/rawjson.tmpl\n</code></pre> <p>Postee</p> <p>Tracee default delivery mechanism, using Helm, is through Postee and uses the <code>rawjson.tmpl</code> go template.</p> </li> <li> <p>Deliver using a Webhook</p> </li> <li> <p>Deliver using Postee</p> </li> <li> <p>Deliver using Falcosidekick</p> </li> </ol>"},{"location":"docs/integrating/go-templates/#authoring","title":"Authoring","text":"<p>When authoring a Go template for either stdout or webhook, you have Tracee's <code>types.Finding</code> struct as the data source:</p> <pre><code>// Finding is the main output of a signature. It represents a match result for\n// the signature business logic.\n\ntype Finding struct {\nSigMetadata SignatureMetadata // information about the signature that made the detection\nContext     Event // the raw event that triggered the detection\nData        map[string]interface{} // detection specific information\n}\n</code></pre> <p>The Go template can utilize helper functions from Sprig.</p> <p>For example templates, see tracee/cmd/tracee-rules/templates.</p>"},{"location":"docs/integrating/postee/","title":"Detections: Deliver using Postee","text":"<p>Postee integration is the default experience when using helm deployment.</p> <p>Also</p> <ol> <li>Deliver using a Webhook</li> <li>Deliver using Falcosidekick</li> </ol>"},{"location":"docs/integrating/prometheus/","title":"Prometheus","text":"<p>Integrating with Prometheus</p> <p>Performance</p> <p>Current Prometheus integration targets performance numbers for event production, consumption and detection. It does not target the detections themselves.</p> <p>Tracee is enabled for prometheus scraping by default. Scraping can be done through the following URLs:</p> <ol> <li>tracee-ebpf can be scraped through <code>:3366/metrics</code></li> <li>tracee-rules can be scraped through <code>:4466/metrics</code></li> </ol> <p>Metrics addresses can be changed through tracee-ebpf command line arguments <code>metrics</code> and <code>listen-addr</code>, check <code>--help</code> for more information.</p> <p>Tip</p> <p>Check this tutorial for more information as well.</p>"},{"location":"docs/integrating/webhook/","title":"Detections: Deliver using a Webhook","text":"<p>In addition, Tracee can notify a web service when a detection is made using a custom webhook:</p> <pre><code>tracee-rules --webhook http://my.webhook/endpoint \\\n--webhook-template /path/to/my.tmpl \\\n--webhook-content-type application/json\n</code></pre> <p>Also</p> <ol> <li>Deliver using Postee</li> <li>Deliver using Falcosidekick</li> </ol>"},{"location":"docs/tracing/","title":"Getting Started with Tracing","text":"<p>Note</p> <p>This entire section is about running tracee-ebpf only, without piping events to tracee-rules.</p> <p>In some cases, you might want to leverage Tracee event collection capabilities only, without involving the detection engine. You may, or may not, choose to capture artifacts while tracing.</p> <p>This might be useful for:</p> <ol> <li>debugging</li> <li>troubleshooting</li> <li>analysing executions</li> <li>security research</li> <li>education</li> </ol> <p>In this case you can use Tracee's eBPF collector component (tracee-ebpf), which will start dumping raw data directly into standard output.</p> <p>Watch a quick video demo of Tracee's eBPF tracing capabilities</p>"},{"location":"docs/tracing/#using-tracee-ebpf","title":"Using Tracee-eBPF","text":"<p>Before you proceed, make sure you follow the prerequisites.</p> <pre><code>$ docker run \\\n    --name tracee --rm -it \\\n    --pid=host --cgroupns=host --privileged \\\n    -v /etc/os-release:/etc/os-release-host:ro \\\n    -e LIBBPFGO_OSRELEASE_FILE=/etc/os-release-host \\\n    aquasec/tracee:0.10.0 \\\n    trace\n</code></pre> <p>Here, we are running the <code>aquasec/tracee</code> container, but with the <code>trace</code> sub-command, which will start just a raw trace (Tracee-eBPF), without the detection engine tracee-rules. Here's a sample output of running with no additional arguments:</p> <pre><code>TIME(s)        UID    COMM             PID     TID     RET             EVENT                ARGS\n176751.746515  1000   zsh              14726   14726   0               execve               pathname: /usr/bin/ls, argv: [ls]\n176751.746772  1000   zsh              14726   14726   0               security_bprm_check  pathname: /usr/bin/ls, dev: 8388610, inode: 777\n176751.747044  1000   ls               14726   14726  -2               access               pathname: /etc/ld.so.preload, mode: R_OK\n176751.747077  1000   ls               14726   14726   0               security_file_open   pathname: /etc/ld.so.cache, flags: O_RDONLY|O_LARGEFILE, dev: 8388610, inode: 533737\n...\n</code></pre> <p>Note</p> <p>There are 2 ways to enable tracing only: 1. To export a TRACEE_EBPF_ONLY=1 env variable to docker. 2. To provide a <code>trace</code> 1st argument to docker container.  </p> <p>Each line is a single event collected by Tracee-eBPF, with the following information:</p> <ol> <li>TIME    event time relative to system boot time in seconds</li> <li>UID    real user id of the calling process (in host userns)</li> <li>COMM    name of the calling process</li> <li>PID    pid of the calling process</li> <li>TID    tid of the calling thread</li> <li>RET    value returned by the function</li> <li>EVENT    identifies the event (e.g. syscall name)</li> <li>ARGS    list of arguments given to the function</li> </ol> <p>Note</p> <p>Use the <code>--help</code> flag to see a full description of available options. Some flags have specific help sections that can be accessed by passing <code>help</code> to the flag, for example <code>--output help</code>. This section covers some of the more common options.</p> <p>Check the existing output options for other output options. Check the existing output format for other output formats.</p> <p>Follow getting tracee in order to get tracee-ebpf.</p>"},{"location":"docs/tracing/event-filtering/","title":"Tracing Event Filtering","text":"<pre><code>$ sudo ./dist/tracee-ebpf --trace help\n$ sudo ./dist/tracee-ebpf --trace xxx\n</code></pre> <p>Tracing output might become too hard to consume when tracing all the events from a system. Luckily, Tracee has a powerful mechanism to accurately trace just the information that is relevant to the user, the <code>--trace</code> flag.</p> <p>With <code>--trace</code> command line flag you define expressions that tells tracee-ebpf what you are interested in based on event metadata filtering capabilities. Only events that match given criteria will be traced.</p> <p>Tip</p> <p>You can filter events by most of the visible fields from Tracee events.</p>"},{"location":"docs/tracing/event-filtering/#initial-example","title":"Initial Example","text":"<p>All the examples bellow this item can be executed with the following tracee-ebpf prefix command:</p> <pre><code>$ sudo ./dist/tracee-ebpf \\\n    --output json \\\n    --trace comm=bash \\\n    --trace follow\n    --output option:parse-arguments \\\n    &lt;rest of filters&gt;\n</code></pre> <p>This will allow you to test the filtering rules by executing a new process in any running shell and might serve as a good indicative if your filter works as expected.</p>"},{"location":"docs/tracing/event-filtering/#filters-and-operators","title":"Filters and Operators","text":"<ol> <li> <p>Event <code>(Operators: =, != and \"follow\". Prefix/Suffix: *)</code></p> <pre><code>1) --trace event=openat\n2) --trace event=execve,open\n3) --trace event=open*\n4) --trace event!=open*,dup*\n5) --trace follow\n</code></pre> <p>Note</p> <p>The \"follow\" operator will make tracee to follow all newly created processes, that are being filtered for, childs.</p> </li> <li> <p>Event Arguments <code>(Operators: =, !=. Prefix/Suffix: *)</code></p> <pre><code>1) --trace event=openat --trace openat.pathname=/etc/shadow\n2) --trace event=openat --trace openat.pathname=/tmp*\n3) --trace event=openat --trace openat.pathname!=/tmp/1,/bin/ls\n</code></pre> <p>Note</p> <p>Multiple values are ORed if used with = operator But ANDed if used with any other operator.</p> </li> <li> <p>Event Return Code <code>(Operators: =, !=, &lt;, &gt;)</code></p> <pre><code>1) --trace event=openat --trace openat.pathname=/etc/shadow --trace \"openat.retval&gt;0\"\n2) --trace event=openat --trace openat.pathname=/etc/shadow --trace \"openat.retval&lt;0\"\n</code></pre> <p>Tip</p> <p>Try <code>cat /etc/shadow</code> as a regular use and filter for <code>retval&lt;0</code>.</p> </li> <li> <p>Event Context <code>(Operators: vary by field)</code></p> <pre><code>1) --trace openat.context.container --trace openat.pathname=/etc/shadow\n2) --trace event=openat --trace openat.context.container --trace openat.pathname=/etc/shadow\n</code></pre> <p>Note</p> <p>The following is a list of available context fields: 1)  \"timestamp\" 2)  \"processorId\" 3)  \"p\", \"pid\", \"processId\" 4)  \"tid\", \"threadId\" 5)  \"ppid\", \"parentProcessId\" 6)  \"hostTid\", \"hostThreadId\" 7)  \"hostPid\", \"hostParentProcessId\" 8)  \"uid\", \"userId\" 9)  \"mntns\", \"mountNamespace\" 10) \"pidns\", \"pidNamespace\" 11) \"processName\", \"comm\" 12) \"hostName\" 13) \"cgroupId\" 14) \"host\" (inversion of \"container\") 15) \"container\" 16) \"containerId\" 17) \"containerImage\" 18) \"containerName\" 19) \"podName\" 20) \"podNamespace\" 21) \"podUid\"  </p> <p>Tip</p> <p>Open a container and try <code>cat /etc/shadow</code>.</p> </li> <li> <p>Event Sets <code>(Operators: =, !=)</code></p> <pre><code>1) --trace set=fs\n2) --trace set=lsm_hooks,network_events\n</code></pre> <p>Note</p> <p>Selects a set of events to tracee according to pre-defined sets which can be listed by using <code>--list</code> command line argument.</p> </li> <li> <p>Container <code>(Operators: =, != and \"new\". Boolean)</code></p> <pre><code>1) --trace container # all container events\n2) --trace '!container' # events from the host only\n3) --trace container=new # containers created after tracee-ebf execution\n4) --trace container=3f93da58be3c --trace event=openat\n5) --trace container=new --trace event=openat --trace openat.pathname=\"/etc/shadow\"\n</code></pre> <p>Note</p> <p>The new flag allows to trace newly created containers only.  </p> </li> <li> <p>Command <code>(Operators: =, !=)</code></p> <pre><code>1) --trace comm=cat,vim,ping\n2) --trace comm!=ping\n</code></pre> <p>Note</p> <p>Do not use given command prefix for these examples as they're filtering by command name as well.</p> </li> <li> <p>Binary Path <code>(Operators: =, !=)</code></p> <pre><code>1) --trace binary=/usr/bin/ls\n2) --trace binary=host:/usr/bin/ls\n3) --trace binary=4026532448:/usr/bin/ls\n</code></pre> <p>Note</p> <ol> <li>Mount namespace id or the special \"host:\" prefix can be used for finer filtering</li> <li>Given path must be absolute; i.e starts with \"/\"</li> <li>Only binaries that were executed after Tracee will be filtered</li> <li>Symbolic link paths are not supported</li> </ol> </li> <li> <p>PID <code>(Operators: =, !=, &lt;, &gt; and \"new\")</code></p> <pre><code>1) --trace pid=new # newly created events (after tracee-ebpf execution)\n2) --trace pid=510,1709 # # pids 510 and 1709\n3) --trace 'pid&gt;0' --trace pid 'pid&lt;1000'\n4) --trace pid=2578238 --trace event=openat --trace openat.pathname=/etc/shadow --trace follow\n</code></pre> <p>Note</p> <p>This filter can be used to trace a specific process or thread: 1. Providing a tgid (aka pid) will trace all threads of the process. 2. Providing a tid (where tid != tgid) will only trace the specific thread.</p> </li> <li> <p>Process Tree</p> <pre><code>1) --trace tree=476165 # events descending from process 476165\n2) --trace tree!=5023 # events that do not descend from process 5023\n</code></pre> </li> <li> <p>UID <code>(Operators: =, !=, &lt;, &gt;)</code></p> <pre><code>1) --trace uid=0\n2) --trace 'uid&gt;0'\n3) --trace 'uid&gt;0' --trace uid!=1000 # do not trace root and uid=1000\n</code></pre> </li> <li> <p>Network Interface</p> <pre><code>1) -trace comm=nc,ping -trace event=net_packet -trace net=docker0\n2) -trace event=dns_request,dns_response -trace net=docker0\n</code></pre> <p>Attention</p> <p>Do not forget to provide the interface to be traced with \"net=name\"</p> </li> <li> <p>UTS Namespace (hostnames) <code>(Operators: =, !=)</code></p> <pre><code>1) --trace uts!=ab356bc4dd554 \n</code></pre> </li> <li> <p>PID Namespace <code>(Operators: =, !=)</code></p> <pre><code>1) --trace pidns!=4026531836\n</code></pre> </li> <li> <p>MOUNT Namespace <code>(Operators: =, !=)</code></p> <pre><code>1) --trace mntns=4026531840\n</code></pre> </li> </ol>"},{"location":"docs/tracing/network-events/","title":"Tracing Network Events","text":"<p>In order to trace network events you may execute:</p> <pre><code>$ sudo ./dist/tracee-ebpf --output format:json --trace event=X,Y,Z\n</code></pre> <p>where <code>X,Y,Z</code> might be one of the events described below. All the network events try to translate the referred protocols (IP, IPv6, TCP, UDP, ICMPv6, DNS) headers into tracee events, so all fields from that network header are available for tracing. Besides the protocol header, there is also some primary arguments, to each event, classifying the event using: <code>src</code>, <code>dest</code> (and <code>src_port</code>, <code>dst_port</code> if the protocol has those arguments).</p>"},{"location":"docs/tracing/network-events/#network-event-types","title":"Network Event Types","text":"<ol> <li> <p>net_packet_ipv4</p> <pre><code>--output format:json  --trace comm=nc --trace event=net_packet_ipv4\n</code></pre> <pre><code># three way handshake for a TCP connection.\n\n{\"timestamp\":1671040290192938971,\"threadStartTime\":341237880436231,\"processorId\":2,\"processId\":3120261,\"cgroupId\":20552,\"threadId\":3120261,\"parentProcessId\":3101489,\"hostProcessId\":3120261,\"hostThreadId\":3120261,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2007\",\"eventName\":\"net_packet_ipv4\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.157.254.1\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.157.254.193\"},{\"name\":\"proto_ipv4\",\"type\":\"trace.ProtoIPv4\",\"value\":{\"version\":4,\"IHL\":5,\"TOS\":0,\"length\":60,\"id\":42857,\"flags\":2,\"fragOffset\":0,\"TTL\":64,\"protocol\":\"TCP\",\"checksum\":33109,\"srcIP\":\"10.157.254.1\",\"dstIP\":\"10.157.254.193\"}}]}\n{\"timestamp\":1671040290193572748,\"threadStartTime\":341237880436231,\"processorId\":13,\"processId\":3120261,\"cgroupId\":20552,\"threadId\":3120261,\"parentProcessId\":3101489,\"hostProcessId\":3120261,\"hostThreadId\":3120261,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2007\",\"eventName\":\"net_packet_ipv4\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.157.254.193\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.157.254.1\"},{\"name\":\"proto_ipv4\",\"type\":\"trace.ProtoIPv4\",\"value\":{\"version\":4,\"IHL\":5,\"TOS\":0,\"length\":60,\"id\":0,\"flags\":2,\"fragOffset\":0,\"TTL\":64,\"protocol\":\"TCP\",\"checksum\":10431,\"srcIP\":\"10.157.254.193\",\"dstIP\":\"10.157.254.1\"}}]}\n{\"timestamp\":1671040290193642873,\"threadStartTime\":341237880436231,\"processorId\":13,\"processId\":3120261,\"cgroupId\":20552,\"threadId\":3120261,\"parentProcessId\":3101489,\"hostProcessId\":3120261,\"hostThreadId\":3120261,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2007\",\"eventName\":\"net_packet_ipv4\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.157.254.1\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.157.254.193\"},{\"name\":\"proto_ipv4\",\"type\":\"trace.ProtoIPv4\",\"value\":{\"version\":4,\"IHL\":5,\"TOS\":0,\"length\":52,\"id\":42858,\"flags\":2,\"fragOffset\":0,\"TTL\":64,\"protocol\":\"TCP\",\"checksum\":33116,\"srcIP\":\"10.157.254.1\",\"dstIP\":\"10.157.254.193\"}}]}\n\n# send a single packet and receive an ack.\n\n{\"timestamp\":1671040295319879439,\"threadStartTime\":341237880436231,\"processorId\":2,\"processId\":3120261,\"cgroupId\":20552,\"threadId\":3120261,\"parentProcessId\":3101489,\"hostProcessId\":3120261,\"hostThreadId\":3120261,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2007\",\"eventName\":\"net_packet_ipv4\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.157.254.1\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.157.254.193\"},{\"name\":\"proto_ipv4\",\"type\":\"trace.ProtoIPv4\",\"value\":{\"version\":4,\"IHL\":5,\"TOS\":0,\"length\":54,\"id\":42859,\"flags\":2,\"fragOffset\":0,\"TTL\":64,\"protocol\":\"TCP\",\"checksum\":33113,\"srcIP\":\"10.157.254.1\",\"dstIP\":\"10.157.254.193\"}}]}\n{\"timestamp\":1671040295320501275,\"threadStartTime\":341237880436231,\"processorId\":15,\"processId\":3120261,\"cgroupId\":20552,\"threadId\":3120261,\"parentProcessId\":3101489,\"hostProcessId\":3120261,\"hostThreadId\":3120261,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2007\",\"eventName\":\"net_packet_ipv4\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.157.254.193\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.157.254.1\"},{\"name\":\"proto_ipv4\",\"type\":\"trace.ProtoIPv4\",\"value\":{\"version\":4,\"IHL\":5,\"TOS\":0,\"length\":52,\"id\":56842,\"flags\":2,\"fragOffset\":0,\"TTL\":64,\"protocol\":\"TCP\",\"checksum\":19132,\"srcIP\":\"10.157.254.193\",\"dstIP\":\"10.157.254.1\"}}]}\n\n# receive a single packet and send an ack.\n\n{\"timestamp\":1671040299925291880,\"threadStartTime\":341237880436231,\"processorId\":5,\"processId\":3120261,\"cgroupId\":20552,\"threadId\":3120261,\"parentProcessId\":3101489,\"hostProcessId\":3120261,\"hostThreadId\":3120261,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2007\",\"eventName\":\"net_packet_ipv4\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.157.254.193\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.157.254.1\"},{\"name\":\"proto_ipv4\",\"type\":\"trace.ProtoIPv4\",\"value\":{\"version\":4,\"IHL\":5,\"TOS\":0,\"length\":54,\"id\":56843,\"flags\":2,\"fragOffset\":0,\"TTL\":64,\"protocol\":\"TCP\",\"checksum\":19129,\"srcIP\":\"10.157.254.193\",\"dstIP\":\"10.157.254.1\"}}]}\n{\"timestamp\":1671040299925385970,\"threadStartTime\":341237880436231,\"processorId\":5,\"processId\":3120261,\"cgroupId\":20552,\"threadId\":3120261,\"parentProcessId\":3101489,\"hostProcessId\":3120261,\"hostThreadId\":3120261,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2007\",\"eventName\":\"net_packet_ipv4\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.157.254.1\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.157.254.193\"},{\"name\":\"proto_ipv4\",\"type\":\"trace.ProtoIPv4\",\"value\":{\"version\":4,\"IHL\":5,\"TOS\":0,\"length\":52,\"id\":42860,\"flags\":2,\"fragOffset\":0,\"TTL\":64,\"protocol\":\"TCP\",\"checksum\":33114,\"srcIP\":\"10.157.254.1\",\"dstIP\":\"10.157.254.193\"}}]}\n</code></pre> </li> <li> <p>net_packet_ipv6</p> <pre><code>--output format:json  --trace comm=nc --trace event=net_packet_ipv6\n</code></pre> <pre><code># three way handshake for a TCP under IPv6 connection.\n\n{\"timestamp\":1671041051949404378,\"threadStartTime\":341999636945074,\"processorId\":10,\"processId\":3141206,\"cgroupId\":20552,\"threadId\":3141206,\"parentProcessId\":3101489,\"hostProcessId\":3141206,\"hostThreadId\":3141206,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2008\",\"eventName\":\"net_packet_ipv6\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"fd6e:a63d:71f:2000::1\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"fd6e:a63d:71f:2000::2\"},{\"name\":\"proto_ipv6\",\"type\":\"trace.ProtoIPv6\",\"value\":{\"version\":6,\"trafficClass\":0,\"flowLabel\":263249,\"length\":40,\"nextHeader\":\"TCP\",\"hopLimit\":64,\"srcIP\":\"fd6e:a63d:71f:2000::1\",\"dstIP\":\"fd6e:a63d:71f:2000::2\"}}]}\n{\"timestamp\":1671041051950428522,\"threadStartTime\":341999636945074,\"processorId\":3,\"processId\":3141206,\"cgroupId\":20552,\"threadId\":3141206,\"parentProcessId\":3101489,\"hostProcessId\":3141206,\"hostThreadId\":3141206,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2008\",\"eventName\":\"net_packet_ipv6\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"fd6e:a63d:71f:2000::2\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"fd6e:a63d:71f:2000::1\"},{\"name\":\"proto_ipv6\",\"type\":\"trace.ProtoIPv6\",\"value\":{\"version\":6,\"trafficClass\":0,\"flowLabel\":917337,\"length\":40,\"nextHeader\":\"TCP\",\"hopLimit\":64,\"srcIP\":\"fd6e:a63d:71f:2000::2\",\"dstIP\":\"fd6e:a63d:71f:2000::1\"}}]}\n{\"timestamp\":1671041051950513760,\"threadStartTime\":341999636945074,\"processorId\":3,\"processId\":3141206,\"cgroupId\":20552,\"threadId\":3141206,\"parentProcessId\":3101489,\"hostProcessId\":3141206,\"hostThreadId\":3141206,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2008\",\"eventName\":\"net_packet_ipv6\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"fd6e:a63d:71f:2000::1\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"fd6e:a63d:71f:2000::2\"},{\"name\":\"proto_ipv6\",\"type\":\"trace.ProtoIPv6\",\"value\":{\"version\":6,\"trafficClass\":0,\"flowLabel\":263249,\"length\":32,\"nextHeader\":\"TCP\",\"hopLimit\":64,\"srcIP\":\"fd6e:a63d:71f:2000::1\",\"dstIP\":\"fd6e:a63d:71f:2000::2\"}}]}\n\n# send a single packet and receive an ack.\n\n{\"timestamp\":1671041054444258140,\"threadStartTime\":341999636945074,\"processorId\":10,\"processId\":3141206,\"cgroupId\":20552,\"threadId\":3141206,\"parentProcessId\":3101489,\"hostProcessId\":3141206,\"hostThreadId\":3141206,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2008\",\"eventName\":\"net_packet_ipv6\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"fd6e:a63d:71f:2000::1\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"fd6e:a63d:71f:2000::2\"},{\"name\":\"proto_ipv6\",\"type\":\"trace.ProtoIPv6\",\"value\":{\"version\":6,\"trafficClass\":0,\"flowLabel\":263249,\"length\":34,\"nextHeader\":\"TCP\",\"hopLimit\":64,\"srcIP\":\"fd6e:a63d:71f:2000::1\",\"dstIP\":\"fd6e:a63d:71f:2000::2\"}}]}\n{\"timestamp\":1671041054444933243,\"threadStartTime\":341999636945074,\"processorId\":19,\"processId\":3141206,\"cgroupId\":20552,\"threadId\":3141206,\"parentProcessId\":3101489,\"hostProcessId\":3141206,\"hostThreadId\":3141206,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2008\",\"eventName\":\"net_packet_ipv6\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"fd6e:a63d:71f:2000::2\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"fd6e:a63d:71f:2000::1\"},{\"name\":\"proto_ipv6\",\"type\":\"trace.ProtoIPv6\",\"value\":{\"version\":6,\"trafficClass\":0,\"flowLabel\":917337,\"length\":32,\"nextHeader\":\"TCP\",\"hopLimit\":64,\"srcIP\":\"fd6e:a63d:71f:2000::2\",\"dstIP\":\"fd6e:a63d:71f:2000::1\"}}]}\n\n# receive a single packet and send an ack.\n\n{\"timestamp\":1671041058522081844,\"threadStartTime\":341999636945074,\"processorId\":3,\"processId\":3141206,\"cgroupId\":20552,\"threadId\":3141206,\"parentProcessId\":3101489,\"hostProcessId\":3141206,\"hostThreadId\":3141206,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2008\",\"eventName\":\"net_packet_ipv6\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"fd6e:a63d:71f:2000::2\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"fd6e:a63d:71f:2000::1\"},{\"name\":\"proto_ipv6\",\"type\":\"trace.ProtoIPv6\",\"value\":{\"version\":6,\"trafficClass\":0,\"flowLabel\":917337,\"length\":34,\"nextHeader\":\"TCP\",\"hopLimit\":64,\"srcIP\":\"fd6e:a63d:71f:2000::2\",\"dstIP\":\"fd6e:a63d:71f:2000::1\"}}]}\n{\"timestamp\":1671041058522149062,\"threadStartTime\":341999636945074,\"processorId\":3,\"processId\":3141206,\"cgroupId\":20552,\"threadId\":3141206,\"parentProcessId\":3101489,\"hostProcessId\":3141206,\"hostThreadId\":3141206,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2008\",\"eventName\":\"net_packet_ipv6\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"fd6e:a63d:71f:2000::1\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"fd6e:a63d:71f:2000::2\"},{\"name\":\"proto_ipv6\",\"type\":\"trace.ProtoIPv6\",\"value\":{\"version\":6,\"trafficClass\":0,\"flowLabel\":263249,\"length\":32,\"nextHeader\":\"TCP\",\"hopLimit\":64,\"srcIP\":\"fd6e:a63d:71f:2000::1\",\"dstIP\":\"fd6e:a63d:71f:2000::2\"}}]}\n</code></pre> </li> <li> <p>net_packet_tcp</p> <pre><code>--output format:json  --trace comm=nc --trace event=net_packet_tcp\n</code></pre> <pre><code># three way handshake for the tcp connection (note SYN and ACK flags).\n\n{\"timestamp\":1671041571396216462,\"threadStartTime\":342519082935538,\"processorId\":12,\"processId\":3156273,\"cgroupId\":20552,\"threadId\":3156273,\"parentProcessId\":3101489,\"hostProcessId\":3156273,\"hostThreadId\":3156273,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2009\",\"eventName\":\"net_packet_tcp\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.157.254.1\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.157.254.193\"},{\"name\":\"proto_tcp\",\"type\":\"trace.ProtoTCP\",\"value\":{\"srcPort\":51594,\"dstPort\":8090,\"seq\":1188220445,\"ack\":0,\"dataOffset\":10,\"FIN\":0,\"SYN\":1,\"RST\":0,\"PSH\":0,\"ACK\":0,\"URG\":0,\"ECE\":0,\"CWR\":0,\"NS\":0,\"window\":64240,\"checksum\":4652,\"urgent\":0}}]}\n{\"timestamp\":1671041571397219944,\"threadStartTime\":342519082935538,\"processorId\":1,\"processId\":3156273,\"cgroupId\":20552,\"threadId\":3156273,\"parentProcessId\":3101489,\"hostProcessId\":3156273,\"hostThreadId\":3156273,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2009\",\"eventName\":\"net_packet_tcp\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.157.254.193\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.157.254.1\"},{\"name\":\"proto_tcp\",\"type\":\"trace.ProtoTCP\",\"value\":{\"srcPort\":8090,\"dstPort\":51594,\"seq\":658038831,\"ack\":1188220446,\"dataOffset\":10,\"FIN\":0,\"SYN\":1,\"RST\":0,\"PSH\":0,\"ACK\":1,\"URG\":0,\"ECE\":0,\"CWR\":0,\"NS\":0,\"window\":65160,\"checksum\":4652,\"urgent\":0}}]}\n{\"timestamp\":1671041571397303639,\"threadStartTime\":342519082935538,\"processorId\":1,\"processId\":3156273,\"cgroupId\":20552,\"threadId\":3156273,\"parentProcessId\":3101489,\"hostProcessId\":3156273,\"hostThreadId\":3156273,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2009\",\"eventName\":\"net_packet_tcp\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.157.254.1\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.157.254.193\"},{\"name\":\"proto_tcp\",\"type\":\"trace.ProtoTCP\",\"value\":{\"srcPort\":51594,\"dstPort\":8090,\"seq\":1188220446,\"ack\":658038832,\"dataOffset\":8,\"FIN\":0,\"SYN\":0,\"RST\":0,\"PSH\":0,\"ACK\":1,\"URG\":0,\"ECE\":0,\"CWR\":0,\"NS\":0,\"window\":502,\"checksum\":4644,\"urgent\":0}}]}\n\n# send a single packet and receive an ack for the sequence.\n\n{\"timestamp\":1671041574116624540,\"threadStartTime\":342519082935538,\"processorId\":20,\"processId\":3156273,\"cgroupId\":20552,\"threadId\":3156273,\"parentProcessId\":3101489,\"hostProcessId\":3156273,\"hostThreadId\":3156273,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2009\",\"eventName\":\"net_packet_tcp\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.157.254.1\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.157.254.193\"},{\"name\":\"proto_tcp\",\"type\":\"trace.ProtoTCP\",\"value\":{\"srcPort\":51594,\"dstPort\":8090,\"seq\":1188220446,\"ack\":658038832,\"dataOffset\":8,\"FIN\":0,\"SYN\":0,\"RST\":0,\"PSH\":1,\"ACK\":1,\"URG\":0,\"ECE\":0,\"CWR\":0,\"NS\":0,\"window\":502,\"checksum\":4646,\"urgent\":0}}]}\n{\"timestamp\":1671041574117560789,\"threadStartTime\":342519082935538,\"processorId\":21,\"processId\":3156273,\"cgroupId\":20552,\"threadId\":3156273,\"parentProcessId\":3101489,\"hostProcessId\":3156273,\"hostThreadId\":3156273,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2009\",\"eventName\":\"net_packet_tcp\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.157.254.193\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.157.254.1\"},{\"name\":\"proto_tcp\",\"type\":\"trace.ProtoTCP\",\"value\":{\"srcPort\":8090,\"dstPort\":51594,\"seq\":658038832,\"ack\":1188220448,\"dataOffset\":8,\"FIN\":0,\"SYN\":0,\"RST\":0,\"PSH\":0,\"ACK\":1,\"URG\":0,\"ECE\":0,\"CWR\":0,\"NS\":0,\"window\":510,\"checksum\":4644,\"urgent\":0}}]}\n\n# receive a single packet and send an ack for the sequence.\n\n{\"timestamp\":1671041577684649596,\"threadStartTime\":342519082935538,\"processorId\":0,\"processId\":3156273,\"cgroupId\":20552,\"threadId\":3156273,\"parentProcessId\":3101489,\"hostProcessId\":3156273,\"hostThreadId\":3156273,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2009\",\"eventName\":\"net_packet_tcp\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.157.254.193\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.157.254.1\"},{\"name\":\"proto_tcp\",\"type\":\"trace.ProtoTCP\",\"value\":{\"srcPort\":8090,\"dstPort\":51594,\"seq\":658038832,\"ack\":1188220448,\"dataOffset\":8,\"FIN\":0,\"SYN\":0,\"RST\":0,\"PSH\":1,\"ACK\":1,\"URG\":0,\"ECE\":0,\"CWR\":0,\"NS\":0,\"window\":510,\"checksum\":4646,\"urgent\":0}}]}\n{\"timestamp\":1671041577684705270,\"threadStartTime\":342519082935538,\"processorId\":0,\"processId\":3156273,\"cgroupId\":20552,\"threadId\":3156273,\"parentProcessId\":3101489,\"hostProcessId\":3156273,\"hostThreadId\":3156273,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2009\",\"eventName\":\"net_packet_tcp\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.157.254.1\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.157.254.193\"},{\"name\":\"proto_tcp\",\"type\":\"trace.ProtoTCP\",\"value\":{\"srcPort\":51594,\"dstPort\":8090,\"seq\":1188220448,\"ack\":658038834,\"dataOffset\":8,\"FIN\":0,\"SYN\":0,\"RST\":0,\"PSH\":0,\"ACK\":1,\"URG\":0,\"ECE\":0,\"CWR\":0,\"NS\":0,\"window\":502,\"checksum\":4644,\"urgent\":0}}]}\n</code></pre> </li> <li> <p>net_packet_udp</p> <pre><code>--output format:json  --trace comm=nc --trace event=net_packet_udp\n</code></pre> <pre><code># send a single packet.\n\n{\"timestamp\":1671041745559197126,\"threadStartTime\":342691388187456,\"processorId\":15,\"processId\":3160590,\"cgroupId\":20552,\"threadId\":3160590,\"parentProcessId\":3101489,\"hostProcessId\":3160590,\"hostThreadId\":3160590,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2010\",\"eventName\":\"net_packet_udp\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.157.254.1\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.157.254.193\"},{\"name\":\"proto_udp\",\"type\":\"trace.ProtoUDP\",\"value\":{\"srcPort\":54370,\"dstPort\":8090,\"length\":10,\"checksum\":4633}}]}\n\n# receive a single packet.\n\n{\"timestamp\":1671041746569025030,\"threadStartTime\":342691388187456,\"processorId\":5,\"processId\":3160590,\"cgroupId\":20552,\"threadId\":3160590,\"parentProcessId\":3101489,\"hostProcessId\":3160590,\"hostThreadId\":3160590,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2010\",\"eventName\":\"net_packet_udp\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.157.254.193\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.157.254.1\"},{\"name\":\"proto_udp\",\"type\":\"trace.ProtoUDP\",\"value\":{\"srcPort\":8090,\"dstPort\":54370,\"length\":10,\"checksum\":4633}}]}\n</code></pre> </li> <li> <p>net_packet_icmp</p> <pre><code>--output format:json  --trace comm=ping --trace event=net_packet_icmp\n</code></pre> <pre><code># send an ICMP echo request.\n\n{\"timestamp\":1671041834556860509,\"threadStartTime\":342782244688605,\"processorId\":0,\"processId\":3162824,\"cgroupId\":20552,\"threadId\":3162824,\"parentProcessId\":3101489,\"hostProcessId\":3162824,\"hostThreadId\":3162824,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"ping\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2011\",\"eventName\":\"net_packet_icmp\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.157.254.1\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.157.254.193\"},{\"name\":\"proto_icmp\",\"type\":\"trace.ProtoICMP\",\"value\":{\"typeCode\":\"EchoRequest\",\"checksum\":1592,\"id\":27646,\"seq\":1}}]}\n\n# receive an ICMP echo reply.\n\n{\"timestamp\":1671041834557721951,\"threadStartTime\":342782244688605,\"processorId\":13,\"processId\":3162824,\"cgroupId\":20552,\"threadId\":3162824,\"parentProcessId\":3101489,\"hostProcessId\":3162824,\"hostThreadId\":3162824,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"ping\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2011\",\"eventName\":\"net_packet_icmp\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.157.254.193\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.157.254.1\"},{\"name\":\"proto_icmp\",\"type\":\"trace.ProtoICMP\",\"value\":{\"typeCode\":\"EchoReply\",\"checksum\":3640,\"id\":27646,\"seq\":1}}]}\n</code></pre> </li> <li> <p>net_packet_icmpv6</p> <pre><code>--output format:json  --trace comm=ping --trace event=net_packet_icmpv6\n</code></pre> <pre><code># send an ICMPv6 echo request.\n\n{\"timestamp\":1671041966651955456,\"threadStartTime\":342914339316549,\"processorId\":13,\"processId\":3166608,\"cgroupId\":20552,\"threadId\":3166608,\"parentProcessId\":3101489,\"hostProcessId\":3166608,\"hostThreadId\":3166608,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"ping\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2012\",\"eventName\":\"net_packet_icmpv6\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"fd6e:a63d:71f:2000::1\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"fd6e:a63d:71f:2000::2\"},{\"name\":\"proto_icmpv6\",\"type\":\"trace.ProtoICMPv6\",\"value\":{\"typeCode\":\"EchoRequest\",\"checksum\":25099}}]}\n\n# receive an ICMPv6 echo reply.\n\n{\"timestamp\":1671041966653079084,\"threadStartTime\":342914339316549,\"processorId\":3,\"processId\":3166608,\"cgroupId\":20552,\"threadId\":3166608,\"parentProcessId\":3101489,\"hostProcessId\":3166608,\"hostThreadId\":3166608,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"ping\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2012\",\"eventName\":\"net_packet_icmpv6\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"fd6e:a63d:71f:2000::2\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"fd6e:a63d:71f:2000::1\"},{\"name\":\"proto_icmpv6\",\"type\":\"trace.ProtoICMPv6\",\"value\":{\"typeCode\":\"EchoReply\",\"checksum\":24843}}]}\n</code></pre> </li> <li> <p>net_packet_dns</p> <pre><code>--output format:json  --trace comm=nslookup --trace follow --trace event=net_packet_dns\n</code></pre> <p>the <code>follow</code> tracing option is needed as <code>nslookup</code> creates child processes to execute the queries, and this makes tracee to also follow all <code>nslookup</code> child processes.</p> <pre><code># query type=A from nslookup to local systemd-resolved.\n\n{\"timestamp\":1671042316117498783,\"threadStartTime\":343263806334087,\"processorId\":7,\"processId\":3179904,\"cgroupId\":20552,\"threadId\":3179905,\"parentProcessId\":3101489,\"hostProcessId\":3179904,\"hostThreadId\":3179905,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"isc-net-0000\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2013\",\"eventName\":\"net_packet_dns\",\"argsNum\":5,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"127.0.0.1\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"127.0.0.53\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":42752},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":53},{\"name\":\"proto_dns\",\"type\":\"trace.ProtoDNS\",\"value\":{\"ID\":52902,\"QR\":0,\"opCode\":\"query\",\"AA\":0,\"TC\":0,\"RD\":1,\"RA\":0,\"Z\":0,\"responseCode\":\"no error\",\"QDCount\":1,\"ANCount\":0,\"NSCount\":0,\"ARCount\":0,\"questions\":[{\"name\":\"www.uol.com.br\",\"type\":\"A\",\"class\":\"IN\"}],\"answers\":[],\"authorities\":[],\"additionals\":[]}}]}\n\n# response from systemd-resolved to nslookup (after querying default nameserver).\n# response contains original query and multiple answers to the query.\n\n{\"timestamp\":1671042316131226611,\"threadStartTime\":343263806334087,\"processorId\":10,\"processId\":3179904,\"cgroupId\":20552,\"threadId\":3179905,\"parentProcessId\":3101489,\"hostProcessId\":3179904,\"hostThreadId\":3179905,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"isc-net-0000\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2013\",\"eventName\":\"net_packet_dns\",\"argsNum\":5,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"127.0.0.53\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"127.0.0.1\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":53},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":42752},{\"name\":\"proto_dns\",\"type\":\"trace.ProtoDNS\",\"value\":{\"ID\":52902,\"QR\":1,\"opCode\":\"query\",\"AA\":0,\"TC\":0,\"RD\":1,\"RA\":1,\"Z\":0,\"responseCode\":\"no error\",\"QDCount\":1,\"ANCount\":5,\"NSCount\":0,\"ARCount\":0,\"questions\":[{\"name\":\"www.uol.com.br\",\"type\":\"A\",\"class\":\"IN\"}],\"answers\":[{\"name\":\"www.uol.com.br\",\"type\":\"CNAME\",\"class\":\"IN\",\"TTL\":43,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"dftex7xfha8fh.cloudfront.net\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"dftex7xfha8fh.cloudfront.net\",\"type\":\"A\",\"class\":\"IN\",\"TTL\":55,\"IP\":\"65.8.214.126\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"dftex7xfha8fh.cloudfront.net\",\"type\":\"A\",\"class\":\"IN\",\"TTL\":55,\"IP\":\"65.8.214.78\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"dftex7xfha8fh.cloudfront.net\",\"type\":\"A\",\"class\":\"IN\",\"TTL\":55,\"IP\":\"65.8.214.70\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"dftex7xfha8fh.cloudfront.net\",\"type\":\"A\",\"class\":\"IN\",\"TTL\":55,\"IP\":\"65.8.214.49\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}],\"authorities\":[],\"additionals\":[]}}]}\n\n# query type=MX from nslookup to local systemd-resolved.\n\n{\"timestamp\":1671042491079309907,\"threadStartTime\":343438768169717,\"processorId\":1,\"processId\":3183907,\"cgroupId\":20552,\"threadId\":3183908,\"parentProcessId\":3101489,\"hostProcessId\":3183907,\"hostThreadId\":3183908,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"isc-net-0000\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2013\",\"eventName\":\"net_packet_dns\",\"argsNum\":5,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"127.0.0.1\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"127.0.0.53\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":34981},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":53},{\"name\":\"proto_dns\",\"type\":\"trace.ProtoDNS\",\"value\":{\"ID\":33920,\"QR\":0,\"opCode\":\"query\",\"AA\":0,\"TC\":0,\"RD\":1,\"RA\":0,\"Z\":0,\"responseCode\":\"no error\",\"QDCount\":1,\"ANCount\":0,\"NSCount\":0,\"ARCount\":0,\"questions\":[{\"name\":\"uol.com.br\",\"type\":\"MX\",\"class\":\"IN\"}],\"answers\":[],\"authorities\":[],\"additionals\":[]}}]}\n\n# response from systemd-resolved to nslookup containing original MX query and the MX answer.\n\n{\"timestamp\":1671042491090381166,\"threadStartTime\":343438768169717,\"processorId\":10,\"processId\":3183907,\"cgroupId\":20552,\"threadId\":3183908,\"parentProcessId\":3101489,\"hostProcessId\":3183907,\"hostThreadId\":3183908,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"isc-net-0000\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2013\",\"eventName\":\"net_packet_dns\",\"argsNum\":5,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"127.0.0.53\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"127.0.0.1\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":53},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":34981},{\"name\":\"proto_dns\",\"type\":\"trace.ProtoDNS\",\"value\":{\"ID\":33920,\"QR\":1,\"opCode\":\"query\",\"AA\":0,\"TC\":0,\"RD\":1,\"RA\":1,\"Z\":0,\"responseCode\":\"no error\",\"QDCount\":1,\"ANCount\":1,\"NSCount\":0,\"ARCount\":0,\"questions\":[{\"name\":\"uol.com.br\",\"type\":\"MX\",\"class\":\"IN\"}],\"answers\":[{\"name\":\"uol.com.br\",\"type\":\"MX\",\"class\":\"IN\",\"TTL\":17618,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":10,\"name\":\"mx.uol.com.br\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}],\"authorities\":[],\"additionals\":[]}}]}\n</code></pre> </li> <li> <p>net_packet_dns_request</p> <p>The <code>net_packet_dns_request</code> event is a simpler event, than the full <code>net_packet_dns</code> one. It contains simpler arguments to consume.</p> <pre><code>--output format:json  --trace comm=nslookup --trace follow --trace event=net_packet_dns_request\n</code></pre> <p>the <code>follow</code> tracing option is needed as <code>nslookup</code> creates child processes to execute the queries, and this makes tracee to also follow all <code>nslookup</code> child processes.</p> <pre><code># query type=A from nslookup to local systemd-resolved.\n# this event does not contain all DNS header fields as the net_packet_dns does.\n\n{\"timestamp\":1671043215487322928,\"threadStartTime\":344163176158597,\"processorId\":5,\"processId\":3200575,\"cgroupId\":20552,\"threadId\":3200576,\"parentProcessId\":3101489,\"hostProcessId\":3200575,\"hostThreadId\":3200576,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"isc-net-0000\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2014\",\"eventName\":\"net_packet_dns_request\",\"argsNum\":2,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"metadata\",\"type\":\"trace.PktMeta\",\"value\":{\"src_ip\":\"127.0.0.1\",\"dst_ip\":\"127.0.0.53\",\"src_port\":46259,\"dst_port\":53,\"protocol\":17,\"packet_len\":60,\"iface\":\"any\"}},{\"name\":\"dns_questions\",\"type\":\"[]trace.DnsQueryData\",\"value\":[{\"query\":\"www.uol.com.br\",\"query_type\":\"A\",\"query_class\":\"IN\"}]}]}\n{\"timestamp\":1671043215503932068,\"threadStartTime\":344163176158597,\"processorId\":10,\"processId\":3200575,\"cgroupId\":20552,\"threadId\":3200576,\"parentProcessId\":3101489,\"hostProcessId\":3200575,\"hostThreadId\":3200576,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"isc-net-0000\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2014\",\"eventName\":\"net_packet_dns_request\",\"argsNum\":2,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"metadata\",\"type\":\"trace.PktMeta\",\"value\":{\"src_ip\":\"127.0.0.53\",\"dst_ip\":\"127.0.0.1\",\"src_port\":53,\"dst_port\":46259,\"protocol\":17,\"packet_len\":166,\"iface\":\"any\"}},{\"name\":\"dns_questions\",\"type\":\"[]trace.DnsQueryData\",\"value\":[{\"query\":\"www.uol.com.br\",\"query_type\":\"A\",\"query_class\":\"IN\"}]}]}\n</code></pre> <p>Attention</p> <p>The <code>net_packet_dns_request</code> event is an event that is backwards compatible with an existing event called <code>dns_request</code>. The intention to have such event is to allow existing signatures already relying in the <code>dns_request</code> event, to rely in the new <code>net_packet_dns_request</code>. The benefit for the new event is that, differently from the <code>dns_request</code> event, there is no need to set an interface to monitor events when monitoring <code>net_packet_dns_request</code>. It gets DNS events from all existing interfaces and filters applied.</p> <p>Important</p> <p>This event might be deprecated or have its argument types changed in future versions.</p> </li> <li> <p>net_packet_response</p> <p>The <code>net_packet_dns_response</code> event is a simpler event, than the full <code>net_packet_dns</code> one. It contains simpler arguments to consume.</p> <pre><code>--output format:json  --trace comm=nslookup --trace follow --trace event=net_packet_dns_response\n</code></pre> <p>the <code>follow</code> tracing option is needed as <code>nslookup</code> creates child processes to execute the queries, and this makes tracee to also follow all <code>nslookup</code> child processes.</p> <pre><code># response from systemd-resolved to nslookup (after querying default nameserver).\n# response contains original query and multiple answers to the query.\n# this event does not contain all DNS header fields as the net_packet_dns does.\n\n{\"timestamp\":1671043317719969041,\"threadStartTime\":344265391016498,\"processorId\":10,\"processId\":3203040,\"cgroupId\":20552,\"threadId\":3203041,\"parentProcessId\":3101489,\"hostProcessId\":3203040,\"hostThreadId\":3203041,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"isc-net-0000\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2015\",\"eventName\":\"net_packet_dns_response\",\"argsNum\":2,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"metadata\",\"type\":\"trace.PktMeta\",\"value\":{\"src_ip\":\"127.0.0.53\",\"dst_ip\":\"127.0.0.1\",\"src_port\":53,\"dst_port\":41373,\"protocol\":17,\"packet_len\":166,\"iface\":\"any\"}},{\"name\":\"dns_response\",\"type\":\"[]trace.DnsResponseData\",\"value\":[{\"query_data\":{\"query\":\"www.uol.com.br\",\"query_type\":\"A\",\"query_class\":\"IN\"},\"dns_answer\":[{\"answer_type\":\"CNAME\",\"ttl\":22,\"answer\":\"dftex7xfha8fh.cloudfront.net\"},{\"answer_type\":\"A\",\"ttl\":60,\"answer\":\"65.8.214.126\"},{\"answer_type\":\"A\",\"ttl\":60,\"answer\":\"65.8.214.70\"},{\"answer_type\":\"A\",\"ttl\":60,\"answer\":\"65.8.214.49\"},{\"answer_type\":\"A\",\"ttl\":60,\"answer\":\"65.8.214.78\"}]}]}]}\n</code></pre> <p>Attention</p> <p>The <code>net_packet_dns_response</code> event is an event that is backwards compatible with an existing event called <code>dns_response</code>. The intention to have such event is to allow existing signatures already relying in the <code>dns_response</code> event, to rely in the new <code>net_packet_dns_response</code>. The benefit for the new event is that, differently from the <code>dns_response</code> event, there is no need to set an interface to monitor events when monitoring <code>net_packet_dns_response</code>. It gets DNS events from all existing interfaces and filters applied.</p> <p>Important</p> <p>This event might be deprecated or have its argument types changed in future versions.</p> </li> </ol>"},{"location":"docs/tracing/network-events/#network-event-filtering","title":"Network Event Filtering","text":"<p>Supported</p> <p>For now it is NOT possible to filter the events through the header fields, but it IS possible, and recommended, to filter the events through <code>src</code>, <code>dest</code> fields. Not filtering network events might be hard to consume because of the amount of traced events.</p> <ol> <li> <p>How to filter network events</p> <p>Let's say you're interested in all TCP packets sent to port 80 anywhere, from any process:</p> <pre><code>--output format:json --trace event=net_packet_tcp --trace net_packet_tcp.args.dst_port=80\n</code></pre> <p>you can trace all commands talking to any other peer using TCP to port 80.</p> <pre><code>{\"timestamp\":1671149983169847976,\"threadStartTime\":450930828307685,\"processorId\":22,\"processId\":1284215,\"cgroupId\":27149,\"threadId\":1284215,\"parentProcessId\":1268815,\"hostProcessId\":1284215,\"hostThreadId\":1284215,\"hostParentProcessId\":1268815,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"w3m\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2009\",\"eventName\":\"net_packet_tcp\",\"argsNum\":5,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"192.168.100.2\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"200.147.3.157\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":46594},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":80},{\"name\":\"proto_tcp\",\"type\":\"trace.ProtoTCP\",\"value\":{\"srcPort\":46594,\"dstPort\":80,\"seq\":3415564579,\"ack\":0,\"dataOffset\":10,\"FIN\":0,\"SYN\":1,\"RST\":0,\"PSH\":0,\"ACK\":0,\"URG\":0,\"ECE\":0,\"CWR\":0,\"NS\":0,\"window\":64240,\"checksum\":61705,\"urgent\":0}}]}\n{\"timestamp\":1671149983178147951,\"threadStartTime\":450930828307685,\"processorId\":23,\"processId\":1284215,\"cgroupId\":27149,\"threadId\":1284215,\"parentProcessId\":1268815,\"hostProcessId\":1284215,\"hostThreadId\":1284215,\"hostParentProcessId\":1268815,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"w3m\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2009\",\"eventName\":\"net_packet_tcp\",\"argsNum\":5,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"192.168.100.2\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"200.147.3.157\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":46594},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":80},{\"name\":\"proto_tcp\",\"type\":\"trace.ProtoTCP\",\"value\":{\"srcPort\":46594,\"dstPort\":80,\"seq\":3415564580,\"ack\":1519583696,\"dataOffset\":8,\"FIN\":0,\"SYN\":0,\"RST\":0,\"PSH\":0,\"ACK\":1,\"URG\":0,\"ECE\":0,\"CWR\":0,\"NS\":0,\"window\":502,\"checksum\":61697,\"urgent\":0}}]}\n{\"timestamp\":1671149983178263829,\"threadStartTime\":450930828307685,\"processorId\":22,\"processId\":1284215,\"cgroupId\":27149,\"threadId\":1284215,\"parentProcessId\":1268815,\"hostProcessId\":1284215,\"hostThreadId\":1284215,\"hostParentProcessId\":1268815,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"w3m\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2009\",\"eventName\":\"net_packet_tcp\",\"argsNum\":5,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"192.168.100.2\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"200.147.3.157\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":46594},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":80},{\"name\":\"proto_tcp\",\"type\":\"trace.ProtoTCP\",\"value\":{\"srcPort\":46594,\"dstPort\":80,\"seq\":3415564580,\"ack\":1519583696,\"dataOffset\":8,\"FIN\":0,\"SYN\":0,\"RST\":0,\"PSH\":1,\"ACK\":1,\"URG\":0,\"ECE\":0,\"CWR\":0,\"NS\":0,\"window\":502,\"checksum\":61907,\"urgent\":0}}]}\n</code></pre> <p>OR you're interested in all DNS packets received ONLY from Google DNS server '8.8.8.8'. You could execute the command below:</p> <pre><code>--output format:json --trace event=net_packet_dns --trace net_packet_dns.args.src=8.8.8.8\n</code></pre> <p>and see all processes that are resolving names using that server (only systemd-resolved, since all the other processes are resolving using local systemd-resolved server <code>127.0.1.1:53</code>):</p> <pre><code>{\"timestamp\":1671044490960363328,\"threadStartTime\":17862285588,\"processorId\":5,\"processId\":1016,\"cgroupId\":2847,\"threadId\":1016,\"parentProcessId\":1,\"hostProcessId\":1016,\"hostThreadId\":1016,\"hostParentProcessId\":1,\"userId\":104,\"mountNamespace\":4026533212,\"pidNamespace\":4026531836,\"processName\":\"systemd-resolve\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2013\",\"eventName\":\"net_packet_dns\",\"argsNum\":5,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"8.8.8.8\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"192.168.100.2\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":53},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":57278},{\"name\":\"proto_dns\",\"type\":\"trace.ProtoDNS\",\"value\":{\"ID\":45141,\"QR\":1,\"opCode\":\"query\",\"AA\":0,\"TC\":0,\"RD\":1,\"RA\":1,\"Z\":0,\"responseCode\":\"no error\",\"QDCount\":1,\"ANCount\":0,\"NSCount\":1,\"ARCount\":1,\"questions\":[{\"name\":\"github.com\",\"type\":\"AAAA\",\"class\":\"IN\"}],\"answers\":[],\"authorities\":[{\"name\":\"github.com\",\"type\":\"SOA\",\"class\":\"IN\",\"TTL\":2,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"ns-1707.awsdns-21.co.uk\",\"RName\":\"awsdns-hostmaster.amazon.com\",\"serial\":1,\"refresh\":7200,\"retry\":900,\"expire\":1209600,\"minimum\":86400},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}],\"additionals\":[{\"name\":\"\",\"type\":\"OPT\",\"class\":\"Unknown\",\"TTL\":0,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}]}}]}\n{\"timestamp\":1671044491458692167,\"threadStartTime\":17862285588,\"processorId\":5,\"processId\":1016,\"cgroupId\":2847,\"threadId\":1016,\"parentProcessId\":1,\"hostProcessId\":1016,\"hostThreadId\":1016,\"hostParentProcessId\":1,\"userId\":104,\"mountNamespace\":4026533212,\"pidNamespace\":4026531836,\"processName\":\"systemd-resolve\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2013\",\"eventName\":\"net_packet_dns\",\"argsNum\":5,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"8.8.8.8\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"192.168.100.2\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":53},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":44834},{\"name\":\"proto_dns\",\"type\":\"trace.ProtoDNS\",\"value\":{\"ID\":60536,\"QR\":1,\"opCode\":\"query\",\"AA\":0,\"TC\":0,\"RD\":1,\"RA\":1,\"Z\":0,\"responseCode\":\"no error\",\"QDCount\":1,\"ANCount\":1,\"NSCount\":0,\"ARCount\":1,\"questions\":[{\"name\":\"github.com\",\"type\":\"A\",\"class\":\"IN\"}],\"answers\":[{\"name\":\"github.com\",\"type\":\"A\",\"class\":\"IN\",\"TTL\":60,\"IP\":\"20.201.28.151\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}],\"authorities\":[],\"additionals\":[{\"name\":\"\",\"type\":\"OPT\",\"class\":\"Unknown\",\"TTL\":0,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}]}}]}\n{\"timestamp\":1671044592138383113,\"threadStartTime\":17862285588,\"processorId\":5,\"processId\":1016,\"cgroupId\":2847,\"threadId\":1016,\"parentProcessId\":1,\"hostProcessId\":1016,\"hostThreadId\":1016,\"hostParentProcessId\":1,\"userId\":104,\"mountNamespace\":4026533212,\"pidNamespace\":4026531836,\"processName\":\"systemd-resolve\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2013\",\"eventName\":\"net_packet_dns\",\"argsNum\":5,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"8.8.8.8\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"192.168.100.2\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":53},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":44265},{\"name\":\"proto_dns\",\"type\":\"trace.ProtoDNS\",\"value\":{\"ID\":22103,\"QR\":1,\"opCode\":\"query\",\"AA\":0,\"TC\":0,\"RD\":1,\"RA\":1,\"Z\":0,\"responseCode\":\"no error\",\"QDCount\":1,\"ANCount\":1,\"NSCount\":0,\"ARCount\":1,\"questions\":[{\"name\":\"github.com\",\"type\":\"A\",\"class\":\"IN\"}],\"answers\":[{\"name\":\"github.com\",\"type\":\"A\",\"class\":\"IN\",\"TTL\":60,\"IP\":\"20.201.28.151\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}],\"authorities\":[],\"additionals\":[{\"name\":\"\",\"type\":\"OPT\",\"class\":\"Unknown\",\"TTL\":0,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}]}}]}\n{\"timestamp\":1671044592139849906,\"threadStartTime\":17862285588,\"processorId\":5,\"processId\":1016,\"cgroupId\":2847,\"threadId\":1016,\"parentProcessId\":1,\"hostProcessId\":1016,\"hostThreadId\":1016,\"hostParentProcessId\":1,\"userId\":104,\"mountNamespace\":4026533212,\"pidNamespace\":4026531836,\"processName\":\"systemd-resolve\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2013\",\"eventName\":\"net_packet_dns\",\"argsNum\":5,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"8.8.8.8\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"192.168.100.2\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":53},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":53099},{\"name\":\"proto_dns\",\"type\":\"trace.ProtoDNS\",\"value\":{\"ID\":55518,\"QR\":1,\"opCode\":\"query\",\"AA\":0,\"TC\":0,\"RD\":1,\"RA\":1,\"Z\":0,\"responseCode\":\"no error\",\"QDCount\":1,\"ANCount\":0,\"NSCount\":1,\"ARCount\":1,\"questions\":[{\"name\":\"github.com\",\"type\":\"AAAA\",\"class\":\"IN\"}],\"answers\":[],\"authorities\":[{\"name\":\"github.com\",\"type\":\"SOA\",\"class\":\"IN\",\"TTL\":398,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"ns-1707.awsdns-21.co.uk\",\"RName\":\"awsdns-hostmaster.amazon.com\",\"serial\":1,\"refresh\":7200,\"retry\":900,\"expire\":1209600,\"minimum\":86400},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}],\"additionals\":[{\"name\":\"\",\"type\":\"OPT\",\"class\":\"Unknown\",\"TTL\":0,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}]}}]}\n{\"timestamp\":1671044593058863894,\"threadStartTime\":17862285588,\"processorId\":5,\"processId\":1016,\"cgroupId\":2847,\"threadId\":1016,\"parentProcessId\":1,\"hostProcessId\":1016,\"hostThreadId\":1016,\"hostParentProcessId\":1,\"userId\":104,\"mountNamespace\":4026533212,\"pidNamespace\":4026531836,\"processName\":\"systemd-resolve\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2013\",\"eventName\":\"net_packet_dns\",\"argsNum\":5,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"8.8.8.8\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"192.168.100.2\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":53},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":51112},{\"name\":\"proto_dns\",\"type\":\"trace.ProtoDNS\",\"value\":{\"ID\":64479,\"QR\":1,\"opCode\":\"query\",\"AA\":0,\"TC\":0,\"RD\":1,\"RA\":1,\"Z\":0,\"responseCode\":\"no error\",\"QDCount\":1,\"ANCount\":2,\"NSCount\":0,\"ARCount\":1,\"questions\":[{\"name\":\"star-actions-githubusercontent-com.l-0007.l-msedge.net\",\"type\":\"AAAA\",\"class\":\"IN\"}],\"answers\":[{\"name\":\"star-actions-githubusercontent-com.l-0007.l-msedge.net\",\"type\":\"CNAME\",\"class\":\"IN\",\"TTL\":149,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"l-0007.l-msedge.net\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"l-0007.l-msedge.net\",\"type\":\"AAAA\",\"class\":\"IN\",\"TTL\":149,\"IP\":\"2620:1ec:21::16\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}],\"authorities\":[],\"additionals\":[{\"name\":\"\",\"type\":\"OPT\",\"class\":\"Unknown\",\"TTL\":0,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}]}}]}\n{\"timestamp\":1671044593059043810,\"threadStartTime\":17862285588,\"processorId\":5,\"processId\":1016,\"cgroupId\":2847,\"threadId\":1016,\"parentProcessId\":1,\"hostProcessId\":1016,\"hostThreadId\":1016,\"hostParentProcessId\":1,\"userId\":104,\"mountNamespace\":4026533212,\"pidNamespace\":4026531836,\"processName\":\"systemd-resolve\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2013\",\"eventName\":\"net_packet_dns\",\"argsNum\":5,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"8.8.8.8\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"192.168.100.2\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":53},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":51952},{\"name\":\"proto_dns\",\"type\":\"trace.ProtoDNS\",\"value\":{\"ID\":4355,\"QR\":1,\"opCode\":\"query\",\"AA\":0,\"TC\":0,\"RD\":1,\"RA\":1,\"Z\":0,\"responseCode\":\"no error\",\"QDCount\":1,\"ANCount\":1,\"NSCount\":0,\"ARCount\":1,\"questions\":[{\"name\":\"l-0007.l-msedge.net\",\"type\":\"AAAA\",\"class\":\"IN\"}],\"answers\":[{\"name\":\"l-0007.l-msedge.net\",\"type\":\"AAAA\",\"class\":\"IN\",\"TTL\":105,\"IP\":\"2620:1ec:21::16\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}],\"authorities\":[],\"additionals\":[{\"name\":\"\",\"type\":\"OPT\",\"class\":\"Unknown\",\"TTL\":0,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}]}}]}\n{\"timestamp\":1671044594595474660,\"threadStartTime\":17862285588,\"processorId\":5,\"processId\":1016,\"cgroupId\":2847,\"threadId\":1016,\"parentProcessId\":1,\"hostProcessId\":1016,\"hostThreadId\":1016,\"hostParentProcessId\":1,\"userId\":104,\"mountNamespace\":4026533212,\"pidNamespace\":4026531836,\"processName\":\"systemd-resolve\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2013\",\"eventName\":\"net_packet_dns\",\"argsNum\":5,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"8.8.8.8\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"192.168.100.2\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":53},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":57386},{\"name\":\"proto_dns\",\"type\":\"trace.ProtoDNS\",\"value\":{\"ID\":50508,\"QR\":1,\"opCode\":\"query\",\"AA\":0,\"TC\":0,\"RD\":1,\"RA\":1,\"Z\":0,\"responseCode\":\"no error\",\"QDCount\":1,\"ANCount\":3,\"NSCount\":0,\"ARCount\":1,\"questions\":[{\"name\":\"pipelines.actions.githubusercontent.com\",\"type\":\"A\",\"class\":\"IN\"}],\"answers\":[{\"name\":\"pipelines.actions.githubusercontent.com\",\"type\":\"CNAME\",\"class\":\"IN\",\"TTL\":3395,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"star-actions-githubusercontent-com.l-0007.l-msedge.net\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"star-actions-githubusercontent-com.l-0007.l-msedge.net\",\"type\":\"CNAME\",\"class\":\"IN\",\"TTL\":35,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"l-0007.l-msedge.net\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"l-0007.l-msedge.net\",\"type\":\"A\",\"class\":\"IN\",\"TTL\":35,\"IP\":\"13.107.42.16\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}],\"authorities\":[],\"additionals\":[{\"name\":\"\",\"type\":\"OPT\",\"class\":\"Unknown\",\"TTL\":0,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}]}}]}\n{\"timestamp\":1671044594596611226,\"threadStartTime\":17862285588,\"processorId\":5,\"processId\":1016,\"cgroupId\":2847,\"threadId\":1016,\"parentProcessId\":1,\"hostProcessId\":1016,\"hostThreadId\":1016,\"hostParentProcessId\":1,\"userId\":104,\"mountNamespace\":4026533212,\"pidNamespace\":4026531836,\"processName\":\"systemd-resolve\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2013\",\"eventName\":\"net_packet_dns\",\"argsNum\":5,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"8.8.8.8\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"192.168.100.2\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":53},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":47545},{\"name\":\"proto_dns\",\"type\":\"trace.ProtoDNS\",\"value\":{\"ID\":44968,\"QR\":1,\"opCode\":\"query\",\"AA\":0,\"TC\":0,\"RD\":1,\"RA\":1,\"Z\":0,\"responseCode\":\"no error\",\"QDCount\":1,\"ANCount\":3,\"NSCount\":0,\"ARCount\":1,\"questions\":[{\"name\":\"pipelines.actions.githubusercontent.com\",\"type\":\"AAAA\",\"class\":\"IN\"}],\"answers\":[{\"name\":\"pipelines.actions.githubusercontent.com\",\"type\":\"CNAME\",\"class\":\"IN\",\"TTL\":2771,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"star-actions-githubusercontent-com.l-0007.l-msedge.net\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"star-actions-githubusercontent-com.l-0007.l-msedge.net\",\"type\":\"CNAME\",\"class\":\"IN\",\"TTL\":115,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"l-0007.l-msedge.net\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"l-0007.l-msedge.net\",\"type\":\"AAAA\",\"class\":\"IN\",\"TTL\":119,\"IP\":\"2620:1ec:21::16\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}],\"authorities\":[],\"additionals\":[{\"name\":\"\",\"type\":\"OPT\",\"class\":\"Unknown\",\"TTL\":0,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}]}}]}\n{\"timestamp\":1671044595955957557,\"threadStartTime\":17862285588,\"processorId\":5,\"processId\":1016,\"cgroupId\":2847,\"threadId\":1016,\"parentProcessId\":1,\"hostProcessId\":1016,\"hostThreadId\":1016,\"hostParentProcessId\":1,\"userId\":104,\"mountNamespace\":4026533212,\"pidNamespace\":4026531836,\"processName\":\"systemd-resolve\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2013\",\"eventName\":\"net_packet_dns\",\"argsNum\":5,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"8.8.8.8\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"192.168.100.2\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":53},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":42588},{\"name\":\"proto_dns\",\"type\":\"trace.ProtoDNS\",\"value\":{\"ID\":46878,\"QR\":1,\"opCode\":\"query\",\"AA\":0,\"TC\":0,\"RD\":1,\"RA\":1,\"Z\":0,\"responseCode\":\"no error\",\"QDCount\":1,\"ANCount\":1,\"NSCount\":0,\"ARCount\":1,\"questions\":[{\"name\":\"mx.uol.com.br\",\"type\":\"A\",\"class\":\"IN\"}],\"answers\":[{\"name\":\"mx.uol.com.br\",\"type\":\"A\",\"class\":\"IN\",\"TTL\":21233,\"IP\":\"200.147.41.231\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}],\"authorities\":[],\"additionals\":[{\"name\":\"\",\"type\":\"OPT\",\"class\":\"Unknown\",\"TTL\":0,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}]}}]}\n{\"timestamp\":1671044595958021940,\"threadStartTime\":17862285588,\"processorId\":5,\"processId\":1016,\"cgroupId\":2847,\"threadId\":1016,\"parentProcessId\":1,\"hostProcessId\":1016,\"hostThreadId\":1016,\"hostParentProcessId\":1,\"userId\":104,\"mountNamespace\":4026533212,\"pidNamespace\":4026531836,\"processName\":\"systemd-resolve\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2013\",\"eventName\":\"net_packet_dns\",\"argsNum\":5,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"8.8.8.8\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"192.168.100.2\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":53},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":57033},{\"name\":\"proto_dns\",\"type\":\"trace.ProtoDNS\",\"value\":{\"ID\":61528,\"QR\":1,\"opCode\":\"query\",\"AA\":0,\"TC\":0,\"RD\":1,\"RA\":1,\"Z\":0,\"responseCode\":\"no error\",\"QDCount\":1,\"ANCount\":1,\"NSCount\":0,\"ARCount\":1,\"questions\":[{\"name\":\"mx.uol.com.br\",\"type\":\"A\",\"class\":\"IN\"}],\"answers\":[{\"name\":\"mx.uol.com.br\",\"type\":\"A\",\"class\":\"IN\",\"TTL\":20920,\"IP\":\"200.147.41.231\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}],\"authorities\":[],\"additionals\":[{\"name\":\"\",\"type\":\"OPT\",\"class\":\"Unknown\",\"TTL\":0,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}]}}]}\n</code></pre> </li> </ol>"},{"location":"docs/tracing/network-events/#network-based-signatures","title":"Network Based Signatures","text":"<p>It is possible to create Golang (or Rego) signatures for the network events. If you haven't read about how to create signatures, do it HERE.</p> <p>Examples</p> <p>Bellow is an example of how to create a signature for the <code>net_packet_dns</code> event. This same example is used by Tracee CI/CD tests and can be found at the GitHub repository, together with some other signatures for the network events.</p> <ol> <li>net_packet_dns signature example</li> </ol> <pre><code>package main\n\nimport (\n\"fmt\"\n\"strings\"\n\n\"github.com/aquasecurity/tracee/signatures/helpers\"\n\"github.com/aquasecurity/tracee/types/detect\"\n\"github.com/aquasecurity/tracee/types/protocol\"\n\"github.com/aquasecurity/tracee/types/trace\"\n)\n\n//\n// HOWTO: The way to trigger this test signature is to execute:\n//\n//        nslookup -type=mx uol.com.br      and then\n//        nslookup -type=ns uol.com.br      and then\n//        nslookup -type=soa uol.com.br     and then\n//        nslookup -type=txt uol.com.br\n//\n//        This will cause it trigger once and reset it status.\n\ntype e2eDNS struct {\nfoundMX   bool\nfoundNS   bool\nfoundSOA  bool\nfoundTXTs bool\ncb        detect.SignatureHandler\n}\n\nfunc (sig *e2eDNS) Init(cb detect.SignatureHandler) error {\nsig.cb = cb\nsig.foundMX = false   // proforma\nsig.foundNS = false   // proforma\nsig.foundSOA = false  // proforma\nsig.foundTXTs = false // proforma\nreturn nil\n}\n\nfunc (sig *e2eDNS) GetMetadata() (detect.SignatureMetadata, error) {\nreturn detect.SignatureMetadata{\nID:          \"DNS\",\nVersion:     \"0.1.0\",\nName:        \"Network DNS Test\",\nDescription: \"Network E2E Tests: DNS\",\nTags:        []string{\"e2e\", \"network\"},\n}, nil\n}\n\nfunc (sig *e2eDNS) GetSelectedEvents() ([]detect.SignatureEventSelector, error) {\nreturn []detect.SignatureEventSelector{\n{Source: \"tracee\", Name: \"net_packet_dns\"},\n}, nil\n}\n\nfunc (sig *e2eDNS) OnEvent(event protocol.Event) error {\neventObj, ok := event.Payload.(trace.Event)\nif !ok {\nreturn fmt.Errorf(\"failed to cast event's payload\")\n}\n\nif eventObj.EventName == \"net_packet_dns\" {\ndns, err := helpers.GetProtoDNSByName(eventObj, \"proto_dns\")\nif err != nil {\nreturn err\n}\n\nif len(dns.Answers) &gt; 0 {\nfor _, answer := range dns.Answers {\n// check if MX works\nif answer.MX.Name == \"mx.uol.com.br\" &amp;&amp; answer.MX.Preference == 10 {\nsig.foundMX = true\n}\n// check if NS works\nif answer.NS == \"eliot.uol.com.br\" {\nsig.foundNS = true\n}\n// check if SOA works\nif answer.SOA.RName == \"root.uol.com.br\" {\nsig.foundSOA = true\n}\n// check if TXTs works\nif answer.TXTs != nil &amp;&amp; len(answer.TXTs) &gt; 0 {\nfor _, txt := range answer.TXTs {\nif strings.Contains(txt, \"spf.uol.com.br\") {\nsig.foundTXTs = true\n}\n}\n}\n}\n}\n\nif !sig.foundMX || !sig.foundNS || !sig.foundSOA || !sig.foundTXTs {\nreturn nil\n}\n\nif sig.foundMX &amp;&amp; sig.foundNS &amp;&amp; sig.foundSOA &amp;&amp; sig.foundTXTs { // reset signature state\nsig.foundMX = false\nsig.foundNS = false\nsig.foundSOA = false\nsig.foundTXTs = false\n}\n\nm, _ := sig.GetMetadata()\n\nsig.cb(detect.Finding{\nSigMetadata: m,\nEvent:       event,\nData:        map[string]interface{}{},\n})\n}\n\nreturn nil\n}\n\nfunc (sig *e2eDNS) OnSignal(s detect.Signal) error {\nreturn nil\n}\n\nfunc (sig *e2eDNS) Close() {}\n</code></pre>"},{"location":"docs/tracing/output-formats/","title":"Tracing Output Formats","text":"<p>In order to check latest output options you may execute:</p> <pre><code>$ sudo ./dist/tracee-ebpf --output help\n$ sudo ./dist/tracee-ebpf --output format:xxx\n</code></pre> <p>Tracee supports different output formats for detected events:</p> <ol> <li> <p>Table</p> <pre><code>$ sudo ./dist/tracee-ebpf --output table --trace comm=bash --trace follow --trace event=openat\nTIME             UID    COMM             PID     TID     RET              EVENT                ARGS\n11:21:51:254199  1000   exa              1639459 1639459 3                openat               dirfd: -100, pathname: /etc/ld.so.cache, flags: O_RDONLY|O_CLOEXEC, mode: 0\n11:21:51:254285  1000   exa              1639459 1639459 3                openat               dirfd: -100, pathname: /lib/x86_64-linux-gnu/libgcc_s.so.1, flags: O_RDONLY|O_CLOEXEC, mode: 0\n11:21:51:254418  1000   exa              1639459 1639459 3                openat               dirfd: -100, pathname: /lib/x86_64-linux-gnu/libm.so.6, flags: O_RDONLY|O_CLOEXEC, mode: 0\n\nEnd of events stream\nStats: {EventCount:6 EventsFiltered:0 NetEvCount:0 ErrorCount:0 LostEvCount:0 LostWrCount:0 LostNtCount:0}\n</code></pre> </li> <li> <p>Table (Verbose)</p> <pre><code>$ sudo ./dist/tracee-ebpf --output table-verbose --trace comm=bash --trace follow --trace event=openat\nTIME             UTS_NAME         CONTAINER_ID  MNT_NS       PID_NS       UID    COMM             PID     TID     PPID    RET              EVENT                ARGS\n11:22:16:970700  fujitsu                        4026531840   4026531836   1000   exa              1643836 1643836 3795408 3                openat               dirfd: -100, pathname: /etc/ld.so.cache, flags: 524288, mode: 0\n11:22:16:970783  fujitsu                        4026531840   4026531836   1000   exa              1643836 1643836 3795408 3                openat               dirfd: -100, pathname: /lib/x86_64-linux-gnu/libgcc_s.so.1, flags: 524288, mode: 0\n11:22:16:970913  fujitsu                        4026531840   4026531836   1000   exa              1643836 1643836 3795408 3                openat               dirfd: -100, pathname: /lib/x86_64-linux-gnu/libm.so.6, flags: 524288, mode: 0\n\nEnd of events stream\nStats: {EventCount:6 EventsFiltered:0 NetEvCount:0 ErrorCount:0 LostEvCount:0 LostWrCount:0 LostNtCount:0}\n</code></pre> </li> <li> <p>JSON</p> <pre><code>$ sudo ./dist/tracee-ebpf --output json --trace comm=bash --trace follow --trace event=openat\n</code></pre> <pre><code>{\"timestamp\":1657290245020855990,\"threadStartTime\":615325807626168,\"processorId\":22,\"processId\":1664936,\"cgroupId\":1,\"threadId\":1664936,\"parentProcessId\":3795408,\"hostProcessId\":1664936,\"hostThreadId\":1664936,\"hostParentProcessId\":3795408,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"exa\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"257\",\"eventName\":\"openat\",\"argsNum\":4,\"returnValue\":3,\"stackAddresses\":null,\"args\":[{\"name\":\"dirfd\",\"type\":\"int\",\"value\":-100},{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"/etc/ld.so.cache\"},{\"name\":\"flags\",\"type\":\"int\",\"value\":524288},{\"name\":\"mode\",\"type\":\"mode_t\",\"value\":0}]}\n{\"timestamp\":1657290245020940791,\"threadStartTime\":615325807626168,\"processorId\":22,\"processId\":1664936,\"cgroupId\":1,\"threadId\":1664936,\"parentProcessId\":3795408,\"hostProcessId\":1664936,\"hostThreadId\":1664936,\"hostParentProcessId\":3795408,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"exa\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"257\",\"eventName\":\"openat\",\"argsNum\":4,\"returnValue\":3,\"stackAddresses\":null,\"args\":[{\"name\":\"dirfd\",\"type\":\"int\",\"value\":-100},{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"/lib/x86_64-linux-gnu/libgcc_s.so.1\"},{\"name\":\"flags\",\"type\":\"int\",\"value\":524288},{\"name\":\"mode\",\"type\":\"mode_t\",\"value\":0}]}\n</code></pre> <p>Tip</p> <p>A good tip is to pipe tracee-ebpf json output to jq tool, this way you can select fields, rename them, filter values, and many other things:</p> <pre><code>sudo ./dist/tracee-ebpf -o format:json -o option:parse-arguments\n-trace comm=ping -capture net=lo | jq -c '. | {eventId, hostName\n,processName,hostProcessId,UserId}'\n</code></pre> </li> <li> <p>GOB</p> <pre><code>$ sudo ./dist/tracee-ebpf --output json --trace comm=bash --trace follow --trace event=openat\n</code></pre> <p>The output is binary (optimizes performance when piping tracee-ebpf events to tracee-rules, for signature patterns detections).</p> </li> <li> <p>GOTEMPLATE</p> <p>Check integrations page for more info.</p> </li> </ol>"},{"location":"docs/tracing/output-formats/#output-files","title":"Output Files","text":"<p>Tracee gives user the option to select which files they want to use as standard output and standard error:</p> <ol> <li> <p>Output file</p> <p>Tip</p> <p>User might use different output formats combined with output file option</p> <pre><code>$ sudo ./dist/tracee-ebpf --output json --trace comm=bash --trace follow --trace event=openat --output out-file:/tmp/tracee.log\n\n$ cat /tmp/tracee.log | jq -c\n</code></pre> <pre><code>{\"timestamp\":1657291487418386000,\"threadStartTime\":616568205378363,\"processorId\":11,\"processId\":1893369,\"cgroupId\":1,\"threadId\":1893369,\"parentProcessId\":3795408,\"hostProcessId\":1893369,\"hostThreadId\":1893369,\"hostParentProcessId\":3795408,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"exa\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"257\",\"eventName\":\"openat\",\"argsNum\":4,\"returnValue\":3,\"stackAddresses\":null,\"args\":[{\"name\":\"dirfd\",\"type\":\"int\",\"value\":-100},{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"/etc/ld.so.cache\"},{\"name\":\"flags\",\"type\":\"int\",\"value\":524288},{\"name\":\"mode\",\"type\":\"mode_t\",\"value\":0}]}\n{\"timestamp\":1657291487418510000,\"threadStartTime\":616568205378363,\"processorId\":11,\"processId\":1893369,\"cgroupId\":1,\"threadId\":1893369,\"parentProcessId\":3795408,\"hostProcessId\":1893369,\"hostThreadId\":1893369,\"hostParentProcessId\":3795408,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"exa\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"257\",\"eventName\":\"openat\",\"argsNum\":4,\"returnValue\":3,\"stackAddresses\":null,\"args\":[{\"name\":\"dirfd\",\"type\":\"int\",\"value\":-100},{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"/lib/x86_64-linux-gnu/libgcc_s.so.1\"},{\"name\":\"flags\",\"type\":\"int\",\"value\":524288},{\"name\":\"mode\",\"type\":\"mode_t\",\"value\":0}]}\n</code></pre> </li> <li> <p>Error file</p> <p>Redirect logs to a file if needed:</p> <pre><code>$ sudo TRACEE_BPF_FILE=do-not-exist ./dist/tracee-ebpf --output json --trace comm=bash --trace follow --trace event=openat --output out-file:/tmp/tracee.events --output log-file:/tmp/tracee.log\n</code></pre> </li> </ol>"},{"location":"docs/tracing/output-options/","title":"Tracing Output Options","text":"<p>In order to check latest output options you may execute:</p> <pre><code>$ sudo ./dist/tracee-ebpf --output help\n$ sudo ./dist/tracee-ebpf --output option:xxx\n</code></pre> <p>Tracee supports different output options for detected events:</p> <ol> <li> <p>option:stack-addresses </p> <p>Pick stack memory address from each event</p> <pre><code>$ sudo ./dist/tracee-ebpf --output json --trace comm=bash --trace follow --trace event=openat --output option:stack-addresses\n</code></pre> <pre><code>{\"timestamp\":1657291777566819000,\"threadStartTime\":616858353946737,\"processorId\":9,\"processId\":1948212,\"cgroupId\":1,\"threadId\":1948212,\"parentProcessId\":3795408,\"hostProcessId\":1948212,\"hostThreadId\":1948212,\"hostParentProcessId\":3795408,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"exa\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"257\",\"eventName\":\"openat\",\"argsNum\":4,\"returnValue\":3,\"stackAddresses\":[140395297729336,140395297614210],\"args\":[{\"name\":\"dirfd\",\"type\":\"int\",\"value\":-100},{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"/etc/ld.so.cache\"},{\"name\":\"flags\",\"type\":\"int\",\"value\":524288},{\"name\":\"mode\",\"type\":\"mode_t\",\"value\":0}]}\n</code></pre> </li> <li> <p>option:parse-arguments</p> <p>In order to have a better experience with the output provided by tracee-ebpf, you may opt to parse event arguments to a human *readable format.</p> <p><pre><code>$ sudo ./dist/tracee-ebpf --output json --trace comm=bash --trace follow --trace event=security_file_open --output option:parse-arguments\n</code></pre> <pre><code>{\"timestamp\":1657292314817581101,\"threadStartTime\":617395606682013,\"processorId\":9,\"processId\":2045288,\"cgroupId\":1,\"threadId\":2045288,\"parentProcessId\":3795408,\"hostProcessId\":2045288,\"hostThreadId\":2045288,\"hostParentProcessId\":3795408,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"bash\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"722\",\"eventName\":\"security_file_open\",\"argsNum\":7,\"returnValue\":0,\"stackAddresses\":null,\"args\":[{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"/usr/bin/exa\"},{\"name\":\"flags\",\"type\":\"string\",\"value\":\"O_RDONLY|O_LARGEFILE\"},{\"name\":\"dev\",\"type\":\"dev_t\",\"value\":271581185},{\"name\":\"inode\",\"type\":\"unsigned long\",\"value\":2493759},{\"name\":\"ctime\",\"type\":\"unsigned long\",\"value\":1653730234432691496},{\"name\":\"syscall_pathname\",\"type\":\"const char*\",\"value\":\"\"},{\"name\":\"syscall\",\"type\":\"int\",\"value\":\"execve\"}]}\n{\"timestamp\":1657292314817690279,\"threadStartTime\":617395606682013,\"processorId\":9,\"processId\":2045288,\"cgroupId\":1,\"threadId\":2045288,\"parentProcessId\":3795408,\"hostProcessId\":2045288,\"hostThreadId\":2045288,\"hostParentProcessId\":3795408,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"bash\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"722\",\"eventName\":\"security_file_open\",\"argsNum\":7,\"returnValue\":0,\"stackAddresses\":null,\"args\":[{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2\"},{\"name\":\"flags\",\"type\":\"string\",\"value\":\"O_RDONLY|O_LARGEFILE\"},{\"name\":\"dev\",\"type\":\"dev_t\",\"value\":271581185},{\"name\":\"inode\",\"type\":\"unsigned long\",\"value\":2752590},{\"name\":\"ctime\",\"type\":\"unsigned long\",\"value\":1653730015033811838},{\"name\":\"syscall_pathname\",\"type\":\"const char*\",\"value\":\"\"},{\"name\":\"syscall\",\"type\":\"int\",\"value\":\"execve\"}]}\n</code></pre></p> <p>As you can see now, the syscall that generated the event security_file_open was indeed execve:</p> <pre><code>{\"name\":\"syscall\",\"type\":\"int\",\"value\":\"execve\"}\n</code></pre> </li> <li> <p>option:parse-arguments-fds</p> <p>In order to have a better experience with the output provided by tracee-ebpf, you may opt to parse event fd arguments to be enriched with file paths. This option also enables <code>parse-arguments</code>.</p> <pre><code>$ sudo ./dist/tracee-ebpf --output json --trace comm=bash --trace follow --trace event=read --output option:parse-arguments-fds\n</code></pre> <pre><code>$ cat /etc/passwd\n</code></pre> <pre><code>{\"timestamp\":1658356809979365547,\"threadStartTime\":11570447751601,\"processorId\":1,\"processId\":239413,\"cgroupId\":10575,\"threadId\":239413,\"parentProcessId\":91515,\"hostProcessId\":239413,\"hostThreadId\":239413,\"hostParentProcessId\":91515,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"cat\",\"hostName\":\"ubuntu-impish\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"0\",\"eventName\":\"read\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":null,\"args\":[{\"name\":\"fd\",\"type\":\"int\",\"value\":\"3=/etc/locale.alias\"},{\"name\":\"buf\",\"type\":\"void*\",\"value\":93921853269152},{\"name\":\"count\",\"type\":\"size_t\",\"value\":4096}]}\n{\"timestamp\":1658356809979748006,\"threadStartTime\":11570447751601,\"processorId\":1,\"processId\":239413,\"cgroupId\":10575,\"threadId\":239413,\"parentProcessId\":91515,\"hostProcessId\":239413,\"hostThreadId\":239413,\"hostParentProcessId\":91515,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"cat\",\"hostName\":\"ubuntu-impish\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"0\",\"eventName\":\"read\",\"argsNum\":3,\"returnValue\":1867,\"stackAddresses\":null,\"args\":[{\"name\":\"fd\",\"type\":\"int\",\"value\":\"3=/etc/passwd\"},{\"name\":\"buf\",\"type\":\"void*\",\"value\":139658814046208},{\"name\":\"count\",\"type\":\"size_t\",\"value\":131072}]}\n</code></pre> <p>As you can see now, the value of fd is enriched with its file path following the <code>\"fd=filepath\"</code> format (string type in JSON).</p> <pre><code>{\"name\":\"fd\",\"type\":\"int\",\"value\":\"3=/etc/locale.alias\"}\n...\n{\"name\":\"fd\",\"type\":\"int\",\"value\":\"3=/etc/passwd\"}\n</code></pre> </li> <li> <p>option:exec-env</p> <p>Sometimes it is also important to know the execution environment variables whenever an event is detected, specially when deteting execve event.</p> <pre><code>$ sudo ./dist/tracee-ebpf --output json --trace comm=bash --trace follow --trace event=execve --output option:parse-arguments --output option:exec-env\n</code></pre> <pre><code>{\"timestamp\":1657294974430672155,\"threadStartTime\":620055219867435,\"processorId\":11,\"processId\":2531912,\"cgroupId\":1,\"threadId\":2531912,\"parentProcessId\":2490011,\"hostProcessId\":2531912,\"hostThreadId\":2531912,\"hostParentProcessId\":2490011,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"bash\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"59\",\"eventName\":\"execve\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":null,\"args\":[{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"/bin/ls\"},{\"name\":\"argv\",\"type\":\"const char*const*\",\"value\":[\"ls\"]},{\"name\":\"envp\",\"type\":\"const char*const*\",\"value\":[\"SHELL=/bin/bash\",\"COLORTERM=truecolor\",\"LESS=-RF --mouse\",\"HISTCONTROL=ignoreboth\",\"HISTSIZE=1000000\",\"DEBFULLNAME=Rafael David Tinoco\",\"EDITOR=nvim\",\"PWD=/home/rafaeldtinoco/work/ebpf/tracee\",\"LOGNAME=rafaeldtinoco\",\"DEB_BUILD_PROFILES=parallel=36 nocheck nostrip noudeb doc\",\"LINES=82\",\"HOME=/home/rafaeldtinoco\",\"LANG=C.UTF-8\",\"COLUMNS=106\",\"MANROFFOPT=-c\",\"DEBEMAIL=rafaeldtinoco@ubuntu.com\",\"LC_TERMINAL=iTerm2\",\"PROMPT_COMMAND=echo -ne \\\"\\\\033]0;$what\\\\007\\\"; history -a\",\"BAT_THEME=GitHub\",\"TERM=screen-256color\",\"USER=rafaeldtinoco\",\"GIT_PAGER=batcat --theme=\\\"GitHub\\\" -p --pager=less --tabs 0\",\"MANPAGER=bash -c 'col -bx | batcat --theme=\\\"GitHub\\\" -l man -p'\",\"LC_TERMINAL_VERSION=3.5.0beta5\",\"DEB_BUILD_OPTIONS=parallel=36 nocheck nostrip noudeb doc\",\"SHLVL=2\",\"PAGER=batcat --theme=\\\"GitHub\\\" -p --pager=less --tabs 0\",\"BAT_STYLE=plain\",\"PROMPT_DIRTRIM=2\",\"SYSTEMD_PAGER=batcat --theme=\\\"GitHub\\\" -p --pager=less --tabs 0\",\"LC_CTYPE=C.UTF-8\",\"LESS_HISTFILE=/dev/null\",\"PS1=\\\\u@\\\\h \\\\w $ \",\"PATH=/home/rafaeldtinoco/bin:/home/rafaeldtinoco/go/bin:.:/sbin:/bin:/usr/sbin:/usr/bin:/snap/bin:/snap/sbin:/usr/local/bin:/usr/local/sbin:/usr/games/\",\"HISTFILESIZE=1000000\",\"DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus\",\"SSH_TTY=/dev/pts/3\",\"OLDPWD=/home/rafaeldtinoco\",\"_=/bin/ls\"]}]}\n</code></pre> <p>As  you can see, from the execve event we can also see the process environment variables in place:</p> <pre><code>{\"name\":\"envp\",\"type\":\"const char*const*\",\"value\":[\"SHELL=/bin/bash\",\"COLORTERM=truecolor\",\"LESS=-RF --mouse\",\"HISTCONTROL=ignoreboth\",\"HISTSIZE=1000000\",\"DEBFULLNAME=Rafael David Tinoco\",\"EDITOR=nvim\",\"PWD=/home/rafaeldtinoco/work/ebpf/tracee\",\"LOGNAME=rafaeldtinoco\",\"DEB_BUILD_PROFILES=parallel=36 nocheck nostrip noudeb doc\",\"LINES=82\",\"HOME=/home/rafaeldtinoco\",\"LANG=C.UTF-8\",\"COLUMNS=106\",\"MANROFFOPT=-c\",\"DEBEMAIL=rafaeldtinoco@ubuntu.com\",\"LC_TERMINAL=iTerm2\",\"PROMPT_COMMAND=echo -ne \\\"\\\\033]0;$what\\\\007\\\"; history -a\",\"BAT_THEME=GitHub\",\"TERM=screen-256color\",\"USER=rafaeldtinoco\",\"GIT_PAGER=batcat --theme=\\\"GitHub\\\" -p --pager=less --tabs 0\",\"MANPAGER=bash -c 'col -bx | batcat --theme=\\\"GitHub\\\" -l man -p'\",\"LC_TERMINAL_VERSION=3.5.0beta5\",\"DEB_BUILD_OPTIONS=parallel=36 nocheck nostrip noudeb doc\",\"SHLVL=2\",\"PAGER=batcat --theme=\\\"GitHub\\\" -p --pager=less --tabs 0\",\"BAT_STYLE=plain\",\"PROMPT_DIRTRIM=2\",\"SYSTEMD_PAGER=batcat --theme=\\\"GitHub\\\" -p --pager=less --tabs 0\",\"LC_CTYPE=C.UTF-8\",\"LESS_HISTFILE=/dev/null\",\"PS1=\\\\u@\\\\h \\\\w $ \",\"PATH=/home/rafaeldtinoco/bin:/home/rafaeldtinoco/go/bin:.:/sbin:/bin:/usr/sbin:/usr/bin:/snap/bin:/snap/sbin:/usr/local/bin:/usr/local/sbin:/usr/games/\",\"HISTFILESIZE=1000000\",\"DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus\",\"SSH_TTY=/dev/pts/3\",\"OLDPWD=/home/rafaeldtinoco\",\"_=/bin/ls\"]}\n</code></pre> </li> <li> <p>option:exec-hash</p> <p>This is a special output option for sched_process_exec so user can get the file hash and process ctime (particularly interesting if you would like to compare executed binaries from a list of known hashes, for example).</p> <pre><code>$ sudo ./dist/tracee-ebpf --output json --trace comm=bash --trace follow --trace event=sched_process_exec --output option:parse-arguments --output option:exec-hash\n</code></pre> <pre><code>{\"timestamp\":1657295236470126167,\"threadStartTime\":620317257297855,\"processorId\":3,\"processId\":2578324,\"cgroupId\":1,\"threadId\":2578324,\"parentProcessId\":2578238,\"hostProcessId\":2578324,\"hostThreadId\":2578324,\"hostParentProcessId\":2578238,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"exa\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"707\",\"eventName\":\"sched_process_exec\",\"argsNum\":14,\"returnValue\":0,\"stackAddresses\":null,\"args\":[{\"name\":\"cmdpath\",\"type\":\"const char*\",\"value\":\"/bin/exa\"},{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"/usr/bin/exa\"},{\"name\":\"argv\",\"type\":\"const char**\",\"value\":[\"exa\",\"--color=auto\"]},{\"name\":\"dev\",\"type\":\"dev_t\",\"value\":271581185},{\"name\":\"inode\",\"type\":\"unsigned long\",\"value\":2493759},{\"name\":\"invoked_from_kernel\",\"type\":\"int\",\"value\":0},{\"name\":\"ctime\",\"type\":\"unsigned long\",\"value\":1653730234432691496},{\"name\":\"stdin_type\",\"type\":\"string\",\"value\":\"S_IFCHR\"},{\"name\":\"inode_mode\",\"type\":\"umode_t\",\"value\":33261},{\"name\":\"interp\",\"type\":\"const char*\",\"value\":\"/bin/exa\"},{\"name\":\"interpreter_pathname\",\"type\":\"const char*\",\"value\":\"/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2\"},{\"name\":\"interpreter_dev\",\"type\":\"dev_t\",\"value\":271581185},{\"name\":\"ineterpreter_inode\",\"type\":\"unsigned long\",\"value\":2752590},{\"name\":\"sha256\",\"type\":\"const char*\",\"value\":\"\"}]}\n</code></pre> <p>At the end of the event, you will also get information about the loader </p> </li> </ol>"},{"location":"getting-started/docker-quickstart/","title":"Getting started with tracee with Docker","text":"<p>This guide is focused on running tracee in a docker container on your local machine.</p> <p>Before you proceed, make sure you follow the [prerequiresites].</p> <ol> <li>Running tracee:v0.10.0</li> </ol> <pre><code>docker run \\\n     --name tracee --rm -it \\\n     --pid=host --cgroupns=host --privileged \\\n     -v /etc/os-release:/etc/os-release-host:ro \\\n     -e LIBBPFGO_OSRELEASE_FILE=/etc/os-release-host \\\n     aquasec/tracee:0.10.0\n</code></pre> <ol> <li>Running tracee:full</li> </ol> <pre><code>docker run \\\n     --name tracee --rm -it \\\n     --pid=host --cgroupns=host --privileged \\\n     -v /etc/os-release:/etc/os-release-host:ro \\\n     -e LIBBPFGO_OSRELEASE_FILE=/etc/os-release-host \\\n     -v /usr/src:/usr/src:ro \\\n     -v /lib/modules:/lib/modules:ro \\\n     -v /tmp/tracee:/tmp/tracee:rw \\\n     aquasec/tracee:full\n</code></pre> <p>Notes</p> <ol> <li> <p>The default (latest) image is lightweight and portable. It is    supposed to support different kernel versions without having to build    source code. If the host kernel does not support BTF then you may use    the full container image. The full container will compile an eBPF    object during startup, if you do not have one already cached in    <code>/tmp/tracee</code>.</p> </li> <li> <p>You may need to change the volume mounts for the kernel headers based on    your setup. See Linux Headers section for    more info.</p> </li> <li> <p>Tracee supports enriching events with additional data from running    containers. In order to enable this capability please look    here.</p> </li> </ol> <p>These docker commands run Tracee with default settings and start reporting detections to standard output. In order to simulate a suspicious behavior, you can simply run:</p> <pre><code>strace ls\n</code></pre> <p>in another terminal. This will trigger the Anti-Debugging signature, which is loaded by default, and you will get a warning:</p> <pre><code>INFO: probing tracee-ebpf capabilities...\nINFO: starting tracee-ebpf...\nINFO: starting tracee-rules...\nLoaded 14 signature(s): [TRC-1 TRC-13 TRC-2 TRC-14 TRC-3 TRC-11 TRC-9 TRC-4 TRC-5 TRC-12 TRC-8 TRC-6 TRC-10 TRC-7]\nServing metrics endpoint at :3366\nServing metrics endpoint at :4466\n\n*** Detection ***\nTime: 2022-03-25T08:04:22Z\nSignature ID: TRC-2\nSignature: Anti-Debugging\nData: map[]\nCommand: strace\nHostname: ubuntu-impish\n</code></pre>"},{"location":"getting-started/kubernetes-quickstart/","title":"Getting started with tracee in Kubernetes","text":"<p>This guide is focused on running tracee on Kubernetes. To demonstrate how to use Tracee we will use minikube, a distribution of kubernetes that can run on your local machine. Alternatively, you could use most other Kubernetes clusters such as microk8s or from a cloud provider.</p>"},{"location":"getting-started/kubernetes-quickstart/#prerequisites","title":"Prerequisites","text":"<p>minikube - see installation instructions and dependencies here.</p> <p>Note: Your local cluster has to be run on an intel processor. Apple silicon is not currently supported.</p> <p>Start minikube and ensure that it is running correctly:</p> <pre><code>minikube start\n</code></pre> <pre><code>kubectl get po -A\n\nNAMESPACE     NAME                               READY   STATUS    RESTARTS   AGE \nkube-system   coredns-565d847f94-kd9xx           1/1     Running   0          15s \nkube-system   etcd-minikube                      1/1     Running   0          26s \nkube-system   kube-apiserver-minikube            1/1     Running   0          26s \nkube-system   kube-controller-manager-minikube   1/1     Running   0          26s \nkube-system   kube-proxy-cvqjm                   1/1     Running   0          15s \nkube-system   kube-scheduler-minikube            1/1     Running   0          26s \nkube-system   storage-provisioner                1/1     Running   0          15s \n</code></pre>"},{"location":"getting-started/kubernetes-quickstart/#running-tracee-as-a-daemon-set","title":"Running tracee as a daemon set","text":"<p>Tracee uses eBPF for host-based detections, meaning it has visibility into all processes running on a given host, regardless of them being separated into different containers or pods. Therefore, we want to have tracee running on each node.</p> <p>Tracee can be installed through a Kubernetes DaemonSet. This tells Kubernetes to have a single tracee process on each node.</p> <p>You can find the full manifest on the tracee repository.</p> <p>We can install the DaemonSet directly from the Tracee repository through the following command:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/aquasecurity/tracee/v0.10.0/deploy/kubernetes/tracee/tracee.yaml\n</code></pre> <p>You can verify that the tracee daemon set is running via:</p> <pre><code>kubectl get nodes \nNAME       STATUS   ROLES           AGE   VERSION \nminikube   Ready    control-plane   17m   v1.25.2 \n\nkubectl get pods  \nNAME           READY   STATUS    RESTARTS   AGE \ntracee-fcjmp   1/1     Running   0          4m11s \n</code></pre> <p>You can see that we have a single pod running in our cluster, which has just a single node.  </p>"},{"location":"getting-started/kubernetes-quickstart/#tracee-in-action","title":"Tracee in action","text":"<p>At this point tracee is running with default behaviour. You can see this at the top of the pod\u2019s logs: </p> <pre><code>kubectl logs tracee-fcjmp \n\nINFO: probing tracee-ebpf capabilities... \nINFO: starting tracee-ebpf... \nINFO: starting tracee-rules... \nLoaded 15 signature(s): [TRC-1 TRC-13 TRC-2 TRC-14 TRC-3 TRC-11 TRC-9 TRC-4 TRC-5 TRC-12 TRC-6 TRC-10 TRC-7 TRC-16 TRC-15]\n</code></pre> <p>Note that the pod-name has been taken from the previous command.</p> <p>Each of the signatures listed above represent potentially malicious behaviors for tracee to detect and alert you on. You can see signature definitions here. Tracee comes with these default signatures but also allows for you to write custom ones as well. More information can be found here</p> <p>Let\u2019s trigger one of the default signatures to see tracee in action.</p> <p>We can start by launching a shell on the same node as tracee, and install <code>strace</code>, a debugging tool that should trigger the TRC-2 signature which detects use of PTRACE, and should not be running in your kubernetes cluster.</p> <pre><code>kubectl create deployment nginx --image=nginx  # creates a deployment\n\nkubectl exec -ti deployment/nginx -- bash  # get a bash into it\n\n$~ apt update &amp;&amp; apt install -y strace\n$~ strace ls\n...\n</code></pre> <p>Now to confirm that tracee caught this malicious behavior we can check the logs of the pod again:</p> <pre><code>kubectl logs tracee-fcjmp \u2013follow\n\n*** Detection ***\nTime: 2022-10-20T17:08:13Z\nSignature ID: TRC-2\nSignature: Anti-Debugging\nData: map[]\nCommand: strace\nHostname: tracee-fcjmp\n</code></pre>"},{"location":"getting-started/installing/docker/","title":"Docker","text":"<p>Tracee, as a runtime detection tool, is built and distributed as a docker container. Tracee, as an introspection tool, can either be used as a docker image, binary artifacts or OS packages.</p> <p>Check Getting Started for how to run tracee.</p>"},{"location":"getting-started/installing/getting/","title":"Getting Tracee","text":"<p>You're able to use tracee by any of these means:</p> <ol> <li>docker hub container image</li> <li>distributed binaries (<code>tracee.tar.gz</code>).</li> <li>building from the source</li> <li>building environment</li> <li>building container images</li> <li>building OS packages</li> </ol>"},{"location":"getting-started/installing/headers/","title":"Linux Headers","text":"<p>Note</p> <p>The default image is lightweight and portable. It is supposed to support different kernel versions without having to build source code. If the host kernel does not support BTF then you may use the full container image. The full container will compile an eBPF object during startup, if you do not have one already cached in /tmp/tracee.</p> <p>When running <code>tracee:full</code> container image, in order to compile the kernel version specific eBPF object, Tracee needs some Linux kernel headers. Depending on your Linux distribution, there may be different ways to obtain them.  </p> <ul> <li>Ubuntu/Debian/Arch/Manjaro: install <code>linux-headers</code> package.</li> <li>CentOS/Fedora: install <code>kernel-headers</code> and <code>kernel-devel</code> packages.</li> <li>macOS: follow the Building on OSX guidelines.</li> </ul> <p>Normally the files will be installed in <code>/lib/modules/${kernel_version}/build</code> which is where Tracee expects them. If you have the headers elsewhere, you can set the <code>KERN_HEADERS</code> environment variable with the correct location.</p> <p>Note</p> <p>It's important that the kernel headers match the exact version of the kernel you are running. To check the current kernel version, run the command <code>uname -r</code>. To install a specific kernel headers version append the version to the package name: <code>linux-headers-$(uname -r)</code>.</p> <p>Warning</p> <p>More often than not the kernel headers files contains filesystem links to other files in other directories. Therefore, when passing the kernel headers to Tracee docker container, make sure all the necessary directories are mounted. This is why the quickstart example mounts <code>/usr/src</code> in addition to <code>/lib/modules</code>.</p>"},{"location":"getting-started/installing/kubernetes/","title":"Install Tracee on Kubernetes","text":"<p>In the deploy/kubernetes directory you will find Yaml files to deploy Tracee in a Kubernetes environment. These files will deploy Tracee as a DaemonSet alongside a message routing application (Postee) that will help you consume the detections in your preferred way (e.g. Slack, E-mail, JIRA and more). </p> <p>Note</p> <p>Although not optimal, you may consume Tracee detections through daemonset/tracee logs with <code>kubectl logs -f daemonset/tracee -n tracee-system</code>.</p> <p>Tip</p> <p>The preferred way to deploy Tracee is through its Helm chart!</p> <ol> <li> <p>Install Tracee using Helm</p> <ol> <li> <p>Add Aqua chart repository:</p> <pre><code>$ helm repo add aqua https://aquasecurity.github.io/helm-charts/\n$ helm repo update\n</code></pre> <p>or clone the Helm chart:</p> <pre><code>$ git clone --depth 1 --branch v0.10.0 https://github.com/aquasecurity/tracee.git\n$ cd tracee\n</code></pre> </li> <li> <p>Install the chart from the Aqua chart repository:</p> <pre><code>$ helm install tracee aqua/tracee \\\n        --namespace tracee-system --create-namespace \\\n        --set hostPID=true\n</code></pre> <p>or install the Helm chart from a local directory:</p> <pre><code>$ helm repo add aqua https://aquasecurity.github.io/helm-charts/\n$ helm dependency update ./deploy/helm/tracee\n$ helm install tracee ./deploy/helm/tracee \\\n        --namespace tracee-system --create-namespace \\\n        --set hostPID=true\n</code></pre> </li> </ol> </li> <li> <p>Install Tracee Manually</p> <p>To install Tracee with Postee, simply run:</p> <pre><code>$ kubectl create namespace tracee-system\n$ kubectl create -n tracee-system \\\n    -f https://raw.githubusercontent.com/aquasecurity/postee/main/deploy/kubernetes/postee.yaml \\\n    -f https://raw.githubusercontent.com/aquasecurity/tracee/v0.10.0/deploy/kubernetes/tracee-postee/tracee.yaml\n</code></pre> </li> <li> <p>After Installation</p> <p>In order to choose how to make Postee deliver detection events from Tracee, you may edit the <code>postee-config</code> configMap. Follow this example.</p> <p>You can also use the Postee UI to configure integrations.</p> </li> </ol>"},{"location":"getting-started/installing/kubernetes/#platform-support","title":"Platform Support","text":"<p>This approach assumes that host nodes have either BTF available or kernel headers available under conventional location. See Tracee's prerequisites for more info. For the major Kubernetes platforms this should work out-of-the-box, including GKE, EKS, AKS, minikube.</p>"},{"location":"getting-started/installing/prerequisites/","title":"Prerequisites for running Tracee","text":"<p>A longterm supported kernel: 5.4, 5.10, 5.15, 5.18, 5.19. Check kernel.org for current supported kernels.</p> <p>Note</p> <p>Most distributions longterm supported kernels are supported as well, including CentOS8 4.18 kernel.</p> <ol> <li> <p>For tracee:v0.10.0 docker image, you should have one of the two:</p> <ol> <li>A kernel that has <code>/sys/kernel/btf/vmlinux</code> file available</li> <li>A kernel supported through BTFHUB <p>see libbpf CO-RE documentation for more info</p> </li> </ol> </li> <li> <p>For tracee:full docker image:</p> <ol> <li>kernel readers (most distros provide packages)</li> <li>clang (12 or 13)</li> <li>golang (1.18)</li> <li>libelf and libelf-dev (or elfutils-libelf and elfutils-libelf-devel)</li> <li>zlib1g and lib1g-dev (or zlib and zlib-devel)</li> </ol> </li> </ol>"},{"location":"getting-started/installing/prerequisites/#permissions","title":"Permissions","text":"<p>For using the eBPF Linux subsystem, Tracee needs to run with sufficient capabilities:</p> <ul> <li>Manage eBPF maps limits (<code>CAP_SYS_RESOURCE</code>)</li> <li>Load and Attach eBPF programs:<ol> <li><code>CAP_BPF</code>+<code>CAP_PERFMON</code> for recent kernels (&gt;=5.8) where the kernel perf paranoid value in <code>/proc/sys/kernel/perf_event_paranoid</code> is equal to 2 or less</li> <li>or <code>CAP_SYS_ADMIN</code> otherwise</li> </ol> </li> <li><code>CAP_SYS_PTRACE</code> (to collect information about processes upon startup)</li> <li><code>CAP_NET_ADMIN</code> (to use tc for packets capture)</li> <li><code>CAP_SETPCAP</code> (if given - used to reduce bounding set capabilities)</li> <li><code>CAP_SYSLOG</code> (to access kernel symbols through /proc/kallsyms)</li> <li>On some environments (e.g. Ubuntu) <code>CAP_IPC_LOCK</code> might be required as well.</li> <li>On cgroup v1 environments, <code>CAP_SYS_ADMIN</code> is recommended if running from a   container in order to allow tracee to mount the cpuset cgroup controller.</li> </ul> <p>Alternatively, run as <code>root</code> or with the <code>--privileged</code> flag of Docker.</p>"},{"location":"getting-started/installing/distros/fedora/","title":"Fedora Packages","text":"<p>Tracee does not provide Fedora packages out-of-the-box, but there is a quick way to build a Fedora package.</p>"},{"location":"getting-started/installing/distros/nix-nixos/","title":"Nix/NixOS (Community)","text":"<p>If installing tracee via nix please ensure you're running a kernel with libbpf CO-RE support, see Tracee's prerequisites for more info.</p> <p>Direct issues installing tracee via nix through the channels mentioned here (non-CO-RE not supported)</p> <p><code>nix-env --install -A nixpkgs.tracee</code></p> <p>Or through your configuration as usual</p> <p>NixOS:</p> <pre><code>  # your other config ...\n  environment.systemPackages = with pkgs; [\n    # your other packages ...\n    tracee\n  ];\n</code></pre> <p>home-manager:</p> <pre><code>  # your other config ...\n  home.packages = with pkgs; [\n    # your other packages ...\n    tracee\n  ];\n</code></pre>"},{"location":"getting-started/installing/distros/ubuntu/","title":"Ubuntu Packages","text":"<p>Tracee does not provide Ubuntu packages out-of-the-box, but there is a quick way to build an Ubuntu package.</p>"},{"location":"tutorials/deploy-grafana-dashboard/","title":"Deploy Grafana Dashboard","text":"<p>Grafana is a visualization tools for exported metrics and logs, most commomly used alongside prometheus.</p> <p>Since version 0.7.0, tracee exports useful runtime metrics to prometheus.</p> <p>These metrics exports are enabled by default in all docker images and can be enabled using the <code>--metrics</code> flag in both tracee-ebpf and tracee-rules.</p> <p>By using grafana and the new metrics from tracee, we can deploy a simple dashboard which tracks your tracee's instance performance and outputs.</p>"},{"location":"tutorials/deploy-grafana-dashboard/#prequisites","title":"Prequisites","text":"<p>The following tools must be available for use, they can all be installed either through docker or installed/built on your machine.</p> <ul> <li>Tracee</li> <li>Prometheus</li> <li>Grafana</li> </ul>"},{"location":"tutorials/deploy-grafana-dashboard/#run-tracee-with-metrics-enabled","title":"Run Tracee with Metrics Enabled","text":"<p>Tracee can be most easily deployed with metrics enabled by default and port forwarded through the following commands:</p> <pre><code>$ docker run \\\n    --name tracee --rm --pid=host \\\n    --cgroupns=host --privileged \\\n    -v /tmp/tracee:/tmp/tracee  \\\n    -v /etc/os-release:/etc/os-release-host:ro \\\n    -e LIBBPFGO_OSRELEASE_FILE=/etc/os-release-host \\\n    -it -p 3366:3366 -p 4466:4466 aquasec/tracee:v0.10.0\n</code></pre> <p>Of course, the forwarded metrics ports can be changed, but you should note that some of the later instructions depend on these ports.</p> <p>If running Tracee locally through built binaries, the metrics address may be overriden with the <code>--listen-addr</code> flag in both tracee-ebpf and tracee-rules.</p>"},{"location":"tutorials/deploy-grafana-dashboard/#run-prometheus-and-configure-it-to-scrape-tracee","title":"Run Prometheus and Configure it to Scrape Tracee","text":"<p>Install prometheus or pull it's docker image. Then create the following configuration file, call it <code>prometheus.yml</code> to scrape Tracee:</p> <pre><code># A scrape configuration containing exactly one endpoint to scrape:\n# Here it's Tracee.\nscrape_configs:\n  # The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.\n  - job_name: 'prometheus'\n\n    # Override the global default and scrape targets from this job every 5 seconds.\n    scrape_interval: 5s\n\n    #Scrape tracee-ebpf's and tracee-rules's default metrics hosts.\n    #If forwarding different ports make sure to change these addresses.\n    static_configs:\n      - targets: ['localhost:3366', 'localhost:4466']\n</code></pre> <p>We must then start prometheus with the following command:</p> <pre><code>prometheus --config.file=/path/to/prometheus.yml\n</code></pre> <p>Or alternatively with docker:</p> <pre><code>docker run -p 9090:9090 -v /path/to/config:/etc/prometheus prom/prometheus\n</code></pre> <p>Then, try to access prometheus through <code>http://localhost:9090</code>. If succesful, move to the next step, otherwise consult with prometheus documentation.</p>"},{"location":"tutorials/deploy-grafana-dashboard/#run-grafana-to-display-tracees-prometheus-metrics","title":"Run Grafana to display Tracee's Prometheus Metrics","text":"<p>After succesfuly deploying Tracee and Prometheus we may now run Grafana to visualize it's metrics.</p> <p>Install grafana using their instructions and enter the now available grafana website (by default it's usually through http://localhost:3000).</p> <p>After entering the website, logging in with username and password <code>admin</code> (and changing your password if you wish), you should see the homepage:</p> <p></p> <p>Add your data source by hovering the configuration tab (the gear icon), selecting \"Data Sources\" and pressing \"Add Data Source\" at the top left. Create a Prometheus Data Source and point it's URL to the relevant location (usually http://localhost:9090)</p> <p>You may now either create your own Dashboard or import our default dashboard.</p>"},{"location":"tutorials/deploy-grafana-dashboard/#import-tracees-default-dashboard","title":"Import Tracee's Default Dashboard","text":"<p>First download our Grafana Dashboard's json here.</p> <p>After adding the data source hover on the plus icon in the sidebar and select \"Import\". Press \"Upload JSON File\" at the top of the page and select the downloaded json from your file browser. Change the name and Dashboard UID if you wish and press \"Import\" to finish. </p> <p>Finally you will be redirected to the dashboard \ud83e\udd73</p>"},{"location":"tutorials/everything-is-an-event/","title":"Everything is an event","text":"<p>This guide will show an example of running the new Tracee experience we are experimenting with on Kubernetes. For more context on this change, please check the discussion on Github.</p>"},{"location":"tutorials/everything-is-an-event/#prerequisites","title":"Prerequisites","text":"<p>Helm - see installation instructions and dependencies here.</p> <p>minikube - see installation instructions and dependencies here.</p> <p>Note: Your local cluster must run on an Intel processor or ARM64. Apple silicon is not currently supported.</p> <p>Start minikube and ensure that it is running correctly:</p> <pre><code>minikube start\n</code></pre> <pre><code>kubectl get po -A\n\nNAMESPACE     NAME                               READY   STATUS    RESTARTS   AGE \nkube-system   coredns-565d847f94-kd9xx           1/1     Running   0          15s \nkube-system   etcd-minikube                      1/1     Running   0          26s \nkube-system   kube-apiserver-minikube            1/1     Running   0          26s \nkube-system   kube-controller-manager-minikube   1/1     Running   0          26s \nkube-system   kube-proxy-cvqjm                   1/1     Running   0          15s \nkube-system   kube-scheduler-minikube            1/1     Running   0          26s \nkube-system   storage-provisioner                1/1     Running   0          15s \n</code></pre>"},{"location":"tutorials/everything-is-an-event/#running-tracee-as-a-daemonset","title":"Running Tracee as a DaemonSet","text":"<p>Tracee is installed as a DaemonSet and the new experience we are trying is not enabled by default. To install it we can use Helm and pass a custom flag <code>everythingIsAnEvent</code>.</p> <p>First, add the Aqua Security Helm Repository to your Helm CLI: <pre><code>helm repo add aqua https://aquasecurity.github.io/helm-charts/\n\nhelm repo update\n</code></pre></p> <p>Next, we can install the Helm Chart, with the new experience enabled, through the following command:</p> <pre><code>helm install tracee aqua/tracee  --namespace tracee-system --create-namespace  --set everythingIsAnEvent=true\n</code></pre> <p>You can verify that the Tracee DaemonSet is running via:</p> <pre><code>kubectl get pods\nNAME           READY   STATUS    RESTARTS   AGE \ntracee-fcjmp   1/1     Running   0          4m11s\n</code></pre>"},{"location":"tutorials/everything-is-an-event/#tracee-in-action","title":"Tracee in action","text":"<p>At this point Tracee is running with new behavior. You can see this at the top of the pod\u2019s logs:</p> <pre><code>kubectl logs -f daemonset/tracee -n tracee-system\n</code></pre> <p>To test it we can trigger a rule, simulating a fileless attack. </p> <pre><code>kubectl run tracee-tester --image=aquasec/tracee-tester -- TRC-105\n</code></pre> <p>It will print the rule as an event.</p> <pre><code>kubectl -n tracee-system logs -f ds/tracee | grep fileless_execution \n\n{\"timestamp\":1671119128028881186,\"threadStartTime\":883410317491,\"processorId\":1,\"processId\":9,\"cgroupId\":8972,\"threadId\":9,\"parentProcessId\":8,\"hostProcessId\":6136,\"hostThreadId\":6136,\"hostParentProcessId\":6135,\"userId\":0,\"mountNamespace\":4026532816,\"pidNamespace\":4026532817,\"processName\":\"3\",\"hostName\":\"tracee-tester\",\"containerId\":\"c7e3c75bf167348bf79262bf6e688088f9b4d54ebcc79464f40b52b80c73ff55\",\"containerImage\":\"docker.io/aquasec/tracee:latest\",\"containerName\":\"tracee\",\"podName\":\"tracee-wk8wh\",\"podNamespace\":\"tracee-system\",\"podUID\":\"5cb83966-e274-48f1-89fb-25bd748d2773\",\"eventId\":\"6023\",\"eventName\":\"fileless_execution\",\"argsNum\":15,\"returnValue\":0,\"stackAddresses\":null,\"contextFlags\":{\"containerStarted\":true},\"args\":[{\"name\":\"cmdpath\",\"type\":\"const char*\",\"value\":\"/dev/fd/3\"},{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"memfd:\"},{\"name\":\"dev\",\"type\":\"dev_t\",\"value\":1},{\"name\":\"inode\",\"type\":\"unsigned long\",\"value\":1033},{\"name\":\"ctime\",\"type\":\"unsigned long\",\"value\":1671119128024105994},{\"name\":\"inode_mode\",\"type\":\"umode_t\",\"value\":33279},{\"name\":\"interpreter_pathname\",\"type\":\"const char*\",\"value\":\"/lib/x86_64-linux-gnu/ld-2.28.so\"},{\"name\":\"interpreter_dev\",\"type\":\"dev_t\",\"value\":234},{\"name\":\"interpreter_inode\",\"type\":\"unsigned long\",\"value\":1704546},{\"name\":\"interpreter_ctime\",\"type\":\"unsigned long\",\"value\":1671118551446622730},{\"name\":\"argv\",\"type\":\"const char**\",\"value\":[\"\"]},{\"name\":\"interp\",\"type\":\"const char*\",\"value\":\"/dev/fd/3\"},{\"name\":\"stdin_type\",\"type\":\"string\",\"value\":\"S_IFCHR\"},{\"name\":\"stdin_path\",\"type\":\"char*\",\"value\":\"/dev/null\"},{\"name\":\"invoked_from_kernel\",\"type\":\"int\",\"value\":0}]}\n</code></pre> <p>Part of our goal with the new experience is to allow users to have the rules provide by tracee, but also be able to collect events from the kernel they might be interested. Let's change the default events tracee was installed with, by editing the tracee DamemonSet running on the cluster.</p> <pre><code>kubectl edit ds/tracee -n tracee-system\n</code></pre> <p>We can go to the line below, which shows all events (rules) Tracee has loaded, and add to it the <code>execve</code> syscall events.</p> <p>From:</p> <pre><code>- event=anti_debugging,aslr_inspection,cgroup_notify_on_release,cgroup_release_agent,core_pattern_modification,default_loader_mod,disk_mount,docker_abuse,dynamic_code_loading,fileless_execution,hidden_file_created,illegitimate_shell,k8s_api_connection,k8s_cert_theft,kernel_module_loading,ld_preload,process_vm_write_inject,proc_fops_hooking,proc_kcore_read,proc_mem_access,proc_mem_code_injection,ptrace_code_injection,rcd_modification,sched_debug_recon,scheduled_task_mod,stdio_over_socket,sudoers_modification,syscall_hooking,system_request_key_mod\n</code></pre> <p>To (we added <code>execve</code> to the end of the list):</p> <pre><code>- event=anti_debugging,aslr_inspection,cgroup_notify_on_release,cgroup_release_agent,core_pattern_modification,default_loader_mod,disk_mount,docker_abuse,dynamic_code_loading,fileless_execution,hidden_file_created,illegitimate_shell,k8s_api_connection,k8s_cert_theft,kernel_module_loading,ld_preload,process_vm_write_inject,proc_fops_hooking,proc_kcore_read,proc_mem_access,proc_mem_code_injection,ptrace_code_injection,rcd_modification,sched_debug_recon,scheduled_task_mod,stdio_over_socket,sudoers_modification,syscall_hooking,system_request_key_mod,execve\n</code></pre> <p>Let's restart Tracee to run it with the new configuration.</p> <pre><code>kubectl rollout restart ds/tracee -n tracee-system\n</code></pre> <p>Now if you check the logs you will see the <code>execve</code> events that are happening on your cluster.</p> <pre><code>kubectl  logs -f ds/tracee -n tracee-system | grep execve\n\n{\"timestamp\":1671119209363959531,\"threadStartTime\":964819225255,\"processorId\":1,\"processId\":6664,\"cgroupId\":4950,\"threadId\":6664,\"parentProcessId\":1428,\"hostProcessId\":6664,\"hostThreadId\":6664,\"hostParentProcessId\":1362,\"userId\":0,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"kubelet\",\"hostName\":\"pool-hst1l5k80-\",\"containerId\":\"a54718a9bd3bd16ddcbebd1c1f058c8f9538a2526d25a048263b0c6e30776041\",\"containerImage\":\"docker.io/aquasec/tracee:latest\",\"containerName\":\"tracee\",\"podName\":\"tracee-hr52p\",\"podNamespace\":\"tracee-system\",\"podUID\":\"82b23cd8-f81b-403d-92fb-85af412e5f73\",\"eventId\":\"59\",\"eventName\":\"execve\",\"argsNum\":2,\"returnValue\":0,\"stackAddresses\":null,\"contextFlags\":{\"containerStarted\":true},\"args\":[{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"/usr/bin/umount\"},{\"name\":\"argv\",\"type\":\"const char*const*\",\"value\":[\"umount\",\"/var/lib/kubelet/pods/b0067d27-41c6-46eb-bb53-c1e0c75af9b8/volumes/kubernetes.io~projected/kube-api-access-mgc48\"]}]}\n</code></pre> <p>Tracee supports lots of events, you can see a list by running:</p> <pre><code>kubectl  exec ds/tracee -n tracee-system -- /tracee/tracee --list\n</code></pre> <p>Try them out and let us know what you think on the Github discussion or Slack.</p>"},{"location":"tutorials/setup-development-machine-with-vagrant/","title":"Setup Development Machine with Vagrant","text":"<p>HashiCorp Vagrant leverages a declarative configuration file, which describes all software requirements, packages, operating system configuration, and users to provide the same development environment for everyone.</p> <p>The Vagrantfile describes the type of machine required to build Tracee from source and follow the Getting Started guides. This allows developers involved in the project to check out the code, run <code>vagrant up</code>, and be on their way.</p>"},{"location":"tutorials/setup-development-machine-with-vagrant/#prerequisites","title":"Prerequisites","text":"<ul> <li>Vagrant</li> <li>Hypervisor supported by Vagrant, such as VirtualBox.</li> </ul>"},{"location":"tutorials/setup-development-machine-with-vagrant/#create-development-machine","title":"Create Development Machine","text":"<p>Clone and change directory to Tracee Git repository:</p> <pre><code>git clone --branch v0.10.0 https://github.com/aquasecurity/tracee.git\ncd tracee\n</code></pre> <p>Create and configure development machine according to the <code>Vagrantfile</code>:</p> <pre><code>vagrant up\n</code></pre> <p>If everything goes well, you can SSH into a running development machine and access its shell:</p> <pre><code>$ vagrant ssh\nWelcome to Ubuntu 21.10 (GNU/Linux 5.13.0-35-generic x86_64)\n\n * Documentation:  https://help.ubuntu.com\n * Management:     https://landscape.canonical.com\n * Support:        https://ubuntu.com/advantage\n\n  System information as of Sat Mar 26 18:08:08 UTC 2022\n\n  System load:  0.94               Processes:                153\n  Usage of /:   14.7% of 38.71GB   Users logged in:          1\n  Memory usage: 59%                IPv4 address for docker0: 172.17.0.1\n  Swap usage:   0%                 IPv4 address for enp0s3:  10.0.2.15\n\n\n9 updates can be applied immediately.\n9 of these updates are standard security updates.\nTo see these additional updates run: apt list --upgradable\n\n\nLast login: Sat Mar 26 17:14:16 2022 from 10.0.2.2\nvagrant@ubuntu-impish:~$\n</code></pre> <p>Tip</p> <p>Provisioning from scratch take time, but once created you can reuse the machine with <code>vagrant halt</code> and <code>vagrant up</code> commands. If something goes wrong with your machine, there's also the <code>vagrant destroy</code> to destroy it and start over again.</p> <p>Synced folders enable Vagrant to sync a folder on the host machine to the development machine, allowing you to continue working on your project's files on your host machine, but use the resources in the development machine to compile or run Tracee.</p> <p>By default, Vagrant will share Tracee project directory (the directory with the <code>Vagrantfile</code>) to <code>/vagrant</code>. To get started, change directory to <code>/vagrant</code> and list files:</p> <pre><code>$ ls -l\ntotal 204\ndrwxr-xr-x 1 vagrant vagrant    224 Mar 17 14:31 3rdparty\n-rw-r--r-- 1 vagrant vagrant   3474 Mar 17 14:31 CONTRIBUTING.md\n-rw-r--r-- 1 vagrant vagrant  11358 Mar 17 14:31 LICENSE\n-rw-r--r-- 1 vagrant vagrant  16529 Mar 25 07:46 Makefile\n-rw-r--r-- 1 vagrant vagrant    133 Mar 17 14:31 NOTICE\n-rw-r--r-- 1 vagrant vagrant   2116 Mar 26 16:41 RELEASING.md\n-rw-r--r-- 1 vagrant vagrant   4097 Mar 17 14:31 Readme.md\n-rw-r--r-- 1 vagrant vagrant   2732 Mar 26 16:41 Vagrantfile\ndrwxr-xr-x 1 vagrant vagrant    384 Mar 26 16:41 builder\ndrwxr-xr-x 1 vagrant vagrant    128 Dec 14 15:27 cmd\ndrwxr-xr-x 1 vagrant vagrant     96 Dec  8 14:20 deploy\ndrwxr-xr-x 1 vagrant vagrant    288 Mar 25 10:51 dist\ndrwxr-xr-x 1 vagrant vagrant    448 Mar 26 16:44 docs\n-rw-r--r-- 1 vagrant vagrant    164 Mar 17 14:31 embedded-ebpf.go\n-rw-r--r-- 1 vagrant vagrant    101 Mar 17 14:31 embedded.go\n-rw-r--r-- 1 vagrant vagrant   4382 Mar 24 14:13 go.mod\n-rw-r--r-- 1 vagrant vagrant 129439 Mar 24 14:13 go.sum\n-rw-r--r-- 1 vagrant vagrant   1546 Mar 26 18:20 mkdocs.yml\ndrwxr-xr-x 1 vagrant vagrant    256 Mar 22 14:08 packaging\ndrwxr-xr-x 1 vagrant vagrant    416 Mar 24 14:13 pkg\ndrwxr-xr-x 1 vagrant vagrant    192 Dec 14 13:02 signatures\ndrwxr-xr-x 1 vagrant vagrant    160 Mar 24 14:13 tests\ndrwxr-xr-x 1 vagrant vagrant    224 Mar 24 11:59 types\n</code></pre> <p>As you can see the <code>/vagrant</code> directory contains source code of Tracee cloned from GitHub.</p>"},{"location":"tutorials/setup-development-machine-with-vagrant/#build-and-run-tracee-ebpf-and-tracee-rules","title":"Build and Run Tracee-eBPF and Tracee-Rules","text":"<p>To build tracee-ebpf and tracee-rules executable binaries, run the default make target:</p> <pre><code>make\n</code></pre> <p>Build targets are saved in the <code>/vagrant/dist</code> directory:</p> <pre><code>$ ls -l dist/\ntotal 47972\ndrwxr-xr-x 1 vagrant vagrant       96 Mar 25 10:45 btfhub\ndrwxr-xr-x 1 vagrant vagrant      224 Mar 25 10:45 libbpf\ndrwxr-xr-x 1 vagrant vagrant      512 Mar 25 10:46 rules\n-rwxr-xr-x 1 vagrant vagrant 17876784 Mar 26 18:32 tracee-ebpf\n-rwxr-xr-x 1 vagrant vagrant 26982352 Mar 25 10:45 tracee-rules\ndrwxr-xr-x 1 vagrant vagrant      544 Mar 26 18:31 tracee.bpf\n-rw-r--r-- 1 vagrant vagrant  4232032 Mar 26 18:31 tracee.bpf.core.o\n</code></pre> <p>You can now run Tracee-eBPF and see raw events printed to the standard output in a tabular format:</p> <pre><code>$ sudo ./dist/tracee-ebpf\nTIME             UID    COMM             PID     TID     RET              EVENT                ARGS\n18:39:43:781824  0      mkdocs           1       19      0                stat                 pathname: /docs/docs, statbuf: 0x7f851365eb20\n18:39:43:782125  0      mkdocs           1       19      0                security_file_open   pathname: /docs/docs, flags: O_RDONLY|O_LARGEFILE|O_DIRECTORY, dev: 43, inode: 47, ctime: 1648313072000000000\n18:39:43:782008  0      mkdocs           1       19      6                open                 pathname: /docs/docs, flags: O_RDONLY|O_LARGEFILE|O_DIRECTORY|O_CLOEXEC, mode: 0\n18:39:43:783200  0      mkdocs           1       19      464              getdents64           fd: 6, dirp: 0x7f8513d8e0b8, count: 2048\n18:39:43:783232  0      mkdocs           1       19      0                getdents64           fd: 6, dirp: 0x7f8513d8e0b8, count: 2048\n18:39:43:783259  0      mkdocs           1       19      0                close                fd: 6\n18:39:43:783271  0      mkdocs           1       19      0                stat                 pathname: /docs/docs/architecture.md, statbuf: 0x7f851365e9b0\n18:39:43:783734  0      mkdocs           1       19      0                stat                 pathname: /docs/docs/install, statbuf: 0x7f851365e9b0\n18:39:43:784163  0      mkdocs           1       19      0                stat                 pathname: /docs/docs/images, statbuf: 0x7f851365e9b0\n18:39:43:784589  0      mkdocs           1       19      0                stat                 pathname: /docs/docs/integrations.md, statbuf: 0x7f851365e9b0\n18:39:43:784906  0      mkdocs           1       19      0                stat                 pathname: /docs/docs/faq.md, statbuf: 0x7f851365e9b0\n</code></pre> <p>To analyze collected events and see detections printed to the standard output, run tracee-ebpf and pipe it with tracee-rules:</p> <pre><code>$ sudo ./dist/tracee-ebpf \\\n--output=format:gob \\\n--output=option:parse-arguments \\\n| ./dist/tracee-rules \\\n--input-tracee=file:stdin \\\n--input-tracee=format:gob\nLoaded 14 signature(s): [TRC-1 TRC-13 TRC-2 TRC-14 TRC-3 TRC-11 TRC-9 TRC-4 TRC-5 TRC-12 TRC-8 TRC-6 TRC-10 TRC-7]\n\n*** Detection ***\nTime: 2022-03-26T18:48:00Z\nSignature ID: TRC-2\nSignature: Anti-Debugging\nData: map[]\nCommand: strace\nHostname: ubuntu-impish\n</code></pre> <p>In this example, we run <code>strace ls</code> to trigger Anit-Debugging signature detection.</p>"},{"location":"tutorials/setup-development-machine-with-vagrant/#switch-between-co-re-and-non-co-re-linux-distribution","title":"Switch Between CO-RE and non CO-RE Linux Distribution","text":"<p>By default, the development machine is running Ubuntu Linux 21.10 Impish Indri. You can see that it has a BTF-enabled kernel by checking the existence of the <code>/sys/kernel/btf/vmlinux</code> file.</p> <pre><code>Vagrant.configure(\"2\") do |config|\n# config.vm.box = \"ubuntu/focal64\"     # Ubuntu 20.04 Focal Fossa (non CO-RE)\n# config.vm.box = \"ubuntu/hirsute64\"   # Ubuntu 21.04 Hirsute Hippo (CO-RE)\nconfig.vm.box = \"ubuntu/impish64\"      # Ubuntu 21.10 Impish Indri (CO-RE)\nend\n</code></pre> <p>Sometimes you may want to test Tracee with a non CO-RE distribution. You can do that by editing the Vagrantfile and modifying the <code>config.vm.box</code> property. For example, you can switch to Ubuntu Linux 20.04 Focal Fossa as follows:</p> <pre><code>Vagrant.configure(\"2\") do |config|\nconfig.vm.box = \"ubuntu/focal64\"       # Ubuntu 20.04 Focal Fossa (non CO-RE)\n# config.vm.box = \"ubuntu/hirsute64\"   # Ubuntu 21.04 Hirsute Hippo (CO-RE)\n# config.vm.box = \"ubuntu/impish64\"    # Ubuntu 21.10 Impish Indri (CO-RE)\nend\n</code></pre> <p>This change requires reprovisioning the development machine:</p> <pre><code>vagrant destroy\nvagrant up\n</code></pre> <p>Attention</p> <p>Ubuntu Focal distribution has introduced BTF information to their recent kernels, allowing eBPF CO-RE capable code to run. If you're willing to test non CO-RE kernels, make sure to use an older kernel that does not provide the <code>/sys/kernel/btf/vmlinux</code> file.</p>"},{"location":"tutorials/setup-development-machine-with-vagrant/#deploy-tracee-with-postee-on-kubernetes","title":"Deploy Tracee with Postee on Kubernetes","text":"<p>The development machine described by Vagrantfile preinstalls MicroK8s Kubernetes cluster, which is suitable for testing Tracee.</p> <pre><code>$ microk8s status\nmicrok8s is running\nhigh-availability: no\n  datastore master nodes: 127.0.0.1:19001\n  datastore standby nodes: none\n</code></pre> <p>There's also the kubectl command installed and configured to communicate with the cluster:</p> <pre><code>$ kubectl get nodes -o wide\nNAME            STATUS   ROLES    AGE    VERSION                    INTERNAL-IP   EXTERNAL-IP   OS-IMAGE       KERNEL-VERSION      CONTAINER-RUNTIME\nubuntu-impish   Ready    &lt;none&gt;   139m   v1.23.4-2+98fc2022f3ad3e   10.0.2.15     &lt;none&gt;        Ubuntu 21.10   5.13.0-35-generic   containerd://1.5.9\n</code></pre> <p>Create a new namespace called <code>tracee-system</code>:</p> <pre><code>kubectl create ns tracee-system\n</code></pre> <p>Create Postee Persistent Volumes and StatefulSet in the <code>tracee-system</code> namespace:</p> <pre><code>kubectl apply -n tracee-system \\\n  -f https://raw.githubusercontent.com/aquasecurity/postee/v2.2.0/deploy/kubernetes/hostPath/postee-pv.yaml \\\n  -f https://raw.githubusercontent.com/aquasecurity/postee/v2.2.0/deploy/kubernetes/postee.yaml\n</code></pre> <p>Create Tracee DaemonSet in the <code>tracee-system</code>, which is preconfigured to print detections to the standard output and send them over to Postee webhook on http://postee-svc:8082:</p> <pre><code>kubectl apply -n tracee-system -f deploy/kubernetes/tracee-postee/tracee.yaml\n</code></pre> <p>Tip</p> <p>To test code that hasn't been released yet do the following:</p> <ol> <li>Build the <code>tracee:latest</code> container image from the current Git revision:    <pre><code>make -f builder/Makefile.tracee-container build-tracee\n</code></pre></li> <li>Import the container image to MicroK8s registry:    <pre><code>docker image save -o /tmp/tracee-latest.tar tracee:latest\nmicrok8s ctr images import /tmp/tracee-latest.tar\nrm /tmp/tracee-latest.tar\n</code></pre></li> <li>Create Tracee DaemonSet using <code>tracee:latest</code> as container image:    <pre><code>kubectl apply -n tracee-system -k deploy/kubernetes/tracee-postee\n</code></pre></li> </ol> <p>While Tracee pod is running, run <code>strace ls</code> command and observe detection printed to the standard output.</p> <pre><code>$ kubectl logs n tracee-system -f daemonset/tracee\nINFO: probing tracee-ebpf capabilities...\nINFO: starting tracee-ebpf...\nINFO: starting tracee-rules...\nLoaded 14 signature(s): [TRC-1 TRC-13 TRC-2 TRC-14 TRC-3 TRC-11 TRC-9 TRC-4 TRC-5 TRC-12 TRC-8 TRC-6 TRC-10 TRC-7]\nServing metrics endpoint at :3366\n\n*** Detection ***\nTime: 2022-03-29T08:26:32Z\nSignature ID: TRC-2\nSignature: Anti-Debugging\nData: map[]\nCommand: strace\nHostname: ubuntu-impish\n</code></pre> <p>If everything is configured properly, you can find the same detection in Postee logs:</p> <pre><code>$ kubectl -n tracee-system logs -f postee-0\n2022/03/29 08:26:32 {\"Data\":null,\"Context\":{\"timestamp\":1648542392170684298,\"processorId\":1,\"processId\":90731,\"threadId\"\n:90731,\"parentProcessId\":90729,\"hostProcessId\":90731,\"hostThreadId\":90731,\"hostParentProcessId\":90729,\"userId\":1000,\"mou\nntNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"strace\",\"hostName\":\"ubuntu-impish\",\"containerId\":\"\",\"ev\nentId\":\"101\",\"eventName\":\"ptrace\",\"argsNum\":4,\"returnValue\":0,\"stackAddresses\":null,\"args\":[{\"name\":\"request\",\"type\":\"st\nring\",\"value\":\"PTRACE_TRACEME\"},{\"name\":\"pid\",\"type\":\"pid_t\",\"value\":0},{\"name\":\"addr\",\"type\":\"void*\",\"value\":\"0x0\"},{\"n\name\":\"data\",\"type\":\"void*\",\"value\":\"0x0\"}]},\"SigMetadata\":{\"ID\":\"TRC-2\",\"Version\":\"0.1.0\",\"Name\":\"Anti-Debugging\",\"Descr\niption\":\"Process uses anti-debugging technique to block debugger\",\"Tags\":[\"linux\",\"container\"],\"Properties\":{\"MITRE ATT\\\nu0026CK\":\"Defense Evasion: Execution Guardrails\",\"Severity\":3}}}\n</code></pre> <p>As an alternative to static deployment descriptors you can install Tracee and Postee with Helm:</p> <pre><code>helm repo add aqua https://aquasecurity.github.io/helm-charts\nhelm dependency update ./deploy/helm/tracee\nhelm install tracee ./deploy/helm/tracee \\\n  --namespace tracee-system --create-namespace \\\n  --set hostPID=true \\\n  --set postee.enabled=true\n</code></pre>"},{"location":"tutorials/setup-development-machine-with-vagrant/#access-kubernetes-dashboard","title":"Access Kubernetes Dashboard","text":"<p>Use the following command to get the token required to log in to the Kubernetes Dashboard:</p> <pre><code>kubectl -n kube-system describe secret \\\n  $(kubectl -n kube-system get secret | grep default-token | cut -d \" \" -f1)\n</code></pre> <p>Forward port 10443 in the development machine to the Kubernetes Dashboard's pod:</p> <pre><code>kubectl port-forward --address 0.0.0.0 -n kube-system service/kubernetes-dashboard 10443:443\n</code></pre> <p>Since port 10443 is forwarded to port 10443 on your host, you can open your browser to https://localhost:10443 and access Kubernetes Dashboard.</p> <p>Warning</p> <p>Modern browser usually block insecure localhost TLS connections. For Google Chrome you may allow insecure TLS connections at chrome://flags/#allow-insecure-localhost.</p>"},{"location":"tutorials/setup-development-machine-with-vagrant/#preview-tracee-documentation","title":"Preview Tracee Documentation","text":"<p>You can run MkDocs server and preview documentation on your host:</p> <pre><code>make -f builder/Makefile.mkdocs\n</code></pre> <p>The development machine is running the MkDocs server listening on port 8000, which is forwarded to port 8000 on your host. Therefore, you can open your browser to http://localhost:8000 and access documentation pages.</p>"}]}