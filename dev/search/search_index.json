{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Overview","text":"<p>Before moving on, please consider giving us a star \u2b50\ufe0f by clicking the button at the top of the GitHub page</p>"},{"location":"#tracee-documentation","title":"Tracee Documentation","text":"<p>\ud83d\udc4b Welcome to Tracee Documentation! To help you get around, please notice the different sections at the top global menu:</p> <ul> <li>You are currently in the Getting Started section where you can find general information and help with first steps.</li> <li>In the Tutorials section you can find step-by-step guides that help you accomplish specific tasks.</li> <li>In the Docs section you can find the complete reference documentation for all of the different features and settings that Tracee has to offer.</li> <li>In the Contributing section you can find technical developer documentation and contribution guidelines.</li> </ul>"},{"location":"#tracee-runtime-security-and-forensics-using-ebpf","title":"Tracee: Runtime Security and Forensics using eBPF","text":"<p>Tracee uses eBPF technology to tap into your system and give you access to hundreds of events that help you understand how your system behaves. In addition to basic observability events about system activity, Tracee adds a collection of sophisticated security events that expose more advanced behavioral patterns. You can also easily add your own events using the popular Rego language. Tracee provides a rich filtering mechanism that allows you to eliminate noise and focus on specific workloads that matter most to you.</p>"},{"location":"#quickstart","title":"Quickstart","text":"<p>You can easily start experimenting with Tracee using the Docker image as follows:</p> <pre><code>docker run \\\n  --name tracee --rm -it \\\n  --pid=host --cgroupns=host --privileged \\\n  -v /etc/os-release:/etc/os-release-host:ro \\\n  aquasec/tracee:latest\n</code></pre> <p>To learn how to install Tracee in a production environment, check out the Kubernetes guide.</p> <p>Tracee is an Aqua Security open source project. Learn about our open source work and portfolio Here. Join the community, and talk to us about any matter in GitHub Discussion or Slack.  </p>"},{"location":"contributing/architecture/","title":"Architecture","text":""},{"location":"contributing/architecture/#tracee-architecture-overview","title":"Tracee Architecture Overview","text":"<p>Overview</p> <ol> <li> <p>Kernel eBPF programs GENERATE Tracee Events to Userland:</p> <ol> <li>Tracepoints</li> <li>Probes</li> <li>Traffic Control Hooks</li> </ol> </li> <li> <p>Userland events are COLLECTED and ENRICHED with more information:</p> <ol> <li>Kernel Events (Syscalls, Tracepoints, Kprobes)</li> <li>OS Events (Running Containers, ...)</li> <li>Derived (from other) Events</li> <li>Network Events</li> </ol> </li> <li> <p>DETECT patterns based on existing signatures:</p> <ol> <li>OPA/Rego signatures</li> <li>Golang signatures</li> </ol> </li> <li> <p>Let other tools to CONSUME detection events:</p> <ol> <li>Filters</li> </ol> </li> <li> <p>ENFORCE</p> <ol> <li>Work in Progress</li> </ol> </li> </ol>"},{"location":"contributing/architecture/#tracee-pipeline-concept","title":"Tracee Pipeline Concept","text":"<p>Pipeline</p> <ol> <li> <p>Multiple CPUs constantly generate events from the eBPF programs running    inside the kernel (inside an eBPF VM).</p> </li> <li> <p>The eBPF programs are executed whenever the kernel (or network) hooks    they're attached to are triggered.</p> </li> <li> <p>eBPF programs decide whether they should submit the events to    tracee or not, based on given filters.</p> </li> <li> <p>Those events are sent to libbpfgo through a [shared memory ring buffer]    mechanism (called perfbuffer).</p> </li> <li> <p>libbpfgo sends collected events to tracee through golang    channels.</p> </li> <li> <p>tracee parses received events and does multiple things:</p> <ol> <li>parse events for argument type conversions if requested</li> <li>enriches the events that need enrichment (containers, network, processes)</li> <li>capture artifacts from collected events into external files</li> </ol> </li> <li> <p>tracee writes events to tracee-rules through a mechanism    called printer.</p> </li> <li> <p>tracee-rules receives events and evaluate them using either golang    or rego signatures.</p> <ol> <li>Golang signatures are faster and do pretty much anything the language    allows. They might connect (or have cached) external data sources to    evaluate events, for example.</li> </ol> </li> <li> <p>Detections are spit out from tracee-rules if evaluations are    positive.</p> </li> </ol> <p>This mechanism is what we call the tracee pipeline: to receive events from the kernel into userland (tracee), then to parse and enrich those events and to submit them to tracee-rules for it to evaluate them looking for detection patterns described as signatures.</p>"},{"location":"contributing/guidelines/","title":"Source Code Guidelines","text":""},{"location":"contributing/guidelines/#style-guide-for-contributors","title":"Style Guide for Contributors","text":"<p>For those willing to contribute to Tracee, this repository has code formatting guidelines being enforced. It is recommended that, before commiting your changes, you run the following command:</p> <ol> <li>Check for formatting issues</li> </ol> <p>Check-fmt</p> <pre><code>make check-fmt\n</code></pre> <pre><code>Checking C and eBPF files and headers formatting...\nChecking golang files formatting...\n</code></pre> <p>This will make sure PRs won't fail due to same checks being enforced.</p> <ol> <li>Fix Go and C source files formatting</li> </ol> <p>Fix-fmt</p> <pre><code>make fix-fmt\n</code></pre> <pre><code>Fixing C and eBPF files and headers formatting...\nFormatting ./pkg/ebpf/c/missing_definitions.h\nFormatting ./pkg/ebpf/c/struct_flavors.h\nFormatting ./pkg/ebpf/c/tracee.bpf.c\nFormatting ./pkg/ebpf/c/vmlinux.h\n\nFixing golang files formatting...\npatching file pkg/ebpf/tracee.go\n</code></pre> <pre><code>git status -s\n</code></pre> <pre><code> M Makefile\n M builder/Makefile.checkers\n M pkg/ebpf/c/missing_definitions.h\n M pkg/ebpf/c/struct_flavors.h\n M pkg/ebpf/c/tracee.bpf.c\n M pkg/ebpf/c/vmlinux.h\n</code></pre> <ol> <li>Static Check Go and C source files</li> </ol> <p>Check-code</p> <pre><code>make check-code\n</code></pre> <pre><code>Checking Golang vet...\nmake[2]: warning: jobserver unavailable: using -j1.  Add '+' to parent make rule.\nGOOS=linux CC=clang GOARCH=amd64 CGO_CFLAGS=\"-I/home/rafaeldtinoco/work/ebpf/tracee-review/dist/libbpf\" CGO_LDFLAGS=\"-lelf -lz /home/rafaeldtinoco/work/ebpf/tracee-review/dist/libbpf/libbpf.a\" \\\ngo vet \\\n    -tags core,ebpf \\\n    ./...\n\nChecking Golang with StaticChecker...\nmake[2]: warning: jobserver unavailable: using -j1.  Add '+' to parent make rule.\nGOOS=linux CC=clang GOARCH=amd64 CGO_CFLAGS=\"-I/home/rafaeldtinoco/work/ebpf/tracee-review/dist/libbpf\" CGO_LDFLAGS=\"-lelf -lz /home/rafaeldtinoco/work/ebpf/tracee-review/dist/libbpf/libbpf.a\" \\\nstaticcheck -f stylish \\\n    -tags core,ebpf \\\n    ./...\n \u2716 0 problems (0 errors, 0 warnings, 0 ignored)\n\n Checking Golang with errcheck...\n</code></pre>"},{"location":"contributing/overview/","title":"Overview","text":""},{"location":"contributing/overview/#contributing","title":"Contributing","text":"<p>Thank you for taking interest in contributing to Tracee! This document covers our working practices and conventions.</p>"},{"location":"contributing/overview/#issues-and-discussions","title":"Issues and Discussions","text":"<p>We encourage open discussion and collaboration using both GitHub Issues and Discussions.  </p> <ul> <li>Discussions are free-style conversational tool, we use them for conversations.</li> <li>Issues are project management tool, we use them to keep track on who's working on what and plan ahead.</li> </ul> <p>If you have a suggestion, question, or a general comment - please use Discussions. If there's a clear work item (including bugs) - you can open an Issue.</p>"},{"location":"contributing/overview/#discussions","title":"Discussions:","text":"<ul> <li>We have the following discussion topics: <ol> <li>Announcements: One way communication from the team to the community. Consider this like our mini blog</li> <li>Questions and Help: For help and support. Consider this similar to StackOverflow.</li> <li>Development: For discussing potential features, and collaborating on their design.</li> </ol> </li> </ul>"},{"location":"contributing/overview/#issues","title":"Issues:","text":"<ol> <li>Every issue needs to be actionable and assignable. Consider the scope of the issue if assigned to one person, and break down if necessary.</li> <li>Be clear and definitive when composing issues. For bug reports, include detailed error messages and environment description. For features, include a clear scope and acceptance criteria.</li> <li>Since we have different projects under the same monorepo, use labels to denote areas that the issue relates to:<ol> <li><code>tracee</code></li> <li><code>tracee-ebpf</code></li> <li><code>tracee-rules</code></li> <li><code>signatures</code></li> <li>If non of the labels is relevant don't add any (usually for top-level issues)</li> </ol> </li> <li>We use the following labels to describe the type of issue:<ol> <li><code>bug</code></li> <li><code>good-first-issue</code></li> </ol> </li> <li>Self-assign or request assignment for issues you intend to work on. Don't work on an issue assigned to someone else without checking with them first and reassigning.</li> </ol>"},{"location":"contributing/overview/#pull-requests","title":"Pull Requests","text":"<ol> <li>Every Pull Request should have an associated Issue unless it is a trivial fix.</li> <li>When adding a flag option or other UX related change, make sure the design is explicitly described in the associated issue, and a maintainer approved it.</li> <li>Commit subject should succinctly describe the change:<ol> <li>Max 50 chars.</li> <li>Written in imperative mood: begin with a verb like \"fix\", \"add\", \"improve\", or \"refactor\"; Think \"once applied, this commit will...\".</li> <li>If ambiguous, mention the area that this commit affects (see area labels above).</li> </ol> </li> <li>Optional commit body (separated by empty line from subject) may explain why the change was made and not how. Wrap at 72 chars.</li> <li>Code related information should be in commit message, review related information should be in PR description.</li> <li>For changes that span different areas please try to make each change self contained and independent.</li> </ol>"},{"location":"contributing/overview/#code","title":"Code","text":"<ol> <li>Follow Golang's code review standards: https://github.com/golang/go/wiki/CodeReviewComments.</li> <li>Follow <code>gofmt</code> + <code>govet</code> + <code>goimports</code> formatting.</li> <li>Tests should be included alongside code changes wherever applicable, except for parts that are harder to test and are not currently tested (e.g. eBPF). When modifying already tested code, your changes must be represented in the existing tests.</li> </ol>"},{"location":"contributing/setup-development-machine-with-vagrant/","title":"Setup Development Machine with Vagrant","text":"<p>HashiCorp Vagrant leverages a declarative configuration file, which describes all software requirements, packages, operating system configuration, and users to provide the same development environment for everyone.</p> <p>The Vagrantfile describes the type of machine required to build Tracee from source and follow the Getting Started guides. This allows developers involved in the project to check out the code, run <code>vagrant up</code>, and be on their way.</p>"},{"location":"contributing/setup-development-machine-with-vagrant/#prerequisites","title":"Prerequisites","text":"<ul> <li>Vagrant</li> <li>Hypervisor supported by Vagrant, such as VirtualBox.</li> </ul>"},{"location":"contributing/setup-development-machine-with-vagrant/#create-development-machine","title":"Create Development Machine","text":"<p>Clone and change directory to Tracee Git repository:</p> <pre><code>git clone --branch v0.16.0-rc-14-gd8fa9648e https://github.com/aquasecurity/tracee.git\ncd tracee\n</code></pre> <p>Create and configure development machine according to the <code>Vagrantfile</code>:</p> <pre><code>vagrant up\n</code></pre> <p>If everything goes well, you can SSH into a running development machine and access its shell:</p> <pre><code>vagrant ssh\n</code></pre> <pre><code>vagrant@ubuntu-jammy:/vagrant$\n</code></pre> <p>Tip</p> <p>Provisioning from scratch take time, but once created you can reuse the machine with <code>vagrant halt</code> and <code>vagrant up</code> commands. If something goes wrong with your machine, there's also the <code>vagrant destroy</code> to destroy it and start over again.</p> <p>Synced folders enable Vagrant to sync a folder on the host machine to the development machine, allowing you to continue working on your project's files on your host machine, but use the resources in the development machine to compile or run Tracee.</p> <p>By default, Vagrant will share Tracee project directory (the directory with the <code>Vagrantfile</code>) to <code>/vagrant</code>. To get started list files:</p> <pre><code>ls -l\n</code></pre> <pre><code>total 648\ndrwxr-xr-x 1 vagrant vagrant   4096 Mar 22 23:43 3rdparty\n-rw-r--r-- 1 vagrant vagrant  11358 Mar 18 14:45 LICENSE\n-rw-r--r-- 1 vagrant vagrant  21821 Mar 27 13:40 Makefile\n-rw-r--r-- 1 vagrant vagrant    133 Mar 18 14:45 NOTICE\n-rw-r--r-- 1 vagrant vagrant   2643 Mar 29 18:30 RELEASING.md\n-rw-r--r-- 1 vagrant vagrant   2238 Mar 22 23:43 Readme.md\n-rw-r--r-- 1 vagrant vagrant   3337 Mar 22 23:43 Vagrantfile\ndrwxr-xr-x 1 vagrant vagrant   4096 Mar 29 18:05 brand\ndrwxr-xr-x 1 vagrant vagrant   4096 Mar 22 23:43 builder\ndrwxr-xr-x 1 vagrant vagrant   4096 Mar 22 23:43 cmd\n-rw-r--r-- 1 vagrant vagrant 415013 Mar 28 23:17 coverage.txt\ndrwxr-xr-x 1 vagrant vagrant   4096 Mar 18 14:45 deploy\ndrwxr-xr-x 1 vagrant vagrant   4096 Mar 29 18:15 dist\ndrwxr-xr-x 1 vagrant vagrant   4096 Mar 22 23:43 docs\n-rw-r--r-- 1 vagrant vagrant    164 Mar 18 14:45 embedded-ebpf.go\n-rw-r--r-- 1 vagrant vagrant    101 Mar 18 14:45 embedded.go\ndrwxr-xr-x 1 vagrant vagrant   4096 Mar 27 12:08 examples\n-rw-r--r-- 1 vagrant vagrant   5599 Mar 29 17:22 go.mod\n-rw-r--r-- 1 vagrant vagrant  77170 Mar 29 17:22 go.sum\n-rw-r--r-- 1 vagrant vagrant  40206 Mar 22 23:43 mkdocs.yml\ndrwxr-xr-x 1 vagrant vagrant   4096 Mar 22 23:43 packaging\ndrwxr-xr-x 1 vagrant vagrant   4096 Mar 22 23:43 pkg\ndrwxr-xr-x 1 vagrant vagrant   4096 Mar 18 14:45 signatures\n-rw-r--r-- 1 vagrant vagrant    157 Mar 22 23:43 staticcheck.conf\ndrwxr-xr-x 1 vagrant vagrant   4096 Mar 24 15:44 tests\ndrwxr-xr-x 1 vagrant vagrant   4096 Mar 22 23:43 types\n</code></pre> <p>As you can see the <code>/vagrant</code> directory contains source code of Tracee cloned from GitHub.</p>"},{"location":"contributing/setup-development-machine-with-vagrant/#build-and-run-tracee","title":"Build and Run Tracee","text":"<p>To build tracee executable binary, run the default make target:</p> <pre><code>make\n</code></pre> <p>Build targets are saved in the <code>/vagrant/dist</code> directory:</p> <pre><code>ls -l dist/\n</code></pre> <pre><code>total 161096\ndrwxr-xr-x 1 vagrant vagrant     4096 Mar 29 19:06 btfhub\ndrwxr-xr-x 1 vagrant vagrant     4096 Mar 29 19:06 libbpf\ndrwxr-xr-x 1 vagrant vagrant     4096 Mar 29 19:08 signatures\n-rwxr-xr-x 1 vagrant vagrant 62619312 Mar 29 19:08 tracee\n-rw-r--r-- 1 vagrant vagrant 10753624 Mar 29 19:06 tracee.bpf.o\n</code></pre> <p>You can now run Tracee and see events printed to the standard output in a tabular format:</p> <pre><code>sudo ./dist/tracee\n</code></pre> <pre><code>TIME             UID    COMM             PID     TID     RET              EVENT                     ARGS\n19:10:09:453832  0      coredns          1       8       0                security_socket_connect   sockfd: 13, remote_addr: map[sa_family:AF_INET sin_addr:0.0.0.0 sin_port:8080]\n19:10:09:454179  0      coredns          1       9       0                security_socket_accept    sockfd: 8, local_addr: map[sa_family:AF_INET6 sin6_addr::: sin6_flowinfo:0 sin6_port:8080 sin6_scopeid:0]\n19:10:09:454265  0      coredns          1       9       0                security_socket_accept    sockfd: 8, local_addr: map[sa_family:AF_INET6 sin6_addr::: sin6_flowinfo:0 sin6_port:8080 sin6_scopeid:0]\n19:10:09:454478  0      coredns          1       14      0                net_packet_http_request   metadata: {127.0.0.1 127.0.0.1 43306 8080 6 144 any}, http_request: &amp;{GET HTTP/1.1 :8080 /health map[Accept-Encoding:[gzip] User-Agent:[Go-http-client/1.1]] 0}\n19:10:09:454774  0      coredns          1       14      0                net_packet_http_response  metadata: {127.0.0.1 127.0.0.1 8080 43306 6 170 any}, http_response: &amp;{200 OK 200 HTTP/1.1 map[Content-Length:[2] Content-Type:[text/plain; charset=utf-8] Date:[Wed, 29 Mar 2023 19:10:09 GMT]] 2}\n19:10:10:452992  0      coredns          1       14      0                security_socket_connect   sockfd: 13, remote_addr: map[sa_family:AF_INET sin_addr:0.0.0.0 sin_port:8080]\n19:10:10:453850  0      coredns          1       1       0                security_socket_accept    sockfd: 8, local_addr: map[sa_family:AF_INET6 sin6_addr::: sin6_flowinfo:0 sin6_port:8080 sin6_scopeid:0]\n19:10:10:453983  0      coredns          1       1       0                security_socket_accept    sockfd: 8, local_addr: map[sa_family:AF_INET6 sin6_addr::: sin6_flowinfo:0 sin6_port:8080 sin6_scopeid:0]\n19:10:10:454612  0      coredns          1       9       0                net_packet_http_request   metadata: {127.0.0.1 127.0.0.1 43318 8080 6 144 any}, http_request: &amp;{GET HTTP/1.1 :8080 /health map[Accept-Encoding:[gzip] User-Agent:[Go-http-client/1.1]] 0}\n19:10:10:455114  0      coredns          1       9       0                net_packet_http_response  metadata: {127.0.0.1 127.0.0.1 8080 43318 6 170 any}, http_response: &amp;{200 OK 200 HTTP/1.1 map[Content-Length:[2] Content-Type:[text/plain; charset=utf-8] Date:[Wed, 29 Mar 2023 19:10:10 GMT]] 2}\n</code></pre>"},{"location":"contributing/setup-development-machine-with-vagrant/#switch-between-co-re-and-non-co-re-linux-distribution","title":"Switch Between CO-RE and non CO-RE Linux Distribution","text":"<p>By default, the development machine is running Ubuntu Linux 22.04 Jammy Jellyfish. You can see that it has a BTF-enabled kernel by checking the existence of the <code>/sys/kernel/btf/vmlinux</code> file.</p> <pre><code>Vagrant.configure(\"2\") do |config|\n# config.vm.box = \"ubuntu/focal64\"     # Ubuntu 20.04 Focal Fossa (non CO-RE)\n# config.vm.box = \"ubuntu/hirsute64\"   # Ubuntu 21.04 Hirsute Hippo (CO-RE)\n# config.vm.box = \"ubuntu/impish64\"    # Ubuntu 21.10 Impish Indri (CO-RE)\nconfig.vm.box = \"ubuntu/jammy64\"       # Ubuntu 22.04 Jammy Jellyfish (CO-RE)\n...\n</code></pre> <p>Sometimes you may want to test Tracee with a non CO-RE distribution. You can do that by editing the Vagrantfile and modifying the <code>config.vm.box</code> property. For example, you can switch to Ubuntu Linux 20.04 Focal Fossa as follows:</p> <pre><code>Vagrant.configure(\"2\") do |config|\nconfig.vm.box = \"ubuntu/focal64\"       # Ubuntu 20.04 Focal Fossa (non CO-RE)\n# config.vm.box = \"ubuntu/hirsute64\"   # Ubuntu 21.04 Hirsute Hippo (CO-RE)\n# config.vm.box = \"ubuntu/impish64\"    # Ubuntu 21.10 Impish Indri (CO-RE)\n# config.vm.box = \"ubuntu/jammy64\"     # Ubuntu 22.04 Jammy Jellyfish (CO-RE)\n...\n</code></pre> <p>This change requires re-provisioning the development machine:</p> <pre><code>vagrant destroy\nvagrant up\n</code></pre> <p>Attention</p> <p>Ubuntu Focal distribution has introduced BTF information to their recent kernels, allowing eBPF CO-RE capable code to run. If you're willing to test non CO-RE kernels, make sure to use an older kernel that does not provide the <code>/sys/kernel/btf/vmlinux</code> file.</p>"},{"location":"contributing/setup-development-machine-with-vagrant/#deploy-tracee-with-postee-on-kubernetes","title":"Deploy Tracee with Postee on Kubernetes","text":"<p>The development machine described by Vagrantfile pre-installs MicroK8s Kubernetes cluster, which is suitable for testing Tracee.</p> <pre><code>microk8s status\n</code></pre> <pre><code>microk8s is running\nhigh-availability: no\n  datastore master nodes: 127.0.0.1:19001\n  datastore standby nodes: none\n...\n</code></pre> <p>There's also the kubectl command installed and configured to communicate with the cluster:</p> <pre><code>kubectl get nodes -o wide\n</code></pre> <pre><code>NAME           STATUS   ROLES    AGE   VERSION   INTERNAL-IP   EXTERNAL-IP   OS-IMAGE             KERNEL-VERSION      CONTAINER-RUNTIME\nubuntu-jammy   Ready    &lt;none&gt;   40m   v1.26.1   10.0.2.15     &lt;none&gt;        Ubuntu 22.04.2 LTS   5.15.0-69-generic   containerd://1.6.8\n</code></pre> <p>Create a new namespace called <code>tracee-system</code>:</p> <pre><code>kubectl create ns tracee-system\n</code></pre> <p>Create Postee Persistent Volumes and StatefulSet in the <code>tracee-system</code> namespace:</p> <pre><code>kubectl apply -n tracee-system \\\n  -f https://raw.githubusercontent.com/aquasecurity/postee/v2.2.0/deploy/kubernetes/hostPath/postee-pv.yaml \\\n  -f https://raw.githubusercontent.com/aquasecurity/postee/v2.2.0/deploy/kubernetes/postee.yaml\n</code></pre> <p>Create Tracee DaemonSet in the <code>tracee-system</code>, configuring it to send  detections to the standard output and send them over to Postee webhook on http://postee-svc:8082:</p> <pre><code>helm repo add aqua https://aquasecurity.github.io/helm-charts\nhelm install tracee ./deploy/helm/tracee \\\n  --namespace tracee-system \\\n  --set hostPID=true \\\n  --set webhook=http://postee-svc:8082\n</code></pre> <p>Tip</p> <p>To test code that hasn't been released yet do the following:</p> <ol> <li>Build the <code>tracee:latest</code> container image from the current Git revision:    <pre><code>make -f builder/Makefile.tracee-container build-tracee\n</code></pre></li> <li>Import the container image to MicroK8s registry:    <pre><code>docker image save -o /tmp/tracee-latest.tar tracee:latest\nmicrok8s ctr images import /tmp/tracee-latest.tar\nrm /tmp/tracee-latest.tar\n</code></pre></li> <li>Create Tracee DaemonSet using <code>tracee:latest</code> as container image:    <pre><code>kubectl apply -n tracee-system -k deploy/kubernetes/tracee\n</code></pre></li> </ol> <p>While Tracee pod is running, run <code>strace ls</code> command and observe detection printed to the standard output.</p> <pre><code>kubectl logs -n tracee-system -f daemonset/tracee\n</code></pre> <pre><code>INFO: probing tracee capabilities...\nINFO: starting tracee...\n{\"timestamp\":1680119087787203746,\"threadStartTime\":1680119087787109775,\"processorId\":0,\"processId\":95599,\"cgroupId\":9789,\"threadId\":95599,\"parentProcessId\":95597,\"hostProcessId\":95599,\"hostThreadId\":95599,\"hostParentProcessId\":95597,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"strace\",\"hostName\":\"ubuntu-jammy\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"podSandbox\":false,\"eventId\":\"6018\",\"eventName\":\"Anti-Debugging detected\",\"matchedScopes\":1,\"argsNum\":0,\"returnValue\":0,\"syscall\":\"\",\"stackAddresses\":null,\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[],\"metadata\":{\"Version\":\"1\",\"Description\":\"A process used anti-debugging techniques to block a debugger. Malware use anti-debugging to stay invisible and inhibit analysis of their behavior.\",\"Tags\":null,\"Properties\":{\"Category\":\"defense-evasion\",\"Kubernetes_Technique\":\"\",\"Severity\":1,\"Technique\":\"Debugger Evasion\",\"external_id\":\"T1622\",\"id\":\"attack-pattern--e4dc8c01-417f-458d-9ee0-bb0617c1b391\",\"signatureID\":\"TRC-102\",\"signatureName\":\"Anti-Debugging detected\"}}}\n</code></pre> <p>If everything is configured properly, you can find the same detection in Postee logs:</p> <pre><code>kubectl -n tracee-system logs -f postee-0\n</code></pre> <pre><code>2023/03/29 19:44:47 {\"timestamp\":1680119087787203746,\"threadStartTime\":1680119087787109775,\"processorId\":0,\"processId\":95599,\"cgroupId\":9789,\"threadId\":95599,\"parentProcessId\":95597,\"hostProcessId\":95599,\"hostThreadId\":95599,\"hostParentProcessId\":95597,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"strace\",\"hostName\":\"ubuntu-jammy\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"podSandbox\":false,\"eventId\":\"6018\",\"eventName\":\"Anti-Debugging detected\",\"matchedScopes\":1,\"argsNum\":0,\"returnValue\":0,\"syscall\":\"\",\"stackAddresses\":null,\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[],\"metadata\":{\"Version\":\"1\",\"Description\":\"A process used anti-debugging techniques to block a debugger. Malware use anti-debugging to stay invisible and inhibit analysis of their behavior.\",\"Tags\":null,\"Properties\":{\"Category\":\"defense-evasion\",\"Kubernetes_Technique\":\"\",\"Severity\":1,\"Technique\":\"Debugger Evasion\",\"external_id\":\"T1622\",\"id\":\"attack-pattern--e4dc8c01-417f-458d-9ee0-bb0617c1b391\",\"signatureID\":\"TRC-102\",\"signatureName\":\"Anti-Debugging detected\"}}}\n</code></pre>"},{"location":"contributing/setup-development-machine-with-vagrant/#access-kubernetes-dashboard","title":"Access Kubernetes Dashboard","text":"<p>Use the following command to get the token required to log in to the Kubernetes Dashboard:</p> <pre><code>kubectl -n kube-system describe secret \\\n  $(kubectl -n kube-system get secret | grep default-token | cut -d \" \" -f1)\n</code></pre> <p>Forward port 10443 in the development machine to the Kubernetes Dashboard's pod:</p> <pre><code>kubectl port-forward --address 0.0.0.0 -n kube-system service/kubernetes-dashboard 10443:443\n</code></pre> <p>Since port 10443 is forwarded to port 10443 on your host, you can open your browser to https://localhost:10443 and access Kubernetes Dashboard.</p> <p>Warning</p> <p>Modern browser usually block insecure localhost TLS connections. For Google Chrome you may allow insecure TLS connections at chrome://flags/#allow-insecure-localhost.</p>"},{"location":"contributing/setup-development-machine-with-vagrant/#preview-tracee-documentation","title":"Preview Tracee Documentation","text":"<p>You can run MkDocs server and preview documentation on your host:</p> <pre><code>make -f builder/Makefile.mkdocs\n</code></pre> <p>The development machine is running the MkDocs server listening on port 8000, which is forwarded to port 8000 on your host. Therefore, you can open your browser to http://localhost:8000 and access documentation pages.</p>"},{"location":"contributing/building/building/","title":"Building from the source","text":"<p>Note</p> <p>Consider also visiting the following instructions: 1. docker container as building environment 2. building tracee container images </p> <ol> <li> <p>Supported Architectures</p> <ol> <li>x86_64 (amd64)</li> <li>aarch64 (arm64)</li> </ol> </li> <li> <p>Building dependencies</p> <ol> <li>clang &amp;&amp; llvm (12, 13 or 14)</li> <li>golang (1.19)</li> <li>libelf and libelf-dev    (or elfutils-libelf and elfutils-libelf-devel)</li> <li>zlib1g and zlib1g-dev    (or zlib and zlib-devel)</li> <li>clang-format-12 (specific version) for <code>fix-fmt</code></li> </ol> <p>You might take a look at the following files to understand how to have a building environment:</p> <ol> <li>.github/actions/build-dependencies/action.yaml</li> <li>packaging/Dockerfile.ubuntu-packaging</li> <li>packaging/Dockerfile.fedora-packaging</li> </ol> <p>Those are very good examples for you to replicate a working environment.</p> </li> <li> <p>Clone tracee repository</p> <pre><code>git clone git@github.com:aquasecurity/tracee\n</code></pre> <pre><code>Cloning into 'tracee'...\nremote: Enumerating objects: 13251, done.\nremote: Counting objects: 100% (555/555), done.\nremote: Compressing objects: 100% (240/240), done.\nremote: Total 13251 (delta 343), reused 369 (delta 280), pack-reused 12696\nReceiving objects: 100% (13251/13251), 11.75 MiB | 8.62 MiB/s, done.\nResolving deltas: 100% (8105/8105), done.\n</code></pre> </li> <li> <p>All makefiles have a help target to give you needed instructions</p> <pre><code>make help\n</code></pre> <pre><code># environment\n\n    $ make env                      # show makefile environment/variables\n\n# build\n\n    $ make all                      # build tracee-ebpf, tracee-rules &amp; signatures\n    $ make bpf                      # build ./dist/tracee.bpf.o\n    $ make tracee-ebpf              # build ./dist/tracee-ebpf\n    $ make tracee-rules             # build ./dist/tracee-rules\n    $ make tracee-bench             # build ./dist/tracee-bench\n    $ make signatures               # build ./dist/signatures\n    $ make e2e-net-signatures       # build ./dist/e2e-net-signatures\n    $ make e2e-inst-signatures      # build ./dist/e2e-inst-signatures\n    $ make tracee                   # build ./dist/tracee\n\n# clean\n\n    $ make clean                    # wipe ./dist/\n    $ make clean-bpf                # wipe ./dist/tracee.bpf.o\n    $ make clean-tracee-ebpf        # wipe ./dist/tracee-ebpf\n    $ make clean-tracee-rules       # wipe ./dist/tracee-rules\n    $ make clean-tracee-bench       # wipe ./dist/tracee-bench\n    $ make clean-signatures         # wipe ./dist/signatures\n    $ make clean-tracee             # wipe ./dist/tracee\n\n# test\n\n    $ make test-unit                # run unit tests\n    $ make test-types               # run unit tests for types module\n    $ make test-integration         # run integration tests\n    $ make test-signatures          # opa test (tracee-rules)\n\n# flags\n\n    $ STATIC=1 make ...             # build static binaries\n    $ BTFHUB=1 STATIC=1 make ...    # build static binaries, embed BTF\n    $ DEBUG=1 make ...              # build binaries with debug symbols\n</code></pre> </li> <li> <p>Build all targets at once</p> <pre><code>make all\n</code></pre> <pre><code>Submodule 'libbpf' (https://github.com/libbpf/libbpf.git) registered for path '3rdparty/libbpf'\nCloning into '/home/rafaeldtinoco/tracee/3rdparty/libbpf'...\nmkdir -p dist/signatures\nGOOS=linux CC=clang GOARCH=amd64 CGO_CFLAGS= CGO_LDFLAGS= go build \\\n    --buildmode=plugin \\\n    -o dist/signatures/builtin.so \\\n    signatures/golang/export.go signatures/golang/kubernetes_api_connection.go signatures/golang/stdio_over_socket.go\n</code></pre> </li> <li> <p>Build a static binary by setting <code>STATIC=1</code></p> <pre><code>STATIC=1 make all\n</code></pre> <pre><code>CC=\"clang\" \\\n    CFLAGS=\"\"-fPIC\"\" \\\n    LD_FLAGS=\"\" \\\n    make \\\n    -C ./3rdparty/libbpf/src \\\n    BUILD_STATIC_ONLY=1 \\\n    DESTDIR=/home/rafaeldtinoco/tracee/dist/libbpf \\\n    OBJDIR=/home/rafaeldtinoco/tracee/dist/libbpf/obj \\\n    INCLUDEDIR= LIBDIR= UAPIDIR= prefix= libdir= \\\n    install install_uapi_headers\n...\n</code></pre> </li> <li> <p>Build a static binary with BTFHUB Support</p> <pre><code>BTFHUB=1 STATIC=1 make all\n</code></pre> <pre><code>Cloning into '/home/rafaeldtinoco/tracee/3rdparty/btfhub'...\nremote: Enumerating objects: 205, done.\nremote: Counting objects: 100% (16/16), done.\nremote: Compressing objects: 100% (12/12), done.\nremote: Total 205 (delta 4), reused 10 (delta 3), pack-reused 189\nReceiving objects: 100% (205/205), 10.59 MiB | 7.56 MiB/s, done.\nResolving deltas: 100% (73/73), done.\nCloning into '/home/rafaeldtinoco/tracee/3rdparty/btfhub-archive'...\nremote: Enumerating objects: 1993, done.\nremote: Counting objects: 100% (28/28), done.\nremote: Compressing objects: 100% (23/23), done.\nReceiving objects:  15% (301/1993), 154.97 MiB | 15.72 MiB/s\n</code></pre> <p>Note</p> <p>BTFHUB support will embed several very small files (BTF files) into your final binary. Those files will allow tracee binary to be executed in kernels that doesn't have embedded BTF information (the ones described at the BTFHUB repository)</p> <p>Attention</p> <p>compiling <code>tracee-rules</code> with STATIC=1 won't allow you to use golang based signatures as plugins, only as built-ins:</p> <pre><code>2021/12/13 13:27:21 error opening plugin /tracee/dist/signatures/builtin.so:\nplugin.Open(\"/tracee/dist/signatures/builtin.so\"): Dynamic loading not supported\n</code></pre> </li> <li> <p>Build a debugable binary with DWARF generation by setting <code>DEBUG=1</code></p> <pre><code>DEBUG=1 make\n</code></pre> <pre><code>GOOS=linux CC=clang GOARCH=amd64 CGO_CFLAGS=\"-I/home/gg/code/tracee/dist/libbpf\" CGO_LDFLAGS=\"-lelf  -lz  /home/gg/code/tracee/dist/libbpf/libbpf.a\" go build \\\n    -tags core,ebpf \\\n    -ldflags=\" \\\n         -extldflags \\\"\\\" \\\n         -X main.version=\\\"v0.8.0-107-g121efeb\\\" \\\n        \" \\\n    -v -o dist/tracee \\\n   ./cmd/tracee\n</code></pre> </li> </ol>"},{"location":"contributing/building/containers/","title":"Creating Tracee Container Images","text":"<p>These instructions are meant to describe how to build the official tracee container image, instead of just downloading it from the Docker Hub.</p> <p>If you would like to have a local building and execution environment, read this instead.</p>"},{"location":"contributing/building/containers/#using-tracee-container-image-from-docker-hub","title":"Using Tracee Container Image from Docker Hub","text":"<p>Before moving on to how to build Tracee container, it is important to know the published container images and their tag meanings. Here is the current list of docker container images being published during a release (or a snapshot release):</p> <ol> <li> <p>SNAPSHOT (development) container images:</p> <p>These container images are built daily and its tags always point to the  latest daily built container images (based on the version currently being  developed).</p> <ul> <li>aquasec/tracee:dev (arch: amd64)</li> </ul> <p>Multiple architecture tags:</p> <ul> <li>aquasec/tracee:x86_64-dev</li> <li>aquasec/tracee:aarch64-dev</li> </ul> </li> <li> <p>RELEASE (official versions) container images:</p> <p>Preferable aliases for latest released images (per arch)):</p> <ul> <li>aquasec/tracee:x86_64</li> <li>aquasec/tracee:aarch64</li> </ul> <p>And the container images for each released version of Tracee (per arch):</p> <ul> <li>aquasec/tracee:x86_64-VERSION</li> <li>aquasec/tracee:aarch64-VERSION</li> </ul> </li> </ol>"},{"location":"contributing/building/containers/#generating-tracee-container-images","title":"Generating Tracee Container Images","text":"<ol> <li> <p>tracee:latest</p> <p>Contains an executable binary with an embedded and CO-RE enabled eBPF object that makes it portable against multiple Linux and kernel versions.</p> <pre><code>make -f builder/Makefile.tracee-container build-tracee\n</code></pre> <p>Note</p> <p><code>BTFHUB=1</code> adds support to some older kernels.</p> <pre><code>BTFHUB=1 make -f builder/Makefile.tracee-container build-tracee\n</code></pre> </li> </ol>"},{"location":"contributing/building/containers/#running-generated-tracee-container-image","title":"Running Generated Tracee Container Image","text":"<p>Tracee container is supposed to be executed through docker cmdline directly, from the official built images. Nevertheless, during the image building process, it may be useful to execute the recently generated container image with correct arguments, mostly to see if the image is working.</p> <p>User may execute built containers through <code>Makefile.tracee-container</code> file with the \"run\" targets:</p> <ol> <li> <p>To run recently generated tracee:latest container:</p> <pre><code>make -f builder/Makefile.tracee-container run-tracee\n</code></pre> <p>Note</p> <p>Tracee arguments are passed through the <code>ARG</code> variable: <pre><code>make -f builder/Makefile.tracee-container run-tracee ARG=\"--help\"\n</code></pre></p> </li> </ol>"},{"location":"contributing/building/environment/","title":"Creating a local building environment","text":"<p>These instructions are meant to describe how to create a local building and execution environment. If you would like to build tracee container(s) image(s), read this instead.</p> <p>Note</p> <p>A building environment will let you build and execute tracee inside a docker container, containing all needed tools to build and execute it. If you're using an OSX environment, for example, you can install gmake (<code>brew install gmake</code>) and configure such environment by using Docker.</p> <p>Attention</p> <p>If you want to build tracee on your local machine read this.</p>"},{"location":"contributing/building/environment/#quick-steps-impatient-readers","title":"Quick steps (impatient readers)","text":"<p>Example</p> <ul> <li> <p>Build and execute tracee:</p> <pre><code>make -f builder/Makefile.tracee-make alpine-prepare\nmake -f builder/Makefile.tracee-make alpine-shell\n</code></pre> <p>and inside the container:</p> <pre><code>make clean\nmake tracee\nsudo ./dist/tracee \\\n    -o option:parse-arguments \\\n    --scope comm=bash \\\n    --scope follow\n</code></pre> </li> </ul> <p>Now, in your host's bash shell, execute a command. You will see all events (except scheduler ones) being printed, in \"table format\", to stdout.</p> <ul> <li> <p>Build and execute tracee:</p> <pre><code>make -f builder/Makefile.tracee-make alpine-prepare\nmake -f builder/Makefile.tracee-make alpine-shell\n</code></pre> <p>and inside the container:</p> <pre><code>make clean\nmake all\nsudo ./dist/tracee \\\n    -o format:json \\\n    -o option:parse-arguments \\\n    --scope comm=bash \\\n    --scope follow \n</code></pre> </li> </ul> <p>Now, in your host's bash shell, execute: <code>sudo strace /bin/ls</code> and observe tracee warning you about a possible risk (with its Anti-Debugging signature).</p> <p>Now, for more patient readers ...</p>"},{"location":"contributing/building/environment/#how-to-build-and-use-the-environment","title":"How to build and use the environment","text":"<p>In order to have a controlled building environment for tracee, tracee provides a <code>Makefile.tracee-make</code> file that allows you to create and use a docker container environment to build &amp; test tracee. </p> <p>Two different environments are maintained for building tracee:</p> <ul> <li>Alpine</li> <li>Ubuntu</li> </ul> <p>The reason for that is that Alpine Linux is based in the musl C standard library, while the Ubuntu Linux uses glibc. By supporting both building environments we can always be sure that the project builds (and executes) correctly in both environments.</p> <p>Attention</p> <p>Locally created containers, called <code>alpine-tracee-make</code> or <code>ubuntu-tracee-make</code>, share the host source code directory. This means that, if you build tracee binary using <code>alpine</code> distribution, the binary might not be compatible to the Linux distribution from your host OS.</p>"},{"location":"contributing/building/environment/#creating-a-builder-environment","title":"Creating a builder environment","text":"<ul> <li> <p>To create an alpine-tracee-make container:</p> <pre><code>make -f builder/Makefile.tracee-make alpine-prepare\n</code></pre> </li> <li> <p>To create an ubuntu-tracee-make container:</p> <pre><code>make -f builder/Makefile.tracee-make ubuntu-prepare\n</code></pre> </li> </ul>"},{"location":"contributing/building/environment/#executing-a-builder-environment","title":"Executing a builder environment","text":"<ul> <li> <p>To execute an alpine-tracee-make shell:</p> <pre><code>make -f builder/Makefile.tracee-make alpine-shell\n</code></pre> </li> <li> <p>To execute an ubuntu-tracee-make shell:</p> <pre><code>make -f builder/Makefile.tracee-make ubuntu-shell\n</code></pre> </li> </ul>"},{"location":"contributing/building/environment/#using-build-environment-as-a-make-replacement","title":"Using build environment as a make replacement","text":"<p>Instead of executing a builder shell, you may use <code>alpine-tracee-make</code>, or <code>ubuntu-tracee-make</code>, as a replacement for the <code>make</code> command:</p> <pre><code>make -f builder/Makefile.tracee-make ubuntu-prepare\nmake -f builder/Makefile.tracee-make ubuntu-make ARG=\"help\"\nmake -f builder/Makefile.tracee-make ubuntu-make ARG=\"clean\"\nmake -f builder/Makefile.tracee-make ubuntu-make ARG=\"bpf\"\nmake -f builder/Makefile.tracee-make ubuntu-make ARG=\"tracee\"\nmake -f builder/Makefile.tracee-make ubuntu-make ARG=\"all\"\n</code></pre> <p>And, after the compilation, run the commands directly in your host:</p> <pre><code>sudo ./dist/tracee \\\n    -o option:parse-arguments \\\n    --scope comm=bash \\\n    --scope follow\n</code></pre> <p>Note: the generated binary must be compatible to your host (depending on glibc version, for example).</p> <p>If you don't want to depend on host's libraries versions, or if you are using the <code>alpine-tracee-make</code> container as a replacement for <code>make</code>, and your host is not an Alpine Linux, then you may set <code>STATIC=1</code> variable so you can run compiled binaries in your host:</p> <pre><code>make -f builder/Makefile.tracee-make alpine-prepare\nmake -f builder/Makefile.tracee-make alpine-make ARG=\"help\"\nSTATIC=1 make -f builder/Makefile.tracee-make alpine-make ARG=\"all\"\n</code></pre> <p>and execute the static binary from your host:</p> <pre><code>ldd dist/tracee\n</code></pre> <pre><code>not a dynamic executable\n</code></pre> <p>Attention</p> <p>compiling tracee-rules with STATIC=1 won't allow you to use golang based signatures:</p> <pre><code>2021/12/13 13:27:21 error opening plugin /tracee/dist/signatures/builtin.so:\nplugin.Open(\"/tracee/dist/signatures/builtin.so\"): Dynamic loading not supported\n</code></pre>"},{"location":"contributing/building/packaging/","title":"Creating Tracee Linux packages","text":"<p>These instructions are meant to describe how to build Linux distributions packages. If you would like to have a local build and execution environment, read this instead.</p>"},{"location":"contributing/building/packaging/#ubuntu","title":"Ubuntu","text":"<p>You may use <code>builder/Makefile.packaging</code> to generate Ubuntu deb packages. It will use docker containers to generate appropriate packages, so you don't need to install build dependencies in your OS.</p> <p>Before running these commands make sure your user is added to the docker group:</p> <pre><code>sudo usermod -aG docker $USER\n</code></pre> <p>Ubuntu</p> <p>Building</p> <ul> <li>Focal (LTS)</li> </ul> <pre><code>make -f builder/Makefile.packaging ubuntu-bin-focal\n</code></pre> <ul> <li>Jammy (LTS)</li> </ul> <pre><code>make -f builder/Makefile.packaging ubuntu-bin-jammy\n</code></pre> <p>Versioning</p> <p>The ubuntu <code>.deb</code> packages have the following versioning format:</p> <p><code>tracee-{ebpf,rules}_version~ubuntuver~builddate-lastcommit_arch.deb</code></p> <p>Examples:</p> <pre><code># focal\ntracee_0.6.5-111~20.04~2201281302-3a6874a_amd64.deb\n\n...\n</code></pre> <p>This allows upgrades among future releases of tracee AND ubuntu. It also allows you to upgrade to \"in between releases\" versions if a fix is needed.</p> <p>Location</p> <p>The packages will be generated in <code>dist/</code> directory.</p>"},{"location":"contributing/building/packaging/#fedora","title":"Fedora","text":"<p>You may use <code>builder/Makefile.packaging</code> to generate Fedora rpm packages. It will use docker containers to generate appropriate packages, so you don't need to install build dependencies in your OS.</p> <p>Before running these commands make sure your user is added to the docker group:</p> <pre><code>sudo usermod -aG docker $USER\n</code></pre> <p>Fedora</p> <p>Building</p> <ul> <li>36 (still maintained)</li> </ul> <pre><code>make -f builder/makefile.packaging fedora-bin-36\n</code></pre> <ul> <li>37 (latest)</li> </ul> <pre><code>make -f builder/makefile.packaging fedora-bin-37\n</code></pre> <p>Versioning</p> <p>The fedora <code>.rpm</code> packages have the following versioning format:</p> <p><code>tracee-{ebpf,rules}-version-f{34,35,36}.builddate.lastcommit.arch.rpm</code></p> <p>Examples:</p> <pre><code># f36\ntracee-0.6.5.163-f36.2202140514.ef35306d.x86_64.rpm\n\n# f37\ntracee-0.8.0.rc-f37.2207080417.07c8af7.x86_64.rpm\n...\n</code></pre> <p>This allows upgrades among future releases of tracee AND fedora. It also allows you to upgrade to \"in between releases\" versions if a fix is needed.</p> <p>Location</p> <p>The packages will be generated in <code>dist/</code> directory.</p>"},{"location":"docs/overview/","title":"Docs","text":"<p>In this section you can find the complete reference documentation for all of the different features and settings that Tracee has to offer.</p> <p>Note</p> <p>We have recently transitioned to a new architecture and user-experience, as detailed here, and the documentation has been updated accordingly.  </p> <p>\ud83d\udc48 Please use the side-navigation on the left in order to browse the different topics.</p>"},{"location":"docs/config/kubernetes/","title":"Kubernetes Config","text":""},{"location":"docs/config/kubernetes/#configmap","title":"Configmap","text":"<p>Tracee ConfigMap exposed tracee configuration to the deployment.</p> <pre><code>---\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  labels:\n    app.kubernetes.io/name: tracee\n    app.kubernetes.io/component: tracee\n    app.kubernetes.io/part-of: tracee\n  name: tracee\ndata:\n  config.yaml: |-\n    cache:\n      - cache-type=mem\n      - mem-cache-size=512\n    perf-buffer-size: 1024\n    containers: true\n    healthz: false\n    metrics: true\n    pprof: false\n    pyroscope: false\n    listen-addr: :3366\n    log:\n        - info\n    output:\n        - json\n        - option:parse-arguments\n</code></pre>"},{"location":"docs/config/kubernetes/#customizing","title":"Customizing","text":"<p>You can customize specific options with the helm installation:</p> <pre><code># setting blob-perf-event-size\nhelm install tracee aqua/tracee \\\n        --namespace tracee-system --create-namespace \\\n        --set config.blobPerfEventSize=1024\n\n\n# setting a different output\nhelm install tracee aqua/tracee \\\n        --namespace tracee-system --create-namespace \\\n                --set config.output[0]=table\n                --set config.output[1]=option:parse-arguments\n</code></pre> <p>Or you can pass a config file directly:</p> <pre><code> helm install tracee aqua/tracee \\\n        --namespace tracee-system --create-namespace \\\n                --set-file traceeConfig=&lt;path/to/config/file&gt;\n</code></pre>"},{"location":"docs/config/overview/","title":"Config","text":""},{"location":"docs/config/overview/#configuring-tracee-with-the-config-flag","title":"Configuring Tracee with the <code>--config</code> Flag","text":"<p>The <code>--config</code> flag allows you to specify global configuration options for Tracee by providing a configuration file in YAML or JSON format, among other supported formats. The <code>--config</code> flag can be used to set any flag that is available through the command line interface (CLI), except for a few reserved flags.</p>"},{"location":"docs/config/overview/#usage","title":"Usage","text":"<p>To use the <code>--config</code> flag, you need to provide the path to the configuration file. For example, if you have a YAML configuration file located at /path/to/tracee-config.yaml, you can load it with the following command:</p> <pre><code>tracee --config /path/to/tracee-config.yaml\n</code></pre> <p>You can also override specific configuration options by passing additional flags on the command line. For example, the following command overrides the log level set in the configuration file with info:</p> <pre><code>sudo ./dist/tracee --config ./examples/config/global_config.yaml --log info\n</code></pre> <p>Note</p> <p>Any flags specified on the command line will take precedence over the values specified in the configuration file.</p>"},{"location":"docs/config/overview/#configuration-file-format","title":"Configuration File Format","text":"<p>The configuration file can be in any format supported by the viper library, which includes YAML, JSON, TOML, INI, HCL and Java properties. The configuration file should contain a mapping of flag names to their values. For example, to output aggregated debug level logs every default seconds <code>--log debug --log aggregate</code>, you would add the following to your configuration file:</p> <pre><code>log:\n- debug\n- aggregate\n</code></pre>"},{"location":"docs/config/overview/#reserved-flags","title":"Reserved Flags","text":"<p>There are a few flags that are reserved for the CLI and cannot be set through the configuration file. These include: <code>--config</code>, <code>--capture</code>, <code>--policy</code>, <code>--scope</code>, and <code>--events</code>.</p>"},{"location":"docs/config/overview/#example-configuration-files","title":"Example Configuration Files","text":"<p>To help you get started with configuring Tracee using the <code>--config</code> flag, we've provided two example configuration files in the <code>examples/config</code> directory of the Tracee repository:</p> <ul> <li><code>examples/config/global_config.json</code>: This file contains an example configuration in JSON format.</li> <li><code>examples/config/global_config.yaml</code>: This file contains the same example configuration as global_config.json, but in YAML format.</li> </ul> <p>These example files demonstrate how you can set various configuration options using the <code>--config</code> flag. You can use these files as a starting point for your own configuration, or as a reference for the available configuration options.</p> <p>To use one of the example configuration files with Tracee, simply pass the path to the file as an argument to the -<code>-config</code> flag. For example, to use the YAML configuration file, you could run the following command:</p> <pre><code>tracee --config examples/config/global_config.yaml\n</code></pre> <p>By starting with one of these example files and modifying it to suit your needs, you can quickly get up and running with Tracee's configuration options.</p>"},{"location":"docs/data-sources/overview/","title":"Data Sources (Experimental)","text":"<p>Data sources are a new feature, which will be the base of allowing access to dynamic data stores in signature writing (currently only available in golang). Data sources are currently an experimental feature and in active development, and usage is opt-in.</p>"},{"location":"docs/data-sources/overview/#why-use-data-sources","title":"Why use data sources?","text":"<p>Data sources should be used when a signature requires access to data not available to it from the events it receives. For example, a signature may need access to additional data about a container where an event was generated. Using tracee's builtin container data source it can do so without additionally tracking container lifecycle events.</p>"},{"location":"docs/data-sources/overview/#what-data-sources-can-i-use","title":"What data sources can I use","text":"<p>Currently, only builtin data sources from tracee are available. Initially only a data source for containers will be available, but the list will be expanded as this and other features are further developed.  </p>"},{"location":"docs/data-sources/overview/#how-to-use-data-sources","title":"How to use data sources","text":"<p>In order to use a data source in a signature you must request access to it in the <code>Init</code> stage. This can be done through the <code>SignatureContext</code> passed at that stage as such: <pre><code>func (sig *mySig) Init(ctx detect.SignatureContext) error {\n...\ncontainersData, ok := ctx.GetDataSource(\"tracee\", \"containers\")\nif !ok {\nreturn fmt.Errorf(\"containers data source not registered\")\n}\nif containersData.Version() &gt; 1 {\nreturn fmt.Errorf(\"containers data source version not supported, please update this signature\")\n}\nsig.containersData = containersData\n}\n</code></pre></p> <p>As you can see we have requested access to the data source through two keys, a namespace, and a data source ID. Namespaces are used to avoid name conflicts in the future when custom data sources can be integrated. All of tracee's builtin data sources will be available under the \"tracee\" namespace. After checking the data source is available, we suggest to add a version check against the data source. Doing so will let you avoid running a signature which was not updated to run with a new data source schema.  </p> <p>Now, in the <code>OnEvent</code> function, you may use the data source like so: <pre><code>container, err := sig.containersData.Get(containerId)\nif !ok {\nreturn fmt.Errorf(\"failed to find container in data source: %v\", err)\n}\n\ncontainerName := container[\"container_name\"].(string)\n</code></pre> Each Data source comes with one querying method <code>Get(key any) map[string]any</code>. In the above example, omitting the type validation when checking the key, which was safe to do by following the schema (given through the <code>Schema()</code> method), a json representation of the returned map, and initially checking the data source version.</p>"},{"location":"docs/deep-dive/caching-events/","title":"Special: Caching Events","text":"<p>Tracee has an events caching (in-memory) mechanism. In order to check latest caching options you may execute:</p> <pre><code>./dist/tracee --help cache\n</code></pre> <p>Read</p> <p>Before continuing, please read the architecture page, in order to understand the tracee pipeline concept, AND the [performance page], to understand possible pain points.</p> <p></p> <p>The caching happens in userland, it is an in-memory caching, and it helps with workload bursts: if kernel produces more events than userland is capable of processing then the events are kept in a sizeable cache (defined by user) so they're not lost (if cache isn't full).</p> <p>The effects of this are the following:</p> <ol> <li> <p>Detections might be delayed because of workload bursts, but not lost (if    cache isn't full).</p> </li> <li> <p>Event losses from the kernel perf/ring buffer will only happen when    cache is full.</p> </li> <li> <p>Any difference in ratio production:consumption can be mitigated temporarily.</p> </li> </ol>"},{"location":"docs/deep-dive/caching-events/#use-caching","title":"Use caching","text":"<p>Example using 1GB cache, container enrichment in the pipeline, argument parsing so arguments are formatted in a human consumable way:</p> <pre><code>sudo ./dist/tracee \\\n    --cache cache-type=mem \\\n    --cache mem-cache-size=1024 \\\n    --containers -o format:json \\\n    -o option:parse-arguments \\\n    -trace container \\\n    --crs docker:/var/run/docker.sock\n</code></pre> <p>Attention</p> <p>If you pipe tracee output to another tool, like <code>jq</code>: <pre><code>| jq -c '. | {cgroupid, processname, containername}'\n</code></pre> You may cause latencies in tracee pipeline because the event json processing from <code>jq</code> might not be as fast as how tracee is capable of writing events to it.</p>"},{"location":"docs/deep-dive/dropping-capabilities/","title":"Special: Environment Capabilities","text":""},{"location":"docs/deep-dive/dropping-capabilities/#introduction-to-capabilities-quoting-parts-of-kernel-docs","title":"Introduction to Capabilities (quoting parts of kernel docs)","text":"<p>For the purpose of performing permission checks, traditional UNIX implementations distinguish two categories of processes: privileged processes (whose effective user ID is 0, referred to as superuser or root), and unprivileged processes (whose effective UID is nonzero).</p> <p>Privileged processes bypass all kernel permission checks, while unprivileged processes are subject to full permission checking based on the process's credentials (usually: effective UID, effective GID, and supplementary group list).</p> <p>Linux divides the privileges traditionally associated with superuser into distinct units, known as capabilities, which can be independently enabled and disabled. Capabilities are a per-thread attribute.</p> <p>Thread capability sets:</p> <ul> <li> <p>Permitted: This is a limiting superset for the effective capabilities that the thread may assume. It is also a limiting superset for the capabilities that may be added to the inheritable set by a thread that does not have the CAP_SETPCAP capability in its effective set.</p> </li> <li> <p>Inheritable: This is a set of capabilities preserved across an execve(2). Inheritable capabilities remain inheritable when executing any program, and inheritable capabilities are added to the permitted set when executing a program that has the corresponding bits set in the file inheritable set.</p> </li> <li> <p>Effective: This is the set of capabilities used by the kernel to perform permission checks for the thread.</p> </li> <li> <p>Bounding: The capability bounding set is a mechanism that can be used to limit the capabilities that are gained during execve(2).</p> </li> </ul>"},{"location":"docs/deep-dive/dropping-capabilities/#tracee-and-capabilities","title":"Tracee and capabilities","text":"<p>tracee tries to reduce its capabilities during its execution. The way it does is through different \"execution protection rings\":</p> <ul> <li>Full:     All capabilities are effective (less secure)</li> <li>EBPF:     eBPF needed capabilities + Base capabilities</li> <li>Specific: Specific capabilities (from time to time) + Base Capabilities</li> <li>Base:     None or Some capabilities always effective (more secure)</li> </ul>"},{"location":"docs/deep-dive/dropping-capabilities/#listing-available-capabilities","title":"Listing available capabilities","text":"<p>You may see all available capabilities in the running environment by running:</p> <pre><code>--help capabilities\n</code></pre> <p>command line flag.</p>"},{"location":"docs/deep-dive/dropping-capabilities/#bypass-capabilities-dropping-feature","title":"Bypass capabilities dropping feature","text":"<p>Attention</p> <p>This session is important if you're facing errors related to tracee dropping its capabilities OR any other permission related errors.</p> <p>Some environments won't allow capabilities dropping because of permission issues (for example - AWS Lambdas).</p> <p>It might be a result of seccomp filter for example, restricting syscalls access.</p> <p>Failure in capabilities dropping will result tracee's exit with a matching error, to guarantee that tracee isn't running with excess capabilities without the user agreement.</p> <p>To allow tracee to run with high capabilities, and prevent those errors, the <code>--capabilities bypass=true</code> flag can be used. For the docker container users, the environment variable <code>CAPABILITIES_BYPASS=0|1</code> will have the same effect.</p> <p>Note</p> <p>Bypassing the capabilities drop will run tracee with all capabilities set as Effective and it is only recommended if you know what you are doing.</p>"},{"location":"docs/deep-dive/dropping-capabilities/#capabilities-errors-missing-or-too-permissive","title":"Capabilities Errors (Missing or Too Permissive)","text":"<p>During development, tracee might have bugs related to capabilities dropping feature: one event might not have its needed capabilities set as a dependency, for example, and you might still want to use that event.</p> <p>One way to have fine grained control of \"execution time\" effective capabilities is to rely on following 2 command line flags:</p> <ul> <li><code>--capabilities add=cap_X,cap_Y</code> (docker env variable CAPABILITIES_ADD)</li> <li><code>--capabilities drop=cap_Y,capZ</code> (docker env variable CAPABILITIES_DROP)</li> </ul> <p>The first will add given capabilities to the Base ring, the ring that describe capabilities that will always be effective while tracee is running, so events might be able to work. The last will remove the capabilities from that same ring.</p>"},{"location":"docs/deep-dive/ordering-events/","title":"Special: Ordering Events","text":"<p>Package sorting feature is responsible for sorting incoming events from the BPF programs chronologically.</p> <pre><code>sudo ./dist/tracee \\\n    -o json \\\n    -o option:parse-arguments \\\n    -o option:sort-events\n</code></pre> <p>Information</p> <p>There are 3 known sources to events sorting issues:</p> <ol> <li> <p>In perf buffer, events are read in round robing order from CPUs buffers      (and not according to invocation time).</p> </li> <li> <p>Syscall events are invoked after internal events of the syscall (though      the syscall happened before the internal events).</p> </li> <li> <p>Virtual CPUs might enter sleep mode by host machine scheduler and send      events after some delay.</p> </li> </ol>"},{"location":"docs/deep-dive/ordering-events/#deep-dive-into-sorting-feature","title":"Deep Dive Into Sorting Feature","text":"<p>To address the events perf buffers issue, the events are divided to queues according to the source CPU. This way the events are almost ordered (except for syscalls). The syscall events are inserted to their right chronological place manually.</p> <p>This way, all events which occurred before the last event of the most delaying CPU could be sent forward with guaranteed order.</p> <p>To make sure syscall events are not missed when sending, a small delay is needed. Lastly, to address the vCPU sleep issue (which might cause up to 2 events received in a delay), the events need to be sent after a delay which is bigger than max possible vCPU sleep time (which is just an increase of the syscall events delay sending).</p>"},{"location":"docs/deep-dive/ordering-events/#algorithm-for-nerds-d","title":"Algorithm for Nerds =D","text":"<p>To summarize the algorithm main logic, here is textual simulation of the operation (assume that 2 scheduler ticks are larger than max possible vCPU sleep time):  </p> <p>Tn = Timestamp (n == TOD) #m = Event's Source CPU  </p> <ol> <li> <p>Initial State</p> <pre><code>       [ CPU 0 ]    [ CPU 1 ]    [ CPU 2 ]\n  HEAD    T1           T2           T4\n          T3           T5\n          T6\n  TAIL    T8\n</code></pre> </li> <li> <p>Scheduler Tick #1</p> <pre><code>Incoming events: T9#1, T11#2, T13#1, T10#2, T12#2\n\nQueues state after insert:\n       [ CPU 0 ]    [ CPU 1 ]    [ CPU 2 ]\n  HEAD    T1           T2           T4\n          T3           T5           T10 +\n          T6           T9  +        T11 +\n  TAIL    T8           T13 +        T12 +\n\n  - No event sent.\n  - Oldest timestamp = T1.\n  - T8 is oldest timestamp in most recent timestamps.\n  - In 2 ticks from now: send all events up to T8.\n  - Bigger timestamps than T8 (+) will be sent in future scheduling.\n</code></pre> </li> <li> <p>Scheduler Tick #2</p> <pre><code>Incoming events: T7#0, T22#1, T23#2, T20#0, T25#1, T24#2, T21#0\n\nQueues state after insert:\n       [ CPU 0 ]    [ CPU 1 ]    [ CPU 2 ]\n  HEAD    T1  ^        T2  ^        T4  ^\n          T3  ^        T5  ^        T10\n          T6  ^        T9           T11\n          T7  +^       T13          T12\n          T8  ^        T22 +        T23 +\n          T20 +        T25 +        T24 +\n  TAIL    T21 +\n\n  - No event sent.\n  - Oldest timestamp = T1.\n  - T21 is oldest timestamp in most recent timestamps.\n  - In 2 ticks from now: send all events up to T21.\n  - T8 is previous oldest timestamp in most recent timestamps.\n  - Next tick: send all events up to T8.\n  - Bigger timestamps than T21 (+) will be sent in future scheduling.\n</code></pre> </li> <li> <p>Scheduler Tick #3</p> <pre><code>Incoming events: T30#0, T34#1, T35#2, T31#0, T36#2, T32#0, T37#2, T33#0, T38#2, T50#1, T51#1\n\nQueues state after insert:\n       [ CPU 0 ]    [ CPU 1 ]    [ CPU 2 ]\n  HEAD    T20 ^        T9  ^        T10 ^\n          T21 ^        T13 ^        T11 ^\n          T30 +        T22          T12 ^\n          T31 +        T23          T24\n          T32 +        T25          T35 +\n          T33 +        T34 +        T36 +\n                       T50 +        T37 +\n   TAIL                T51 +        T38 +\n\n  - Max sent timestamp = T8.\n  - Oldest timestamp = T9.\n  - T33 is oldest timestamp in most recent timestamps.\n  - In 2 ticks from now: send all events up to T33.\n  - T21 is previous oldest timestamp in most recent timestamps.\n  - Next tick: send all events up to T21.\n  - Bigger timestamps than T33 (+) will be sent in future scheduling.\n</code></pre> </li> </ol>"},{"location":"docs/deep-dive/secure-tracing/","title":"FAQ - Frequently Asked Questions","text":"<ol> <li> <p>Secure tracing</p> <p>When tracee reads information from user programs, it is subject to a race condition where the user program might be able to change the arguments after tracee read them.</p> <p>For example, a program invoked:</p> <pre><code>execve(\"/bin/ls\", NULL, 0)\n</code></pre> <p>Tracee picked that up and will report that, then the program changed the first argument from <code>/bin/ls</code> to <code>/bin/bash</code>, and this is what the kernel will execute.</p> <p>To mitigate this, Tracee also provides \"LSM\" (Linux Security Module) based events, for example, the <code>bprm_check</code> event which can be reported by Tracee and cross-referenced with the reported regular syscall event.</p> </li> </ol>"},{"location":"docs/events/overview/","title":"Events","text":"<p>This section documents all of the different events that Tracee exposes.</p>"},{"location":"docs/events/overview/#everything-is-an-event","title":"Everything is an event","text":"<p>Tracee uses eBPF technology to tap into your system and give you access to hundreds of events that help you understand how your system behaves. The events can be specified either through CLI with filters or with policies.</p> <p>eg:</p> <p>Tracing <code>execve</code> events with filters:</p> <pre><code>tracee --events execve\n</code></pre> <p>Tracing <code>execve</code> events with policies:</p> <pre><code>cat &lt;&lt;EOF &gt;sample_policy.yaml\nname: sample policy\ndescription: traces execve events\nscope:\n  - global\nrules:\n  - event: execve\nEOF\n</code></pre> <pre><code>tracee --policies sample_policy.yaml\n</code></pre> <p>If no event is passed with filters or policies, tracee will start with a sane default. Below a list of tracee default events.</p>"},{"location":"docs/events/overview/#default-events","title":"Default events","text":"Name Sets stdio_over_socket [signatures default] k8s_api_connection [signatures default] aslr_inspection [signatures default] proc_mem_code_injection [signatures default] docker_abuse [signatures default] scheduled_task_mod [signatures default] ld_preload [signatures default] cgroup_notify_on_release [signatures default] default_loader_mod [signatures default] sudoers_modification [signatures default] sched_debug_recon [signatures default] system_request_key_mod [signatures default] cgroup_release_agent [signatures default] rcd_modification [signatures default] core_pattern_modification [signatures default] proc_kcore_read [signatures default] proc_mem_access [signatures default] hidden_file_created [signatures default] anti_debugging [signatures default] ptrace_code_injection [signatures default] process_vm_write_inject [signatures default] disk_mount [signatures default] dynamic_code_loading [signatures default] fileless_execution [signatures default] illegitimate_shell [signatures default] kernel_module_loading [signatures default] k8s_cert_theft [signatures default] proc_fops_hooking [signatures default] syscall_hooking [signatures default] dropped_executable [signatures default] creat [default syscalls fs fs_file_ops] chmod [default syscalls fs fs_file_attr] fchmod [default syscalls fs fs_file_attr] chown [default syscalls fs fs_file_attr] fchown [default syscalls fs fs_file_attr] lchown [default syscalls fs fs_file_attr] ptrace [default syscalls proc] setuid [default syscalls proc proc_ids] setgid [default syscalls proc proc_ids] setpgid [default syscalls proc proc_ids] setsid [default syscalls proc proc_ids] setreuid [default syscalls proc proc_ids] setregid [default syscalls proc proc_ids] setresuid [default syscalls proc proc_ids] setresgid [default syscalls proc proc_ids] setfsuid [default syscalls proc proc_ids] setfsgid [default syscalls proc proc_ids] init_module [default syscalls system system_module] fchownat [default syscalls fs fs_file_attr] fchmodat [default syscalls fs fs_file_attr] setns [default syscalls proc] process_vm_readv [default syscalls proc] process_vm_writev [default syscalls proc] finit_module [default syscalls system system_module] memfd_create [default syscalls fs fs_file_ops] move_mount [default syscalls fs] sched_process_exec [default proc] security_inode_unlink [default lsm_hooks fs fs_file_ops] security_socket_connect [default lsm_hooks net net_sock] security_socket_accept [default lsm_hooks net net_sock] security_socket_bind [default lsm_hooks net net_sock] security_sb_mount [default lsm_hooks fs] container_create [default containers] container_remove [default containers] net_packet_icmp [default network_events] net_packet_icmpv6 [default network_events] net_packet_dns_request [default network_events] net_packet_dns_response [default network_events] net_packet_http_request [default network_events] net_packet_http_response [default network_events]"},{"location":"docs/events/overview/#sets","title":"Sets","text":"<p>Events can be part of a set, for example on the table above we can see a few sets like <code>default</code>, <code>network_events</code>, <code>syscalls</code>.  We can ask tracee to trace a full set, or sets, instead of passing event by event, for example:</p> <p><pre><code>tracee --events syscalls\n</code></pre> or </p> <pre><code>tracee --events syscalls,network_events\n</code></pre>"},{"location":"docs/events/overview/#read-in-cli","title":"Read in CLI","text":"<p>You can view the list of available events and their schema by running <code>tracee list</code> command.</p>"},{"location":"docs/events/overview/#read-in-avd","title":"Read in AVD","text":"<p>Aqua Vulnerability Database (AVD) is a public index of all security information that can be reported across all of Aqua's products and tools. As such, it also contains entries about Tracee security events. The AVD entries on runtime security are generated from the detection signatures and are organized by MITRE ATT&amp;CK categorization. Browse at avd.aquasec.com/tracee.</p> <p>\ud83d\udc48 Please use the side-navigation on the left in order to browse the different topics.</p>"},{"location":"docs/events/builtin/network/","title":"Network Events","text":"<p>Tracee offers a set of network events that makes it easy to trace network activity in common protocols.</p>"},{"location":"docs/events/builtin/network/#available-network-events","title":"Available network events","text":"<ul> <li>net_packet_ipv4</li> <li>net_packet_ipv6</li> <li>net_packet_tcp</li> <li>net_packet_udp</li> <li>net_packet_icmp</li> <li>net_packet_icmpv6</li> <li>net_packet_dns</li> <li>net_packet_dns_request</li> <li>net_packet_dns_response</li> </ul>"},{"location":"docs/events/builtin/network/#examples","title":"Examples","text":""},{"location":"docs/events/builtin/network/#net_packet_ipv4","title":"net_packet_ipv4","text":"<pre><code># three way handshake for a TCP connection.\n\n{\"timestamp\":1671040290192938971,\"threadStartTime\":341237880436231,\"processorId\":2,\"processId\":3120261,\"cgroupId\":20552,\"threadId\":3120261,\"parentProcessId\":3101489,\"hostProcessId\":3120261,\"hostThreadId\":3120261,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2007\",\"eventName\":\"net_packet_ipv4\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.157.254.1\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.157.254.193\"},{\"name\":\"proto_ipv4\",\"type\":\"trace.ProtoIPv4\",\"value\":{\"version\":4,\"IHL\":5,\"TOS\":0,\"length\":60,\"id\":42857,\"flags\":2,\"fragOffset\":0,\"TTL\":64,\"protocol\":\"TCP\",\"checksum\":33109,\"srcIP\":\"10.157.254.1\",\"dstIP\":\"10.157.254.193\"}}]}\n{\"timestamp\":1671040290193572748,\"threadStartTime\":341237880436231,\"processorId\":13,\"processId\":3120261,\"cgroupId\":20552,\"threadId\":3120261,\"parentProcessId\":3101489,\"hostProcessId\":3120261,\"hostThreadId\":3120261,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2007\",\"eventName\":\"net_packet_ipv4\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.157.254.193\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.157.254.1\"},{\"name\":\"proto_ipv4\",\"type\":\"trace.ProtoIPv4\",\"value\":{\"version\":4,\"IHL\":5,\"TOS\":0,\"length\":60,\"id\":0,\"flags\":2,\"fragOffset\":0,\"TTL\":64,\"protocol\":\"TCP\",\"checksum\":10431,\"srcIP\":\"10.157.254.193\",\"dstIP\":\"10.157.254.1\"}}]}\n{\"timestamp\":1671040290193642873,\"threadStartTime\":341237880436231,\"processorId\":13,\"processId\":3120261,\"cgroupId\":20552,\"threadId\":3120261,\"parentProcessId\":3101489,\"hostProcessId\":3120261,\"hostThreadId\":3120261,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2007\",\"eventName\":\"net_packet_ipv4\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.157.254.1\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.157.254.193\"},{\"name\":\"proto_ipv4\",\"type\":\"trace.ProtoIPv4\",\"value\":{\"version\":4,\"IHL\":5,\"TOS\":0,\"length\":52,\"id\":42858,\"flags\":2,\"fragOffset\":0,\"TTL\":64,\"protocol\":\"TCP\",\"checksum\":33116,\"srcIP\":\"10.157.254.1\",\"dstIP\":\"10.157.254.193\"}}]}\n\n# send a single packet and receive an ack.\n\n{\"timestamp\":1671040295319879439,\"threadStartTime\":341237880436231,\"processorId\":2,\"processId\":3120261,\"cgroupId\":20552,\"threadId\":3120261,\"parentProcessId\":3101489,\"hostProcessId\":3120261,\"hostThreadId\":3120261,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2007\",\"eventName\":\"net_packet_ipv4\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.157.254.1\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.157.254.193\"},{\"name\":\"proto_ipv4\",\"type\":\"trace.ProtoIPv4\",\"value\":{\"version\":4,\"IHL\":5,\"TOS\":0,\"length\":54,\"id\":42859,\"flags\":2,\"fragOffset\":0,\"TTL\":64,\"protocol\":\"TCP\",\"checksum\":33113,\"srcIP\":\"10.157.254.1\",\"dstIP\":\"10.157.254.193\"}}]}\n{\"timestamp\":1671040295320501275,\"threadStartTime\":341237880436231,\"processorId\":15,\"processId\":3120261,\"cgroupId\":20552,\"threadId\":3120261,\"parentProcessId\":3101489,\"hostProcessId\":3120261,\"hostThreadId\":3120261,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2007\",\"eventName\":\"net_packet_ipv4\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.157.254.193\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.157.254.1\"},{\"name\":\"proto_ipv4\",\"type\":\"trace.ProtoIPv4\",\"value\":{\"version\":4,\"IHL\":5,\"TOS\":0,\"length\":52,\"id\":56842,\"flags\":2,\"fragOffset\":0,\"TTL\":64,\"protocol\":\"TCP\",\"checksum\":19132,\"srcIP\":\"10.157.254.193\",\"dstIP\":\"10.157.254.1\"}}]}\n\n# receive a single packet and send an ack.\n\n{\"timestamp\":1671040299925291880,\"threadStartTime\":341237880436231,\"processorId\":5,\"processId\":3120261,\"cgroupId\":20552,\"threadId\":3120261,\"parentProcessId\":3101489,\"hostProcessId\":3120261,\"hostThreadId\":3120261,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2007\",\"eventName\":\"net_packet_ipv4\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.157.254.193\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.157.254.1\"},{\"name\":\"proto_ipv4\",\"type\":\"trace.ProtoIPv4\",\"value\":{\"version\":4,\"IHL\":5,\"TOS\":0,\"length\":54,\"id\":56843,\"flags\":2,\"fragOffset\":0,\"TTL\":64,\"protocol\":\"TCP\",\"checksum\":19129,\"srcIP\":\"10.157.254.193\",\"dstIP\":\"10.157.254.1\"}}]}\n{\"timestamp\":1671040299925385970,\"threadStartTime\":341237880436231,\"processorId\":5,\"processId\":3120261,\"cgroupId\":20552,\"threadId\":3120261,\"parentProcessId\":3101489,\"hostProcessId\":3120261,\"hostThreadId\":3120261,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2007\",\"eventName\":\"net_packet_ipv4\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.157.254.1\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.157.254.193\"},{\"name\":\"proto_ipv4\",\"type\":\"trace.ProtoIPv4\",\"value\":{\"version\":4,\"IHL\":5,\"TOS\":0,\"length\":52,\"id\":42860,\"flags\":2,\"fragOffset\":0,\"TTL\":64,\"protocol\":\"TCP\",\"checksum\":33114,\"srcIP\":\"10.157.254.1\",\"dstIP\":\"10.157.254.193\"}}]}\n</code></pre>"},{"location":"docs/events/builtin/network/#net_packet_ipv6","title":"net_packet_ipv6","text":"<pre><code># three way handshake for a TCP under IPv6 connection.\n\n{\"timestamp\":1671041051949404378,\"threadStartTime\":341999636945074,\"processorId\":10,\"processId\":3141206,\"cgroupId\":20552,\"threadId\":3141206,\"parentProcessId\":3101489,\"hostProcessId\":3141206,\"hostThreadId\":3141206,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2008\",\"eventName\":\"net_packet_ipv6\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"fd6e:a63d:71f:2000::1\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"fd6e:a63d:71f:2000::2\"},{\"name\":\"proto_ipv6\",\"type\":\"trace.ProtoIPv6\",\"value\":{\"version\":6,\"trafficClass\":0,\"flowLabel\":263249,\"length\":40,\"nextHeader\":\"TCP\",\"hopLimit\":64,\"srcIP\":\"fd6e:a63d:71f:2000::1\",\"dstIP\":\"fd6e:a63d:71f:2000::2\"}}]}\n{\"timestamp\":1671041051950428522,\"threadStartTime\":341999636945074,\"processorId\":3,\"processId\":3141206,\"cgroupId\":20552,\"threadId\":3141206,\"parentProcessId\":3101489,\"hostProcessId\":3141206,\"hostThreadId\":3141206,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2008\",\"eventName\":\"net_packet_ipv6\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"fd6e:a63d:71f:2000::2\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"fd6e:a63d:71f:2000::1\"},{\"name\":\"proto_ipv6\",\"type\":\"trace.ProtoIPv6\",\"value\":{\"version\":6,\"trafficClass\":0,\"flowLabel\":917337,\"length\":40,\"nextHeader\":\"TCP\",\"hopLimit\":64,\"srcIP\":\"fd6e:a63d:71f:2000::2\",\"dstIP\":\"fd6e:a63d:71f:2000::1\"}}]}\n{\"timestamp\":1671041051950513760,\"threadStartTime\":341999636945074,\"processorId\":3,\"processId\":3141206,\"cgroupId\":20552,\"threadId\":3141206,\"parentProcessId\":3101489,\"hostProcessId\":3141206,\"hostThreadId\":3141206,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2008\",\"eventName\":\"net_packet_ipv6\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"fd6e:a63d:71f:2000::1\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"fd6e:a63d:71f:2000::2\"},{\"name\":\"proto_ipv6\",\"type\":\"trace.ProtoIPv6\",\"value\":{\"version\":6,\"trafficClass\":0,\"flowLabel\":263249,\"length\":32,\"nextHeader\":\"TCP\",\"hopLimit\":64,\"srcIP\":\"fd6e:a63d:71f:2000::1\",\"dstIP\":\"fd6e:a63d:71f:2000::2\"}}]}\n\n# send a single packet and receive an ack.\n\n{\"timestamp\":1671041054444258140,\"threadStartTime\":341999636945074,\"processorId\":10,\"processId\":3141206,\"cgroupId\":20552,\"threadId\":3141206,\"parentProcessId\":3101489,\"hostProcessId\":3141206,\"hostThreadId\":3141206,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2008\",\"eventName\":\"net_packet_ipv6\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"fd6e:a63d:71f:2000::1\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"fd6e:a63d:71f:2000::2\"},{\"name\":\"proto_ipv6\",\"type\":\"trace.ProtoIPv6\",\"value\":{\"version\":6,\"trafficClass\":0,\"flowLabel\":263249,\"length\":34,\"nextHeader\":\"TCP\",\"hopLimit\":64,\"srcIP\":\"fd6e:a63d:71f:2000::1\",\"dstIP\":\"fd6e:a63d:71f:2000::2\"}}]}\n{\"timestamp\":1671041054444933243,\"threadStartTime\":341999636945074,\"processorId\":19,\"processId\":3141206,\"cgroupId\":20552,\"threadId\":3141206,\"parentProcessId\":3101489,\"hostProcessId\":3141206,\"hostThreadId\":3141206,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2008\",\"eventName\":\"net_packet_ipv6\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"fd6e:a63d:71f:2000::2\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"fd6e:a63d:71f:2000::1\"},{\"name\":\"proto_ipv6\",\"type\":\"trace.ProtoIPv6\",\"value\":{\"version\":6,\"trafficClass\":0,\"flowLabel\":917337,\"length\":32,\"nextHeader\":\"TCP\",\"hopLimit\":64,\"srcIP\":\"fd6e:a63d:71f:2000::2\",\"dstIP\":\"fd6e:a63d:71f:2000::1\"}}]}\n\n# receive a single packet and send an ack.\n\n{\"timestamp\":1671041058522081844,\"threadStartTime\":341999636945074,\"processorId\":3,\"processId\":3141206,\"cgroupId\":20552,\"threadId\":3141206,\"parentProcessId\":3101489,\"hostProcessId\":3141206,\"hostThreadId\":3141206,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2008\",\"eventName\":\"net_packet_ipv6\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"fd6e:a63d:71f:2000::2\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"fd6e:a63d:71f:2000::1\"},{\"name\":\"proto_ipv6\",\"type\":\"trace.ProtoIPv6\",\"value\":{\"version\":6,\"trafficClass\":0,\"flowLabel\":917337,\"length\":34,\"nextHeader\":\"TCP\",\"hopLimit\":64,\"srcIP\":\"fd6e:a63d:71f:2000::2\",\"dstIP\":\"fd6e:a63d:71f:2000::1\"}}]}\n{\"timestamp\":1671041058522149062,\"threadStartTime\":341999636945074,\"processorId\":3,\"processId\":3141206,\"cgroupId\":20552,\"threadId\":3141206,\"parentProcessId\":3101489,\"hostProcessId\":3141206,\"hostThreadId\":3141206,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2008\",\"eventName\":\"net_packet_ipv6\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"fd6e:a63d:71f:2000::1\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"fd6e:a63d:71f:2000::2\"},{\"name\":\"proto_ipv6\",\"type\":\"trace.ProtoIPv6\",\"value\":{\"version\":6,\"trafficClass\":0,\"flowLabel\":263249,\"length\":32,\"nextHeader\":\"TCP\",\"hopLimit\":64,\"srcIP\":\"fd6e:a63d:71f:2000::1\",\"dstIP\":\"fd6e:a63d:71f:2000::2\"}}]}\n</code></pre>"},{"location":"docs/events/builtin/network/#net_packet_tcp","title":"net_packet_tcp","text":"<pre><code># three way handshake for the tcp connection (note SYN and ACK flags).\n\n{\"timestamp\":1671041571396216462,\"threadStartTime\":342519082935538,\"processorId\":12,\"processId\":3156273,\"cgroupId\":20552,\"threadId\":3156273,\"parentProcessId\":3101489,\"hostProcessId\":3156273,\"hostThreadId\":3156273,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2009\",\"eventName\":\"net_packet_tcp\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.157.254.1\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.157.254.193\"},{\"name\":\"proto_tcp\",\"type\":\"trace.ProtoTCP\",\"value\":{\"srcPort\":51594,\"dstPort\":8090,\"seq\":1188220445,\"ack\":0,\"dataOffset\":10,\"FIN\":0,\"SYN\":1,\"RST\":0,\"PSH\":0,\"ACK\":0,\"URG\":0,\"ECE\":0,\"CWR\":0,\"NS\":0,\"window\":64240,\"checksum\":4652,\"urgent\":0}}]}\n{\"timestamp\":1671041571397219944,\"threadStartTime\":342519082935538,\"processorId\":1,\"processId\":3156273,\"cgroupId\":20552,\"threadId\":3156273,\"parentProcessId\":3101489,\"hostProcessId\":3156273,\"hostThreadId\":3156273,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2009\",\"eventName\":\"net_packet_tcp\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.157.254.193\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.157.254.1\"},{\"name\":\"proto_tcp\",\"type\":\"trace.ProtoTCP\",\"value\":{\"srcPort\":8090,\"dstPort\":51594,\"seq\":658038831,\"ack\":1188220446,\"dataOffset\":10,\"FIN\":0,\"SYN\":1,\"RST\":0,\"PSH\":0,\"ACK\":1,\"URG\":0,\"ECE\":0,\"CWR\":0,\"NS\":0,\"window\":65160,\"checksum\":4652,\"urgent\":0}}]}\n{\"timestamp\":1671041571397303639,\"threadStartTime\":342519082935538,\"processorId\":1,\"processId\":3156273,\"cgroupId\":20552,\"threadId\":3156273,\"parentProcessId\":3101489,\"hostProcessId\":3156273,\"hostThreadId\":3156273,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2009\",\"eventName\":\"net_packet_tcp\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.157.254.1\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.157.254.193\"},{\"name\":\"proto_tcp\",\"type\":\"trace.ProtoTCP\",\"value\":{\"srcPort\":51594,\"dstPort\":8090,\"seq\":1188220446,\"ack\":658038832,\"dataOffset\":8,\"FIN\":0,\"SYN\":0,\"RST\":0,\"PSH\":0,\"ACK\":1,\"URG\":0,\"ECE\":0,\"CWR\":0,\"NS\":0,\"window\":502,\"checksum\":4644,\"urgent\":0}}]}\n\n# send a single packet and receive an ack for the sequence.\n\n{\"timestamp\":1671041574116624540,\"threadStartTime\":342519082935538,\"processorId\":20,\"processId\":3156273,\"cgroupId\":20552,\"threadId\":3156273,\"parentProcessId\":3101489,\"hostProcessId\":3156273,\"hostThreadId\":3156273,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2009\",\"eventName\":\"net_packet_tcp\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.157.254.1\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.157.254.193\"},{\"name\":\"proto_tcp\",\"type\":\"trace.ProtoTCP\",\"value\":{\"srcPort\":51594,\"dstPort\":8090,\"seq\":1188220446,\"ack\":658038832,\"dataOffset\":8,\"FIN\":0,\"SYN\":0,\"RST\":0,\"PSH\":1,\"ACK\":1,\"URG\":0,\"ECE\":0,\"CWR\":0,\"NS\":0,\"window\":502,\"checksum\":4646,\"urgent\":0}}]}\n{\"timestamp\":1671041574117560789,\"threadStartTime\":342519082935538,\"processorId\":21,\"processId\":3156273,\"cgroupId\":20552,\"threadId\":3156273,\"parentProcessId\":3101489,\"hostProcessId\":3156273,\"hostThreadId\":3156273,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2009\",\"eventName\":\"net_packet_tcp\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.157.254.193\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.157.254.1\"},{\"name\":\"proto_tcp\",\"type\":\"trace.ProtoTCP\",\"value\":{\"srcPort\":8090,\"dstPort\":51594,\"seq\":658038832,\"ack\":1188220448,\"dataOffset\":8,\"FIN\":0,\"SYN\":0,\"RST\":0,\"PSH\":0,\"ACK\":1,\"URG\":0,\"ECE\":0,\"CWR\":0,\"NS\":0,\"window\":510,\"checksum\":4644,\"urgent\":0}}]}\n\n# receive a single packet and send an ack for the sequence.\n\n{\"timestamp\":1671041577684649596,\"threadStartTime\":342519082935538,\"processorId\":0,\"processId\":3156273,\"cgroupId\":20552,\"threadId\":3156273,\"parentProcessId\":3101489,\"hostProcessId\":3156273,\"hostThreadId\":3156273,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2009\",\"eventName\":\"net_packet_tcp\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.157.254.193\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.157.254.1\"},{\"name\":\"proto_tcp\",\"type\":\"trace.ProtoTCP\",\"value\":{\"srcPort\":8090,\"dstPort\":51594,\"seq\":658038832,\"ack\":1188220448,\"dataOffset\":8,\"FIN\":0,\"SYN\":0,\"RST\":0,\"PSH\":1,\"ACK\":1,\"URG\":0,\"ECE\":0,\"CWR\":0,\"NS\":0,\"window\":510,\"checksum\":4646,\"urgent\":0}}]}\n{\"timestamp\":1671041577684705270,\"threadStartTime\":342519082935538,\"processorId\":0,\"processId\":3156273,\"cgroupId\":20552,\"threadId\":3156273,\"parentProcessId\":3101489,\"hostProcessId\":3156273,\"hostThreadId\":3156273,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2009\",\"eventName\":\"net_packet_tcp\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.157.254.1\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.157.254.193\"},{\"name\":\"proto_tcp\",\"type\":\"trace.ProtoTCP\",\"value\":{\"srcPort\":51594,\"dstPort\":8090,\"seq\":1188220448,\"ack\":658038834,\"dataOffset\":8,\"FIN\":0,\"SYN\":0,\"RST\":0,\"PSH\":0,\"ACK\":1,\"URG\":0,\"ECE\":0,\"CWR\":0,\"NS\":0,\"window\":502,\"checksum\":4644,\"urgent\":0}}]}\n</code></pre>"},{"location":"docs/events/builtin/network/#net_packet_udp","title":"net_packet_udp","text":"<pre><code># send a single packet.\n\n{\"timestamp\":1671041745559197126,\"threadStartTime\":342691388187456,\"processorId\":15,\"processId\":3160590,\"cgroupId\":20552,\"threadId\":3160590,\"parentProcessId\":3101489,\"hostProcessId\":3160590,\"hostThreadId\":3160590,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2010\",\"eventName\":\"net_packet_udp\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.157.254.1\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.157.254.193\"},{\"name\":\"proto_udp\",\"type\":\"trace.ProtoUDP\",\"value\":{\"srcPort\":54370,\"dstPort\":8090,\"length\":10,\"checksum\":4633}}]}\n\n# receive a single packet.\n\n{\"timestamp\":1671041746569025030,\"threadStartTime\":342691388187456,\"processorId\":5,\"processId\":3160590,\"cgroupId\":20552,\"threadId\":3160590,\"parentProcessId\":3101489,\"hostProcessId\":3160590,\"hostThreadId\":3160590,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"nc\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2010\",\"eventName\":\"net_packet_udp\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.157.254.193\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.157.254.1\"},{\"name\":\"proto_udp\",\"type\":\"trace.ProtoUDP\",\"value\":{\"srcPort\":8090,\"dstPort\":54370,\"length\":10,\"checksum\":4633}}]}\n</code></pre>"},{"location":"docs/events/builtin/network/#net_packet_icmp","title":"net_packet_icmp","text":"<pre><code># send an ICMP echo request.\n\n{\"timestamp\":1671041834556860509,\"threadStartTime\":342782244688605,\"processorId\":0,\"processId\":3162824,\"cgroupId\":20552,\"threadId\":3162824,\"parentProcessId\":3101489,\"hostProcessId\":3162824,\"hostThreadId\":3162824,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"ping\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2011\",\"eventName\":\"net_packet_icmp\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.157.254.1\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.157.254.193\"},{\"name\":\"proto_icmp\",\"type\":\"trace.ProtoICMP\",\"value\":{\"typeCode\":\"EchoRequest\",\"checksum\":1592,\"id\":27646,\"seq\":1}}]}\n\n# receive an ICMP echo reply.\n\n{\"timestamp\":1671041834557721951,\"threadStartTime\":342782244688605,\"processorId\":13,\"processId\":3162824,\"cgroupId\":20552,\"threadId\":3162824,\"parentProcessId\":3101489,\"hostProcessId\":3162824,\"hostThreadId\":3162824,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"ping\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2011\",\"eventName\":\"net_packet_icmp\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"10.157.254.193\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"10.157.254.1\"},{\"name\":\"proto_icmp\",\"type\":\"trace.ProtoICMP\",\"value\":{\"typeCode\":\"EchoReply\",\"checksum\":3640,\"id\":27646,\"seq\":1}}]}\n</code></pre>"},{"location":"docs/events/builtin/network/#net_packet_icmpv6","title":"net_packet_icmpv6","text":"<pre><code># send an ICMPv6 echo request.\n\n{\"timestamp\":1671041966651955456,\"threadStartTime\":342914339316549,\"processorId\":13,\"processId\":3166608,\"cgroupId\":20552,\"threadId\":3166608,\"parentProcessId\":3101489,\"hostProcessId\":3166608,\"hostThreadId\":3166608,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"ping\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2012\",\"eventName\":\"net_packet_icmpv6\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"fd6e:a63d:71f:2000::1\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"fd6e:a63d:71f:2000::2\"},{\"name\":\"proto_icmpv6\",\"type\":\"trace.ProtoICMPv6\",\"value\":{\"typeCode\":\"EchoRequest\",\"checksum\":25099}}]}\n\n# receive an ICMPv6 echo reply.\n\n{\"timestamp\":1671041966653079084,\"threadStartTime\":342914339316549,\"processorId\":3,\"processId\":3166608,\"cgroupId\":20552,\"threadId\":3166608,\"parentProcessId\":3101489,\"hostProcessId\":3166608,\"hostThreadId\":3166608,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"ping\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2012\",\"eventName\":\"net_packet_icmpv6\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"fd6e:a63d:71f:2000::2\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"fd6e:a63d:71f:2000::1\"},{\"name\":\"proto_icmpv6\",\"type\":\"trace.ProtoICMPv6\",\"value\":{\"typeCode\":\"EchoReply\",\"checksum\":24843}}]}\n</code></pre>"},{"location":"docs/events/builtin/network/#net_packet_dns","title":"net_packet_dns","text":"<pre><code># query type=A from nslookup to local systemd-resolved.\n\n{\"timestamp\":1671042316117498783,\"threadStartTime\":343263806334087,\"processorId\":7,\"processId\":3179904,\"cgroupId\":20552,\"threadId\":3179905,\"parentProcessId\":3101489,\"hostProcessId\":3179904,\"hostThreadId\":3179905,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"isc-net-0000\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2013\",\"eventName\":\"net_packet_dns\",\"argsNum\":5,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"127.0.0.1\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"127.0.0.53\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":42752},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":53},{\"name\":\"proto_dns\",\"type\":\"trace.ProtoDNS\",\"value\":{\"ID\":52902,\"QR\":0,\"opCode\":\"query\",\"AA\":0,\"TC\":0,\"RD\":1,\"RA\":0,\"Z\":0,\"responseCode\":\"no error\",\"QDCount\":1,\"ANCount\":0,\"NSCount\":0,\"ARCount\":0,\"questions\":[{\"name\":\"www.uol.com.br\",\"type\":\"A\",\"class\":\"IN\"}],\"answers\":[],\"authorities\":[],\"additionals\":[]}}]}\n\n# response from systemd-resolved to nslookup (after querying default nameserver).\n# response contains original query and multiple answers to the query.\n\n{\"timestamp\":1671042316131226611,\"threadStartTime\":343263806334087,\"processorId\":10,\"processId\":3179904,\"cgroupId\":20552,\"threadId\":3179905,\"parentProcessId\":3101489,\"hostProcessId\":3179904,\"hostThreadId\":3179905,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"isc-net-0000\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2013\",\"eventName\":\"net_packet_dns\",\"argsNum\":5,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"127.0.0.53\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"127.0.0.1\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":53},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":42752},{\"name\":\"proto_dns\",\"type\":\"trace.ProtoDNS\",\"value\":{\"ID\":52902,\"QR\":1,\"opCode\":\"query\",\"AA\":0,\"TC\":0,\"RD\":1,\"RA\":1,\"Z\":0,\"responseCode\":\"no error\",\"QDCount\":1,\"ANCount\":5,\"NSCount\":0,\"ARCount\":0,\"questions\":[{\"name\":\"www.uol.com.br\",\"type\":\"A\",\"class\":\"IN\"}],\"answers\":[{\"name\":\"www.uol.com.br\",\"type\":\"CNAME\",\"class\":\"IN\",\"TTL\":43,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"dftex7xfha8fh.cloudfront.net\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"dftex7xfha8fh.cloudfront.net\",\"type\":\"A\",\"class\":\"IN\",\"TTL\":55,\"IP\":\"65.8.214.126\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"dftex7xfha8fh.cloudfront.net\",\"type\":\"A\",\"class\":\"IN\",\"TTL\":55,\"IP\":\"65.8.214.78\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"dftex7xfha8fh.cloudfront.net\",\"type\":\"A\",\"class\":\"IN\",\"TTL\":55,\"IP\":\"65.8.214.70\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"dftex7xfha8fh.cloudfront.net\",\"type\":\"A\",\"class\":\"IN\",\"TTL\":55,\"IP\":\"65.8.214.49\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}],\"authorities\":[],\"additionals\":[]}}]}\n\n# query type=MX from nslookup to local systemd-resolved.\n\n{\"timestamp\":1671042491079309907,\"threadStartTime\":343438768169717,\"processorId\":1,\"processId\":3183907,\"cgroupId\":20552,\"threadId\":3183908,\"parentProcessId\":3101489,\"hostProcessId\":3183907,\"hostThreadId\":3183908,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"isc-net-0000\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2013\",\"eventName\":\"net_packet_dns\",\"argsNum\":5,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"127.0.0.1\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"127.0.0.53\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":34981},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":53},{\"name\":\"proto_dns\",\"type\":\"trace.ProtoDNS\",\"value\":{\"ID\":33920,\"QR\":0,\"opCode\":\"query\",\"AA\":0,\"TC\":0,\"RD\":1,\"RA\":0,\"Z\":0,\"responseCode\":\"no error\",\"QDCount\":1,\"ANCount\":0,\"NSCount\":0,\"ARCount\":0,\"questions\":[{\"name\":\"uol.com.br\",\"type\":\"MX\",\"class\":\"IN\"}],\"answers\":[],\"authorities\":[],\"additionals\":[]}}]}\n\n# response from systemd-resolved to nslookup containing original MX query and the MX answer.\n\n{\"timestamp\":1671042491090381166,\"threadStartTime\":343438768169717,\"processorId\":10,\"processId\":3183907,\"cgroupId\":20552,\"threadId\":3183908,\"parentProcessId\":3101489,\"hostProcessId\":3183907,\"hostThreadId\":3183908,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"isc-net-0000\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2013\",\"eventName\":\"net_packet_dns\",\"argsNum\":5,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"127.0.0.53\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"127.0.0.1\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":53},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":34981},{\"name\":\"proto_dns\",\"type\":\"trace.ProtoDNS\",\"value\":{\"ID\":33920,\"QR\":1,\"opCode\":\"query\",\"AA\":0,\"TC\":0,\"RD\":1,\"RA\":1,\"Z\":0,\"responseCode\":\"no error\",\"QDCount\":1,\"ANCount\":1,\"NSCount\":0,\"ARCount\":0,\"questions\":[{\"name\":\"uol.com.br\",\"type\":\"MX\",\"class\":\"IN\"}],\"answers\":[{\"name\":\"uol.com.br\",\"type\":\"MX\",\"class\":\"IN\",\"TTL\":17618,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":10,\"name\":\"mx.uol.com.br\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}],\"authorities\":[],\"additionals\":[]}}]}\n</code></pre>"},{"location":"docs/events/builtin/network/#net_packet_dns_request","title":"net_packet_dns_request","text":"<pre><code># query type=A from nslookup to local systemd-resolved.\n# this event does not contain all DNS header fields as the net_packet_dns does.\n\n{\"timestamp\":1671043215487322928,\"threadStartTime\":344163176158597,\"processorId\":5,\"processId\":3200575,\"cgroupId\":20552,\"threadId\":3200576,\"parentProcessId\":3101489,\"hostProcessId\":3200575,\"hostThreadId\":3200576,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"isc-net-0000\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2014\",\"eventName\":\"net_packet_dns_request\",\"argsNum\":2,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"metadata\",\"type\":\"trace.PktMeta\",\"value\":{\"src_ip\":\"127.0.0.1\",\"dst_ip\":\"127.0.0.53\",\"src_port\":46259,\"dst_port\":53,\"protocol\":17,\"packet_len\":60,\"iface\":\"any\"}},{\"name\":\"dns_questions\",\"type\":\"[]trace.DnsQueryData\",\"value\":[{\"query\":\"www.uol.com.br\",\"query_type\":\"A\",\"query_class\":\"IN\"}]}]}\n{\"timestamp\":1671043215503932068,\"threadStartTime\":344163176158597,\"processorId\":10,\"processId\":3200575,\"cgroupId\":20552,\"threadId\":3200576,\"parentProcessId\":3101489,\"hostProcessId\":3200575,\"hostThreadId\":3200576,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"isc-net-0000\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2014\",\"eventName\":\"net_packet_dns_request\",\"argsNum\":2,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"metadata\",\"type\":\"trace.PktMeta\",\"value\":{\"src_ip\":\"127.0.0.53\",\"dst_ip\":\"127.0.0.1\",\"src_port\":53,\"dst_port\":46259,\"protocol\":17,\"packet_len\":166,\"iface\":\"any\"}},{\"name\":\"dns_questions\",\"type\":\"[]trace.DnsQueryData\",\"value\":[{\"query\":\"www.uol.com.br\",\"query_type\":\"A\",\"query_class\":\"IN\"}]}]}\n</code></pre> <p>Attention</p> <p>The <code>net_packet_dns_request</code> event is an event that is backwards compatible with an existing event called <code>dns_request</code>. The intention to have such event is to allow existing signatures already relying in the <code>dns_request</code> event, to rely in the new <code>net_packet_dns_request</code>. The benefit for the new event is that, differently from the <code>dns_request</code> event, there is no need to set an interface to monitor events when monitoring <code>net_packet_dns_request</code>. It gets DNS events from all existing interfaces and filters applied.</p> <p>Important</p> <p>This event might be deprecated or have its argument types changed in future versions.</p>"},{"location":"docs/events/builtin/network/#net_packet_response","title":"net_packet_response","text":"<pre><code># response from systemd-resolved to nslookup (after querying default nameserver).\n# response contains original query and multiple answers to the query.\n# this event does not contain all DNS header fields as the net_packet_dns does.\n\n{\"timestamp\":1671043317719969041,\"threadStartTime\":344265391016498,\"processorId\":10,\"processId\":3203040,\"cgroupId\":20552,\"threadId\":3203041,\"parentProcessId\":3101489,\"hostProcessId\":3203040,\"hostThreadId\":3203041,\"hostParentProcessId\":3101489,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"isc-net-0000\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2015\",\"eventName\":\"net_packet_dns_response\",\"argsNum\":2,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"metadata\",\"type\":\"trace.PktMeta\",\"value\":{\"src_ip\":\"127.0.0.53\",\"dst_ip\":\"127.0.0.1\",\"src_port\":53,\"dst_port\":41373,\"protocol\":17,\"packet_len\":166,\"iface\":\"any\"}},{\"name\":\"dns_response\",\"type\":\"[]trace.DnsResponseData\",\"value\":[{\"query_data\":{\"query\":\"www.uol.com.br\",\"query_type\":\"A\",\"query_class\":\"IN\"},\"dns_answer\":[{\"answer_type\":\"CNAME\",\"ttl\":22,\"answer\":\"dftex7xfha8fh.cloudfront.net\"},{\"answer_type\":\"A\",\"ttl\":60,\"answer\":\"65.8.214.126\"},{\"answer_type\":\"A\",\"ttl\":60,\"answer\":\"65.8.214.70\"},{\"answer_type\":\"A\",\"ttl\":60,\"answer\":\"65.8.214.49\"},{\"answer_type\":\"A\",\"ttl\":60,\"answer\":\"65.8.214.78\"}]}]}]}\n</code></pre> <p>Attention</p> <p>The <code>net_packet_dns_response</code> event is an event that is backwards compatible with an existing event called <code>dns_response</code>. The intention to have such event is to allow existing signatures already relying in the <code>dns_response</code> event, to rely in the new <code>net_packet_dns_response</code>. The benefit for the new event is that, differently from the <code>dns_response</code> event, there is no need to set an interface to monitor events when monitoring <code>net_packet_dns_response</code>. It gets DNS events from all existing interfaces and filters applied.</p> <p>Important</p> <p>This event might be deprecated or have its argument types changed in future versions.</p>"},{"location":"docs/events/builtin/network/#network-event-filtering","title":"Network Event Filtering","text":"<p>Supported</p> <p>For now it is NOT possible to filter the events through the header fields, but it IS possible, and recommended, to filter the events through <code>src</code>, <code>dest</code> fields. Not filtering network events might be hard to consume because of the amount of traced events.</p> <p>Trace all TCP packets sent to port 80 anywhere, from any process:</p> <pre><code>tracee --output json --events net_packet_tcp.args.dst_port=80\n</code></pre> <pre><code>{\"timestamp\":1671149983169847976,\"threadStartTime\":450930828307685,\"processorId\":22,\"processId\":1284215,\"cgroupId\":27149,\"threadId\":1284215,\"parentProcessId\":1268815,\"hostProcessId\":1284215,\"hostThreadId\":1284215,\"hostParentProcessId\":1268815,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"w3m\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2009\",\"eventName\":\"net_packet_tcp\",\"argsNum\":5,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"192.168.100.2\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"200.147.3.157\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":46594},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":80},{\"name\":\"proto_tcp\",\"type\":\"trace.ProtoTCP\",\"value\":{\"srcPort\":46594,\"dstPort\":80,\"seq\":3415564579,\"ack\":0,\"dataOffset\":10,\"FIN\":0,\"SYN\":1,\"RST\":0,\"PSH\":0,\"ACK\":0,\"URG\":0,\"ECE\":0,\"CWR\":0,\"NS\":0,\"window\":64240,\"checksum\":61705,\"urgent\":0}}]}\n{\"timestamp\":1671149983178147951,\"threadStartTime\":450930828307685,\"processorId\":23,\"processId\":1284215,\"cgroupId\":27149,\"threadId\":1284215,\"parentProcessId\":1268815,\"hostProcessId\":1284215,\"hostThreadId\":1284215,\"hostParentProcessId\":1268815,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"w3m\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2009\",\"eventName\":\"net_packet_tcp\",\"argsNum\":5,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"192.168.100.2\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"200.147.3.157\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":46594},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":80},{\"name\":\"proto_tcp\",\"type\":\"trace.ProtoTCP\",\"value\":{\"srcPort\":46594,\"dstPort\":80,\"seq\":3415564580,\"ack\":1519583696,\"dataOffset\":8,\"FIN\":0,\"SYN\":0,\"RST\":0,\"PSH\":0,\"ACK\":1,\"URG\":0,\"ECE\":0,\"CWR\":0,\"NS\":0,\"window\":502,\"checksum\":61697,\"urgent\":0}}]}\n{\"timestamp\":1671149983178263829,\"threadStartTime\":450930828307685,\"processorId\":22,\"processId\":1284215,\"cgroupId\":27149,\"threadId\":1284215,\"parentProcessId\":1268815,\"hostProcessId\":1284215,\"hostThreadId\":1284215,\"hostParentProcessId\":1268815,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"w3m\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2009\",\"eventName\":\"net_packet_tcp\",\"argsNum\":5,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"192.168.100.2\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"200.147.3.157\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":46594},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":80},{\"name\":\"proto_tcp\",\"type\":\"trace.ProtoTCP\",\"value\":{\"srcPort\":46594,\"dstPort\":80,\"seq\":3415564580,\"ack\":1519583696,\"dataOffset\":8,\"FIN\":0,\"SYN\":0,\"RST\":0,\"PSH\":1,\"ACK\":1,\"URG\":0,\"ECE\":0,\"CWR\":0,\"NS\":0,\"window\":502,\"checksum\":61907,\"urgent\":0}}]}\n</code></pre> <p>Trace all DNS packets received ONLY from Google DNS server '8.8.8.8':</p> <pre><code>tracee --output json --events net_packet_dns.args.src=8.8.8.8\n</code></pre> <p>(only systemd-resolved, since all the other processes are resolving using local systemd-resolved server <code>127.0.1.1:53</code>):</p> <pre><code>{\"timestamp\":1671044490960363328,\"threadStartTime\":17862285588,\"processorId\":5,\"processId\":1016,\"cgroupId\":2847,\"threadId\":1016,\"parentProcessId\":1,\"hostProcessId\":1016,\"hostThreadId\":1016,\"hostParentProcessId\":1,\"userId\":104,\"mountNamespace\":4026533212,\"pidNamespace\":4026531836,\"processName\":\"systemd-resolve\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2013\",\"eventName\":\"net_packet_dns\",\"argsNum\":5,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"8.8.8.8\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"192.168.100.2\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":53},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":57278},{\"name\":\"proto_dns\",\"type\":\"trace.ProtoDNS\",\"value\":{\"ID\":45141,\"QR\":1,\"opCode\":\"query\",\"AA\":0,\"TC\":0,\"RD\":1,\"RA\":1,\"Z\":0,\"responseCode\":\"no error\",\"QDCount\":1,\"ANCount\":0,\"NSCount\":1,\"ARCount\":1,\"questions\":[{\"name\":\"github.com\",\"type\":\"AAAA\",\"class\":\"IN\"}],\"answers\":[],\"authorities\":[{\"name\":\"github.com\",\"type\":\"SOA\",\"class\":\"IN\",\"TTL\":2,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"ns-1707.awsdns-21.co.uk\",\"RName\":\"awsdns-hostmaster.amazon.com\",\"serial\":1,\"refresh\":7200,\"retry\":900,\"expire\":1209600,\"minimum\":86400},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}],\"additionals\":[{\"name\":\"\",\"type\":\"OPT\",\"class\":\"Unknown\",\"TTL\":0,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}]}}]}\n{\"timestamp\":1671044491458692167,\"threadStartTime\":17862285588,\"processorId\":5,\"processId\":1016,\"cgroupId\":2847,\"threadId\":1016,\"parentProcessId\":1,\"hostProcessId\":1016,\"hostThreadId\":1016,\"hostParentProcessId\":1,\"userId\":104,\"mountNamespace\":4026533212,\"pidNamespace\":4026531836,\"processName\":\"systemd-resolve\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2013\",\"eventName\":\"net_packet_dns\",\"argsNum\":5,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"8.8.8.8\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"192.168.100.2\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":53},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":44834},{\"name\":\"proto_dns\",\"type\":\"trace.ProtoDNS\",\"value\":{\"ID\":60536,\"QR\":1,\"opCode\":\"query\",\"AA\":0,\"TC\":0,\"RD\":1,\"RA\":1,\"Z\":0,\"responseCode\":\"no error\",\"QDCount\":1,\"ANCount\":1,\"NSCount\":0,\"ARCount\":1,\"questions\":[{\"name\":\"github.com\",\"type\":\"A\",\"class\":\"IN\"}],\"answers\":[{\"name\":\"github.com\",\"type\":\"A\",\"class\":\"IN\",\"TTL\":60,\"IP\":\"20.201.28.151\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}],\"authorities\":[],\"additionals\":[{\"name\":\"\",\"type\":\"OPT\",\"class\":\"Unknown\",\"TTL\":0,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}]}}]}\n{\"timestamp\":1671044592138383113,\"threadStartTime\":17862285588,\"processorId\":5,\"processId\":1016,\"cgroupId\":2847,\"threadId\":1016,\"parentProcessId\":1,\"hostProcessId\":1016,\"hostThreadId\":1016,\"hostParentProcessId\":1,\"userId\":104,\"mountNamespace\":4026533212,\"pidNamespace\":4026531836,\"processName\":\"systemd-resolve\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2013\",\"eventName\":\"net_packet_dns\",\"argsNum\":5,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"8.8.8.8\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"192.168.100.2\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":53},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":44265},{\"name\":\"proto_dns\",\"type\":\"trace.ProtoDNS\",\"value\":{\"ID\":22103,\"QR\":1,\"opCode\":\"query\",\"AA\":0,\"TC\":0,\"RD\":1,\"RA\":1,\"Z\":0,\"responseCode\":\"no error\",\"QDCount\":1,\"ANCount\":1,\"NSCount\":0,\"ARCount\":1,\"questions\":[{\"name\":\"github.com\",\"type\":\"A\",\"class\":\"IN\"}],\"answers\":[{\"name\":\"github.com\",\"type\":\"A\",\"class\":\"IN\",\"TTL\":60,\"IP\":\"20.201.28.151\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}],\"authorities\":[],\"additionals\":[{\"name\":\"\",\"type\":\"OPT\",\"class\":\"Unknown\",\"TTL\":0,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}]}}]}\n{\"timestamp\":1671044592139849906,\"threadStartTime\":17862285588,\"processorId\":5,\"processId\":1016,\"cgroupId\":2847,\"threadId\":1016,\"parentProcessId\":1,\"hostProcessId\":1016,\"hostThreadId\":1016,\"hostParentProcessId\":1,\"userId\":104,\"mountNamespace\":4026533212,\"pidNamespace\":4026531836,\"processName\":\"systemd-resolve\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2013\",\"eventName\":\"net_packet_dns\",\"argsNum\":5,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"8.8.8.8\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"192.168.100.2\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":53},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":53099},{\"name\":\"proto_dns\",\"type\":\"trace.ProtoDNS\",\"value\":{\"ID\":55518,\"QR\":1,\"opCode\":\"query\",\"AA\":0,\"TC\":0,\"RD\":1,\"RA\":1,\"Z\":0,\"responseCode\":\"no error\",\"QDCount\":1,\"ANCount\":0,\"NSCount\":1,\"ARCount\":1,\"questions\":[{\"name\":\"github.com\",\"type\":\"AAAA\",\"class\":\"IN\"}],\"answers\":[],\"authorities\":[{\"name\":\"github.com\",\"type\":\"SOA\",\"class\":\"IN\",\"TTL\":398,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"ns-1707.awsdns-21.co.uk\",\"RName\":\"awsdns-hostmaster.amazon.com\",\"serial\":1,\"refresh\":7200,\"retry\":900,\"expire\":1209600,\"minimum\":86400},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}],\"additionals\":[{\"name\":\"\",\"type\":\"OPT\",\"class\":\"Unknown\",\"TTL\":0,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}]}}]}\n{\"timestamp\":1671044593058863894,\"threadStartTime\":17862285588,\"processorId\":5,\"processId\":1016,\"cgroupId\":2847,\"threadId\":1016,\"parentProcessId\":1,\"hostProcessId\":1016,\"hostThreadId\":1016,\"hostParentProcessId\":1,\"userId\":104,\"mountNamespace\":4026533212,\"pidNamespace\":4026531836,\"processName\":\"systemd-resolve\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2013\",\"eventName\":\"net_packet_dns\",\"argsNum\":5,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"8.8.8.8\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"192.168.100.2\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":53},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":51112},{\"name\":\"proto_dns\",\"type\":\"trace.ProtoDNS\",\"value\":{\"ID\":64479,\"QR\":1,\"opCode\":\"query\",\"AA\":0,\"TC\":0,\"RD\":1,\"RA\":1,\"Z\":0,\"responseCode\":\"no error\",\"QDCount\":1,\"ANCount\":2,\"NSCount\":0,\"ARCount\":1,\"questions\":[{\"name\":\"star-actions-githubusercontent-com.l-0007.l-msedge.net\",\"type\":\"AAAA\",\"class\":\"IN\"}],\"answers\":[{\"name\":\"star-actions-githubusercontent-com.l-0007.l-msedge.net\",\"type\":\"CNAME\",\"class\":\"IN\",\"TTL\":149,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"l-0007.l-msedge.net\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"l-0007.l-msedge.net\",\"type\":\"AAAA\",\"class\":\"IN\",\"TTL\":149,\"IP\":\"2620:1ec:21::16\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}],\"authorities\":[],\"additionals\":[{\"name\":\"\",\"type\":\"OPT\",\"class\":\"Unknown\",\"TTL\":0,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}]}}]}\n{\"timestamp\":1671044593059043810,\"threadStartTime\":17862285588,\"processorId\":5,\"processId\":1016,\"cgroupId\":2847,\"threadId\":1016,\"parentProcessId\":1,\"hostProcessId\":1016,\"hostThreadId\":1016,\"hostParentProcessId\":1,\"userId\":104,\"mountNamespace\":4026533212,\"pidNamespace\":4026531836,\"processName\":\"systemd-resolve\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2013\",\"eventName\":\"net_packet_dns\",\"argsNum\":5,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"8.8.8.8\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"192.168.100.2\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":53},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":51952},{\"name\":\"proto_dns\",\"type\":\"trace.ProtoDNS\",\"value\":{\"ID\":4355,\"QR\":1,\"opCode\":\"query\",\"AA\":0,\"TC\":0,\"RD\":1,\"RA\":1,\"Z\":0,\"responseCode\":\"no error\",\"QDCount\":1,\"ANCount\":1,\"NSCount\":0,\"ARCount\":1,\"questions\":[{\"name\":\"l-0007.l-msedge.net\",\"type\":\"AAAA\",\"class\":\"IN\"}],\"answers\":[{\"name\":\"l-0007.l-msedge.net\",\"type\":\"AAAA\",\"class\":\"IN\",\"TTL\":105,\"IP\":\"2620:1ec:21::16\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}],\"authorities\":[],\"additionals\":[{\"name\":\"\",\"type\":\"OPT\",\"class\":\"Unknown\",\"TTL\":0,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}]}}]}\n{\"timestamp\":1671044594595474660,\"threadStartTime\":17862285588,\"processorId\":5,\"processId\":1016,\"cgroupId\":2847,\"threadId\":1016,\"parentProcessId\":1,\"hostProcessId\":1016,\"hostThreadId\":1016,\"hostParentProcessId\":1,\"userId\":104,\"mountNamespace\":4026533212,\"pidNamespace\":4026531836,\"processName\":\"systemd-resolve\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2013\",\"eventName\":\"net_packet_dns\",\"argsNum\":5,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"8.8.8.8\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"192.168.100.2\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":53},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":57386},{\"name\":\"proto_dns\",\"type\":\"trace.ProtoDNS\",\"value\":{\"ID\":50508,\"QR\":1,\"opCode\":\"query\",\"AA\":0,\"TC\":0,\"RD\":1,\"RA\":1,\"Z\":0,\"responseCode\":\"no error\",\"QDCount\":1,\"ANCount\":3,\"NSCount\":0,\"ARCount\":1,\"questions\":[{\"name\":\"pipelines.actions.githubusercontent.com\",\"type\":\"A\",\"class\":\"IN\"}],\"answers\":[{\"name\":\"pipelines.actions.githubusercontent.com\",\"type\":\"CNAME\",\"class\":\"IN\",\"TTL\":3395,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"star-actions-githubusercontent-com.l-0007.l-msedge.net\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"star-actions-githubusercontent-com.l-0007.l-msedge.net\",\"type\":\"CNAME\",\"class\":\"IN\",\"TTL\":35,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"l-0007.l-msedge.net\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"l-0007.l-msedge.net\",\"type\":\"A\",\"class\":\"IN\",\"TTL\":35,\"IP\":\"13.107.42.16\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}],\"authorities\":[],\"additionals\":[{\"name\":\"\",\"type\":\"OPT\",\"class\":\"Unknown\",\"TTL\":0,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}]}}]}\n{\"timestamp\":1671044594596611226,\"threadStartTime\":17862285588,\"processorId\":5,\"processId\":1016,\"cgroupId\":2847,\"threadId\":1016,\"parentProcessId\":1,\"hostProcessId\":1016,\"hostThreadId\":1016,\"hostParentProcessId\":1,\"userId\":104,\"mountNamespace\":4026533212,\"pidNamespace\":4026531836,\"processName\":\"systemd-resolve\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2013\",\"eventName\":\"net_packet_dns\",\"argsNum\":5,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"8.8.8.8\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"192.168.100.2\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":53},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":47545},{\"name\":\"proto_dns\",\"type\":\"trace.ProtoDNS\",\"value\":{\"ID\":44968,\"QR\":1,\"opCode\":\"query\",\"AA\":0,\"TC\":0,\"RD\":1,\"RA\":1,\"Z\":0,\"responseCode\":\"no error\",\"QDCount\":1,\"ANCount\":3,\"NSCount\":0,\"ARCount\":1,\"questions\":[{\"name\":\"pipelines.actions.githubusercontent.com\",\"type\":\"AAAA\",\"class\":\"IN\"}],\"answers\":[{\"name\":\"pipelines.actions.githubusercontent.com\",\"type\":\"CNAME\",\"class\":\"IN\",\"TTL\":2771,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"star-actions-githubusercontent-com.l-0007.l-msedge.net\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"star-actions-githubusercontent-com.l-0007.l-msedge.net\",\"type\":\"CNAME\",\"class\":\"IN\",\"TTL\":115,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"l-0007.l-msedge.net\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"},{\"name\":\"l-0007.l-msedge.net\",\"type\":\"AAAA\",\"class\":\"IN\",\"TTL\":119,\"IP\":\"2620:1ec:21::16\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}],\"authorities\":[],\"additionals\":[{\"name\":\"\",\"type\":\"OPT\",\"class\":\"Unknown\",\"TTL\":0,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}]}}]}\n{\"timestamp\":1671044595955957557,\"threadStartTime\":17862285588,\"processorId\":5,\"processId\":1016,\"cgroupId\":2847,\"threadId\":1016,\"parentProcessId\":1,\"hostProcessId\":1016,\"hostThreadId\":1016,\"hostParentProcessId\":1,\"userId\":104,\"mountNamespace\":4026533212,\"pidNamespace\":4026531836,\"processName\":\"systemd-resolve\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2013\",\"eventName\":\"net_packet_dns\",\"argsNum\":5,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"8.8.8.8\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"192.168.100.2\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":53},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":42588},{\"name\":\"proto_dns\",\"type\":\"trace.ProtoDNS\",\"value\":{\"ID\":46878,\"QR\":1,\"opCode\":\"query\",\"AA\":0,\"TC\":0,\"RD\":1,\"RA\":1,\"Z\":0,\"responseCode\":\"no error\",\"QDCount\":1,\"ANCount\":1,\"NSCount\":0,\"ARCount\":1,\"questions\":[{\"name\":\"mx.uol.com.br\",\"type\":\"A\",\"class\":\"IN\"}],\"answers\":[{\"name\":\"mx.uol.com.br\",\"type\":\"A\",\"class\":\"IN\",\"TTL\":21233,\"IP\":\"200.147.41.231\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}],\"authorities\":[],\"additionals\":[{\"name\":\"\",\"type\":\"OPT\",\"class\":\"Unknown\",\"TTL\":0,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}]}}]}\n{\"timestamp\":1671044595958021940,\"threadStartTime\":17862285588,\"processorId\":5,\"processId\":1016,\"cgroupId\":2847,\"threadId\":1016,\"parentProcessId\":1,\"hostProcessId\":1016,\"hostThreadId\":1016,\"hostParentProcessId\":1,\"userId\":104,\"mountNamespace\":4026533212,\"pidNamespace\":4026531836,\"processName\":\"systemd-resolve\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"2013\",\"eventName\":\"net_packet_dns\",\"argsNum\":5,\"returnValue\":0,\"stackAddresses\":[0],\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"src\",\"type\":\"const char*\",\"value\":\"8.8.8.8\"},{\"name\":\"dst\",\"type\":\"const char*\",\"value\":\"192.168.100.2\"},{\"name\":\"src_port\",\"type\":\"u16\",\"value\":53},{\"name\":\"dst_port\",\"type\":\"u16\",\"value\":57033},{\"name\":\"proto_dns\",\"type\":\"trace.ProtoDNS\",\"value\":{\"ID\":61528,\"QR\":1,\"opCode\":\"query\",\"AA\":0,\"TC\":0,\"RD\":1,\"RA\":1,\"Z\":0,\"responseCode\":\"no error\",\"QDCount\":1,\"ANCount\":1,\"NSCount\":0,\"ARCount\":1,\"questions\":[{\"name\":\"mx.uol.com.br\",\"type\":\"A\",\"class\":\"IN\"}],\"answers\":[{\"name\":\"mx.uol.com.br\",\"type\":\"A\",\"class\":\"IN\",\"TTL\":20920,\"IP\":\"200.147.41.231\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}],\"authorities\":[],\"additionals\":[{\"name\":\"\",\"type\":\"OPT\",\"class\":\"Unknown\",\"TTL\":0,\"IP\":\"\",\"NS\":\"\",\"CNAME\":\"\",\"PTR\":\"\",\"TXTs\":null,\"SOA\":{\"MName\":\"\",\"RName\":\"\",\"serial\":0,\"refresh\":0,\"retry\":0,\"expire\":0,\"minimum\":0},\"SRV\":{\"priority\":0,\"weight\":0,\"port\":0,\"name\":\"\"},\"MX\":{\"preference\":0,\"name\":\"\"},\"OPT\":[],\"URI\":{\"priority\":0,\"weight\":0,\"target\":\"\"},\"TXT\":\"\"}]}}]}\n</code></pre>"},{"location":"docs/events/builtin/network/#network-based-signatures","title":"Network Based Signatures","text":"<p>It is possible to create Golang (or Rego) signatures for the network events. If you haven't read about how to create signatures, do it HERE.</p> <p>Examples</p> <p>Below is an example of how to create a signature for the <code>net_packet_dns</code> event. This same example is used by Tracee CI/CD tests and can be found at the GitHub repository, together with some other signatures for the network events.</p> <ol> <li>net_packet_dns signature example</li> </ol> <pre><code>package main\n\nimport (\n\"fmt\"\n\"strings\"\n\n\"github.com/aquasecurity/tracee/signatures/helpers\"\n\"github.com/aquasecurity/tracee/types/detect\"\n\"github.com/aquasecurity/tracee/types/protocol\"\n\"github.com/aquasecurity/tracee/types/trace\"\n)\n\n//\n// HOWTO: The way to trigger this test signature is to execute:\n//\n//        nslookup -type=mx uol.com.br      and then\n//        nslookup -type=ns uol.com.br      and then\n//        nslookup -type=soa uol.com.br     and then\n//        nslookup -type=txt uol.com.br\n//\n//        This will cause it trigger once and reset it status.\n\ntype e2eDNS struct {\nfoundMX   bool\nfoundNS   bool\nfoundSOA  bool\nfoundTXTs bool\ncb        detect.SignatureHandler\n}\n\nfunc (sig *e2eDNS) Init(cb detect.SignatureHandler) error {\nsig.cb = cb\nsig.foundMX = false   // proforma\nsig.foundNS = false   // proforma\nsig.foundSOA = false  // proforma\nsig.foundTXTs = false // proforma\nreturn nil\n}\n\nfunc (sig *e2eDNS) GetMetadata() (detect.SignatureMetadata, error) {\nreturn detect.SignatureMetadata{\nID:          \"DNS\",\nVersion:     \"0.1.0\",\nName:        \"Network DNS Test\",\nDescription: \"Network E2E Tests: DNS\",\nTags:        []string{\"e2e\", \"network\"},\n}, nil\n}\n\nfunc (sig *e2eDNS) GetSelectedEvents() ([]detect.SignatureEventSelector, error) {\nreturn []detect.SignatureEventSelector{\n{Source: \"tracee\", Name: \"net_packet_dns\"},\n}, nil\n}\n\nfunc (sig *e2eDNS) OnEvent(event protocol.Event) error {\neventObj, ok := event.Payload.(trace.Event)\nif !ok {\nreturn fmt.Errorf(\"failed to cast event's payload\")\n}\n\nif eventObj.EventName == \"net_packet_dns\" {\ndns, err := helpers.GetProtoDNSByName(eventObj, \"proto_dns\")\nif err != nil {\nreturn err\n}\n\nif len(dns.Answers) &gt; 0 {\nfor _, answer := range dns.Answers {\n// check if MX works\nif answer.MX.Name == \"mx.uol.com.br\" &amp;&amp; answer.MX.Preference == 10 {\nsig.foundMX = true\n}\n// check if NS works\nif answer.NS == \"eliot.uol.com.br\" {\nsig.foundNS = true\n}\n// check if SOA works\nif answer.SOA.RName == \"root.uol.com.br\" {\nsig.foundSOA = true\n}\n// check if TXTs works\nif answer.TXTs != nil &amp;&amp; len(answer.TXTs) &gt; 0 {\nfor _, txt := range answer.TXTs {\nif strings.Contains(txt, \"spf.uol.com.br\") {\nsig.foundTXTs = true\n}\n}\n}\n}\n}\n\nif !sig.foundMX || !sig.foundNS || !sig.foundSOA || !sig.foundTXTs {\nreturn nil\n}\n\nif sig.foundMX &amp;&amp; sig.foundNS &amp;&amp; sig.foundSOA &amp;&amp; sig.foundTXTs { // reset signature state\nsig.foundMX = false\nsig.foundNS = false\nsig.foundSOA = false\nsig.foundTXTs = false\n}\n\nm, _ := sig.GetMetadata()\n\nsig.cb(detect.Finding{\nSigMetadata: m,\nEvent:       event,\nData:        map[string]interface{}{},\n})\n}\n\nreturn nil\n}\n\nfunc (sig *e2eDNS) OnSignal(s detect.Signal) error {\nreturn nil\n}\n\nfunc (sig *e2eDNS) Close() {}\n</code></pre>"},{"location":"docs/events/builtin/signatures/","title":"Behavioral Signatures","text":"<p>Tracee has a library of behavioral patterns that might indicate suspicious malicious activity. These Tracee events, sometimes referred to as \"signatures\" help you detect more sophisticated security insights than basic observability events like syscalls. The following is a list of all available signatures:</p> Name Description Full Description TRC-101 Process standard input/output over socket detected A process has its standard input/output redirected to a socket. This behaviour is the base of a Reverse Shell attack, which is when an interactive shell being invoked from a target machine back to the attacker's machine, giving it interactive control over the target. Adversaries may use a Reverse Shell to retain control over a compromised target while bypassing security measures like network firewalls. TRC-102 Anti-Debugging detected A process used anti-debugging techniques to block a debugger. Malware use anti-debugging to stay invisible and inhibit analysis of their behavior. TRC-103 Code injection detected using ptrace Possible code injection into another process was detected. Code injection is an exploitation technique used to run malicious code, adversaries may use it in order to execute their malware. TRC-104 Dynamic code loading detected Possible dynamic code loading was detected as the binary's memory is both writable and executable. Writing to an executable allocated memory region could be a technique used by adversaries to run code undetected and without dropping executables. TRC-105 Fileless execution detected Fileless execution was detected. Executing a process from memory instead from a file in the filesystem may indicate that an adversary is trying to avoid execution detection. TRC-106 Cgroups notify_on_release file modification An attempt to modify Cgroup notify_on_release file was detected. Cgroups are a Linux kernel feature which limits the resource usage of a set of processes. Adversaries may use this feature for container escaping. TRC-107 LD_PRELOAD code injection detected LD_PRELOAD usage was detected. LD_PRELOAD lets you load your library before any other library, allowing you to hook functions in a process. Adversaries may use this technique to change your applications' behavior or load their own programs. TRC-108 K8s service account token file read The Kubernetes service account token file was read on your container. This token is used to communicate with the Kubernetes API Server. Adversaries may try to communicate with the API Server to steal information and/or credentials, or even run more containers and laterally extend their grip on the systems. TRC-109 ASLR inspection detected The ASLR (address space layout randomization) configuration was inspected. ASLR is used by Linux to prevent memory vulnerabilities. An adversary may want to inspect and change the ASLR configuration in order to avoid detection. TRC-1010 Cgroups release agent file modification An attempt to modify Cgroup release agent file was detected. Cgroups are a Linux kernel feature which limits the resource usage of a set of processes. Adversaries may use this feature for container escaping. TRC-1011 Core dumps configuration file modification detected Modification of the core dump configuration file (core_pattern) detected. Core dumps are usually written to disk when a program crashes. Certain modifications enable container escaping through the kernel core_pattern feature. TRC-1012 Default dynamic loader modification detected The default dynamic loader has been modified. The dynamic loader is an executable file loaded to process memory and run before the executable to load dynamic libraries to the process. An attacker might use this technique to hijack the execution context of each new process and bypass defenses. TRC-1013 Kubernetes API server connection detected A connection to the kubernetes API server was detected. The K8S API server is the brain of your K8S cluster, adversaries may try and communicate with the K8S API server to gather information/credentials, or even run more containers and laterally expand their grip on your systems. TRC-1014 Container device mount detected Container device filesystem mount detected. A mount of a host device filesystem can be exploited by adversaries to perform container escape. TRC-1015 Hidden executable creation detected A hidden executable (ELF file) was created on disk. This activity could be legitimate; however, it could indicate that an adversary is trying to avoid detection by hiding their programs. TRC-1016 Web server spawned a shell A web-server program on your server spawned a shell program. Shell is the linux command-line program, web servers usually don't run shell programs, so this alert might indicate an adversary is exploiting a web server program to gain command execution on the server. TRC-1017 Kernel module loading detected Loading of a kernel module was detected. Kernel modules are binaries meant to run in the kernel. Adversaries may try and load kernel modules to extend their capabilities and avoid detection by running in the kernel and not user space. TRC-1018 K8s TLS certificate theft detected Theft of Kubernetes TLS certificates was detected. TLS certificates are used to establish trust between systems. The Kubernetes certificate is used to to enable secure communication between Kubernetes components, such as kubelet scheduler controller and API Server. An adversary may steal a Kubernetes certificate on a compromised system to impersonate Kubernetes components within the cluster. TRC-1019 Docker socket abuse detected An attempt to abuse the Docker UNIX socket inside a container was detected. docker.sock is the UNIX socket that Docker uses as the entry point to the Docker API. Adversaries may attempt to abuse this socket to compromise the system. TRC-1020 File operations hooking on proc filesystem detected File operations hooking on proc filesystem detected. The proc filesystem is an interface for the running processes as files. This allows programs like <code>ps</code> and <code>top</code> to check what are the running processes. File operations are the functions defined on a file or directory. File operations hooking includes replacing the default function used to perform a basic task on files and directories like enumerating files. By hooking the file operations of /proc an adversary gains control on certain system function, such as file listing or other basic function performed by the operation system. The adversary may also hijack the execution flow and execute it's own code. File operation hooking is considered a malicious behavior that is performed by rootkits and may indicate that the host's kernel has been compromised. Hidden modules are marked as hidden symbol owners and indicate further malicious activity of an adversary. TRC-1021 Kcore memory file read An attempt to read /proc/kcore file was detected. KCore provides a full dump of the physical memory of the system in the core file format. Adversaries may read this file to get all of the host memory and use this information for container escape. TRC-1022 New executable dropped An Executable file was dropped in the system during runtime. Container images are usually built with all binaries needed inside. A dropped binary may indicate that an adversary infiltrated your container. TRC-1023 Process memory access detected Process memory access detected. Adversaries may access other processes memory to steal credentials and secrets. TRC-1024 Code injection detected through /proc//mem file Possible code injection into another process was detected. Code injection is an exploitation technique used to run malicious code, adversaries may use it in order to execute their malware. TRC-1025 Code injection detected using process_vm_writev syscall Possible code injection into another process was detected. Code injection is an exploitation technique used to run malicious code, adversaries may use it in order to execute their malware. TRC-1026 Rcd modification detected The rcd files were modified. rcd files are scripts executed on boot and runlevel switch. Those scripts are responsible for service control in runlevel switch. Adversaries may add or modify rcd files in order to persist a reboot, thus maintaining malicious execution on the affected host. TRC-1027 Scheduled tasks modification detected The task scheduling functionality or files were modified. Crontab schedules task execution or enables task execution at boot time. Adversaries may add or modify scheduled tasks in order to persist a reboot, thus maintaining malicious execution on the affected host. TRC-1028 Sudoers file modification detected The sudoers file was modified. The sudoers file is a configuration file which controls the permissions and options of the sudo feature. Adversaries may alter the sudoers file to elevate privileges, execute commands as other users or spawn processes with higher privileges. TRC-1029 sched_debug CPU file was read The sched_debug file was read. This file contains information about your CPU and processes. Adversaries may read this file in order to gather that information for their use. TRC-1030 Syscall table hooking detected Syscall table hooking detected. Syscalls (system calls) are the interface between user applications and the kernel. By hooking the syscall table an adversary gains control on certain system function, such as file writing and reading or other basic function performed by the operation system. The adversary may also hijack the execution flow and execute it's own code. Syscall table hooking is considered a malicious behavior that is performed by rootkits and may indicate that the host's kernel has been compromised. Hidden modules are marked as hidden symbol owners and indicate further malicious activity of an adversary. TRC-1031 System request key configuration modification An attempt to modify and activate the System Request Key configuration file was detected. The system request key allows immediate input to the kernel through simple key combinations. Adversaries may use this feature to immediately shut down or restart a system. With read access to kernel logs, host related information such as listing tasks and CPU registers may be disclosed and could be used for container escape."},{"location":"docs/events/builtin/extra/bpf_attach/","title":"bpf_attach","text":""},{"location":"docs/events/builtin/extra/bpf_attach/#intro","title":"Intro","text":"<p>bpf_attach - a BPF program is attached to a probe (kprobe/uprobe/tracepoint/raw_tracepoint)</p>"},{"location":"docs/events/builtin/extra/bpf_attach/#description","title":"Description","text":"<p>An event marking that a BPF program was attached to a probe in the system. It occurs whenever a BPF program is attached to an instrumentation probe - either a  raw_tracepoint or perf event of the types kprobe, uprobe or tracepoint. The purpose of the event is to give the user information about the BPF program,  as well as information about the probe itself.</p>"},{"location":"docs/events/builtin/extra/bpf_attach/#arguments","title":"Arguments","text":"<ul> <li><code>prog_type</code>:<code>int</code>[K] - the BPF program type.</li> <li><code>prog_name</code>:<code>const char*</code>[K] - the BPF program name (first 16 bytes only, as this is how it is saved in the kernel).</li> <li><code>prog_id</code>:<code>u32</code>[K] - the BPF program ID as set by the kernel.</li> <li><code>prog_helpers</code>:<code>unsigned long[]</code>[K] - list of all BPF helpers being used by the BPF program.</li> <li><code>symbol_name</code>:<code>const char*</code>[K] - name/path of the symbol the BPF program is being attached to.</li> <li><code>symbol_addr</code>:<code>u64</code>[K] - address/offset of the symbol the BPF program is being attached to.</li> <li><code>attach_type</code>:<code>int</code>[K] - the probe's type.</li> </ul>"},{"location":"docs/events/builtin/extra/bpf_attach/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/extra/bpf_attach/#security_file_ioctl","title":"security_file_ioctl","text":""},{"location":"docs/events/builtin/extra/bpf_attach/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/extra/bpf_attach/#purpose","title":"Purpose","text":"<p>Catch the attachment of the BPF program to the perf event</p>"},{"location":"docs/events/builtin/extra/bpf_attach/#security_bpf","title":"security_bpf","text":""},{"location":"docs/events/builtin/extra/bpf_attach/#type_1","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/extra/bpf_attach/#purpose_1","title":"Purpose","text":"<p>Catch the attachment of the BPF program to the perf event</p>"},{"location":"docs/events/builtin/extra/bpf_attach/#security_bpf_prog","title":"security_bpf_prog","text":""},{"location":"docs/events/builtin/extra/bpf_attach/#type_2","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/extra/bpf_attach/#purpose_2","title":"Purpose","text":"<p>save data of the BPF program for when we output the event</p>"},{"location":"docs/events/builtin/extra/bpf_attach/#tracepoint_probe_register_prio_may_exist","title":"tracepoint_probe_register_prio_may_exist","text":""},{"location":"docs/events/builtin/extra/bpf_attach/#type_3","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/extra/bpf_attach/#purpose_3","title":"Purpose","text":"<p>Catch the attachment of the BPF program to a raw_tracepoint</p>"},{"location":"docs/events/builtin/extra/bpf_attach/#check_helper_call","title":"check_helper_call","text":""},{"location":"docs/events/builtin/extra/bpf_attach/#type_4","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/extra/bpf_attach/#purpose_4","title":"Purpose","text":"<p>get information about which helper functions are used by the BPF program</p>"},{"location":"docs/events/builtin/extra/bpf_attach/#check_map_func_compatibility","title":"check_map_func_compatibility","text":""},{"location":"docs/events/builtin/extra/bpf_attach/#type_5","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/extra/bpf_attach/#purpose_5","title":"Purpose","text":"<p>get information about which helper functions are used by the BPF program</p>"},{"location":"docs/events/builtin/extra/bpf_attach/#example-use-case","title":"Example Use Case","text":"<pre><code>./tracee -e bpf_attach\n</code></pre>"},{"location":"docs/events/builtin/extra/bpf_attach/#issues","title":"Issues","text":""},{"location":"docs/events/builtin/extra/bpf_attach/#related-events","title":"Related Events","text":""},{"location":"docs/events/builtin/extra/do_sigaction/","title":"do_sigaction","text":""},{"location":"docs/events/builtin/extra/do_sigaction/#intro","title":"Intro","text":"<p>do_sigaction - register new signal handler or get information about current one</p>"},{"location":"docs/events/builtin/extra/do_sigaction/#description","title":"Description","text":"<p>The event marks that an attempt to get current task signal handler or to change the signal handler of the current task for a specific signal occurred. Signal handler change mark the change of the program behavior, and might indicate an attempt to defy expected signal behavior. This event is relevant for each syscall related to signal handling - <code>rt_sigaction</code>, <code>sigaction</code> and <code>signal</code>.</p>"},{"location":"docs/events/builtin/extra/do_sigaction/#arguments","title":"Arguments","text":"<ul> <li><code>sig</code>:<code>int</code>[K] - the signal that its handler is inspected or changed.</li> <li><code>is_sa_initialized</code>:<code>bool</code>[K] - is a new signal handler given. If not, this event marks only inspection of data. If given, this will be the new handler for the event.</li> <li><code>sa_flags</code>:<code>unsigned long</code>[K,OPT] - the flags given for the new signal handler. Passed only if <code>is_sa_initialized</code>=<code>true</code>.</li> <li><code>sa_mask</code>:<code>unsigned long</code> [K,OPT] - the mask given for the new signal handler. Passed only if <code>is_sa_initialized</code>=<code>true</code>.</li> <li><code>sa_handle_method</code>:<code>u8</code>[K,OPT] - the handling method of the new signal handler. Passed only if <code>is_sa_initialized</code>=<code>true</code>.</li> <li><code>sa_handler</code>:<code>void*</code>[K,OPT] - the address of the new signal handling function if method is SIG_HND. Passed only if <code>is_sa_initialized</code>=<code>true</code>.</li> <li><code>is_old_sa_initialized</code>:<code>bool</code>[K] - is an old signal handler given. If given, the old signal handler will be copied back to the caller.</li> <li><code>old_sa_flags</code>:<code>unsigned long</code>[K] - the flags of the old signal handler</li> <li><code>old_sa_mask</code>:<code>unsigned long</code>[K] - the mask of the old signal handler</li> <li><code>old_sa_handle_method</code>:<code>u8</code>[K] - the handling method of the old signal handler</li> <li><code>old_sa_handler</code>:<code>void*</code>[K] - the address of the old signal handling function if method was SIG_HND</li> </ul>"},{"location":"docs/events/builtin/extra/do_sigaction/#handle-method","title":"Handle Method","text":"<p>In the kernel, the handle method and the handler are united to one field. To make it more accessible to the user, Tracee split the two apart. Normally, the value can be one of the following: <code>SIG_DFL</code>(0), <code>SIG_IGN</code>(1) or pointer to user-mode handler function. To deal with the case of a user-mode handler, the value <code>SIG_HND</code>(2) is created to specify that the method is by handler.</p>"},{"location":"docs/events/builtin/extra/do_sigaction/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/extra/do_sigaction/#do_sigaction_1","title":"do_sigaction","text":""},{"location":"docs/events/builtin/extra/do_sigaction/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/extra/do_sigaction/#purpose","title":"Purpose","text":"<p>The function implementing the signal handler inspection/modification for syscalls</p>"},{"location":"docs/events/builtin/extra/do_sigaction/#related-events","title":"Related Events","text":"<p><code>rt_sigaction</code>,<code>sigaction</code>,<code>signal</code></p>"},{"location":"docs/events/builtin/extra/file_modification/","title":"file_modification","text":""},{"location":"docs/events/builtin/extra/file_modification/#intro","title":"Intro","text":"<p>file_modification - a file was changed by a process</p>"},{"location":"docs/events/builtin/extra/file_modification/#description","title":"Description","text":"<p>An event marking that a file was modified. This event is only submitted once between the open and close of the file by a process.</p>"},{"location":"docs/events/builtin/extra/file_modification/#arguments","title":"Arguments","text":"<ul> <li><code>file_path</code>:<code>const char*</code>[K] - the path of the file that was changed.</li> <li><code>dev</code>:<code>dev_t</code>[K] - the device of which this file belongs to.</li> <li><code>inode</code>:<code>unsigned long</code>[K] - the inode number of this file.</li> <li><code>old_ctime</code>:<code>unsigned long</code>[K] - the ctime of the file before the change.</li> <li><code>new_ctime</code>:<code>unsigned long</code>[K] - the ctime of the file after the change.</li> </ul>"},{"location":"docs/events/builtin/extra/file_modification/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/extra/file_modification/#fd_install","title":"fd_install","text":""},{"location":"docs/events/builtin/extra/file_modification/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/extra/file_modification/#purpose","title":"Purpose","text":"<p>Catch the open of a file and set the event of file_modification to be submitted for it</p>"},{"location":"docs/events/builtin/extra/file_modification/#filp_close","title":"filp_close","text":""},{"location":"docs/events/builtin/extra/file_modification/#type_1","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/extra/file_modification/#purpose_1","title":"Purpose","text":"<p>Catch the close of a file and remove it from cache of files t submit the event for</p>"},{"location":"docs/events/builtin/extra/file_modification/#file_update_time","title":"file_update_time","text":""},{"location":"docs/events/builtin/extra/file_modification/#type_2","title":"Type","text":"<p>kprobe + kretprobe</p>"},{"location":"docs/events/builtin/extra/file_modification/#purpose_2","title":"Purpose","text":"<p>Catch the file ctime change and submit the event if marked to be submitted</p>"},{"location":"docs/events/builtin/extra/file_modification/#file_modified","title":"file_modified","text":""},{"location":"docs/events/builtin/extra/file_modification/#type_3","title":"Type","text":"<p>kprobe + kretprobe</p>"},{"location":"docs/events/builtin/extra/file_modification/#purpose_3","title":"Purpose","text":"<p>Catch the file ctime change and submit the event if marked to be submitted</p>"},{"location":"docs/events/builtin/extra/file_modification/#example-use-case","title":"Example Use Case","text":"<pre><code>./tracee -e file_modification\n</code></pre>"},{"location":"docs/events/builtin/extra/file_modification/#note","title":"Note","text":"<p>Only the first event of file modification is submitted between the open and the close of a file by a process.  This is to reduce the amount of file modification events on a file which might be a lot.  That means that the event is not submitted for each write to the file.</p>"},{"location":"docs/events/builtin/extra/file_modification/#issues","title":"Issues","text":"<p>The file_modification event could be submitted more than once between the open and the close of a file by a process. This is due to the use of an LRU map, which acts as a cache of files that the event should be submitted on. Entries of the map are evicted when it is full, thus information about whether an event should be submitted for a  specific file might be lost, and a new event would be submitted even though such an event was submitted before. </p>"},{"location":"docs/events/builtin/extra/file_modification/#related-events","title":"Related Events","text":""},{"location":"docs/events/builtin/extra/format/","title":"","text":""},{"location":"docs/events/builtin/extra/format/#intro","title":"Intro","text":"<p> - one sentence description of the event"},{"location":"docs/events/builtin/extra/format/#description","title":"Description","text":"<p>Detailed description of the event. Should include: * What is the purpose of the event? * Are there any edge-cases, drawbacks or advantages of using it?</p>"},{"location":"docs/events/builtin/extra/format/#arguments","title":"Arguments","text":"<ul> <li><code>&lt;arg#1&gt;</code>:<code>&lt;type&gt;</code>[] - short description of the argument value. If the type or value might change (like with the <code>parse-arguments</code> flag) it should be elaborated here. <li><code>&lt;arg#2&gt;</code>:<code>&lt;type&gt;</code>[] - ..."},{"location":"docs/events/builtin/extra/format/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/extra/format/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/extra/format/#_2","title":"","text":""},{"location":"docs/events/builtin/extra/format/#type","title":"Type","text":"<p>Type of probes or hooks used to hook this function. If include more than one, should be in the form of  + ."},{"location":"docs/events/builtin/extra/format/#purpose","title":"Purpose","text":"<p>Why was this function hooked?</p>"},{"location":"docs/events/builtin/extra/format/#_3","title":"<p>...</p>","text":""},{"location":"docs/events/builtin/extra/format/#example-use-case","title":"Example Use Case","text":"<p>Example of a case where this event could be used.  </p>"},{"location":"docs/events/builtin/extra/format/#issues","title":"Issues","text":"<p>If there is an issue with this event, this is the place to write it.</p>"},{"location":"docs/events/builtin/extra/format/#related-events","title":"Related Events","text":"<p>Events connected by logic or interesting to be used in the context of the event.</p>"},{"location":"docs/events/builtin/extra/hidden_kernel_module/","title":"hidden_kernel_module","text":""},{"location":"docs/events/builtin/extra/hidden_kernel_module/#intro","title":"Intro","text":"<p>hidden_kernel_module - a linux kernel module that is hidden was detected.</p>"},{"location":"docs/events/builtin/extra/hidden_kernel_module/#description","title":"Description","text":"<p>An event marking that a loaded hidden kernel module was detected on your system. This event helps in providing a strong indication that your system is compromised. It periodically checks for a hidden module.</p>"},{"location":"docs/events/builtin/extra/hidden_kernel_module/#arguments","title":"Arguments","text":"<ul> <li><code>address</code>:<code>const char*</code>[K] - the memory address of the hidden kernel module. </li> <li><code>name</code>:<code>const char*</code>[K] - the name of the hidden kernel module.</li> </ul>"},{"location":"docs/events/builtin/extra/hidden_kernel_module/#hooks","title":"Hooks","text":"<p>Self-triggered hook by uprobing itself.</p>"},{"location":"docs/events/builtin/extra/hidden_kernel_module/#example-use-case","title":"Example Use Case","text":"<pre><code>./tracee -e hidden_kernel_module\n</code></pre>"},{"location":"docs/events/builtin/extra/hidden_kernel_module/#issues","title":"Issues","text":""},{"location":"docs/events/builtin/extra/hidden_kernel_module/#related-events","title":"Related Events","text":""},{"location":"docs/events/builtin/extra/hooked_syscalls/","title":"hooked_syscalls","text":""},{"location":"docs/events/builtin/extra/hooked_syscalls/#intro","title":"Intro","text":"<p><code>hooked_syscalls</code> is an event that checks the selected syscalls for any syscall hooking.</p>"},{"location":"docs/events/builtin/extra/hooked_syscalls/#description","title":"Description","text":"<p>The purpose of the <code>hooked_syscalls</code> event is to monitor for system call hooking in the Linux kernel. It verifies the function pointer of the system call to ensure it lies between the etext and stext addresses. This helps identify instances of kernel code modifications, often used for malicious activities such as hiding processes, files, or network connections.</p> <p>The <code>hooked_syscalls</code> event checks either user-specified syscalls or a default list of syscalls depending on the architecture of the system, with a different list for amd64 and arm64 respectively.</p>"},{"location":"docs/events/builtin/extra/hooked_syscalls/#arguments","title":"Arguments","text":"<ul> <li> <p><code>check_syscalls</code>:<code>[]string</code>[U] - the syscall checked for syscall hooking. Can be used to specify selected syscalls or use the default ones.  The default syscalls for amd64 are:</p> <p><code>read</code> <code>write</code> <code>open</code> <code>close</code> <code>ioctl</code> <code>socket</code> <code>sendto</code> <code>recvfrom</code> <code>sendmsg</code> <code>recvmsg</code> <code>execve</code> <code>kill</code> <code>getdents</code> <code>ptrace</code> <code>getdents64</code> <code>openat</code> <code>bpf</code> <code>execveat</code></p> </li> </ul> <p>The default syscalls for arm64 are:     <code>ioctl</code> <code>openat</code> <code>close</code> <code>getdents64</code> <code>read</code> <code>write</code> <code>ptrace</code> <code>kill</code> <code>socket</code> <code>execveat</code> <code>sendto</code> <code>recvfrom</code> <code>sendmsg</code> <code>recvmsg</code> <code>execve</code> <code>bpf</code> * <code>hooked_syscalls</code>:<code>[]trace.HookedSymbolData</code> [K] - The hooked syscalls that were found along with their owners. <code>Hidden</code> owner means that the pointed function owner is not a part of the kernel modules list.</p>"},{"location":"docs/events/builtin/extra/hooked_syscalls/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/extra/hooked_syscalls/#various-system-calls","title":"Various system calls","text":""},{"location":"docs/events/builtin/extra/hooked_syscalls/#type","title":"Type","text":"<p>Uprobe</p>"},{"location":"docs/events/builtin/extra/hooked_syscalls/#purpose","title":"Purpose","text":"<p>Detection of syscall hooking.</p>"},{"location":"docs/events/builtin/extra/hooked_syscalls/#example-use-case","title":"Example Use Case","text":"<p>The <code>hooked_syscalls</code> event could be used as part of a broader system integrity monitoring solution. For example, a security engineer could use it to raise alerts or run further investigations if unexpected syscall hooking activities are detected. This could aid in the early detection and mitigation of malware or rootkit infections. Example:</p> <pre><code>tracee -e hooked_syscalls.args.check_syscalls=&lt;syscall&gt;,&lt;syscall&gt;,...`\n</code></pre>"},{"location":"docs/events/builtin/extra/hooked_syscalls/#issues","title":"Issues","text":"<p>The <code>check_syscalls</code> argument is used as a parameter to specify the syscalls to be checked. This will change in the future to be an event parameter.</p>"},{"location":"docs/events/builtin/extra/hooked_syscalls/#related-events","title":"Related Events","text":""},{"location":"docs/events/builtin/extra/kallsyms_lookup_name/","title":"kallsyms_lookup_name","text":""},{"location":"docs/events/builtin/extra/kallsyms_lookup_name/#intro","title":"Intro","text":"<p>kallsyms_lookup_name - lookup the address for a symbol</p>"},{"location":"docs/events/builtin/extra/kallsyms_lookup_name/#description","title":"Description","text":"<p>This event is invoked when the 'kallsyms_lookup_name()' kernel function returns.  It suggests a lookup of kernel symbol address. This function is used mainly by external kernel extensions like kernel modules or BPF programs. It might be interesting in cases where a sensitive kernel symbol is looked-up.</p>"},{"location":"docs/events/builtin/extra/kallsyms_lookup_name/#arguments","title":"Arguments","text":"<ul> <li><code>symbol_name</code>:<code>const char*</code>[K] - the symbol that is being looked-up.</li> <li><code>symbol_address</code>:<code>void*</code>[K] - the address of the symbol returned by the function. 0 if not found.</li> </ul>"},{"location":"docs/events/builtin/extra/kallsyms_lookup_name/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/extra/kallsyms_lookup_name/#kallsyms_lookup_name_1","title":"kallsyms_lookup_name","text":""},{"location":"docs/events/builtin/extra/kallsyms_lookup_name/#type","title":"Type","text":"<p>kprobe + kretprobe</p>"},{"location":"docs/events/builtin/extra/kallsyms_lookup_name/#purpose","title":"Purpose","text":"<p>tracing the kallsyms_lookup_name event</p>"},{"location":"docs/events/builtin/extra/kallsyms_lookup_name/#example-use-case","title":"Example Use Case","text":"<pre><code>./dist/tracee -e kallsyms_lookup_name\n</code></pre>"},{"location":"docs/events/builtin/extra/magic_write/","title":"magic_write","text":""},{"location":"docs/events/builtin/extra/magic_write/#intro","title":"Intro","text":"<p>magic_write - write operation to a file which changed the file's headers</p>"},{"location":"docs/events/builtin/extra/magic_write/#description","title":"Description","text":"<p>An event marking that a new file is written, or an existing file header changed. The event occurs whenever a write operation to a file in offset 0 is done. The purpose of the event is to give the user information about the file's type and other meta-data needed to understand if the file is a threat.</p>"},{"location":"docs/events/builtin/extra/magic_write/#note","title":"Note","text":"<p>The event doesn't occur for FIFO files or other files with no persistent offsets, to reduce spam events.</p>"},{"location":"docs/events/builtin/extra/magic_write/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code>[K] - the path of the file written.</li> <li><code>bytes</code>:<code>bytes</code>[U,TOCTOU] - the first 20 bytes of the file.</li> <li><code>dev</code>:<code>dev_t</code>[K] - the device the file resides in.</li> <li><code>inode</code>:<code>unsigned long</code>[K] - the inode of the file in the FS.</li> </ul>"},{"location":"docs/events/builtin/extra/magic_write/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/extra/magic_write/#vfs_write","title":"vfs_write","text":""},{"location":"docs/events/builtin/extra/magic_write/#type","title":"Type","text":"<p>kprobe + kretprobe</p>"},{"location":"docs/events/builtin/extra/magic_write/#purpose","title":"Purpose","text":"<p>Catch write operations to a file using the <code>write</code> syscall</p>"},{"location":"docs/events/builtin/extra/magic_write/#vfs_writev","title":"vfs_writev","text":""},{"location":"docs/events/builtin/extra/magic_write/#type_1","title":"Type","text":"<p>kprobe + kretprobe</p>"},{"location":"docs/events/builtin/extra/magic_write/#purpose_1","title":"Purpose","text":"<p>Catch write operations to a file using the <code>writev</code> syscall</p>"},{"location":"docs/events/builtin/extra/magic_write/#__kernel_write","title":"__kernel_write","text":""},{"location":"docs/events/builtin/extra/magic_write/#type_2","title":"Type","text":"<p>kprobe + kretprobe</p>"},{"location":"docs/events/builtin/extra/magic_write/#purpose_2","title":"Purpose","text":"<p>Catch write operations to a file from within the kernel (written buffer resides in kernel space)</p>"},{"location":"docs/events/builtin/extra/magic_write/#example-use-case","title":"Example Use Case","text":""},{"location":"docs/events/builtin/extra/magic_write/#issues","title":"Issues","text":""},{"location":"docs/events/builtin/extra/magic_write/#related-events","title":"Related Events","text":"<p>write, writev, vfs_write, vfs_writev, __kernel_write, security_file_open</p>"},{"location":"docs/events/builtin/extra/mem_prot_alert/","title":"mem_prot_alert","text":""},{"location":"docs/events/builtin/extra/mem_prot_alert/#intro","title":"Intro","text":"<p>mem_prot_alert - access protection change of some memory region is suspicious for malicious activity or leave it exposed to one.</p>"},{"location":"docs/events/builtin/extra/mem_prot_alert/#description","title":"Description","text":"<p>An event marking that a memory region protection access change is suspicious for malicious activity. Memory access protection changes might expose writeable memory to execution, or hide its possible execution. The specific alert is passed through the event arguments.</p>"},{"location":"docs/events/builtin/extra/mem_prot_alert/#arguments","title":"Arguments","text":"<ul> <li><code>alert</code>:<code>u32</code>[K] - the specific alert rose. Will be changed to a meaningful string with the <code>parse-args</code> flag on.</li> <li><code>addr</code>:<code>void*</code>[K] - the start address of the memory region the alert is on.</li> <li><code>len</code>:<code>size_t</code>[K] - the length of the memory region the alert is on.</li> <li><code>prot</code>:<code>int</code>[K] - the new access protection for the memory region.</li> <li><code>prev_prot</code>:<code>int</code> [K] - the previous access protection of the memory region.</li> <li><code>pathname</code>:<code>const char*</code>[K,OPT] - the path of the file related to the memory region, if there is a related file.</li> <li><code>dev</code>:<code>dev_t</code>[K,OPT] - the device of the file related to the memory region, if there is a related file.</li> <li><code>inode</code>:<code>unsigned long</code>[K,OPT] - the inode of the file related to the memory region, if there is a related file.</li> <li><code>ctime</code>:<code>u64</code>[K,OPT] - the last change time of the file related to the memory region, if there is a related file.</li> </ul>"},{"location":"docs/events/builtin/extra/mem_prot_alert/#alert-argument-values","title":"Alert argument values","text":"<p>The value given can be translated to a meaningful string using the parsing function in the <code>trace</code> package. Here are the current possible values: * \"Mmaped region with W+E permissions!\" - a mmap operation creating a memory that is exposed to dynamic code execution. * \"Protection changed to Executable!\" - the access protection of the memory region expose it to execution, after some different access protection in the past. * \"Protection changed from E to W+E!\" - the access protection of the memory region now enable dynamic modification and execution, enabling dynamic code execution. * \"Protection changed from W to E!\" - the access protection of the memory region reduced from dynamic code execution, but still exposed to execution of pre-written code. Might be some evasion attempt.</p>"},{"location":"docs/events/builtin/extra/mem_prot_alert/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/extra/mem_prot_alert/#security_mmap_addr","title":"security_mmap_addr","text":""},{"location":"docs/events/builtin/extra/mem_prot_alert/#type","title":"Type","text":"<p>LSM hook</p>"},{"location":"docs/events/builtin/extra/mem_prot_alert/#purpose","title":"Purpose","text":"<p>Catch the mmap of a memory, getting access to its access protection.</p>"},{"location":"docs/events/builtin/extra/mem_prot_alert/#security_file_mprotect","title":"security_file_mprotect","text":""},{"location":"docs/events/builtin/extra/mem_prot_alert/#type_1","title":"Type","text":"<p>LSM hook</p>"},{"location":"docs/events/builtin/extra/mem_prot_alert/#purpose_1","title":"Purpose","text":"<p>Catch the change of access protection of a memory.</p>"},{"location":"docs/events/builtin/extra/mem_prot_alert/#sys_enter","title":"sys_enter","text":""},{"location":"docs/events/builtin/extra/mem_prot_alert/#type_2","title":"Type","text":"<p>raw tracepoint</p>"},{"location":"docs/events/builtin/extra/mem_prot_alert/#purpose_2","title":"Purpose","text":"<p>Extraction information from syscall arguments for deeper hooks oeration.</p>"},{"location":"docs/events/builtin/extra/mem_prot_alert/#related-events","title":"Related Events","text":"<p><code>security_mmap_addr</code>,<code>security_file_mprotect</code>,<code>security_mmap_file</code>,<code>mmap</code>,<code>mprotect</code></p>"},{"location":"docs/events/builtin/extra/process_execute_failed/","title":"process_execute_failed","text":""},{"location":"docs/events/builtin/extra/process_execute_failed/#intro","title":"Intro","text":"<p>process_execute_failed - a failed process execution occurred.</p>"},{"location":"docs/events/builtin/extra/process_execute_failed/#description","title":"Description","text":"<p>An event marking that a process execution failure has occurred. This event helps in  monitoring failed executions, with the ability to access (mostly - see below) kernel provided arguments. This is a high-level event, planned to include all the failure cases of process execution,  while providing as much as possible the arguments as used by the kernel.</p>"},{"location":"docs/events/builtin/extra/process_execute_failed/#arguments","title":"Arguments","text":"<ul> <li><code>path</code>:<code>const char*</code>[K] - the path to the file as provided by the user. </li> <li><code>binary.path</code>:<code>const char*</code>[K] - the binary path being executed.</li> <li><code>binary.device_id</code>:<code>dev_t</code>[K] - the device id of the binary being executed.</li> <li><code>binary.inode_number</code>:<code>unsigned long</code>[K] - the inode number of the binary being executed.</li> <li><code>binary.ctime</code>:<code>unsigned long</code>[K] - the change time (ctime) of the binary being executed.</li> <li><code>binary.inode_mode</code>:<code>u64</code>[K] - the inode mode of the binary being executed.</li> <li><code>interpreter_path</code>:<code>const char*</code>[K] - the path to the interpreter used.</li> <li><code>stdin_type</code>:<code>umode_t</code>[K] - the stdin type.</li> <li><code>stdin_path</code>:<code>char*</code>[K] - the stdin path.</li> <li><code>kernel_invoked</code>:<code>int</code>[K] - whether this execution was initiated by the kernel (or user-space).</li> <li><code>environment</code>:<code>const char*const*</code>[U,TOCTOU] - the environment variables of this execution.</li> <li><code>arguments</code>:<code>const char*const*</code>[U,TOCTOU] - the arguments of this execution.</li> </ul>"},{"location":"docs/events/builtin/extra/process_execute_failed/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/extra/process_execute_failed/#exec_binprm","title":"exec_binprm","text":""},{"location":"docs/events/builtin/extra/process_execute_failed/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/extra/process_execute_failed/#purpose","title":"Purpose","text":"<p>Fetch the arguments of exec_binprm</p>"},{"location":"docs/events/builtin/extra/process_execute_failed/#exec_binprm_1","title":"exec_binprm","text":""},{"location":"docs/events/builtin/extra/process_execute_failed/#type_1","title":"Type","text":"<p>kretprobe</p>"},{"location":"docs/events/builtin/extra/process_execute_failed/#purpose_1","title":"Purpose","text":"<p>Fetch the return value of exec_binprm</p>"},{"location":"docs/events/builtin/extra/process_execute_failed/#example-use-case","title":"Example Use Case","text":"<pre><code>./tracee -e process_execution_failed\n</code></pre>"},{"location":"docs/events/builtin/extra/process_execute_failed/#issues","title":"Issues","text":"<p>Currently, only covers failed executions that are happening within exec_binprm. Other failures may occur at an earlier stage.</p>"},{"location":"docs/events/builtin/extra/process_execute_failed/#related-events","title":"Related Events","text":"<p>execve,execveat,bprm_check,sched_process_exec</p>"},{"location":"docs/events/builtin/extra/security_bpf_prog/","title":"security_bpf_prog","text":""},{"location":"docs/events/builtin/extra/security_bpf_prog/#intro","title":"Intro","text":"<p>security_bpf_prog - Do a check when the kernel generate and return a file descriptor for BPF programs.</p>"},{"location":"docs/events/builtin/extra/security_bpf_prog/#description","title":"Description","text":"<p>This event marks the act of getting a file descriptor of a BPF program. It is triggered when the BPF program is being  loaded, or when the user asks for it explicitly. This event is of type LSM hook. The event contains data about the BPF program, and whether it is currently being loaded or not. </p>"},{"location":"docs/events/builtin/extra/security_bpf_prog/#arguments","title":"Arguments","text":"<ul> <li><code>type</code>:<code>int</code>[K] - the BPF program type.</li> <li><code>name</code>:<code>const char*</code>[K] - the BPF program name (first 16 bytes only, as this is how it is saved in the kernel).</li> <li><code>helpers</code>:<code>unsigned long[]</code>[K] - list of all BPF helpers being used by the BPF program.</li> <li><code>id</code>:<code>u32</code>[K] - the BPF program ID as set by the kernel.</li> <li><code>load</code>:<code>bool</code>[K] - whether this BPF program is currently being loaded.</li> </ul>"},{"location":"docs/events/builtin/extra/security_bpf_prog/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/extra/security_bpf_prog/#security_bpf_prog_1","title":"security_bpf_prog","text":""},{"location":"docs/events/builtin/extra/security_bpf_prog/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/extra/security_bpf_prog/#purpose","title":"Purpose","text":"<p>The LSM hook of getting a file descriptor of a BPF program. This hook triggers the event. </p>"},{"location":"docs/events/builtin/extra/security_bpf_prog/#bpf_check","title":"bpf_check","text":""},{"location":"docs/events/builtin/extra/security_bpf_prog/#type_1","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/extra/security_bpf_prog/#purpose_1","title":"Purpose","text":"<p>Save data of whether this BPF program is currently being loaded.</p>"},{"location":"docs/events/builtin/extra/security_bpf_prog/#check_helper_call","title":"check_helper_call","text":""},{"location":"docs/events/builtin/extra/security_bpf_prog/#type_2","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/extra/security_bpf_prog/#purpose_2","title":"Purpose","text":"<p>get information about which helper functions are used by the BPF program</p>"},{"location":"docs/events/builtin/extra/security_bpf_prog/#check_map_func_compatibility","title":"check_map_func_compatibility","text":""},{"location":"docs/events/builtin/extra/security_bpf_prog/#type_3","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/extra/security_bpf_prog/#purpose_3","title":"Purpose","text":"<p>get information about which helper functions are used by the BPF program</p>"},{"location":"docs/events/builtin/extra/security_bpf_prog/#example-use-case","title":"Example Use Case","text":"<pre><code>./tracee -e security_bpf_prog\n</code></pre>"},{"location":"docs/events/builtin/extra/security_bpf_prog/#issues","title":"Issues","text":""},{"location":"docs/events/builtin/extra/security_bpf_prog/#related-events","title":"Related Events","text":""},{"location":"docs/events/builtin/extra/security_file_mprotect/","title":"security_file_mprotect","text":""},{"location":"docs/events/builtin/extra/security_file_mprotect/#intro","title":"Intro","text":"<p>security_file_mprotect - check permissions before changing the memory access protection of some memory region</p>"},{"location":"docs/events/builtin/extra/security_file_mprotect/#description","title":"Description","text":"<p>The event marks an attempt to change the access protection of some memory region, probably by the <code>mprotect</code> or <code>pkey_mprotect</code> syscalls. The event is triggered by the permissions check for the operation, as LSM hook. The event gives insight on the new access protection, as well as information on the memory addresses the attempt operation is on. This is a useful event to tracee memory protection changes originated by a user. Notice that the change of protection is applied to the pages containing the address range given, not only for given range.</p>"},{"location":"docs/events/builtin/extra/security_file_mprotect/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code>[K] - the path of the file associated with the memory region.</li> <li><code>prot</code>:<code>int</code>[K] - the new access protection for the memory region. Will be changed to a string representation if <code>parse-args</code> flag was used.</li> <li><code>ctime</code>:<code>unsigned long</code>[K] - the creation time of the file associated with the memory region.</li> <li><code>prev_prot</code>:<code>int</code>[K] - the previous access protection for the memory region. Will be changed to a string representation if <code>parse-args</code> flag was used.</li> <li><code>addr</code>:<code>void*</code>[K] - the start of virtual memory address to change its access protection.</li> <li><code>len</code>:<code>size_t</code>[K] - the length of the memory to apply the new protection on.</li> <li><code>pkey</code>:<code>int</code>[K,OPT] - the protection key used for the operation. Available only if invoking syscall is <code>pkey_mprotect</code>.</li> </ul>"},{"location":"docs/events/builtin/extra/security_file_mprotect/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/extra/security_file_mprotect/#security_file_mprotect_1","title":"security_file_mprotect","text":""},{"location":"docs/events/builtin/extra/security_file_mprotect/#type","title":"Type","text":"<p>LSM hook</p>"},{"location":"docs/events/builtin/extra/security_file_mprotect/#purpose","title":"Purpose","text":"<p>The LSM hook for the <code>mprotect</code> related syscalls - <code>mprotect</code> and <code>pkey_mprotect</code>.</p>"},{"location":"docs/events/builtin/extra/security_file_mprotect/#related-events","title":"Related Events","text":"<p><code>mprotect</code>,<code>pkey_mprotect</code></p>"},{"location":"docs/events/builtin/extra/security_socket_setsockopt/","title":"security_socket_setsockopt","text":""},{"location":"docs/events/builtin/extra/security_socket_setsockopt/#intro","title":"Intro","text":"<p>security_socket_setsockopt - check permissions before setting the options associated with socket</p>"},{"location":"docs/events/builtin/extra/security_socket_setsockopt/#description","title":"Description","text":"<p>The event marks that an attempt to set a socket option occurred, probably by the <code>setsockopt</code> syscall. The event is triggered by the permissions check for the operation, as LSM hook. The event gives insight to the socket details (which differs from the <code>setsockopt</code> syscall event, that only pass the socket fd). However, unlike the <code>setsockopt</code> syscall event, the option value isn't passed.</p>"},{"location":"docs/events/builtin/extra/security_socket_setsockopt/#arguments","title":"Arguments","text":"<ul> <li><code>sockfd</code>:<code>int</code>[K] - the file descriptor of the socket.</li> <li><code>level</code>:<code>int</code>[K] - the level that the option should apply to. If the <code>parse-arguments</code> option is on, will be transformed to a string with the level name.</li> <li><code>optname</code>:<code>int</code>[K] - the option that is set. If the <code>parse-arguments</code> option is on, will be transformed to a string with the option name.</li> <li><code>local_addr</code>:<code>struct socketaddr*</code>[K] - the details of the socket (like socket type, local IP and port for TCP/UDP sockets, etc.).</li> </ul>"},{"location":"docs/events/builtin/extra/security_socket_setsockopt/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/extra/security_socket_setsockopt/#security_socket_setsockopt_1","title":"security_socket_setsockopt","text":""},{"location":"docs/events/builtin/extra/security_socket_setsockopt/#type","title":"Type","text":"<p>LSM Hook</p>"},{"location":"docs/events/builtin/extra/security_socket_setsockopt/#purpose","title":"Purpose","text":"<p>The LSM hook of the <code>setsockopt</code> syscall implementation.</p>"},{"location":"docs/events/builtin/extra/security_socket_setsockopt/#related-events","title":"Related Events","text":"<p><code>setsockopt</code>, <code>getsockopt</code></p>"},{"location":"docs/events/builtin/extra/symbols_collision/","title":"symbols_collision","text":""},{"location":"docs/events/builtin/extra/symbols_collision/#intro","title":"Intro","text":"<p>symbols_collision - a shared object loaded to a process has collisions in exported symbols with another loaded shared object.</p>"},{"location":"docs/events/builtin/extra/symbols_collision/#description","title":"Description","text":"<p>An event marking that a shared object loaded to current process, and have collisions of exported symbols with other shared object already loaded to the process. This event can help in inform on the  occasion that a shared object tries to override some symbol of another library.</p>"},{"location":"docs/events/builtin/extra/symbols_collision/#configuring-the-event","title":"Configuring the event","text":"<p>The event is configured using arguments filtering.</p>"},{"location":"docs/events/builtin/extra/symbols_collision/#symbols","title":"symbols","text":"<p>Configure the watched symbols that upon collision will trigger the event. Specify the full name of the symbol for each symbol. Notice that only watched symbols will be outputed by the event, and the default is watching all symbols. The use is only with the <code>=</code> or <code>!=</code> operators, and wildcards aren't supported.</p>"},{"location":"docs/events/builtin/extra/symbols_collision/#arguments","title":"Arguments","text":"<ul> <li><code>loaded_path</code>:<code>const char*</code>[K] - the path of the file loaded.</li> <li><code>collision_path</code>:<code>const char*</code>[K,TOCTOU] - the path of the file already loaded, which has collision with the new loaded one.</li> <li><code>symbols</code>:<code>const char*const*</code>[U,TOCTOU] - list of symbols collided between the files.</li> </ul>"},{"location":"docs/events/builtin/extra/symbols_collision/#dependency-events","title":"Dependency Events","text":""},{"location":"docs/events/builtin/extra/symbols_collision/#shared_object_loaded","title":"shared_object_loaded","text":"<p>The event of shared object loading triggers this event, and supplies the information on the shared object necessary to examine its exported symbols.</p>"},{"location":"docs/events/builtin/extra/symbols_collision/#sched_process_exec","title":"sched_process_exec","text":"<p>Used by tracee to maintain mount NS cache, used in this event to get to processes file system. Also, used to maintain the cache used by the event for performance improvement.</p>"},{"location":"docs/events/builtin/extra/symbols_collision/#example-use-case","title":"Example Use Case","text":"<p>Could be used for example to catch collision between a shared object and <code>libc.so</code>, overwriting libc symbols:</p> <pre><code>./dist/tracee -e symbols_collision.args.loaded_path=/usr/lib/libc.so.6\n</code></pre> <p>Running this line will give a lot of spam symbols collision, for example collisions of <code>libc</code> with <code>libm</code>:</p> <pre><code>TIME             UID    COMM             PID     TID     RET              EVENT                ARGS\n14:41:48:296325  1000   xfce4-panel      6808    6808    0                symbols_collision    loaded_path: /usr/lib/libc.so.6, collision_path: /usr/lib/libm.so.6, symbols: [finitel __signbitf finite frexpl frexp scalbn __finite copysignl scalbnf __signbitl scalbnl copysign copysignf ldexpf modff modf ldexp ldexpl finitef frexpf __finitel modfl __finitef __signbit]\n</code></pre> <p>To reduce the spam collisions, we can configure the event to not print the collision using two ways: 1. Whitelist the collided symbols:</p> <pre><code>./dist/tracee -e symbols_collision.args.loaded_path=/usr/lib/libc.so.6 -e symbols_collision.args.symbols!=finitel,__signbitf,finite,frexpl,frexp,scalbn,__finite,copysignl,scalbnf,__signbitl,scalbnl,copysign,copysignf,ldexpf,modff,modf,ldexp,ldexpl,finitef,frexpf,__finitel,modfl,__finitef,__signbit\n</code></pre> <ol> <li>Whitelist the library <code>libm</code>:</li> </ol> <pre><code>./dist/tracee -e symbols_collision.args.loaded_path=/usr/lib/libc.so.6 -e symbols_collision.args.collision_path!=/usr/lib/libm.so.6\n</code></pre> <p>The first approach is recommended when dealing with common symbols like 'setup_', 'finish_' etc. because it will reduce the overall noise and also reduce the event processing time, in contrast to the second filter which only works after processing the event.</p>"},{"location":"docs/events/builtin/extra/symbols_collision/#issues","title":"Issues","text":""},{"location":"docs/events/builtin/extra/symbols_collision/#user-mode-event","title":"User Mode Event","text":"<p>Because the event is implemented in user-mode, it needs to open and read files. This means that the event is not very performance efficient (although it uses some optimizations). It also means that until the SO file is opened, it could be altered or removed.</p>"},{"location":"docs/events/builtin/extra/symbols_collision/#spam","title":"Spam","text":"<p>Notice that there are symbols which unintentionally exported by shared objects regularly. Moreover, there are times which the same ELF load multiple variations of the same shared object, or one shared object copies code from another (for example, <code>libm</code> and <code>libc</code>). This cases will cause unintended spam events, so use wisely.</p>"},{"location":"docs/events/builtin/extra/symbols_collision/#big-event-size","title":"Big Event Size","text":"<p>The event pass list of all collided symbols as an argument. The list might be very large, which will result large memory event resulting performance reduction and excess memory usage.</p>"},{"location":"docs/events/builtin/extra/symbols_collision/#related-events","title":"Related Events","text":"<p>shared_object_loaded, symbols_loaded</p>"},{"location":"docs/events/builtin/extra/symbols_loaded/","title":"symbols_loaded","text":""},{"location":"docs/events/builtin/extra/symbols_loaded/#intro","title":"Intro","text":"<p>symbols_loaded - a shared object which exports a watched symbol was loaded.</p>"},{"location":"docs/events/builtin/extra/symbols_loaded/#description","title":"Description","text":"<p>An event marking that a shared object, which export symbols configured to be watched, was loaded to current process. This event can help in identifying some shared object usage in the system, or inform on the occasion that a shared object tries to override some symbol of another library.</p>"},{"location":"docs/events/builtin/extra/symbols_loaded/#configuring-the-event","title":"Configuring the event","text":"<p>The event is configured using arguments filtering. For each argument, a filter can be used to configure the operation:</p>"},{"location":"docs/events/builtin/extra/symbols_loaded/#symbols","title":"symbols","text":"<p>Configure the watched symbols by the event. Specify the full name of the symbol for each symbol. The use is only with the <code>=</code> operator, and wildcards aren't supported.</p>"},{"location":"docs/events/builtin/extra/symbols_loaded/#library_path","title":"library_path","text":"<p>Whitelist for shared object paths prefixes. The path can be absolute, or just a library name. If only a name is given, then any shared object inside the known libraries directories which starts with the prefix will be whitelisted. The use is only with the <code>!=</code> operator, and wildcards aren't supported.</p>"},{"location":"docs/events/builtin/extra/symbols_loaded/#arguments","title":"Arguments","text":"<ul> <li><code>library_path</code>:<code>const char*</code>[K] - the path of the shared object file loaded.</li> <li><code>symbols</code>:<code>const char*const*</code>[U,TOCTOU] - the watched symbols exported by the shared object.</li> </ul>"},{"location":"docs/events/builtin/extra/symbols_loaded/#dependency-events","title":"Dependency Events","text":""},{"location":"docs/events/builtin/extra/symbols_loaded/#shared_object_loaded","title":"shared_object_loaded","text":"<p>The event of shared object loading triggers this event, and supplies the information on the shared object necessary to examine its shared objects.</p>"},{"location":"docs/events/builtin/extra/symbols_loaded/#sched_process_exec","title":"sched_process_exec","text":"<p>Used by tracee to maintain mount NS cache, used in this event to get to processes file system</p>"},{"location":"docs/events/builtin/extra/symbols_loaded/#example-use-case","title":"Example Use Case","text":"<p>To catch SO which tries to override the <code>fopen</code> function of <code>libc</code>, we can use the event in the following way:</p> <pre><code>./dist/tracee -e symbols_loaded.args.symbols=fopen -e symbols_loaded.args.library_path!=libc\n</code></pre>"},{"location":"docs/events/builtin/extra/symbols_loaded/#issues","title":"Issues","text":"<p>Because the event is implemented in user-mode, it needs to open and read files. This means that the event is not very performance efficient (although it uses some optimizations). It also means that until the SO file is opened, it could be altered or removed.</p>"},{"location":"docs/events/builtin/extra/symbols_loaded/#related-events","title":"Related Events","text":"<p>shared_object_loaded, symbols_collision</p>"},{"location":"docs/events/builtin/extra/vfs_read/","title":"vfs_read","text":""},{"location":"docs/events/builtin/extra/vfs_read/#intro","title":"Intro","text":"<p>vfs_read - generic FS file read to a buffer</p>"},{"location":"docs/events/builtin/extra/vfs_read/#description","title":"Description","text":"<p>An event indicating that a read from a file to a buffer was done. The event is not FS specific, and the hook is on the inner implementation of the <code>read</code> and other buffer read syscalls. Notice that there are more methods for file reading other than this, like <code>vfs_readv</code>, file mapping, etc.</p>"},{"location":"docs/events/builtin/extra/vfs_read/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code>[K] - the path of the file read</li> <li><code>dev</code>:<code>dev_t</code>[K] - the device the file resides in</li> <li><code>inode</code>:<code>unsigned long</code>[K] - the inode of the file in the device</li> <li><code>count</code>:<code>size_t</code>[K] - the size requested to be read by this operation</li> <li><code>pos</code>:<code>off_t</code>[K] - the start position for the read</li> </ul>"},{"location":"docs/events/builtin/extra/vfs_read/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/extra/vfs_read/#vfs_read_1","title":"vfs_read","text":""},{"location":"docs/events/builtin/extra/vfs_read/#type","title":"Type","text":"<p>kprobe + kretprobe</p>"},{"location":"docs/events/builtin/extra/vfs_read/#purpose","title":"Purpose","text":"<p>The implementation of the <code>read</code>, <code>readv</code> syscall after fd resolving.</p>"},{"location":"docs/events/builtin/extra/vfs_read/#related-events","title":"Related Events","text":"<p><code>read</code>,<code>vfs_readv</code>,<code>vfs_write</code></p>"},{"location":"docs/events/builtin/extra/vfs_readv/","title":"vfs_readv","text":""},{"location":"docs/events/builtin/extra/vfs_readv/#intro","title":"Intro","text":"<p>vfs_readv - generic FS file read to a vector</p>"},{"location":"docs/events/builtin/extra/vfs_readv/#description","title":"Description","text":"<p>An event indicating that a read from a file to a vector was done. The event is not FS specific, and the hook is on the inner implementation of the <code>readv</code> and other vector read syscalls. Notice that there are more methods for file reading other than this, like <code>vfs_read</code>, file mapping, etc.</p>"},{"location":"docs/events/builtin/extra/vfs_readv/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code>[K] - the path of the file read</li> <li><code>dev</code>:<code>dev_t</code>[K] - the device the file resides in</li> <li><code>inode</code>:<code>unsigned long</code>[K] - the inode of the file in the device</li> <li><code>vlen</code>:<code>unsigned long</code>[K] - the amount of buffers requested to be read by this operation to the vector</li> <li><code>pos</code>:<code>off_t</code>[K] - the start position for the read</li> </ul>"},{"location":"docs/events/builtin/extra/vfs_readv/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/extra/vfs_readv/#vfs_readv_1","title":"vfs_readv","text":""},{"location":"docs/events/builtin/extra/vfs_readv/#type","title":"Type","text":"<p>kprobe + kretprobe</p>"},{"location":"docs/events/builtin/extra/vfs_readv/#purpose","title":"Purpose","text":"<p>The implementation of the <code>readv</code>, <code>preadv</code> and <code>preadv2</code> syscall after fd resolving.</p>"},{"location":"docs/events/builtin/extra/vfs_readv/#related-events","title":"Related Events","text":"<p><code>readv</code>,<code>vfs_read</code>,<code>vfs_writev</code></p>"},{"location":"docs/events/builtin/syscalls/","title":"Syscalls","text":"<p>Tracee supports tracing all Linux system calls. To trace a system call, use it's name as the event name. For example, to trace the <code>open</code> system call, use the <code>open</code> event name. The arguments of the system call will be available as event arguments. For more information about system calls, please consult the man pages.</p>"},{"location":"docs/events/builtin/syscalls/accept/","title":"<code>accept()</code>","text":""},{"location":"docs/events/builtin/syscalls/accept/#intro","title":"Intro","text":"<p>The <code>accept()</code> syscall returns connected file descriptors for a given listening socket.</p>"},{"location":"docs/events/builtin/syscalls/accept/#description","title":"Description","text":"<p>The <code>accept()</code> syscall enables a process to perform a passive connection, or accept, with a remote peer. The <code>accept()</code> syscall is the accept half of a two-way communication link. It is typically used when a server provides a service over a network. The <code>accept()</code> syscall will block until a connection is accepted. </p> <p>When <code>accept()</code> is successful, it will create a new file descriptor and store the address of the connecting peer in the sockaddr structure provided by the user. </p> <p>There are a few edge cases where <code>accept()</code> might fail and return an error. For example, if the program does not have permission to create a new socket descriptor, or the remote peer does not support the protocol in question, <code>accept()</code> may fail. There is also a chance of a race condition in the <code>accept()</code> syscall if it is used without the <code>O_NONBLOCK</code> flag. In a race condition, <code>accept()</code> may return a newly created descriptor, but the remote connection could be dropped before the connection is actually made. </p>"},{"location":"docs/events/builtin/syscalls/accept/#arguments","title":"Arguments","text":"<ul> <li><code>sockfd</code>: <code>int</code> - Descriptor of the listening socket.</li> <li><code>addr</code>: <code>struct sockaddr*</code>[<code>U</code>] - Structure used to store the address of the connecting peer.</li> <li><code>addrlen</code>: <code>int*</code>[<code>U</code>,<code>OPT</code>] - Size of the sockaddr structure. </li> </ul>"},{"location":"docs/events/builtin/syscalls/accept/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/accept/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/accept/#sys_accept","title":"<code>sys_accept</code>","text":""},{"location":"docs/events/builtin/syscalls/accept/#type","title":"Type","text":"<p>KProbe.</p>"},{"location":"docs/events/builtin/syscalls/accept/#purpose","title":"Purpose","text":"<p>Used for tracing when a process is attempting to accept a connection.</p>"},{"location":"docs/events/builtin/syscalls/accept/#do_accept","title":"<code>do_accept</code>","text":""},{"location":"docs/events/builtin/syscalls/accept/#type_1","title":"Type","text":"<p>KRetProbe.</p>"},{"location":"docs/events/builtin/syscalls/accept/#purpose_1","title":"Purpose","text":"<p>Used for tracing the return value of the <code>sys_accept</code> syscall, indicating whether or not the accept syscall was successful. </p>"},{"location":"docs/events/builtin/syscalls/accept/#example-use-case","title":"Example Use Case","text":"<p>Using <code>accept()</code> in a server application to allow incoming connections from remote clients. </p>"},{"location":"docs/events/builtin/syscalls/accept/#issues","title":"Issues","text":"<p><code>accept()</code> is vulnerable to a type of race condition called Time Of Check, Time Of Use (TOCTOU). If <code>accept()</code> is called without the <code>O_NONBLOCK</code> flag, a newly accepted connection descriptor may be returned before the connection is actually made. If the connection is dropped before the connection is made, <code>accept()</code> will return the connection but the user will not be able to use the descriptor.</p>"},{"location":"docs/events/builtin/syscalls/accept/#related-events","title":"Related Events","text":"<p><code>connect()</code> - Used by the clients in order to connect to a server.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/accept4/","title":"accept4","text":""},{"location":"docs/events/builtin/syscalls/accept4/#intro","title":"Intro","text":"<p>accept4 - a system call for accepting incoming connections on a listening socket</p>"},{"location":"docs/events/builtin/syscalls/accept4/#description","title":"Description","text":"<p>The <code>accept4</code> system call is used by a server process to accept incoming connections on a listening socket. It is a variant of the <code>accept</code> system call which has an additional parameter <code>flags</code>, which can be used to control how the connection is created. For example, the <code>SOCK_NONBLOCK</code> flag can be used to ensure that the connection is created in non-blocking mode, to avoid blocking the server process in the event of no available clients. Further flags can also be used to control whether the socket is granted exclusive access to the address, and whether credentials are passed with the connection (using the <code>SOCK_PASSCRED</code> flag).</p> <p>The <code>sockfd</code> parameter is a file descriptor for the listening socket. The <code>addr</code> and <code>addrlen</code> parameters point to a <code>sockaddr</code> structure and an <code>int</code> respectively, and are used to store information about the client connection. Once accepted, the address and length of the connection are copied to these structures. The <code>flags</code> parameter is used to control the type of socket that is created, as described above.</p>"},{"location":"docs/events/builtin/syscalls/accept4/#arguments","title":"Arguments","text":"<ul> <li><code>sockfd</code>:<code>int</code>[K] - the file descriptor of the listening socket.</li> <li><code>addr</code>:<code>struct sockaddr*</code>[K,U] - pointer to <code>sockaddr</code> to store the details of the connection.</li> <li><code>addrlen</code>:<code>int*</code>[K,U] - pointer to an integer to store the length of the <code>struct sockaddr</code> associated with the connection.</li> <li><code>flags</code>:<code>int</code>[K] - flags to control the type of socket that is created (e.g. <code>SOCK_NONBLOCK</code>), passed as a bitmask.</li> </ul>"},{"location":"docs/events/builtin/syscalls/accept4/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/accept4/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/accept4/#sock_allowsockopt","title":"sock_allowsockopt","text":""},{"location":"docs/events/builtin/syscalls/accept4/#type","title":"Type","text":"<p>Tracepoint + Kprobe</p>"},{"location":"docs/events/builtin/syscalls/accept4/#purpose","title":"Purpose","text":"<p>To monitor the flags parameter of the accept4 syscall</p>"},{"location":"docs/events/builtin/syscalls/accept4/#example-use-case","title":"Example Use Case","text":"<p>An example use case would be a web server that needs to listen for incoming connections, but doesn't want to block waiting for them. By using the <code>SOCK_NONBLOCK</code> flag, the server process can instruct the kernel to create the socket in non-blocking mode and return immediately, even if there are no connections available.</p>"},{"location":"docs/events/builtin/syscalls/accept4/#issues","title":"Issues","text":"<p>One potential issue is with the use of TOCTOU (Time-of-Check-Time-of-Use) attacks. These can occur when the flags parameter is passed with a value that changes between the time of check and the time of use. Therefore, care should be taken to ensure that the parameter is locked before the syscall is invoked.</p>"},{"location":"docs/events/builtin/syscalls/accept4/#related-events","title":"Related Events","text":"<ul> <li><code>bind</code> - used to bind the sockets to an address</li> <li><code>listen</code> - used to begin listening for incoming connections</li> <li><code>select</code> - used to wait for incoming connections in non-blocking mode</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/access/","title":"access","text":""},{"location":"docs/events/builtin/syscalls/access/#intro","title":"Intro","text":"<p>access - check user's permissions to a file</p>"},{"location":"docs/events/builtin/syscalls/access/#description","title":"Description","text":"<p>The access system call checks if the calling process can access the file pathname. It takes in two parameters: the pathname and the mode of the access being checked. It returns 0 if the user has permission and -1 if the user does not have permission. The access mode argument specifies which permissions should be checked. The different modes are defined in <code>&lt;fcntl.h&gt;</code>. </p> <p>The access system call can be used to check access permissions prior to attempting to open a file or directory. This provides an additional layer of security because it can be used to minimize the potential of TOCTOU attacks.</p>"},{"location":"docs/events/builtin/syscalls/access/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>: <code>const char*</code>[KU] - pathname of the file being accessed</li> <li><code>mode</code>: <code>int</code>[K] - mode of access being tested, defined in <code>fcntl.h</code></li> </ul>"},{"location":"docs/events/builtin/syscalls/access/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/access/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/access/#sys_access","title":"sys_access","text":""},{"location":"docs/events/builtin/syscalls/access/#type","title":"Type","text":"<p>Kprobes </p>"},{"location":"docs/events/builtin/syscalls/access/#purpose","title":"Purpose","text":"<p>To trace access system call.</p>"},{"location":"docs/events/builtin/syscalls/access/#example-use-case","title":"Example Use Case","text":"<p>The access system call could be used in order to implement a security policy in an application. For example, an application may require certain users to be members of a specific group in order to access certain files. The application could call access prior to attempting to access or open a file in order to check if the user has permission to access the requested file. </p>"},{"location":"docs/events/builtin/syscalls/access/#issues","title":"Issues","text":"<p>The access system call is vulnerable to TOCTOU (time of check, time of use) attacks. That is, the permission of the requested file can change between the time it was checked and the time of use.</p>"},{"location":"docs/events/builtin/syscalls/access/#related-events","title":"Related Events","text":"<ul> <li>open - to open the file if the user has permission</li> <li>stat - to query file status, including the owner and group of the file</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/acct/","title":"acct()","text":""},{"location":"docs/events/builtin/syscalls/acct/#intro","title":"Intro","text":"<p>acct() - toggle process accounting on or off</p>"},{"location":"docs/events/builtin/syscalls/acct/#description","title":"Description","text":"<p>The acct() system call is used to enable or disable process accounting. It is typically used to start or stop the system writing process accounting information to the file specified in the \"filename\" argument. Process accounting information is stored in a file so that the activities of users on the system can be monitored.</p> <p>Process accounting can be activated by setting the kernel parameter <code>accounting</code> to 1. The kernel will begin writing accounting information to the file specified in the \"filename\" argument when acct() is called. When process accounting is enabled, all processes that terminate have an accounting record written to the accounting file. Accounting records can be read with the acct() system call.</p> <p>Process accounting can be disabled by calling acct() with a null pointer in the \"filename\" argument.</p>"},{"location":"docs/events/builtin/syscalls/acct/#arguments","title":"Arguments","text":"<ul> <li><code>filename</code>:<code>const char*</code>[K] - pathname of the accounting file to be written. If a null pointer is passed, process accounting will be disabled.</li> </ul>"},{"location":"docs/events/builtin/syscalls/acct/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/acct/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/acct/#sys_acct","title":"sys_acct","text":""},{"location":"docs/events/builtin/syscalls/acct/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/acct/#purpose","title":"Purpose","text":"<p>To monitor process accounting activity.</p>"},{"location":"docs/events/builtin/syscalls/acct/#example-use-case","title":"Example Use Case","text":"<p>An application like \"process_tracker\" that needs to monitor user activities on a system and keep track of when each process is started and when it is terminated. The acct() system call can be used to enable process accounting and record the process accounting information in the specified file.</p>"},{"location":"docs/events/builtin/syscalls/acct/#issues","title":"Issues","text":"<p>If the accounting file becomes too large, the kernel may stop writing new records to it. This can be mitigated by periodically rotating the accounting file by calling mv on it and creating a new accounting file.</p>"},{"location":"docs/events/builtin/syscalls/acct/#related-events","title":"Related Events","text":"<ul> <li>execve() - used to execute or start a process which may be recorded in the accounting file. </li> <li>exit() - used to terminate a process which may be recorded in the accounting file.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/add_key/","title":"add_key","text":""},{"location":"docs/events/builtin/syscalls/add_key/#intro","title":"Intro","text":"<p>add_key - adds a key to the kernel's key management facility</p>"},{"location":"docs/events/builtin/syscalls/add_key/#description","title":"Description","text":"<p>add_key is a system call that adds a new key to the kernel's key management facility. The purpose of the system call is to make it easier to use secure symmetric encryption without having to manage and/or store the encryption keys in plaintext. The system call can be used to add public and private keys, as well as binary blobs, as key payloads. After the key is added to the kernel, the key is assigned a unique serial number and stored in secure memory for use.</p> <p>There are some drawbacks to using add_key. Firstly, the size of the payload being added must be less than 768 bytes. Secondly, there is a maximum of 58720 keys allowed in the kernel at any one time, so each key must be manually removed when no longer needed. Additionally, there is a limit of 32 processes that can concurrently access the same keyring.</p>"},{"location":"docs/events/builtin/syscalls/add_key/#arguments","title":"Arguments","text":"<ul> <li><code>type</code>:<code>const char*</code>[K] - string identifying the type of the key.</li> <li><code>description</code>:<code>const char*</code>[K] - readable string specifying the purpose of the key.</li> <li><code>payload</code>:<code>const void*</code>[K] - the key payload, with a size limit of 768 bytes.</li> <li><code>plen</code>:<code>size_t</code>[K] - the size length of the key payload.</li> <li><code>keyring</code>:<code>key_serial_t</code>[U] - the ID of the keyring where the key will be stored. If set to -1, the default keyring will be used.</li> </ul>"},{"location":"docs/events/builtin/syscalls/add_key/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/add_key/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/add_key/#do_add_key","title":"do_add_key","text":""},{"location":"docs/events/builtin/syscalls/add_key/#type","title":"Type","text":"<p>kprobes</p>"},{"location":"docs/events/builtin/syscalls/add_key/#purpose","title":"Purpose","text":"<p>To trace usage of the add_key syscall.</p>"},{"location":"docs/events/builtin/syscalls/add_key/#key_alloc","title":"key_alloc","text":""},{"location":"docs/events/builtin/syscalls/add_key/#type_1","title":"Type","text":"<p>kretprobes</p>"},{"location":"docs/events/builtin/syscalls/add_key/#purpose_1","title":"Purpose","text":"<p>To gather information about allocated keys.</p>"},{"location":"docs/events/builtin/syscalls/add_key/#example-use-case","title":"Example Use Case","text":"<p>add_key can be used for securely storing passwords. For example, an application may have a \"forgot password\" feature, which would require the encryption of a password-reset key. Using add_key, this process can be securely done without ever having to store the key in plaintext.</p>"},{"location":"docs/events/builtin/syscalls/add_key/#issues","title":"Issues","text":"<p>The maximum size of the key payload is limited to 768 bytes. Additionally, the maximum amount of keys allowed in the kernel is limited to 58720, so any key that is no longer needed must be manually removed.</p>"},{"location":"docs/events/builtin/syscalls/add_key/#related-events","title":"Related Events","text":"<ul> <li>keyctl</li> <li>keyctl_assume_authority</li> <li>request_key</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/adjtimex/","title":"adjtimex","text":""},{"location":"docs/events/builtin/syscalls/adjtimex/#intro","title":"Intro","text":"<p>adjtimex - adjust timekeeping variables with the aim of improving accuracy</p>"},{"location":"docs/events/builtin/syscalls/adjtimex/#description","title":"Description","text":"<p>The <code>adjtimex</code> syscall is used to make adjustments to system clock variables. This syscall provides access to the Linux kernel time variables, making it possible to adjust the kernel\u2019s clock frequency and phase, as well as the system time offset. </p> <p>When using <code>adjtimex</code>, it is important to remember that this syscall can modify important system variables. It may lead to side effects like clock desynchronization or even time rollbacks, making it important to be aware of the adjustments being performed to the system\u2019s time variables.</p>"},{"location":"docs/events/builtin/syscalls/adjtimex/#arguments","title":"Arguments","text":"<ul> <li><code>buf</code>: <code>struct timex*</code>[K] - a pointer to a <code>struct timex</code>. This argument contains the adjtimex settings. </li> </ul>"},{"location":"docs/events/builtin/syscalls/adjtimex/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/adjtimex/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/adjtimex/#adjtimex_1","title":"adjtimex","text":""},{"location":"docs/events/builtin/syscalls/adjtimex/#type","title":"Type","text":"<p>Kprobes + tracepoints</p>"},{"location":"docs/events/builtin/syscalls/adjtimex/#purpose","title":"Purpose","text":"<p>Monitoring and modifying system time variables.</p>"},{"location":"docs/events/builtin/syscalls/adjtimex/#example-use-case","title":"Example Use Case","text":"<p>The <code>adjtimex</code> system call can be used to adjust the system's clock offset, frequency and phase. This can be used to provide better time synchronization if there is an issue with current system time accuracy.</p>"},{"location":"docs/events/builtin/syscalls/adjtimex/#issues","title":"Issues","text":"<p>It can lead to unexpected behavior if used incorrectly (e.g. time rollbacks).</p>"},{"location":"docs/events/builtin/syscalls/adjtimex/#related-events","title":"Related Events","text":"<ul> <li>settimeofday </li> <li>clock_settime </li> <li>do_adjtimex</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/afs/","title":"afs","text":""},{"location":"docs/events/builtin/syscalls/afs/#intro","title":"Intro","text":"<p>afs - System call for completely deleting entire directories of files.</p>"},{"location":"docs/events/builtin/syscalls/afs/#description","title":"Description","text":"<p>The afs syscall is used to recursively delete all files and folders in a  given directory. It is a non-atomic operation; each file and folder is  checked and deleted individually. As this type of operation can be  slow and may pose some security risks, it is a somewhat infrequently  used system call. </p> <p>One of the main advantages of using this function is that it is not  affected by symlinks, unlike other functions like <code>rm</code> or <code>unlink</code>.  However, this also means that afs will not detect broken symlinks,  so directories that contain broken symlinks may not be deleted in  their entirety. </p>"},{"location":"docs/events/builtin/syscalls/afs/#arguments","title":"Arguments","text":"<ul> <li><code>path</code>:<code>string</code>[K, U] - The path to the directory to be deleted. Must be a string relative or absolute path. </li> </ul>"},{"location":"docs/events/builtin/syscalls/afs/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/afs/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/afs/#sys_afs","title":"sys_afs","text":""},{"location":"docs/events/builtin/syscalls/afs/#type","title":"Type","text":"<p>Kprobe + Tracepoints. </p>"},{"location":"docs/events/builtin/syscalls/afs/#purpose","title":"Purpose","text":"<p>To track the system call usage of afs. </p>"},{"location":"docs/events/builtin/syscalls/afs/#example-use-case","title":"Example Use Case","text":"<p>This system call is useful for applications that need to clean up  after themselves, to ensure that no files or folders remain on the  system after it finishes running. This can be useful for applications  that need to leave no trace of their execution. </p>"},{"location":"docs/events/builtin/syscalls/afs/#issues","title":"Issues","text":"<p>The main issue with afs is that, because of its recursive nature, it  has the potential to cause serious system issues if used incorrectly.  Therefore, caution should be taken when using this function. </p>"},{"location":"docs/events/builtin/syscalls/afs/#related-events","title":"Related Events","text":"<ul> <li>rm - System call used to remove individual files and directories. </li> <li>unlink - System call used to delete symbolic links.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/afs_syscall/","title":"afs_syscall","text":""},{"location":"docs/events/builtin/syscalls/afs_syscall/#intro","title":"Intro","text":"<p><code>afs_syscall</code> - Handler for the <code>sys_afs</code> system call.</p>"},{"location":"docs/events/builtin/syscalls/afs_syscall/#description","title":"Description","text":"<p><code>afs_syscall</code> is a handler for the <code>sys_afs</code> system call, which is used to process AFS requests. The requests are contributed by kernel modules with the help of an ioctl to the AFS device driver. Requests include operations such as file read/write, access control and other complex operations.</p> <p>Using <code>afs_syscall</code> allows AFS requests to be processed by the system in a secure and consistent way. Additionally, requests can be safely and easily marshalled between user and kernel space. </p> <p>However, performance can be an issue as there is some overhead in the marshalling process. Since operations can take a long time to complete, potential race conditions or other security issues can occur if care is not taken.</p>"},{"location":"docs/events/builtin/syscalls/afs_syscall/#arguments","title":"Arguments","text":"<ul> <li><code>cmd</code>:unsigned int[K] - Type of command being requested.</li> <li><code>pn</code>:struct pt_regs*[K, U] - Pointer to task's registers.</li> <li><code>arg1</code>-<code>arg4</code>:unsigned long[K,U] - Arguments to the command.</li> </ul>"},{"location":"docs/events/builtin/syscalls/afs_syscall/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/afs_syscall/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/afs_syscall/#do_sys_afs","title":"do_sys_afs","text":""},{"location":"docs/events/builtin/syscalls/afs_syscall/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/afs_syscall/#purpose","title":"Purpose","text":"<p>The do_sys_afs function is hooked in order to instrument the syscall handlers. This informs the tracing system whenever a syscall is executed, so the tracing system can collect information about the syscall.</p>"},{"location":"docs/events/builtin/syscalls/afs_syscall/#example-use-case","title":"Example Use Case","text":"<p>For example, the AFS tracing system could be set up with <code>afs_syscall</code> so that whenever an AFS request is made, the arguments, timestamps and other relevant information can be collected. This information can be used to analyse system behaviour and observe the impact of AFS requests.</p>"},{"location":"docs/events/builtin/syscalls/afs_syscall/#issues","title":"Issues","text":"<p><code>afs_syscall</code> requires that the arguments to the request are correctly marshalled between user and kernel space. If the arguments are malformed or invalid, it could potentially lead to a system crash or other unpredictable behaviour.</p>"},{"location":"docs/events/builtin/syscalls/afs_syscall/#related-events","title":"Related Events","text":"<ul> <li>sys_afs</li> <li>ioctl</li> <li>do_sys_open</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/alarm/","title":"alarm","text":""},{"location":"docs/events/builtin/syscalls/alarm/#intro","title":"Intro","text":"<p>alarm - set an alarm to be delivered at a specified time</p>"},{"location":"docs/events/builtin/syscalls/alarm/#description","title":"Description","text":"<p>alarm sets an alarm to deliver the signal SIGALRM to the calling process in seconds seconds. If seconds is zero, any currently pending alarms are cancelled.</p> <p>Since the delivery of the signal may be delayed, this function should be used to address any problems related to processes that require a specific timing. However, it should be used with caution, since relying on exact timings can be dangerous and negatively affect the performance of a system if not configured properly.</p>"},{"location":"docs/events/builtin/syscalls/alarm/#arguments","title":"Arguments","text":"<ul> <li><code>seconds</code>:<code>unsigned int</code>[U] - the number of seconds until the alarm is fired. </li> </ul>"},{"location":"docs/events/builtin/syscalls/alarm/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/alarm/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/alarm/#sys_alarm","title":"sys_alarm","text":""},{"location":"docs/events/builtin/syscalls/alarm/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/alarm/#purpose","title":"Purpose","text":"<p>The sys_alarm function is used to hook to obtain the time set for alarm delivery.</p>"},{"location":"docs/events/builtin/syscalls/alarm/#example-use-case","title":"Example Use Case","text":"<p>This event can be used to monitor applications that require precise timing, as well as for debugging and performance evaluation of applications and services that might be affected by long delay alarms.</p>"},{"location":"docs/events/builtin/syscalls/alarm/#issues","title":"Issues","text":"<p>The alarm could be interrupted, depending on the system load, so the alarm time might not be delivered precisely on the set time.</p>"},{"location":"docs/events/builtin/syscalls/alarm/#related-events","title":"Related Events","text":"<ul> <li>SIGCHLD - signal is triggered when a child process of the calling process terminates.</li> <li>SIGALRM - signal is triggered when an alarm set by the calling process completes.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/arch_prctl/","title":"arch_prctl","text":""},{"location":"docs/events/builtin/syscalls/arch_prctl/#intro","title":"Intro","text":"<p><code>arch_prctl</code> - sets architecture-specific thread state</p>"},{"location":"docs/events/builtin/syscalls/arch_prctl/#description","title":"Description","text":"<p>The <code>arch_prctl</code> syscall sets architecture-specific thread state. It allows a process to set a specific architecture feature, such as a floating point unit, from within user-space code. It is particularly useful in cases when a process needs to change the architectural state of a thread for testing purposes, for example. When setting the architectural state the <code>addr</code> argument can optionally be set to provide a pointer to user space memory for getting the removed state. </p> <p>One of the primary drawbacks of <code>arch_prctl</code> is that it is vulnerable to the Time-of-check-to-time-of-use (TOCTOU) race condition, which means that it's possible for the value of <code>addr</code> to change between the invocation of the check and the use of the address. It is therefore important to use <code>arch_prctl</code> very carefully and to take into account the risk of TOCTOU when using this syscall.</p>"},{"location":"docs/events/builtin/syscalls/arch_prctl/#arguments","title":"Arguments","text":"<ul> <li><code>option</code>:<code>int</code>[K] - defines the operation to be performed with <code>arch_prctl</code>.</li> <li><code>addr</code>:<code>unsigned long</code>[K] - address of the state information being set or removed.</li> </ul>"},{"location":"docs/events/builtin/syscalls/arch_prctl/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/arch_prctl/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/arch_prctl/#do_arch_prctl","title":"<code>do_arch_prctl</code>","text":""},{"location":"docs/events/builtin/syscalls/arch_prctl/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/arch_prctl/#purpose","title":"Purpose","text":"<p>Hooked for observability - to measure the latency of the syscall execution, to emit tracing events, to report syscall call patterns and per-process activity.</p>"},{"location":"docs/events/builtin/syscalls/arch_prctl/#example-use-case","title":"Example Use Case","text":"<p>The <code>arch_prctl</code> syscall can be used to change the architecture-specific states in a thread, such as the floating point unit. It can be used for testing purposes or for providing an alternative to a full system reboot in cases where only a few threads need to be stateful.</p>"},{"location":"docs/events/builtin/syscalls/arch_prctl/#issues","title":"Issues","text":"<p>The <code>arch_prctl</code> syscall is vulnerable to the TOCTOU race condition, which means that it is possible for the values of the <code>addr</code> argument to change between the invoked check and the use of the address.</p>"},{"location":"docs/events/builtin/syscalls/arch_prctl/#related-events","title":"Related Events","text":"<p><code>pthread_arch_prctl</code> - sets thread-specific architecture-specific state information.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/bdflush/","title":"bdflush","text":""},{"location":"docs/events/builtin/syscalls/bdflush/#intro","title":"Intro","text":"<p>bdflush - System call that schedules kernel tasks related to buffer flushing.</p>"},{"location":"docs/events/builtin/syscalls/bdflush/#description","title":"Description","text":"<p>The bdflush system call works by writing an argument in to the /proc/sys/vm/bdflush file. Each argument value is taken as an instruction for the bdflush daemon to execute specific buffer-related tasks. This system call responds to pressure from an mmapped buffer pool, not just from the files being written to disk. This can improve performance when dealing with heavy write I/O operations.</p> <p>However, bdflush system calls should be used with care. It can come with a great performance boost, but can also lead to much higher memory usage and potential latency spikes in subsequent system calls.</p>"},{"location":"docs/events/builtin/syscalls/bdflush/#arguments","title":"Arguments","text":"<ul> <li><code>func</code>:<code>int</code>[K] - The parameter value is used by the bdflush daemon to determine what to do.</li> <li><code>buffer_pages</code>:<code>unsigned int</code>[K] - Number of pages to write-back per task.</li> <li><code>read_pages</code>: <code>unsigned int</code>[K] - Number of pages to clean per task.</li> </ul>"},{"location":"docs/events/builtin/syscalls/bdflush/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/bdflush/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/bdflush/#sys_dobdflush","title":"sys_dobdflush","text":""},{"location":"docs/events/builtin/syscalls/bdflush/#type","title":"Type","text":"<p>Kprobe + Kretprobe.</p>"},{"location":"docs/events/builtin/syscalls/bdflush/#purpose","title":"Purpose","text":"<p>To collect information about bdflush system calls.</p>"},{"location":"docs/events/builtin/syscalls/bdflush/#example-use-case","title":"Example Use Case","text":"<p>The bdflush system call can be used when dealing with high-throughput write I/O operations, such as file transfers. This system call can be used to bring the performance back in line with what is expected.</p>"},{"location":"docs/events/builtin/syscalls/bdflush/#issues","title":"Issues","text":"<p>The bdflush system call can lead to excessive memory usage and latency spikes in subsequent system calls, which can reduce performance even further.</p>"},{"location":"docs/events/builtin/syscalls/bdflush/#related-events","title":"Related Events","text":"<ul> <li>open()</li> <li>read()</li> <li>write()</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/bind/","title":"bind","text":""},{"location":"docs/events/builtin/syscalls/bind/#intro","title":"Intro","text":"<p>bind - assigns address name to a socket</p>"},{"location":"docs/events/builtin/syscalls/bind/#description","title":"Description","text":"<p>The bind() system call assigns the address specified by addr to the socket  referred to by the file descriptor sockfd. For AF_INET sockets, the bind()  system call binds addr to the address whose port number is specified in addr  and whose Internet address is any address. Only one process may bind to a specific port. </p> <p>The  addrlen  argument  specifies the size, in bytes, of the address structure pointed to by addr. For more information about addrlen requirements for  different address families, refer to the manual page for addrlen. </p> <p>There might be cases where bind() could produce an error due to limits concerning the number of port numbers from 0 to  1023 that are reserved for internal use  and privileged operations (e.g. by root processes).</p>"},{"location":"docs/events/builtin/syscalls/bind/#arguments","title":"Arguments","text":"<ul> <li><code>sockfd</code>:<code>int</code> - file descriptor used in the bind system call. </li> <li><code>addr</code>:<code>struct sockaddr*</code>[KU] - pointer to a structure of sockaddr for the  address that should be bound. </li> <li><code>addrlen</code>:<code>int</code>[K] OPT - length of the sockaddr structure that is pointed by  addr.</li> </ul>"},{"location":"docs/events/builtin/syscalls/bind/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/bind/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/bind/#sys_bind","title":"sys_bind","text":""},{"location":"docs/events/builtin/syscalls/bind/#type","title":"Type","text":"<p>Kprobes </p>"},{"location":"docs/events/builtin/syscalls/bind/#purpose","title":"Purpose","text":"<p>To track bind\u2019s execution from kernel space.</p>"},{"location":"docs/events/builtin/syscalls/bind/#sock_bind","title":"sock_bind","text":""},{"location":"docs/events/builtin/syscalls/bind/#type_1","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/bind/#purpose_1","title":"Purpose","text":"<p>To track bind\u2019s execution from user space.</p>"},{"location":"docs/events/builtin/syscalls/bind/#example-use-case","title":"Example Use Case","text":"<p>The bind() system call is useful for limiting the scope of applications running  on the same host. By using the bind() system call, different applications can  explicitly bind to a specific IP address and assign certain port numbers, so  that two applications on the same host are not using the same port number.</p>"},{"location":"docs/events/builtin/syscalls/bind/#issues","title":"Issues","text":"<p>The bind() system call can only bind to a specific port number once. If the same  port number is asked to be bound to more than one application, it can produce an  error and therefore result in undesired behavior. </p>"},{"location":"docs/events/builtin/syscalls/bind/#related-events","title":"Related Events","text":"<p>connect(), listen(), accept(), sendto()</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/bpf/","title":"bpf","text":""},{"location":"docs/events/builtin/syscalls/bpf/#intro","title":"Intro","text":"<p>bpf - installs or removes a filter program</p>"},{"location":"docs/events/builtin/syscalls/bpf/#description","title":"Description","text":"<p>The bpf() system call is used to transfer a filter program to the kernel and/or query kernel-managed filter programs. It has capability to extend the kernel by allowing user-defined programs to be attached to probe points specified with the bpf_attach context(8) function. </p> <p>It can perform many actions such as attaching a filter to sockets, attaching an endpoint-agnostic program, attaching a tracking program to kprobes, or creating a seccomp policy. Depending on the command argument supplied, other effects may be observed.</p> <p>There are some edge cases and drawbacks related to using bpf. The kernel can reject user-defined programs that are found to be invalid according to certain criteria. Additionally, an overly complex program may suffer from performance penalties.</p>"},{"location":"docs/events/builtin/syscalls/bpf/#arguments","title":"Arguments","text":"<ul> <li><code>cmd</code>:<code>int</code>[K] - command to execute, determines what other arguments are used. </li> <li><code>attr</code>:<code>union bpf_attr*</code>[K] - points to a structure of type bpf_attr. This must be present in all bpf commands and specifies attributes used by kernels to interpret the bpf program </li> <li><code>size</code>:<code>unsigned int</code>[K] - maximum size of <code>attr</code> in bytes</li> </ul>"},{"location":"docs/events/builtin/syscalls/bpf/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/bpf/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/bpf/#bpf_1","title":"bpf","text":""},{"location":"docs/events/builtin/syscalls/bpf/#type","title":"Type","text":"<p>kprobe + tracepoint</p>"},{"location":"docs/events/builtin/syscalls/bpf/#purpose","title":"Purpose","text":"<p>This function is hooked to allow user-defined programs to be attached to probe points specified with the bpf_attach() context.</p>"},{"location":"docs/events/builtin/syscalls/bpf/#example-use-case","title":"Example Use Case","text":"<p>A use case for bpf() is to examine the output data from database applications. To do this, a user can write a program that monitors database connections to determine the amount of data being sent and received for each connection. This data can then be used to identify and diagnose database performance bottlenecks.</p>"},{"location":"docs/events/builtin/syscalls/bpf/#issues","title":"Issues","text":"<p>The bpf() system call only works on Linux kernels, so it is not available on other operating systems. </p>"},{"location":"docs/events/builtin/syscalls/bpf/#related-events","title":"Related Events","text":"<ul> <li>bpf_attach()</li> <li>bpf_prog_load()</li> <li>seccomp(2)</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/break/","title":"<code>break</code>","text":""},{"location":"docs/events/builtin/syscalls/break/#intro","title":"Intro","text":"<p><code>break</code> - allows a process to set memory protection for a given address range.</p>"},{"location":"docs/events/builtin/syscalls/break/#description","title":"Description","text":"<p>The <code>break</code> system call is used by a process to set specific memory protection of a given address range within its virtual address space. It can be used to mark memory as non-executable, readable, writable, or any combination of the three. The changes in protection are done atomically and, as a result, are always performed as a whole. It is an essential part of modern operating system memory protection and is used to ensure the memory integrity of running processes.</p> <p>The <code>break</code> system call may have the following drawbacks or edge cases: * It must be called with the start and end boundaries of the region to be altered, so it can be difficult to use this system call with regions that span multiple memory pages. * If an area of memory is marked as non-executable, the processor will try and verify that this isn't the case for all instructions within the region; if it is, the instruction will be disallowed. * It does not differentiate between memory pages, so shared and private memory can be affected by a single call to <code>break</code>.</p>"},{"location":"docs/events/builtin/syscalls/break/#arguments","title":"Arguments","text":"<ul> <li><code>addr</code>: <code>void *</code> - start address of the region to be set. </li> <li><code>len</code>: <code>unsigned long</code> - the number of bytes in the memory area to be changed. </li> <li><code>type</code>: <code>int</code> [K | U | TOCTOU | OPT] - the type of memory protection to be implemented. The possible types are <code>PROT_READ = 1</code>, <code>PROT_WRITE = 2</code> <code>PROT_EXEC = 4</code> <code>PROT_NONE = 0</code> or any combination of these.</li> </ul>"},{"location":"docs/events/builtin/syscalls/break/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/break/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/break/#do_mremap","title":"do_mremap()","text":""},{"location":"docs/events/builtin/syscalls/break/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/break/#purpose","title":"Purpose","text":"<p>To detect calls to <code>break</code> to change the memory protection of a given region.</p>"},{"location":"docs/events/builtin/syscalls/break/#example-use-case","title":"Example Use Case","text":"<p>The <code>break</code> system call can be used to mark memory as non-executable to prevent malicious code injection or execution of unsigned code.</p>"},{"location":"docs/events/builtin/syscalls/break/#issues","title":"Issues","text":"<p>The <code>break</code> system call is vulnerable to TOCTOU (time of check, time of use), as the memory may be changed after the call to the <code>break</code> system call and before the protection can be applied.</p>"},{"location":"docs/events/builtin/syscalls/break/#related-events","title":"Related Events","text":"<p><code>mmap</code>, <code>mprotect</code>, <code>mremap</code></p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/brk/","title":"brk","text":""},{"location":"docs/events/builtin/syscalls/brk/#intro","title":"Intro","text":"<p>brk -  manipulates the calling process's data segment.</p>"},{"location":"docs/events/builtin/syscalls/brk/#description","title":"Description","text":"<p>The brk() system call changes the location of the program break, which defines the end of the process's data segment (i.e., the program break is the first location after the end of the uninitialized data segment). Increasing the program break has the effect of allocating memory to the process; decreasing the break deallocates memory.</p> <p>The functionality of the brk() system call is provided by libc, which implements brk() by calling the sbrk() system call. </p>"},{"location":"docs/events/builtin/syscalls/brk/#arguments","title":"Arguments","text":"<ul> <li><code>addr</code>:<code>void*</code>[K] - pointer to the requested address at which the program break would be set.</li> </ul>"},{"location":"docs/events/builtin/syscalls/brk/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/brk/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/brk/#sbrk","title":"sbrk","text":""},{"location":"docs/events/builtin/syscalls/brk/#type","title":"Type","text":"<p>Kprobe+Uprobe</p>"},{"location":"docs/events/builtin/syscalls/brk/#purpose","title":"Purpose","text":"<p>To hook this function to track when the program break is changed.</p>"},{"location":"docs/events/builtin/syscalls/brk/#example-use-case","title":"Example Use Case","text":"<p>brk() is used by programs to manage their own memory usage. This is particularly useful when dealing with dynamic memory allocation.</p>"},{"location":"docs/events/builtin/syscalls/brk/#issues","title":"Issues","text":"<p>There is no guarantee that brk() will successfully allocate memory. Additionally, it can lead to memory fragmentation if memory is requested in large chunks rather than smaller ones.</p>"},{"location":"docs/events/builtin/syscalls/brk/#related-events","title":"Related Events","text":"<p>malloc - for allocating memory in chunks larger than the page size.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/capget/","title":"capget","text":""},{"location":"docs/events/builtin/syscalls/capget/#intro","title":"Intro","text":"<p>capget - Retrieve system capabilities</p>"},{"location":"docs/events/builtin/syscalls/capget/#description","title":"Description","text":"<p>The capget() system call, which retrieves the current capabilities of a certain process or process group. It takes two arguments, a pointer to a <code>cap_user_headers_t</code> structure containing information about the requested capabilities, and a pointer to a <code>cap_user_data_t</code> structure containing an array of capability numbers. The system call then fills in these structures to contain the requested capabilities.</p> <p>There are some drawbacks and edge-cases when using this system call. First, the  requested capabilities must be in range of the capabilities supported by the operating system. Second, if the request is for a process group and the process group doesn't exist, capget() fails with an error code. Finally, not all systems support all of the capabilities that capget() can retrieve.</p>"},{"location":"docs/events/builtin/syscalls/capget/#arguments","title":"Arguments","text":"<ul> <li><code>hdrp</code>: <code>cap_user_header_t</code>[K] - Pointer to a header containing the requested capability type and data length.</li> <li><code>datap</code>: <code>cap_user_data_t</code>[K] - Pointer to an array of one or more capability numbers.</li> </ul>"},{"location":"docs/events/builtin/syscalls/capget/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/capget/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/capget/#capget_1","title":"<code>capget</code>","text":""},{"location":"docs/events/builtin/syscalls/capget/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/capget/#purpose","title":"Purpose","text":"<p>These probes are used to capture system calls when they enter and exit the kernel.</p>"},{"location":"docs/events/builtin/syscalls/capget/#example-use-case","title":"Example Use Case","text":"<p>For example, a security administrator may use capget() to query the current system capabilities of a certain process or process group in order to audit their system configuration. </p>"},{"location":"docs/events/builtin/syscalls/capget/#issues","title":"Issues","text":"<p>Currently, there is no way to retrieve multiple sets of capabilities within one capget() system call.</p>"},{"location":"docs/events/builtin/syscalls/capget/#related-events","title":"Related Events","text":"<ul> <li>capset() - Set system capabilities for process or process group</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/capset/","title":"capset","text":""},{"location":"docs/events/builtin/syscalls/capset/#intro","title":"Intro","text":"<p>capset - dynamically change user's and/or process's capability sets</p>"},{"location":"docs/events/builtin/syscalls/capset/#description","title":"Description","text":"<p>The capset() system call is used to set the user-space capability sets of the current process or of a specified process, as specified in the arguments. cap_user_header_t structure describes the layout of the actual capability sets. It consists of an integer, specifying the version of the structure and an integer, specifying the length of the data that follows. The cap_user_data_t structure describes the capability sets of a given process.</p> <p>The capset() system call can be used to modify the process's current capability sets or to set the capability sets of a specified process, depending on which of the arguments are given. The capset() system call also allows setting flags, if the process is root, to indicate if the capability sets should be inherited by the child processes.</p> <p>There are some drawbacks and advantages of using the capset() system call. The main advantage is that it allows a process to change the set of  capabilities it has at runtime, allowing for higher level of security and stability. On the other hand, it can be susceptible to malicious users of the system, as they can set the capability sets to a different  state than they should be.</p>"},{"location":"docs/events/builtin/syscalls/capset/#arguments","title":"Arguments","text":"<ul> <li><code>hdrp</code>:<code>cap_user_header_t</code>[KU] - pointer to a data structure describing the layout of the capability sets of the process. </li> <li><code>datap</code>:<code>const cap_user_data_t</code>[KU] - pointer to a data structure  describing the capability sets of the process.</li> </ul>"},{"location":"docs/events/builtin/syscalls/capset/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/capset/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/capset/#sys_capset","title":"sys_capset","text":""},{"location":"docs/events/builtin/syscalls/capset/#type","title":"Type","text":"<p>Kprobes </p>"},{"location":"docs/events/builtin/syscalls/capset/#purpose","title":"Purpose","text":"<p>To detect changes to process or threads' capability sets.</p>"},{"location":"docs/events/builtin/syscalls/capset/#uprobes","title":"uprobes","text":""},{"location":"docs/events/builtin/syscalls/capset/#type_1","title":"Type","text":"<p>Uprobes</p>"},{"location":"docs/events/builtin/syscalls/capset/#purpose_1","title":"Purpose","text":"<p>To detect if userspace execution attempts to change a process's capability sets.</p>"},{"location":"docs/events/builtin/syscalls/capset/#example-use-case","title":"Example Use Case","text":"<p>The capset() system call can be useful in order to monitor changes to a  process's capability sets. For example, if a vulnerable process is detected, monitoring its capability sets can help detect if an attacker is attempting to set the capability sets to a different state.</p>"},{"location":"docs/events/builtin/syscalls/capset/#issues","title":"Issues","text":"<p>No significant issues with the system call were found in the manual page.</p>"},{"location":"docs/events/builtin/syscalls/capset/#related-events","title":"Related Events","text":"<ul> <li>get_this_capable() - get the current process's capability sets</li> <li>set_thread_capability() - Associate thread or process with an additional capability set</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/chdir/","title":"chdir","text":""},{"location":"docs/events/builtin/syscalls/chdir/#intro","title":"Intro","text":"<p>chdir - Change the current working directory</p>"},{"location":"docs/events/builtin/syscalls/chdir/#description","title":"Description","text":"<p>The chdir syscall allows the user to set the current working directory and affects the behavior of subsequent path-related syscals. The argument provided is a const char pointer, which points to the directory to which the working directory should be set. If a path is specified that does not exist or is not accessible, a -1 error code is returned</p>"},{"location":"docs/events/builtin/syscalls/chdir/#arguments","title":"Arguments","text":"<ul> <li><code>path</code>:const char* - Pointer to a C-style string that holds the path of the directory to be set as the current working directory</li> </ul>"},{"location":"docs/events/builtin/syscalls/chdir/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/chdir/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/chdir/#sys_chdir","title":"sys_chdir","text":""},{"location":"docs/events/builtin/syscalls/chdir/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/chdir/#purpose","title":"Purpose","text":"<p>To monitor and measure execution of the chdir syscall </p>"},{"location":"docs/events/builtin/syscalls/chdir/#example-use-case","title":"Example Use Case","text":"<p>In some situation, it is useful to monitor chdir syscall invocations and to get various stats regarding their execution. One example of a situation that could benefit from this is separate attempts to change the working directory in a program. This data can be used to better understand the program's behavior or to detect any suspicious activity.</p>"},{"location":"docs/events/builtin/syscalls/chdir/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/chdir/#related-events","title":"Related Events","text":"<ul> <li>execve - Execute program</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/chmod/","title":"chmod","text":""},{"location":"docs/events/builtin/syscalls/chmod/#intro","title":"Intro","text":"<p>chmod - change the permissions of a file</p>"},{"location":"docs/events/builtin/syscalls/chmod/#description","title":"Description","text":"<p>The chmod() system call is used to change the permission of a given file path, determined by the parameter <code>pathname</code>. The permission bits of a file are set using the second parameter of the call, <code>mode</code>, which is the third parameter of type <code>mode_t</code> and is expected as a bitmask of permission bits.</p> <p>The permission are set base on the user or group that own the file, setuid and setgid bit and marix of user, group and other. For more detail the man page of chmod should be consulted.</p> <p>There are some edge cases where the permission are not inhereted by the files that are created in a directory, for instance when creating a file with the O_TMPFILE flag. Also when using the flag chmod(), it will not delete the sticky bit information from the files.</p>"},{"location":"docs/events/builtin/syscalls/chmod/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code>[K] - Path to the file whose permission bits are to be changed.</li> <li><code>mode</code>:<code>mode_t</code>[K] -  A bitmask of permission bits that will be used to set the new permission.</li> </ul>"},{"location":"docs/events/builtin/syscalls/chmod/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/chmod/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/chmod/#sys_chmod","title":"sys_chmod","text":""},{"location":"docs/events/builtin/syscalls/chmod/#type","title":"Type","text":"<p>Kprobe.</p>"},{"location":"docs/events/builtin/syscalls/chmod/#purpose","title":"Purpose","text":"<p>To get a context of the bits which are being used to change the mode and who initiated the call.</p>"},{"location":"docs/events/builtin/syscalls/chmod/#example-use-case","title":"Example Use Case","text":"<p>In order to collect events about every time files permissions inside of a directory are modified, you can use this event.</p>"},{"location":"docs/events/builtin/syscalls/chmod/#issues","title":"Issues","text":"<p>The event is vulnerable to TOCTOU, use care when operating on it.</p>"},{"location":"docs/events/builtin/syscalls/chmod/#related-events","title":"Related Events","text":"<ul> <li>openat()</li> <li>fchmodat()</li> <li>chown()</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/chown/","title":"chown","text":""},{"location":"docs/events/builtin/syscalls/chown/#intro","title":"Intro","text":"<p>chown - changes the owner and group of a file or directory</p>"},{"location":"docs/events/builtin/syscalls/chown/#description","title":"Description","text":"<p>The chown() function changes the user and/or group ownership of a given file or directory. It is only available to users with appropriate permissions or with elevated privileges. The owner and group are changed to the numeric values provided.</p>"},{"location":"docs/events/builtin/syscalls/chown/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code> - the pathname of the file or directory whose ownership is to be changed.</li> <li><code>owner</code>:<code>uid_t</code> - the numerical user ID of the new owner. A value of -1 will not change the owner of the file.</li> <li><code>group</code>:<code>gid_t</code> - the numerical group ID of the new group. A value of -1 will not change the group of the file.</li> </ul>"},{"location":"docs/events/builtin/syscalls/chown/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/chown/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/chown/#sys_chown","title":"sys_chown","text":""},{"location":"docs/events/builtin/syscalls/chown/#type","title":"Type","text":"<p>KProbe</p>"},{"location":"docs/events/builtin/syscalls/chown/#purpose","title":"Purpose","text":"<p>Hooking this function allows to monitor the chown() system call and its parameters in order to track changes in file and directory ownership.</p>"},{"location":"docs/events/builtin/syscalls/chown/#example-use-case","title":"Example Use Case","text":"<p>An example of when chown() might be useful is when a privileged user needs to change ownership of a directory or its files to a different user.</p>"},{"location":"docs/events/builtin/syscalls/chown/#issues","title":"Issues","text":"<p>Care should be taken when using chown() with setuid programs as the file ownership can be changed in an unexpected way.</p>"},{"location":"docs/events/builtin/syscalls/chown/#related-events","title":"Related Events","text":"<ul> <li>chmod - changes the permissions of a file or directory.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/chown16/","title":"chown16","text":""},{"location":"docs/events/builtin/syscalls/chown16/#intro","title":"Intro","text":"<p>chown16 - System call to change the owner and group of a given file pathname. </p>"},{"location":"docs/events/builtin/syscalls/chown16/#description","title":"Description","text":"<p>The chown16 syscall is a system call used to change the owner and group of a given file pathname. It is an important system call because it allows the owner of a file to control who can read, write and perform operations with said file. Furthermore, it also is important for administrators to be able to set permissions for sensitive costs.</p> <p>There are some edge-cases to be considered when using this syscall, such as race conditions, since changes can be made between the check time and the use time, causing inconsistent results. Furthermore, since old_uid_t and old_gid_t are used as parameters, there can be issues with overflows when dealing with high IDs numbers.</p>"},{"location":"docs/events/builtin/syscalls/chown16/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code>[K] - Pathname of the file to change the owner and group.  </li> <li><code>owner</code>:<code>old_uid_t</code>[K] - UID (owner ID) to set as owner of the file.  </li> <li><code>group</code>:<code>old_gid_t</code>[K] - GID (group ID) to set as group of the file.  </li> </ul>"},{"location":"docs/events/builtin/syscalls/chown16/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space. </li> </ul>"},{"location":"docs/events/builtin/syscalls/chown16/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/chown16/#sys_chown16","title":"sys_chown16","text":""},{"location":"docs/events/builtin/syscalls/chown16/#type","title":"Type","text":"<p>Kprobe.</p>"},{"location":"docs/events/builtin/syscalls/chown16/#purpose","title":"Purpose","text":"<p>To track every time chown16 is called, as well as its arguments and return value.</p>"},{"location":"docs/events/builtin/syscalls/chown16/#example-use-case","title":"Example Use Case","text":"<p>A system administrator can use chown16 in order to give access to a group of users to a restricted file, by setting a given group or owner for it.</p>"},{"location":"docs/events/builtin/syscalls/chown16/#issues","title":"Issues","text":"<p>There is a vulnerability known as TOCTOU (time-of-check to time-of-use), which can cause a race condition allowing execution of malicious code.</p>"},{"location":"docs/events/builtin/syscalls/chown16/#related-events","title":"Related Events","text":"<ul> <li>chown - similar system call, but with 32-bit UID and GID parameters.</li> <li>fchown - system call to change the owner and group of a given file descriptor.</li> <li>lchown - system call to change the owner and group of a given symbolic link pathname.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/chroot/","title":"chroot","text":""},{"location":"docs/events/builtin/syscalls/chroot/#intro","title":"Intro","text":"<p>chroot() - changes the root directory of a process</p>"},{"location":"docs/events/builtin/syscalls/chroot/#description","title":"Description","text":"<p>The chroot() system call changes the root directory of the calling process to the path specified in the path argument. This directory will be the new root directory for the calling process and all its children. The chroot() system call restricts the ability of a process to access files outside the new root directory. The process must have root privileges in order to  successfully call chroot().</p> <p>Edge cases/drawbacks:  * This call should only be used under extreme circumstances since it is not reversible.</p>"},{"location":"docs/events/builtin/syscalls/chroot/#arguments","title":"Arguments","text":"<ul> <li><code>path</code>:<code>const char*</code> - path of the new root directory.</li> </ul>"},{"location":"docs/events/builtin/syscalls/chroot/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/chroot/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/chroot/#execve","title":"execve","text":""},{"location":"docs/events/builtin/syscalls/chroot/#type","title":"Type","text":"<p>kprobe.</p>"},{"location":"docs/events/builtin/syscalls/chroot/#purpose","title":"Purpose","text":"<p>Hooked to detect a process that has been successfully chrooted.</p>"},{"location":"docs/events/builtin/syscalls/chroot/#example-use-case","title":"Example Use Case","text":"<p>It can be used to detect malicious activity when a process inside the system is attempting to break out of its jailed environment.</p>"},{"location":"docs/events/builtin/syscalls/chroot/#issues","title":"Issues","text":"<p>The chroot() syscall should be used with extreme caution since it is not reversible and can be easily misused.</p>"},{"location":"docs/events/builtin/syscalls/chroot/#related-events","title":"Related Events","text":"<ul> <li>chdir - changes the current working directory of a process.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/clock_adjtime/","title":"clock_adjtime","text":""},{"location":"docs/events/builtin/syscalls/clock_adjtime/#intro","title":"Intro","text":"<p><code>clock_adjtime()</code> - set, get and adjust a clock's offset and frequency</p>"},{"location":"docs/events/builtin/syscalls/clock_adjtime/#description","title":"Description","text":"<p>The clock_adjtime() system call sets, gets and adjusts (i.e. corrects) the time or frequency of the clock designated by clock_id. buf is a pointer to a <code>struct timex</code> data structure which is used to obtain further details about the operation to be performed by clock_adjtime.</p> <p>The main purpose of this system call is to allow an applications to modify the offset and/or frequency of a time source/clock to ensure time-stamp accuracy, as well as to compensate for any skews in the clocks' frequency caused by environmental factors such as temperature variations. Furthermore, it allows the clock offset of a given clock to be set, directly, to a given value.</p>"},{"location":"docs/events/builtin/syscalls/clock_adjtime/#arguments","title":"Arguments","text":"<ul> <li><code>clk_id</code>: <code>const clockid_t</code> - Identifies the clock to be affected by the call. There are a number of predefined clocks which can exist in the system, each given a specific clock ID, and further application-defined clocks can be created with <code>timer_create()</code>. </li> <li><code>buf</code>: <code>struct timex*</code> - A pointer to a <code>struct timex</code> data structure, which contains the clock adjustments to be made as well as a number of other related parameters.</li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_adjtime/#available-tags","title":"Available Tags","text":"<p>No available tags.</p>"},{"location":"docs/events/builtin/syscalls/clock_adjtime/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/clock_adjtime/#sys_clock_adjtime","title":"<code>sys_clock_adjtime</code>","text":""},{"location":"docs/events/builtin/syscalls/clock_adjtime/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/clock_adjtime/#purpose","title":"Purpose","text":"<p>Determine clock offset and frequency.</p>"},{"location":"docs/events/builtin/syscalls/clock_adjtime/#do_adjtimex","title":"<code>do_adjtimex</code>","text":""},{"location":"docs/events/builtin/syscalls/clock_adjtime/#type_1","title":"Type","text":"<p>Kprobes + Tracepoints</p>"},{"location":"docs/events/builtin/syscalls/clock_adjtime/#purpose_1","title":"Purpose","text":"<p>The purpose of hooking do_adjtimex is to determine whether the clock offset and frequency is being adjusted by a given clock, as well as to record any error values that may be returned.</p>"},{"location":"docs/events/builtin/syscalls/clock_adjtime/#example-use-case","title":"Example Use Case","text":"<p>Consider an application for which time stamp accuracy is paramount. This system could use the <code>clock_adjtime()</code> system call to make adjustments to the clock's frequency and offset. This could be, for example, when the clock source is experiencing temperature-based frequency drift. The <code>clock_adjtime()</code> can be used to correct this drift, ensuring that timestamps are accurate and allowing the application to continue functioning without any substantial interruptions.</p>"},{"location":"docs/events/builtin/syscalls/clock_adjtime/#issues","title":"Issues","text":"<p>This system call requires root privileges. This can be a potential security issue if too many users have access to the call. Furthermore, the system call can be prone to TOCTOU (Time of check, time of use) attacks, as some of the values provided by the caller might have changed by the time the call is executed by the kernel.</p>"},{"location":"docs/events/builtin/syscalls/clock_adjtime/#related-events","title":"Related Events","text":"<ul> <li><code>clock_gettime</code> - returns the time information from the specified 'clock_id'</li> <li><code>clock_settime</code> - sets the given clock to a specified time value</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/clock_adjtime64/","title":"clock_adjtime64","text":""},{"location":"docs/events/builtin/syscalls/clock_adjtime64/#intro","title":"Intro","text":"<p>clock_adjtime64 - Sets clock adjustment for a specific clock.</p>"},{"location":"docs/events/builtin/syscalls/clock_adjtime64/#description","title":"Description","text":"<p>The clock_adjtime64 function allows for an application to adjust the clock for a specific clock. The clock is specified by its id if the id is available. The new adjustment will be applied to the clock immediately if the clock is current, otherwise the adjustment is made relative to the present adjustment. The adjustment given consists of (1) a time value specifying when the adjustment should be made, and (2) a time value specifying the amount of time to be added or subtracted from the clock\u2019s current time. The adjustment is always relative to the system time; that is, the adjustment represents the difference between the system time and the time to be set with the adjustment.</p> <p>When an adjustment is applied, the clock\u2019s \u2018tick counter\u2019 is reset to the adjusting ratio. This means that the number of clock ticks (or \u2018tick counts\u2019) since the last adjustment will remain fixed until the next adjustment.</p> <p>The clock_adjtime64 function is useful for applications which require precise timing, like audio and video applications. Since the clock time is adjusted to the system time, applications can use this function to align their time-referenced activities with the system time.</p> <p>However, applications must be aware of a few parameters when using clock_adjtime64. One is that if a change of the clock times is made, the process must also handle any updates to the system time. Another is that the adjustment may take longer than expected if the system clock is being heavily used. </p>"},{"location":"docs/events/builtin/syscalls/clock_adjtime64/#arguments","title":"Arguments","text":"<ul> <li><code>clock_id</code>:<code>__kernel_clockid_t</code>[K] - The clock id of the clock to adjust. The clock id is a positive integer specifying the clock to modify.</li> <li><code>ts</code>:<code>const struct __kernel_timespec *</code>[K] - A pointer to a <code>struct __kernel_timespec</code> object containing the desired adjustment value (<code>adjustmenttime</code>) and the time of the adjustment (<code>adjustmenttime</code>).</li> <li><code>old_ts</code>:<code>struct timespec *</code>[K] - A pointer to a <code>struct timespec</code> object to receive the time of the last clock adjustment.</li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_adjtime64/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_adjtime64/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/clock_adjtime64/#do_adjtimex","title":"do_adjtimex","text":""},{"location":"docs/events/builtin/syscalls/clock_adjtime64/#type","title":"Type","text":"<p>Raw kernel probes</p>"},{"location":"docs/events/builtin/syscalls/clock_adjtime64/#purpose","title":"Purpose","text":"<p>Logging when clock_adjtime64 is called.</p>"},{"location":"docs/events/builtin/syscalls/clock_adjtime64/#sys_clock_adjtime","title":"sys_clock_adjtime","text":""},{"location":"docs/events/builtin/syscalls/clock_adjtime64/#type_1","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/clock_adjtime64/#purpose_1","title":"Purpose","text":"<p>Logging of clock_adjtime64 parameters.</p>"},{"location":"docs/events/builtin/syscalls/clock_adjtime64/#example-use-case","title":"Example Use Case","text":"<p>An audio software that uses clock_adjtime64 to keep a consistent clock time throughout the application. This provides a bulwark against timing issues that could otherwise lead to distortion or lost data.</p>"},{"location":"docs/events/builtin/syscalls/clock_adjtime64/#issues","title":"Issues","text":"<p>Since the results of a successfully called clock_adjtime64 are non-deterministic, applications must handle the cases where the clock is determined to be too slow or too fast.</p>"},{"location":"docs/events/builtin/syscalls/clock_adjtime64/#related-events","title":"Related Events","text":"<ul> <li>clock_settime</li> <li>clock_gettime</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/clock_getres/","title":"clock_getres","text":""},{"location":"docs/events/builtin/syscalls/clock_getres/#intro","title":"Intro","text":"<p>clock_getres - This system call knows the resolution (precision) of the specified clock, i.e. the period between successive readings.</p>"},{"location":"docs/events/builtin/syscalls/clock_getres/#description","title":"Description","text":"<p>The <code>clock_getres</code> system call gets current clock resolution for the specified clock.  It returns the resolution of the clock, that is, how often clock periods occur.  It is expressed in seconds and nanoseconds. It is allowed for the target of the <code>res</code> argument to be NULL. In this case, the resolution is not returned though the system call does succeed.</p> <p>One advantage of using this system call instead of other system calls to measure time is that  it provides an accurate enough resolution to measure even small chunks of time. As such,  it is widely used in benchmarking and performance testing applications.  A potential drawback of using this system call to measure time is that the resolution of the clock is  based on the system, so the accuracy of the measurement may vary across different system configurations. </p>"},{"location":"docs/events/builtin/syscalls/clock_getres/#arguments","title":"Arguments","text":"<ul> <li><code>clockid</code>:<code>const clockid_t</code> - The clock ID to get the resolution of. </li> <li><code>res</code>:<code>struct timespec*</code>[K] - Pointer to a timespec structure filled by the kernel with the resolution of the clock. </li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_getres/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_getres/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/clock_getres/#sys_clock_getres","title":"sys_clock_getres","text":""},{"location":"docs/events/builtin/syscalls/clock_getres/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/clock_getres/#purpose","title":"Purpose","text":"<p>Hooking the <code>sys_clock_getres</code> function allows us to properly measure the time of execution of the <code>clock_getres</code> system call.</p>"},{"location":"docs/events/builtin/syscalls/clock_getres/#example-use-case","title":"Example Use Case","text":"<p>The <code>clock_getres</code> system call can be used in performance tests or benchmarking applications  in order to accurately measure the time spent in certain parts of the code.</p>"},{"location":"docs/events/builtin/syscalls/clock_getres/#issues","title":"Issues","text":"<p>No known issues.</p>"},{"location":"docs/events/builtin/syscalls/clock_getres/#related-events","title":"Related Events","text":"<ul> <li>clock_gettime</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/clock_getres_time32/","title":"clock_getres_time32","text":""},{"location":"docs/events/builtin/syscalls/clock_getres_time32/#intro","title":"Intro","text":"<p>clock_getres_time32 - retrieves the resolution of the specified clock.</p>"},{"location":"docs/events/builtin/syscalls/clock_getres_time32/#description","title":"Description","text":"<p>clock_getres_time32 retrives the resolution of the specified clock in struct old_timespec32 variable provided in the tp argument. This function allows information about the resolution of the clock to be queried, for use in accurately measuring time intervals. </p> <p>clock_getres_time32 exists for backward compatibility with 32bit systems, in replacement to clock_getres which takes timespec structure as an argument.</p>"},{"location":"docs/events/builtin/syscalls/clock_getres_time32/#arguments","title":"Arguments","text":"<ul> <li><code>which_clock</code>:<code>clockid_t</code>[K] - clock id use to query its resolution.  Supported clocks are the same as with clock_gettime.</li> <li><code>tp</code>:<code>struct old_timespec32*</code>[KU] - pointer to a buffer where the resolution of the clock will be stored.</li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_getres_time32/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_getres_time32/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/clock_getres_time32/#sys_clock_getres_time32","title":"sys_clock_getres_time32","text":""},{"location":"docs/events/builtin/syscalls/clock_getres_time32/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/clock_getres_time32/#purpose","title":"Purpose","text":"<p>To monitor and trace the execution of clock_getres_time32 syscall.</p>"},{"location":"docs/events/builtin/syscalls/clock_getres_time32/#example-use-case","title":"Example Use Case","text":"<p>clock_getres_time32 can be useful in various timing-related projects. For example, it can be used to compare the resolution of different clocks, or query a clock's resolution before a precise time measurement is taken with clock_gettime.</p>"},{"location":"docs/events/builtin/syscalls/clock_getres_time32/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/clock_getres_time32/#related-events","title":"Related Events","text":"<ul> <li>clock_gettime - query the current time</li> <li>clock_getres - query the resolution of a clock (64bit version)</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/clock_gettime/","title":"clock_gettime","text":""},{"location":"docs/events/builtin/syscalls/clock_gettime/#intro","title":"Intro","text":"<p>clock_gettime - Retrieve the current time of a specific clock</p>"},{"location":"docs/events/builtin/syscalls/clock_gettime/#description","title":"Description","text":"<p>clock_gettime() retrieves the current time from the clock specified by clockid. The tp argument is a pointer to a struct timespec, in which the current time is stored. It supports the following clock ids: - CLOCK_REALTIME: system-wide realtime clock - CLOCK_MONOTONIC: system-wide monotonically increasing clock - CLOCK_PROCESS_CPUTIME_ID: per-process accounting clock - CLOCK_THREAD_CPUTIME_ID: per-thread accounting clock</p> <p>Using clock_gettime() is a much more accurate approach than calling <code>time()</code> to retrieve the current time, as the latter will return the timestamp of the System Time Zone.</p>"},{"location":"docs/events/builtin/syscalls/clock_gettime/#arguments","title":"Arguments","text":"<ul> <li><code>clockid</code>:<code>const clockid_t</code>[K] - Id of the clock whose current time should be retrieved.</li> <li><code>tp</code>:<code>struct timespec*</code>[KU] - Pointer to a timespec structure where the current time will be stored.</li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_gettime/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_gettime/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/clock_gettime/#sys_clock_gettime","title":"sys_clock_gettime","text":""},{"location":"docs/events/builtin/syscalls/clock_gettime/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/clock_gettime/#purpose","title":"Purpose","text":"<p>Capture all calls to clock_gettime and monitor the process that calls it.</p>"},{"location":"docs/events/builtin/syscalls/clock_gettime/#example-use-case","title":"Example Use Case","text":"<p>Monitoring the wall clock time of a process and calculating the total execution time.</p>"},{"location":"docs/events/builtin/syscalls/clock_gettime/#issues","title":"Issues","text":"<p>This API may suffer from resource contention when multiple processes call it simultaneously.</p>"},{"location":"docs/events/builtin/syscalls/clock_gettime/#related-events","title":"Related Events","text":"<p>N/A</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/clock_gettime32/","title":"clock_gettime32","text":""},{"location":"docs/events/builtin/syscalls/clock_gettime32/#intro","title":"Intro","text":"<p>clock_gettime32 - get the time of a specific clock, with a 32-bit version of <code>struct timespec</code></p>"},{"location":"docs/events/builtin/syscalls/clock_gettime32/#description","title":"Description","text":"<p>clock_gettime32 is a Linux system call that retrieves the current time of the clock specified in the argument <code>which_clock</code>. The time is returned in <code>struct old_timespec32</code> pointed to by the argument <code>tp</code>. This version of the call is for 32-bit applications using an old version of <code>struct timespec</code>.</p> <p>The call can be subject to races if the time is retrieved between the check, at which point the output is known, and the use, at which point there are no guarantees the output is still valid. It's related to the time-of-check-time-of-use (TOCTOU) vulnerability, and it can be mitigated by applying locks or other synchronization techniques.</p>"},{"location":"docs/events/builtin/syscalls/clock_gettime32/#arguments","title":"Arguments","text":"<ul> <li><code>which_clock</code>:<code>clockid_t</code> - The identifier of the clock whose time is requested.</li> <li><code>tp</code>:<code>struct old_timespec32*</code>[U] - Pointer to a buffer in user-space that is used to return the current time.</li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_gettime32/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_gettime32/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/clock_gettime32/#sys_clock_gettime","title":"sys_clock_gettime","text":""},{"location":"docs/events/builtin/syscalls/clock_gettime32/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/clock_gettime32/#purpose","title":"Purpose","text":"<p>To log the system calls for clock_gettime and clock_gettime32 at the entry point of syscall sys_clock_gettime.</p>"},{"location":"docs/events/builtin/syscalls/clock_gettime32/#example-use-case","title":"Example Use Case","text":"<p>clock_gettime32's usage requires a clockid_t and a pointer to an old timespec structure. It can be used to get the current time of the requested clock, and then store and compare it in the future.</p>"},{"location":"docs/events/builtin/syscalls/clock_gettime32/#issues","title":"Issues","text":"<p>Since clock_gettime32 is vulnerable to TOCTOU, care should be taken that the returned time might be stale by the time it is used. This can be mitigated by applying locks or other synchronization techniques.</p>"},{"location":"docs/events/builtin/syscalls/clock_gettime32/#related-events","title":"Related Events","text":"<ul> <li>clock_nanosleep - Suspend the execution of the current thread until the time pointed by tp.</li> <li>timerfd_gettime - Retrieve the current expiry time of the timer associated with the timerfd.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/clock_nanosleep/","title":"clock_nanosleep","text":""},{"location":"docs/events/builtin/syscalls/clock_nanosleep/#intro","title":"Intro","text":"<p>clock_nanosleep - cause the current thread to sleep until a given time</p>"},{"location":"docs/events/builtin/syscalls/clock_nanosleep/#description","title":"Description","text":"<p>The clock_nanosleep() system call causes the current thread to be suspended from execution until the absolute time specified by *tsp. The suspesion time may be shorter than requested because of the delivery of a signal. If the call is interrupted by the delivery of a signal, the remaining sleep time is returned in the remain argument of type struct timespcae, or is 0 if the timer expired. Two flags for use with nanosleep() are available, and defined in time.h</p> <ul> <li>TIMER_ABSTIME - set absolute timer value</li> <li>TIMER_RELTIME - set relative timer value</li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_nanosleep/#arguments","title":"Arguments","text":"<ul> <li> <p><code>clockid</code>: <code>const clockid_t</code> - The following clocks IDs are available; </p> <ul> <li>[CLOCK_REALTIME] (https://man7.org/linux/man-pages/man2/clock_gettime.2.html)</li> <li>[CLOCK_MONOTONIC] (https://man7.org/linux/man-pages/man2/clock_gettime.2.html)</li> <li>[CLOCK_MONOTONIC_RAW] (https://man7.org/linux/man-pages/man2/clock_gettime.2.html)</li> <li>[CLOCK_BOOTTIME] (https://man7.org/linux/man-pages/man7/timer_create.7.html)</li> </ul> </li> <li> <p><code>flags</code>: <code>int</code> - If this is set to 0, the timer expiration value is specified in the <code>request</code> argument and is an absolute value. If the flag is set to TIMER_ABSTIME, ts is an absolute time. If TIMER_RELTIME is specified in flags, ts is a relative time.</p> </li> <li> <p><code>request</code>: <code>const struct timespec*</code>K - pointer to the timespec structure contains the expcation time of the nanosleep call. For the TIMER_ABSTIME the expiration time is an absolute time specified by <code>request</code>. For the TIMER_RELTIME the expiration time is a relative time specified by <code>request</code>.</p> </li> <li> <p><code>remain</code>: <code>struct timespec*</code>K - pointer to the timespec structure containing the remaining sleep time left or 0 if the timer expired.</p> </li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_nanosleep/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_nanosleep/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/clock_nanosleep/#nanosleep","title":"nanosleep","text":""},{"location":"docs/events/builtin/syscalls/clock_nanosleep/#type","title":"Type","text":"<p>Probed</p>"},{"location":"docs/events/builtin/syscalls/clock_nanosleep/#purpose","title":"Purpose","text":"<p>Hooked to track execution of clock_nanosleep syscall.</p>"},{"location":"docs/events/builtin/syscalls/clock_nanosleep/#example-use-case","title":"Example Use Case","text":"<p>clock_nanosleep can be used to set a timer that will cause the current thread of a process to be suspended for a given amount of time. This can be useful for implementing algorithms such as synchronization, where it is necessary to wait for a certain amount of time before proceeding.</p>"},{"location":"docs/events/builtin/syscalls/clock_nanosleep/#issues","title":"Issues","text":"<ul> <li>clock_nanosleep is vulnerable to TOCTOU (Time-of-Check-Time-of-Use) attack</li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_nanosleep/#related-events","title":"Related Events","text":"<ul> <li>clock_gettime()</li> <li>clock_settime()</li> <li>clock_getres()</li> <li>timer_create()</li> <li>timer_settime()</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/clock_nanosleep_time32/","title":"clock_nanosleep_time32","text":""},{"location":"docs/events/builtin/syscalls/clock_nanosleep_time32/#intro","title":"Intro","text":"<p>clock_nanosleep_time32 - suspend the execution of the calling thread until the time pointed to by rqtp is reached</p>"},{"location":"docs/events/builtin/syscalls/clock_nanosleep_time32/#description","title":"Description","text":"<p>The clock_nanosleep_time32() function is used to suspend the execution of the calling thread until the time pointed to by rqtp is reached. If flags is 0, the thread will be suspended until the time pointed by rqtp is reached. The which_clock argument specifies the clock to use for measuring this timeout, the value can be either CLOCK_REALTIME or CLOCK_MONOTONIC. If rmtp (remaining time pointer) is a non-null pointer then the remaining time is stored in the old_timespec32(include  for details) structure referenced by rmtp. If rmtp is non-null and the clock_nanosleep_time32() time is interrupted by a signal while the thread is suspended, the remaining time is written to rmtp and -1 is returned with errno set to EINTR. This is the most reliable and portable way to implement timeout guards."},{"location":"docs/events/builtin/syscalls/clock_nanosleep_time32/#arguments","title":"Arguments","text":"<ul> <li><code>which_clock</code>:<code>clockid_t</code>[K] - The clock to use for measuring this timeout. The value can be either CLOCK_REALTIME or CLOCK_MONOTONIC.</li> <li><code>flags</code>:<code>int</code>[K] - If flags is 0, the thread will be suspended until the time pointed by rqtp is reached.</li> <li><code>rqtp</code>:<code>struct old_timespec32</code>*[K] - Pointer to the address of structure containing the requested time value.</li> <li><code>rmtp</code>:<code>struct old_timespec32</code>*[K, OPT] - Pointer to an old_timespec32 structure, if it is non-null, the remaining time will be stored in the old_timespec32 structure referenced by it. If it is null the remaining time will be ignored.</li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_nanosleep_time32/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_nanosleep_time32/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/clock_nanosleep_time32/#do_nanosleep_time32","title":"do_nanosleep_time32","text":""},{"location":"docs/events/builtin/syscalls/clock_nanosleep_time32/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/clock_nanosleep_time32/#purpose","title":"Purpose","text":"<p>To trace Nanosleep calls made from user-space.</p>"},{"location":"docs/events/builtin/syscalls/clock_nanosleep_time32/#example-use-case","title":"Example Use Case","text":"<p>The clock_nanosleep_time32() function can be used by applications to easily manage their timeouts while they are waiting for a given event or condition to be satisfied.</p>"},{"location":"docs/events/builtin/syscalls/clock_nanosleep_time32/#issues","title":"Issues","text":"<p>The clock_nanosleep_time32() call relies on the kernel's scheduling policy, so the system may lag if there is heavy activity and the thread may not wake up exactly when it was supposed to.</p>"},{"location":"docs/events/builtin/syscalls/clock_nanosleep_time32/#related-events","title":"Related Events","text":"<ul> <li><code>do_nanosleep_time32</code> - kernel entry point.</li> <li><code>clock_nanosleep</code> - Older syscall which can still be used for the same purpose.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/clock_settime/","title":"clock_settime","text":""},{"location":"docs/events/builtin/syscalls/clock_settime/#intro","title":"Intro","text":"<p>clock_settime - Used to set the time of the specified clock</p>"},{"location":"docs/events/builtin/syscalls/clock_settime/#description","title":"Description","text":"<p>The clock_settime() system call sets the time of the specified clock, clk_id, to the broken-down time, *tp.   </p> <p>If clk_id is CLOCK_REALTIME or CLOCK_MONOTONIC, the time values tp is interpreted as a time value relative to the Epoch, satisfying the constraint that the Epoch + the seconds field in the tp structure must not exceed the maximum value supported by the kernel.</p> <p>The clock can be adjusted with respect to another clock, which is specified by the clockid argument. It is also possible to set a processor-specific clock with the types of CLOCK_PROCESS_CPUTIME_ID or CLOCK_THREAD_CPUTIME_ID.  </p> <p>Using CLOCK_REALTIME, CLOCK_MONOTONIC, or CLOCK_REALTIME_COARSE will guarantee a representable time, satisfying the constraint mentioned above.</p>"},{"location":"docs/events/builtin/syscalls/clock_settime/#arguments","title":"Arguments","text":"<ul> <li><code>clockid</code>: <code>const clockid_t</code> - Identifies a particular clock. The supported clocks depends on the implementation.</li> <li><code>tp</code>: <code>const struct timespec *</code> - Pointer to a timespec structure that contains the new time.</li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_settime/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_settime/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/clock_settime/#do_sys_clock_settime","title":"do_sys_clock_settime","text":""},{"location":"docs/events/builtin/syscalls/clock_settime/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/clock_settime/#purpose","title":"Purpose","text":"<p>To monitor and record the time setting events.</p>"},{"location":"docs/events/builtin/syscalls/clock_settime/#example-use-case","title":"Example Use Case","text":"<p>The clock_settime() system call can be used to set the clocks of real-time applications with an accuracy of around one microsecond. It is useful for ensuring events are accurately timed and synchronized.</p>"},{"location":"docs/events/builtin/syscalls/clock_settime/#issues","title":"Issues","text":"<p>If the specified clock id is invalid, the kernel will return an invalid argument error.  </p>"},{"location":"docs/events/builtin/syscalls/clock_settime/#related-events","title":"Related Events","text":"<ul> <li>clock_gettime</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/clock_settime32/","title":"clock_settime32","text":""},{"location":"docs/events/builtin/syscalls/clock_settime32/#intro","title":"Intro","text":"<p>clock_settime32 - set the time of the specified clock</p>"},{"location":"docs/events/builtin/syscalls/clock_settime32/#description","title":"Description","text":"<p>clock_settime32() sets the time of the clock specified by which_clock to the time given by tp.  </p> <p>Advantages of using clock_settime32 is that it provides a way to set the time of the specified clock with a precision of nanoseconds, while drawbacks are that it doesn't change the system time, nor the time obtained with other clocks such as CLOCK_REALTIME.</p>"},{"location":"docs/events/builtin/syscalls/clock_settime32/#arguments","title":"Arguments","text":"<ul> <li><code>which_clock</code>:<code>clockid_t</code> - ID of the clock to set. </li> <li><code>tp</code>:<code>struct old_timespec32*</code> - pointer to a struct containing the new time of the specified clock. </li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_settime32/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/clock_settime32/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/clock_settime32/#do_sys_clock_settime","title":"do_sys_clock_settime","text":""},{"location":"docs/events/builtin/syscalls/clock_settime32/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/clock_settime32/#purpose","title":"Purpose","text":"<p>Hooked for observability purposes, to measure the execution time of clock_settime32 syscall and collect per-thread and per-process scenarios, such as library calls and user delay calls.</p>"},{"location":"docs/events/builtin/syscalls/clock_settime32/#example-use-case","title":"Example Use Case","text":"<p>clock_settime32 can be used to synchronize multiple applications running on the same machine by setting the same clock time with the same specified clock.</p>"},{"location":"docs/events/builtin/syscalls/clock_settime32/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/clock_settime32/#related-events","title":"Related Events","text":"<p>clock_gettime32 syscall.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/clone/","title":"clone","text":""},{"location":"docs/events/builtin/syscalls/clone/#intro","title":"Intro","text":"<p>clone - creates a child process</p>"},{"location":"docs/events/builtin/syscalls/clone/#description","title":"Description","text":"<p>The <code>clone</code> syscall creates a child process that shares parts of its execution context with its parent process. The parts of the context which are shared are defined by the flags parameter.  Advantages of using clone include the ability to modify the child process in the parent process using signals and ptrace, as well as the ability to share memory between the parent and child process without having to use the traditional Unix fork and exec. </p> <p>Drawbacks of using clone include the complexity of managing the execution context of multiple processes, as well as the potential for unintended sharing of address spaces or execution contexts between processes.</p>"},{"location":"docs/events/builtin/syscalls/clone/#arguments","title":"Arguments","text":"<ul> <li><code>flags</code>:<code>unsigned long</code> - flags specifying how the process will be created. See the flags section for more information.</li> <li><code>stack</code>:<code>void*</code> - pointer to the stack space for the child process. Passing <code>NULL</code> will cause the system to allocate the stack space.</li> <li><code>parent_tid</code>:<code>int*</code> - pointer to the thread ID for the parent process. This parameter is only used in the non-thread primitive case.</li> <li><code>child_tid</code>:<code>int*</code> - pointer to the thread ID for the child process. This parameter is only used in the non-thread primitive case.</li> <li><code>tls</code>:<code>unsigned long</code>- pointer to a structure containing the thread local storage data for the child process.</li> </ul>"},{"location":"docs/events/builtin/syscalls/clone/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/clone/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/clone/#sys_clone","title":"sys_clone","text":""},{"location":"docs/events/builtin/syscalls/clone/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/clone/#purpose","title":"Purpose","text":"<p>To capture the arguments passed to the <code>clone</code> syscall.</p>"},{"location":"docs/events/builtin/syscalls/clone/#example-use-case","title":"Example Use Case","text":"<p>The <code>clone</code> syscall can be used to create a new process with its own address space, but sharing the same execution context as another process. This can be used to create daemons or other services which run alongside an existing process or application.</p>"},{"location":"docs/events/builtin/syscalls/clone/#issues","title":"Issues","text":"<p>One potential issue is that the <code>clone</code> syscall can cause the parent process to enter an inconsistent state if it is interrupted while the child process is being created.</p>"},{"location":"docs/events/builtin/syscalls/clone/#related-events","title":"Related Events","text":"<ul> <li><code>fork</code> - syscall which creates a child process with its own address space, but sharing its execution context with the parent process.</li> <li><code>exec</code> - syscall which reloads a new execution context into a process, destroying the existing execution context.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/clone3/","title":"clone3","text":""},{"location":"docs/events/builtin/syscalls/clone3/#intro","title":"Intro","text":"<p>clone3 - sys_clone3() creates a new process (child process)</p>"},{"location":"docs/events/builtin/syscalls/clone3/#description","title":"Description","text":"<p>Clone3() creates a new process, with a new PID, that shall be a copy of the parent process. This can be used to customize the way a process is created and allows for passing arguments. It includes the standard behavior of clone() along with new features such as customizing the execution domain (which will determine which flags and resources will be used when creating a new process) and allowing for anonymous mapping of memory.</p> <p>The clone3() entry point allows for customizing the execution configuration. If the invocation of the clone3() entry point is successful then the new child process is returned in the variables pointed to by the cl_args struct.</p>"},{"location":"docs/events/builtin/syscalls/clone3/#arguments","title":"Arguments","text":"<ul> <li><code>cl_args</code>:<code>struct clone_args*</code>[KU] - Pointer to a structure containing arguments to customize the execution configuration.</li> <li><code>size</code>:<code>size_t</code>[K] - Size of cl_args structure.</li> </ul>"},{"location":"docs/events/builtin/syscalls/clone3/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/clone3/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/clone3/#sys_clone3","title":"sys_clone3","text":""},{"location":"docs/events/builtin/syscalls/clone3/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/clone3/#purpose","title":"Purpose","text":"<p>To track the execution of clone3 system call in the kernel.</p>"},{"location":"docs/events/builtin/syscalls/clone3/#example-use-case","title":"Example Use Case","text":"<p>This could be used for running services in Docker containers, as it is possible to customize the execution domain by using clone3.</p>"},{"location":"docs/events/builtin/syscalls/clone3/#issues","title":"Issues","text":"<p>It is vulnerable to TOCTOU (time of check, time of use) attacks due to the fact that the arguments passed to the syscall are user supplied.</p>"},{"location":"docs/events/builtin/syscalls/clone3/#related-events","title":"Related Events","text":"<ul> <li>execve - execution of a new program.</li> <li>unshare - creating a process by sharing resources to selectively.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/close/","title":"close","text":""},{"location":"docs/events/builtin/syscalls/close/#intro","title":"Intro","text":"<p>close - Closes a file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/close/#description","title":"Description","text":"<p>The <code>close()</code> system call closes a file descriptor, so that it no longer refers to any file and may be reused. Any file descriptor that is closed is automatically removed from the range of descriptors checked forready-ness in <code>select()</code> or <code>poll()</code>. The resources associated with a file descriptor are released when all file descriptors reference the same file or pipe are closed.</p> <p>close also performs a form of synchronization. When all of the file descriptors associated with a pipe have been closed, any process that had the pipe open can detect the termination of the other end of the pipe, and the process can unblock if it was blocked on a read operation.</p> <p>It is important to close all file descriptors when they are no longer needed, rather than rely on the kernel to do it. Some implementations of <code>select()</code> and <code>poll()</code> attach a copy of the file descriptor table of the process to the kernel data structure associated with the call, for use during the call. If the process has a large file descriptor table and has made a <code>select()</code> or <code>poll()</code> system call, closing a file descriptor could result in the kernel consuming a lot of memory.</p>"},{"location":"docs/events/builtin/syscalls/close/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K,U] - A file descriptor indicating the open file to close. </li> </ul>"},{"location":"docs/events/builtin/syscalls/close/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/close/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/close/#sys_close","title":"sys_close","text":""},{"location":"docs/events/builtin/syscalls/close/#type","title":"Type","text":"<p>kprobe + kretprobe</p>"},{"location":"docs/events/builtin/syscalls/close/#purpose","title":"Purpose","text":"<p>Allow the tracing of successful close system calls to a file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/close/#example-use-case","title":"Example Use Case","text":"<p><code>close()</code> can be used to end the use of a file descriptor during the opening of a file descriptor. It can also be used to close resources that are automatically released, such as network sockets.</p>"},{"location":"docs/events/builtin/syscalls/close/#issues","title":"Issues","text":"<p>It is important to note that <code>close()</code> only works on file descriptors, and does not work on file objects as different platforms have different methods for handling file objects.</p>"},{"location":"docs/events/builtin/syscalls/close/#related-events","title":"Related Events","text":"<p>open, read, write, fsync</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/close_range/","title":"close_range","text":""},{"location":"docs/events/builtin/syscalls/close_range/#intro","title":"Intro","text":"<p>close_range - sys call to close a range of file descriptors</p>"},{"location":"docs/events/builtin/syscalls/close_range/#description","title":"Description","text":"<p>The close_range system call closes the file descriptors in the range [first,last], inclusive. This can be used in UNIX systems to reduce the number of times the same file descriptor is opened, as well as to free up resources and prevent resource leaks.</p> <p>There are some edge cases to consider when using close_range. If a file descriptor is already open, it may not be possible to close it. Also, if multiple processes have the same file descriptor open, closing it within a single process may not free up the resource.</p>"},{"location":"docs/events/builtin/syscalls/close_range/#arguments","title":"Arguments","text":"<ul> <li><code>first</code>:<code>unsigned int</code>[K] - the lowest file descriptor to be closed.</li> <li><code>last</code>:<code>unsigned int</code>[K] - the highest file descriptor to be closed.</li> </ul>"},{"location":"docs/events/builtin/syscalls/close_range/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/close_range/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/close_range/#sys_close_range","title":"sys_close_range","text":""},{"location":"docs/events/builtin/syscalls/close_range/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/close_range/#purpose","title":"Purpose","text":"<p>To track the closing of a range of file descriptors.</p>"},{"location":"docs/events/builtin/syscalls/close_range/#example-use-case","title":"Example Use Case","text":"<p>A system might use <code>close_range</code> to close all unnecessary file descriptors when loading a new process to maintain resources.</p>"},{"location":"docs/events/builtin/syscalls/close_range/#issues","title":"Issues","text":"<p>The <code>close_range</code> system call may not be able to close open file descriptors if they are already open in another process.</p>"},{"location":"docs/events/builtin/syscalls/close_range/#related-events","title":"Related Events","text":"<p>The <code>open</code> and <code>close</code> system calls may accompany <code>close_range</code> calls, as they are used to open and close individual file descriptors. Additionally, the <code>dup</code>, <code>dup2</code> and <code>dup3</code> calls can be used to copy/move file descriptors around.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/connect/","title":"connect","text":""},{"location":"docs/events/builtin/syscalls/connect/#intro","title":"Intro","text":"<p>connect() - establish a connection to a remote socket.</p>"},{"location":"docs/events/builtin/syscalls/connect/#description","title":"Description","text":"<p>This system call connects the socket referred to by the file descriptor sockfd to the address specified by addr. It attempts to make a connection to another socket specified by the addr argument. The addrlen argument specifies the size of the address structure pointed to by addr.</p> <p>The type of socket used is determined by the parameters specified. The addr argument is void which allows for the address to be any type of socket address structure including internet socket address structures.</p> <p>In addition, the connect system call can allow for the passing of flags that can be used to provide functionality such as non-blocking mode, or address reuse.</p> <p>Are there any edge-cases, drawbacks or advantages of using it? One drawback of using connect() is that it is vulnerable to TOCTOU (time of check, time of use) attacks. This can occur if the address being connected to is not valid. Also, the socket being connected may be changed by a malicious actor between the time the connect() call is made and when the connection attempt is completed, thus making the connection vulnerable. In addition, connect() only provides unidirectional communication between the two endpoints, which is more vulnerable to attack in certain scenarios.</p>"},{"location":"docs/events/builtin/syscalls/connect/#arguments","title":"Arguments","text":"<ul> <li><code>sockfd</code>:<code>int</code>[KU] - file descriptor referring to the socket.</li> <li><code>addr</code>:<code>struct sockaddr*</code>[KU] - pointer to a socket address structure.</li> <li><code>addrlen</code>:<code>int</code>[KU] - length in bytes of the socket address structure pointed to by addr.</li> </ul>"},{"location":"docs/events/builtin/syscalls/connect/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/connect/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/connect/#sys_connect","title":"sys_connect","text":""},{"location":"docs/events/builtin/syscalls/connect/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/connect/#purpose","title":"Purpose","text":"<p>To hook the kernel entry point for the connect system call to allow for tracing of all of the system calls arguments.</p>"},{"location":"docs/events/builtin/syscalls/connect/#sock_connect","title":"sock_connect","text":""},{"location":"docs/events/builtin/syscalls/connect/#type_1","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/connect/#purpose_1","title":"Purpose","text":"<p>To hook the socket layer implementation of connect to allow for additional tracing of the arguments associated with this system call.</p>"},{"location":"docs/events/builtin/syscalls/connect/#example-use-case","title":"Example Use Case","text":"<p>The connect system call can be used to establish a network connection between two clients, such as a chat client. The connect system call could be used to connect the two clients over a TCP/IP connection, and then the two could communicate using the write() and read() system calls.</p>"},{"location":"docs/events/builtin/syscalls/connect/#issues","title":"Issues","text":"<p>The connect system call is vulnerable to TOCTOU attacks. This can occur if the address being connected to is not valid. Also, the socket being connected may be changed by a malicious actor between the time the connect() call is made and when the connection attempt is completed, thus making the connection vulnerable.</p>"},{"location":"docs/events/builtin/syscalls/connect/#related-events","title":"Related Events","text":"<ul> <li>accept() - used to accept a connection on a socket.</li> <li>bind() - used to bind a socket to an address.</li> <li>listen() - used to listen for connections on a socket.</li> <li>send() - used to send data on a connected socket.</li> <li>recv() - used to receive data on a connected socket.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/copy_file_range/","title":"copy_file_range","text":""},{"location":"docs/events/builtin/syscalls/copy_file_range/#intro","title":"Intro","text":"<p>copy_file_range - copies data between two file descriptors</p>"},{"location":"docs/events/builtin/syscalls/copy_file_range/#description","title":"Description","text":"<p>The copy_file_range() function copies up to len bytes from the file referenced by fd_in to the file referenced by fd_out at the given offset of off_in and off_out respectively. The flags argument specifies the behavior if the range specified straddles a file boundary. copy_file_range() allows to copy data the same way that splice() does, but the data is copied from one file descriptor to another one instead of to/from a pipe.</p> <p>This function does not work on a file opened with O_DIRECT. An ESYSNOTSUPP error is expected in that case.</p>"},{"location":"docs/events/builtin/syscalls/copy_file_range/#arguments","title":"Arguments","text":"<ul> <li><code>fd_in</code>:<code>int</code>[K] - file descriptor of the input file.</li> <li><code>off_in</code>:<code>off_t *</code>[K] - starting offset of the input file.</li> <li><code>fd_out</code>:<code>int</code>[K] - file descriptor of the output file.</li> <li><code>off_out</code>:<code>off_t *</code>[K] - starting offset of the output file.</li> <li><code>len</code>:<code>size_t</code>[K] - the length of data that needs to be copied.</li> <li><code>flags</code>:<code>unsigned int</code>[K] - Possible values are COPY_FILE_RANGE_WAIT_BEFORE, COPY_FILE_RANGE_WAIT_AFTER, and COPY_FILE_RANGE_NONBLOCK.</li> </ul>"},{"location":"docs/events/builtin/syscalls/copy_file_range/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/copy_file_range/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/copy_file_range/#sys_copy_file_range","title":"sys_copy_file_range","text":""},{"location":"docs/events/builtin/syscalls/copy_file_range/#type","title":"Type","text":"<p>kprobe + kretprobe</p>"},{"location":"docs/events/builtin/syscalls/copy_file_range/#purpose","title":"Purpose","text":"<p>To trace data that is being copied between files.</p>"},{"location":"docs/events/builtin/syscalls/copy_file_range/#sys_copy_file_range2","title":"sys_copy_file_range2","text":""},{"location":"docs/events/builtin/syscalls/copy_file_range/#type_1","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/copy_file_range/#purpose_1","title":"Purpose","text":"<p>To trace data that is being copied between files.</p>"},{"location":"docs/events/builtin/syscalls/copy_file_range/#example-use-case","title":"Example Use Case","text":"<p>An example use case of copy_file_range() is using it to compare two files and detect differences between them.</p>"},{"location":"docs/events/builtin/syscalls/copy_file_range/#issues","title":"Issues","text":"<p>copy_file_range() does not work on files opened with O_DIRECT flags and an ESYSNOTSUPP error is expected in such cases.</p>"},{"location":"docs/events/builtin/syscalls/copy_file_range/#related-events","title":"Related Events","text":"<ul> <li>preadv2</li> <li>pwritev2</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/creat/","title":"creat","text":""},{"location":"docs/events/builtin/syscalls/creat/#intro","title":"Intro","text":"<p>creat - system call to create a new, or overwrite an existing, file with certain permissions</p>"},{"location":"docs/events/builtin/syscalls/creat/#description","title":"Description","text":"<p>The creat() syscall creates a new file or overwrites an existing file, in the file system pointed to by the given pathname, with the given permissions. If the file does not exist, it will be created with the given permissions. If the file does exist, it will be overwritten, and set to the given permissions.</p> <p>It should be noted that the creat() syscall is essentially the same as using the open() syscall with the O_CREAT and O_WRONLY flags.</p>"},{"location":"docs/events/builtin/syscalls/creat/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code> - a pointer to a string containing the path to file being modified.</li> <li><code>mode</code>:<code>mode_t</code> - permissions to be applied to the file.</li> </ul>"},{"location":"docs/events/builtin/syscalls/creat/#available-tags","title":"Available Tags","text":"<ul> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/creat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/creat/#sys_creat","title":"sys_creat","text":""},{"location":"docs/events/builtin/syscalls/creat/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/creat/#purpose","title":"Purpose","text":"<p>To observe and trace when the creat() system call is performed.</p>"},{"location":"docs/events/builtin/syscalls/creat/#example-use-case","title":"Example Use Case","text":"<p>A logging system which keeps track of when files are created or modified.</p>"},{"location":"docs/events/builtin/syscalls/creat/#issues","title":"Issues","text":"<p>When creating a file, there is an atomic race condition which could lead to the file being left in an unexpected state if the creat() syscall fails and the file is overwritten.</p>"},{"location":"docs/events/builtin/syscalls/creat/#related-events","title":"Related Events","text":"<p>open() - Creates or opens a file, modifier relating to the creat() syscall.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/create_module/","title":"create_module","text":""},{"location":"docs/events/builtin/syscalls/create_module/#intro","title":"Intro","text":"<p>create_module - a system call that creates a new loadable kernel module.</p>"},{"location":"docs/events/builtin/syscalls/create_module/#description","title":"Description","text":"<p>The <code>create_module</code> syscall allows user-space programs to create and register a new kernel module. This syscall provides the necessary parameters for defining the module's code, data, name and description, which are then compiled into a loadable kernel object file. After being created, the kernel module can be used for performing various operations such as extending the kernel's functionality or adding device drivers to the kernel.</p> <p>The main advantages of using <code>create_module</code> are that it offers a reliable method of loading and registering a new kernel module, while also providing a degree of flexibility that allows the programmer to customize the module to their needs. Additionally, it is worth noting that <code>create_module</code> can be more efficient than manually creating a kernel module, since it handles most of the necessary steps for creating a kernel module automatically.</p>"},{"location":"docs/events/builtin/syscalls/create_module/#arguments","title":"Arguments","text":"<ul> <li><code>name</code>:<code>char *</code>[K, U] - the name of the kernel module. Must be unique.</li> <li><code>code</code>:<code>void *</code>[U] - a pointer to the module's code.</li> <li><code>len</code>:<code>unsigned long</code>[K] - the size of the module's code.</li> <li><code>mode</code>:<code>mode_t</code>[K] - specifies the kernel module's access privileges.</li> <li><code>flags</code>:<code>int</code>[K] - flags to specify additional parameters for the module.</li> </ul>"},{"location":"docs/events/builtin/syscalls/create_module/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/create_module/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/create_module/#sys_init_module","title":"sys_init_module","text":""},{"location":"docs/events/builtin/syscalls/create_module/#type","title":"Type","text":"<p>KProbe</p>"},{"location":"docs/events/builtin/syscalls/create_module/#purpose","title":"Purpose","text":"<p>Hook <code>sys_init_module</code> to validate the arguments of the <code>create_module</code> syscall before the module is loaded.</p>"},{"location":"docs/events/builtin/syscalls/create_module/#example-use-case","title":"Example Use Case","text":"<p>The <code>create_module</code> syscall can be used to create a new kernel module that extends the kernel's functionality, or adds device drivers to the kernel. For example, a kernel module could be used to detect new hardware in the system, or to add a new system call that could be used to perform a specific operation.</p>"},{"location":"docs/events/builtin/syscalls/create_module/#issues","title":"Issues","text":"<p>Some versions of the <code>create_module</code> syscall are vulnerable to TOCTOU (Time of Check Time of Use) race conditions, which can be exploited by malicious users to subvert the loading process of the module. To mitigate this issue, it is recommended to hook the <code>sys_init_module</code> function using a KProbe and to validate the module's code and arguments before allowing it to be loaded.</p>"},{"location":"docs/events/builtin/syscalls/create_module/#related-events","title":"Related Events","text":"<ul> <li>delete_module: the syscall used to unload a module created with <code>create_module</code>.</li> <li>sys_init_module: the kernel entry point for the <code>create_module</code> syscall, which can be hooked to validate the arguments of the <code>create_module</code> syscall before the module is loaded.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/delete_module/","title":"delete_module","text":""},{"location":"docs/events/builtin/syscalls/delete_module/#intro","title":"Intro","text":"<p>delete_module - system call to delete a module from the running kernel</p>"},{"location":"docs/events/builtin/syscalls/delete_module/#description","title":"Description","text":"<p>The delete_module() system call deletes the specified module from the running kernel. It does not delete the associated files from the disk; for this, use rmmod(8). It takes two arguments - name, which is a pointer to the module name, and flags, an integer.</p> <p>The flags argument serves to specify the behavior of delete_module(). If the module has any active users, the call can either block until all users have freed the module (flags set to 0 or O_NONBLOCK) or just return with an EAGAIN error.</p> <p>Advantage of using delete_module() system call is that it allows to dynamically manage the behavior of the running kernel configuration.</p> <p>Disadvantage is that when the call is blocked, other processes might be delayed because they were not able to wait until the delete_module() system call was completed. This may lead to race conditions, which might cause issues with system stability.</p>"},{"location":"docs/events/builtin/syscalls/delete_module/#arguments","title":"Arguments","text":"<ul> <li><code>name</code>: const char*[K|U] - pointer to the module name</li> <li><code>flags</code>: int[K] - integer to specify the behavior of delete_module()</li> </ul>"},{"location":"docs/events/builtin/syscalls/delete_module/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/delete_module/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/delete_module/#do_delete_module","title":"do_delete_module","text":""},{"location":"docs/events/builtin/syscalls/delete_module/#type","title":"Type","text":"<p>Kprobes + ftrace</p>"},{"location":"docs/events/builtin/syscalls/delete_module/#purpose","title":"Purpose","text":"<p>Hooks do_delete_module to detect when the delete_module() system call is invoked and to monitor the behavior of delete_module()</p>"},{"location":"docs/events/builtin/syscalls/delete_module/#example-use-case","title":"Example Use Case","text":"<p>delete_module() system call can be used to dynamically manage the running kernel configuration. In a production environment, for instance, it can be used to disable certain features or to enable debug mechanisms without restarting the machine.</p>"},{"location":"docs/events/builtin/syscalls/delete_module/#issues","title":"Issues","text":"<p>Race conditions can arise from blocking delete_module() system calls, delaying other processes.</p>"},{"location":"docs/events/builtin/syscalls/delete_module/#related-events","title":"Related Events","text":"<p>The use of delete_module() system call is connected with kprobe_event_handler and rmmod system calls.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/dup/","title":"dup","text":""},{"location":"docs/events/builtin/syscalls/dup/#intro","title":"Intro","text":"<p>dup - duplicate an existing file descriptor</p>"},{"location":"docs/events/builtin/syscalls/dup/#description","title":"Description","text":"<p>The dup() system call creates a duplicate of the file descriptor oldfd. It returns the new glass reference to the same open file description and shares the same file offset and file status flags as the original file descriptor. This system call allows the programmer to use the file descriptor multiple times in the same process.</p> <p>The dup() system call has several advantages, compared to other system calls such as open() and dup2(). It does not require the user to specify a pathname, since it operates on existing file descriptors. Furthermore, it does not perform a separate open() operation and all of the related system call overhead. Finally, dup() properly handles the underlying open file description reference count. </p> <p>There are two edge-cases to be aware of when using the dup() system call. First, the oldfd argument must refer to an open file descriptor in order for the operation to succeed. If the oldfd argument does not refer to an open file descriptor, the system call will return an error. Second, a file descriptor created with the dup() function should also be closed with close() and not with a call to free().</p>"},{"location":"docs/events/builtin/syscalls/dup/#arguments","title":"Arguments","text":"<ul> <li><code>oldfd</code>:<code>int</code>[K] - file descriptor of an open file description.</li> </ul>"},{"location":"docs/events/builtin/syscalls/dup/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/dup/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/dup/#syscall_entry_dup","title":"syscall_entry_dup","text":""},{"location":"docs/events/builtin/syscalls/dup/#type","title":"Type","text":"<p>kretprobe + kprobe</p>"},{"location":"docs/events/builtin/syscalls/dup/#purpose","title":"Purpose","text":"<p>The syscall_entry_dup function is hooked in order to intercept the dup() system call and record its associated arguments.</p>"},{"location":"docs/events/builtin/syscalls/dup/#example-use-case","title":"Example Use Case","text":"<p>The dup() system call can be used to create multiple pointers to the same open file description. This is useful for applications that need to read from the same file from multiple places at the same time. For example, an antivirus program may need to read several chunks of a file in order to scan it for viruses.</p>"},{"location":"docs/events/builtin/syscalls/dup/#issues","title":"Issues","text":"<p>The dup() system call can be vulnerable to TOCTOU (time of check, time of use) attacks, as the open file description of the oldfd argument may have been modified between the time of the check and the time of use. </p>"},{"location":"docs/events/builtin/syscalls/dup/#related-events","title":"Related Events","text":"<ul> <li>open() - open a file descriptor</li> <li>close() - close a file descriptor</li> <li>dup2() - clone existing file descriptor with a given new descriptor</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/dup2/","title":"dup2","text":""},{"location":"docs/events/builtin/syscalls/dup2/#intro","title":"Intro","text":"<p>dup2 - Duplicate an open file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/dup2/#description","title":"Description","text":"<p>The dup2() system call performs the equivalent of dup(), but instead of using the lowest-numbered unused file descriptor, it uses the file descriptor number specified in newfd.  If the file descriptor newfd was previously open, it is silently closed before being reused.</p> <p>The dup2() system call can be used, for example, to convert a disk file descriptor fd into a network socket descriptor (which is really just a file descriptor number). If newfd is already open, it is first closed. Then its value is applied as the new duplicate descriptor so that dup2(fd, newfd) is equivalent to close(newfd); dup2(fd, newfd).</p> <p>The dup2() system call does not cause the file offset (See lseek(2)) and file status flags to be changed.</p>"},{"location":"docs/events/builtin/syscalls/dup2/#arguments","title":"Arguments","text":"<ul> <li><code>oldfd</code>:<code>int</code>[K] - Descriptor of the file that is going to be duplicated.</li> <li><code>newfd</code>:<code>int</code>[K] - Descriptor that is going to contain the duplicate.</li> </ul>"},{"location":"docs/events/builtin/syscalls/dup2/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/dup2/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/dup2/#dup2_1","title":"dup2","text":""},{"location":"docs/events/builtin/syscalls/dup2/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/dup2/#purpose","title":"Purpose","text":"<p>To trace the duplication of an open file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/dup2/#example-use-case","title":"Example Use Case","text":"<p>A use case for the dup2 system call is to duplicate a file descriptor that has been opened in order to write to an alternate location, while still leaving the file descriptor that was opened pointing to the original location. This might be useful if you want to preserve the original file descriptor, but need to make modifications to a different location.</p>"},{"location":"docs/events/builtin/syscalls/dup2/#issues","title":"Issues","text":"<p>The dup2() system call does not cause the file offset and file status flags to be changed.</p>"},{"location":"docs/events/builtin/syscalls/dup2/#related-events","title":"Related Events","text":"<p>The relation between dup2() and dup() and fork().</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/dup3/","title":"dup3","text":""},{"location":"docs/events/builtin/syscalls/dup3/#intro","title":"Intro","text":"<p>dup3 - duplicate a file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/dup3/#description","title":"Description","text":"<p>The dup3() system call creates a copy of the given file descriptor <code>oldfd</code>, and uses the given <code>flags</code> argument to control the behavior of the copy. It then stores the copy as <code>newfd</code>.</p> <p>The advantage of using dup3() over dup2() is that the file descriptor flags are not copied over to the duplicate file descriptor. The flags argument can be used to set new flags on the duplicate fd, but they do not affect the original file descriptor. Any special requests (such as asking for a non-blocking file descriptor) can be set with flags.</p> <p>Duplicating a file descriptor which has already been closed results in an error.</p>"},{"location":"docs/events/builtin/syscalls/dup3/#arguments","title":"Arguments","text":"<ul> <li><code>oldfd</code>:<code>int</code>[K,U] - the file descriptor to duplicate.</li> <li><code>newfd</code>:<code>int</code>[K,U] - the new file descriptor.</li> <li><code>flags</code>:<code>int</code> - flags that control how the descriptor is handled.</li> </ul>"},{"location":"docs/events/builtin/syscalls/dup3/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/dup3/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/dup3/#dup3_1","title":"dup3","text":""},{"location":"docs/events/builtin/syscalls/dup3/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/dup3/#purpose","title":"Purpose","text":"<p>To observe when a process attempts to duplicate a file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/dup3/#example-use-case","title":"Example Use Case","text":"<p>Monitoring application performance can be improved by identifying when a process is spending too much time duplicating file descriptors. A trace can be taken of any process that is seen to repeatedly call dup3(), and the root cause of the inefficiency can be investigated.</p>"},{"location":"docs/events/builtin/syscalls/dup3/#issues","title":"Issues","text":"<p>No notable issues have been found with the dup3() system call.</p>"},{"location":"docs/events/builtin/syscalls/dup3/#related-events","title":"Related Events","text":"<p>The dup2() system call creates a copy of a file descriptor with the same flags as the original, and can be used as an alternative to dup3().</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/epoll_create/","title":"epoll_create","text":""},{"location":"docs/events/builtin/syscalls/epoll_create/#intro","title":"Intro","text":"<p>epoll_create - create an epoll file descriptor</p>"},{"location":"docs/events/builtin/syscalls/epoll_create/#description","title":"Description","text":"<p>The epoll_create() system call creates an epoll instance. It takes a single argument size, which defines the maximum number of file descriptors that can be monitored by the instance. The size argument is used to determine the amount of memory consumed by the epoll instance, which is allocated upon creating the instance. This memory is released when the instance is closed by calling the close() system call.</p> <p>The epoll_create() system call has several advantages: * Allows the registration of multiple file descriptors. * Registering of multiple processes and signals. * It has an efficient memory usage. * It has a low latency for waking up appliy so the system can acquire data.</p> <p>epoll_create() can be used for monitoring non-blocking or non-blocking sockets. It can also be used to keep track of multiple processes and signals.</p>"},{"location":"docs/events/builtin/syscalls/epoll_create/#arguments","title":"Arguments","text":"<ul> <li><code>size</code>:<code>int</code> - Maximum number of file descriptors that can be monitored by the instance.</li> </ul>"},{"location":"docs/events/builtin/syscalls/epoll_create/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/epoll_create/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/epoll_create/#ep_create_files_struct","title":"ep_create_files_struct","text":""},{"location":"docs/events/builtin/syscalls/epoll_create/#type","title":"Type","text":"<p>kprobes</p>"},{"location":"docs/events/builtin/syscalls/epoll_create/#purpose","title":"Purpose","text":"<p>To intercept the system call when creating a new epoll instance.</p>"},{"location":"docs/events/builtin/syscalls/epoll_create/#files_free","title":"files_free","text":""},{"location":"docs/events/builtin/syscalls/epoll_create/#type_1","title":"Type","text":"<p>kretprobes</p>"},{"location":"docs/events/builtin/syscalls/epoll_create/#purpose_1","title":"Purpose","text":"<p>To intercept the system call when closing an epoll instance to free the allocated memory.</p>"},{"location":"docs/events/builtin/syscalls/epoll_create/#example-use-case","title":"Example Use Case","text":"<p>The epoll_create() system call can be used to monitor a directory for changes. For example, in an application that monitors a directory for new files, the epoll_create() system call can be used to create an epoll instance for the directory, and then the application can wait for the incoming files using the epoll_wait() system call.</p>"},{"location":"docs/events/builtin/syscalls/epoll_create/#issues","title":"Issues","text":"<p>The performance of epoll_create() degrades on large datasets due to the added complexity of the constant addition and removal of file descriptors from the instance.</p>"},{"location":"docs/events/builtin/syscalls/epoll_create/#related-events","title":"Related Events","text":"<ul> <li><code>epoll_ctl</code> - control interface for an epoll instance</li> <li><code>epoll_wait</code> - wait for an I/O event on an epoll instance</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/epoll_create1/","title":"epoll_create1","text":""},{"location":"docs/events/builtin/syscalls/epoll_create1/#intro","title":"Intro","text":"<p>epoll_create1 - create a new instance of an epoll set for monitoring file descriptors</p>"},{"location":"docs/events/builtin/syscalls/epoll_create1/#description","title":"Description","text":"<p>The epoll_create1() system call performs the same task as epoll_create(), but it allows for additional features that are beneficial for certain applications. Flags specifies the behavior of the system call and may be used to specify a maximum number of descriptors that the target epoll instance will be able to contain (flags is a bitmask, and only one of the flags in the mask should be used). This syscall is useful in applications that depend on high performance and scalability, such as network servers.</p>"},{"location":"docs/events/builtin/syscalls/epoll_create1/#arguments","title":"Arguments","text":"<ul> <li><code>flags</code>:<code>int</code>[OPT] - bits that specify the behavior of the system call. The flags may be a bitmask specifying the behavior of the system call. The only flag that should be used is EPOLL_CLOEXEC, which creates the epoll instance with the close-on-exec flag.</li> </ul>"},{"location":"docs/events/builtin/syscalls/epoll_create1/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/epoll_create1/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/epoll_create1/#epoll_create1_1","title":"epoll_create1","text":""},{"location":"docs/events/builtin/syscalls/epoll_create1/#type","title":"Type","text":"<p>Tracepoint</p>"},{"location":"docs/events/builtin/syscalls/epoll_create1/#purpose","title":"Purpose","text":"<p>To monitor the execution of the epoll_create1 system call.</p>"},{"location":"docs/events/builtin/syscalls/epoll_create1/#example-use-case","title":"Example Use Case","text":"<p>The epoll_create1 system call can be used to create a new instance of an epoll set for monitoring a large number of file descriptors. This system call is particularly useful for servers that constantly need to monitor a large number of file descriptors.</p>"},{"location":"docs/events/builtin/syscalls/epoll_create1/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/epoll_create1/#related-events","title":"Related Events","text":"<ul> <li>epoll_ctl - used to control an instance of an epoll set</li> <li>epoll_wait - used to wait for events from an instance of an epoll set</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/epoll_ctl/","title":"epoll_ctl","text":""},{"location":"docs/events/builtin/syscalls/epoll_ctl/#intro","title":"Intro","text":"<p>epoll_ctl - program the event filter for an epoll instance </p>"},{"location":"docs/events/builtin/syscalls/epoll_ctl/#description","title":"Description","text":"<p>The epoll_ctl() system call is used to add, modify, or delete entries in an epoll instance's kernel struct associated with a file descriptor. An application creates an epoll instance using epoll_create1() and receives notification of I/O events through that instance.</p> <p>For each file descriptor, the process can register multiple associated events along with a user-supplied file descriptor reference. The set of registered events and their associated user data for a given file descriptor can be changed using epoll_ctl().</p> <p>Note that the epoll_ctl() system call does not generalize I/O event monitoring to other kinds of The epoll_wait() thread-safe system call. Objects like signals and timers - use different system calls to program these special kinds of events.</p>"},{"location":"docs/events/builtin/syscalls/epoll_ctl/#arguments","title":"Arguments","text":"<ul> <li><code>epfd</code>:<code>int</code> - epoll instance file descriptor </li> <li><code>op</code>:<code>int</code>[K] - operation code</li> <li><code>fd</code>:<code>int</code>[K] - file descriptor to be monitored </li> <li><code>event</code>:<code>struct epoll_event*</code>[K] - structure with epoll events </li> </ul>"},{"location":"docs/events/builtin/syscalls/epoll_ctl/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/epoll_ctl/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/epoll_ctl/#sys_epoll_ctl","title":"sys_epoll_ctl","text":""},{"location":"docs/events/builtin/syscalls/epoll_ctl/#type","title":"Type","text":"<p>Kprobe + Kretprobe </p>"},{"location":"docs/events/builtin/syscalls/epoll_ctl/#purpose","title":"Purpose","text":"<p>The purpose for hooking the sys_epoll_ctl kernel entry point is to trace the epoll_ctl system call and its arguments, as well as the return code.</p>"},{"location":"docs/events/builtin/syscalls/epoll_ctl/#sys_epoll_create1","title":"sys_epoll_create1","text":""},{"location":"docs/events/builtin/syscalls/epoll_ctl/#type_1","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/epoll_ctl/#purpose_1","title":"Purpose","text":"<p>The purpose for hooking the sys_epoll_create1 kernel entry point is to trace the epoll_create1 system call and its arguments, as well as the return code.</p>"},{"location":"docs/events/builtin/syscalls/epoll_ctl/#example-use-case","title":"Example Use Case","text":"<p>The epoll_ctl system call can be used to add, modify, or delete entries in an epoll instance's kernel struct associated with a file descriptor. This can be useful for monitoring I/O on a large number of file descriptors. For example, an application can use epoll_ctl to monitor activity on a large number of sockets, and be alerted when one of the sockets has data ready to be read.</p>"},{"location":"docs/events/builtin/syscalls/epoll_ctl/#issues","title":"Issues","text":"<p>epoll_ctl does not generalize I/O event monitoring to other kinds of objects like signals and timers - use different system calls to program these special kinds of events.</p>"},{"location":"docs/events/builtin/syscalls/epoll_ctl/#related-events","title":"Related Events","text":"<ul> <li><code>epoll_create1</code> - creates an epoll instance </li> <li><code>__x64_sys_epoll_pwait</code> - waits for an I/O event on an epoll instance</li> <li><code>epoll_wait</code> - suspends the calling thread until an I/O event occurs on an epoll instance</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/epoll_ctl_old/","title":"epoll_ctl_old","text":""},{"location":"docs/events/builtin/syscalls/epoll_ctl_old/#intro","title":"Intro","text":"<p>epoll_ctl_old - Used to control the interest list used by an epoll instance.</p>"},{"location":"docs/events/builtin/syscalls/epoll_ctl_old/#description","title":"Description","text":"<p>The epoll_ctl_old call tries to add or remove an epoll instance (also referred  to as \"epollfd\") to an interest list. It is used to tell the kernel which events  should be monitored for a given file descriptor.It is the older version of the  epoll_ctl system call and is used to control the interest list used by an epoll  instance.</p> <p>The epoll_ctl_old call can be used to register a file descriptor for events that  were previously not handled by epoll. It can also be used to update an existing  file descriptor with its previous events (e.g.,masking out events that were  previously enabled).</p> <p>When an epoll instance is created, it is initialised with an empty interest  list. Events are then registered using the epoll_ctl_old call. After registering, the epoll instance can start monitoring for events with the epoll_wait call.</p> <p>The epoll_ctl_old call has two different flags which can be used to control the behavior of the call: * EPOLL_CTL_ADD - adds a given file descriptor to the interest list of the    epoll instance. * EPOLL_CTL_DEL - removes a given file descriptor from the epoll instance.</p> <p>The epoll_ctl_old call can also take a third argument which is a pointer to an  epoll_event structure. This argument is used to specify which events are monitored for a given file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/epoll_ctl_old/#arguments","title":"Arguments","text":"<ul> <li><code>epfd</code>:<code>int</code>[K] - File descriptor of epoll instance.</li> <li><code>op</code>:<code>int</code>[K] - Operation that is requested.</li> <li><code>event</code>:<code>struct epoll_event *</code>[KU] - Structure that contains event to be monitored.</li> </ul>"},{"location":"docs/events/builtin/syscalls/epoll_ctl_old/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/epoll_ctl_old/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/epoll_ctl_old/#epoll_ctl_old_1","title":"epoll_ctl_old","text":""},{"location":"docs/events/builtin/syscalls/epoll_ctl_old/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/epoll_ctl_old/#purpose","title":"Purpose","text":"<p>To monitor epoll_ctl_old calls and the arguments they take.</p>"},{"location":"docs/events/builtin/syscalls/epoll_ctl_old/#example-use-case","title":"Example Use Case","text":"<p>A use case for epoll_ctl_old could be for a security monitoring application that  wants to monitor for certain file descriptor events. This application could use epoll_ctl_old to register the file descriptor associated with the event it wants  to monitor and to then use epoll_wait to wait for events.</p>"},{"location":"docs/events/builtin/syscalls/epoll_ctl_old/#issues","title":"Issues","text":"<p>There are no known issues with epoll_ctl_old.</p>"},{"location":"docs/events/builtin/syscalls/epoll_ctl_old/#related-events","title":"Related Events","text":"<ul> <li>epoll_wait</li> <li>epoll_create</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/epoll_pwait/","title":"<code>epoll_pwait</code>","text":""},{"location":"docs/events/builtin/syscalls/epoll_pwait/#intro","title":"Intro","text":"<p>The <code>epoll_pwait</code> system call - wait for an I/O event on an epoll filedescriptor with the option for user-space signal masking.</p>"},{"location":"docs/events/builtin/syscalls/epoll_pwait/#description","title":"Description","text":"<p><code>epoll_pwait</code> was added to Linux to extend the capabilities of the previous <code>epoll_wait</code> system call. Instead of just waiting for an I/O event to happen on an epoll file descriptor, <code>epoll_pwait</code> accepts an additional argument <code>sigmask</code> which is a pointer to a user-space signal mask. This signal mask defines which signals the process is to block while waiting for the I/O event.</p> <p>This system call adds an additional level of control to the process while it's waiting, allowing to have full control over the signals it''ll receive while waiting, making it easier to control in scenarios where it needs to be woken up due to incoming signals.</p> <p>The other arguments, <code>epfd</code>, <code>events</code>, <code>maxevents</code> and <code>timeout</code> are the same as the <code>epoll_wait</code> system call. <code>epfd</code> holds the epoll filedescriptor to query, <code>events</code> is a pointer to a memory space that will store the I/O events info, <code>maxevents</code> is a maximum size of <code>events</code> given, and <code>timeout</code> is the number of milliseconds the process will wait before timing out.</p> <p>It's important to note that this system call is vulnerable to time-of-check/time-of-use (TOCTOU) attacks, as the signal mask used can be changed between the time it checks and the time it waits, with disastrous results in some architectures.</p>"},{"location":"docs/events/builtin/syscalls/epoll_pwait/#arguments","title":"Arguments","text":"<ul> <li><code>epfd</code>:<code>int</code>[K] - epoll filedescriptor to query for I/O events.</li> <li><code>events</code>:<code>struct epoll_event*</code>[K] - pointer to a memory space that will store the I/O events info.</li> <li><code>maxevents</code>:<code>int</code>[K] - maximum size of <code>events</code> given.</li> <li><code>timeout</code>:<code>int</code>[K] - number of milliseconds the process will wait before timing out.</li> <li><code>sigmask</code>:<code>const sigset_t*</code>[KU] - pointer to a user-space signal mask used to block certain signals.</li> <li><code>sigsetsize</code>:<code>size_t</code>[KU] - size of <code>sigmask</code>.</li> </ul>"},{"location":"docs/events/builtin/syscalls/epoll_pwait/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/epoll_pwait/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/epoll_pwait/#sys_epoll_pwait","title":"<code>sys_epoll_pwait</code>","text":""},{"location":"docs/events/builtin/syscalls/epoll_pwait/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/epoll_pwait/#purpose","title":"Purpose","text":"<p>To monitor or trace the use of the epoll_pwait system call.</p>"},{"location":"docs/events/builtin/syscalls/epoll_pwait/#ep_poll_callback","title":"<code>ep_poll_callback</code>","text":""},{"location":"docs/events/builtin/syscalls/epoll_pwait/#type_1","title":"Type","text":"<p>Kretprobes + Tracepoints</p>"},{"location":"docs/events/builtin/syscalls/epoll_pwait/#purpose_1","title":"Purpose","text":"<p>To log information about the returned data from the epoll_pwait system call.</p>"},{"location":"docs/events/builtin/syscalls/epoll_pwait/#example-use-case","title":"Example Use Case","text":"<p>When dealing with a multithreaded application, it's important to be able to control which signals the application will react to while waiting. <code>epoll_pwait</code> allows to have full control over the user-space signal mask, making it easy to decide which signals will be blocked while waiting.</p>"},{"location":"docs/events/builtin/syscalls/epoll_pwait/#issues","title":"Issues","text":"<ul> <li>Vulnerability to TOCTOU attacks - the signal mask used in the system call can be changed between the time of check and the time of use, which can lead to issues in some architectures.</li> </ul>"},{"location":"docs/events/builtin/syscalls/epoll_pwait/#related-events","title":"Related Events","text":"<ul> <li><code>epoll_wait</code> - similar event but without the possibility of signal masking.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/epoll_pwait2/","title":"epoll_pwait2","text":""},{"location":"docs/events/builtin/syscalls/epoll_pwait2/#intro","title":"Intro","text":"<p>epoll_pwait2 - wait for an I/O event on an epoll file descriptor with optional behavior for handling signals</p>"},{"location":"docs/events/builtin/syscalls/epoll_pwait2/#description","title":"Description","text":"<p>The epoll_pwait2 system call provides a wait for an I/O event on an epoll file descriptor. It is an extension to the epoll_pwait system call, which allows for the specification of an optional signal set for atomically unblocked signals. This is particularly useful for applications that need to ensure the correctness of behavior in a multithread environment where multiple threads might be blocked using the same epoll file descriptor, and one thread might unblock a signal that should eventually be handled by a different thread.</p> <p>The advantages of using this system call include allowing signals to be handled atomically (without being interrupted by other signals), and allowing multiple threads to wait on the same epoll file descriptor.</p> <p>However, one drawback to using this system call is that it requires a single set of signals to be specified for all threads, as opposed to the epoll_wait system call which allows for signals to be specified on a per-thread basis.</p>"},{"location":"docs/events/builtin/syscalls/epoll_pwait2/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - epoll instance file descriptor</li> <li><code>events</code>:<code>struct epoll_event*</code>[K] - a memory region where epoll_event structures are featured</li> <li><code>maxevents</code>:<code>int</code>[K] - the maximum number of events to be returned</li> <li><code>timeout</code>:<code>const struct timespec*</code>[K] - a timeout interval, or NULL for no timeout</li> <li><code>sigset</code>:<code>const sigset_t*</code>[K] - a signal set mask, or NULL for the current set</li> </ul>"},{"location":"docs/events/builtin/syscalls/epoll_pwait2/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/epoll_pwait2/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/epoll_pwait2/#sys_epoll_pwait2","title":"sys_epoll_pwait2","text":""},{"location":"docs/events/builtin/syscalls/epoll_pwait2/#type","title":"Type","text":"<p>Kprobes + Uprobes</p>"},{"location":"docs/events/builtin/syscalls/epoll_pwait2/#purpose","title":"Purpose","text":"<p>To capture the entrance and exit of the epoll_pwait2 system call.</p>"},{"location":"docs/events/builtin/syscalls/epoll_pwait2/#example-use-case","title":"Example Use Case","text":"<p>An application that needs to ensure the correctness of its behavior in a multithread environment where multiple threads might be blocked using the same epoll file descriptor and where one thread might unblock a signal that should eventually be handled by a different thread could use this system call to ensure that signals are handled atomically without being interrupted by other signals, and that multiple threads can wait on the same epoll file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/epoll_pwait2/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/epoll_pwait2/#related-events","title":"Related Events","text":"<p>epoll_wait, epoll_pwait</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/epoll_wait/","title":"<code>epoll_wait</code>","text":""},{"location":"docs/events/builtin/syscalls/epoll_wait/#intro","title":"Intro","text":"<p><code>epoll_wait</code> - waits for an I/O event on an epoll file descriptor</p>"},{"location":"docs/events/builtin/syscalls/epoll_wait/#description","title":"Description","text":"<p><code>epoll_wait</code> is a system call used to wait for I/O events on an epoll file descriptor. It is similar to <code>poll</code>, but with better scalability for large numbers of monitored file descriptors. It returns when either an I/O event has been detected or the timeout has expired.</p> <p>The main advantage of using <code>epoll_wait</code> is increased scalability, since <code>poll</code> and <code>select</code> perform worse as the number of monitored events increases. However, there are some drawbacks to using <code>epoll_wait</code>. For example, <code>epoll_wait</code> is not a real-time system call, meaning that there can be a significant lag between events being triggered and them being handled by <code>epoll_wait</code>. Additionally, <code>epoll_wait</code> can be more complicated to use since it requires a more involved setup procedure.</p>"},{"location":"docs/events/builtin/syscalls/epoll_wait/#arguments","title":"Arguments","text":"<ul> <li><code>epfd</code>:<code>int</code> - the epoll file descriptor created with <code>epoll_create</code></li> <li><code>events</code>:<code>struct epoll_event*</code>[U] - pointer to a buffer where the events will be returned</li> <li><code>maxevents</code>:<code>int</code> - the maximum number of events that can be returned</li> <li><code>timeout</code>:<code>int</code> - the timeout in milliseconds; or -1 to wait indefinitely</li> </ul>"},{"location":"docs/events/builtin/syscalls/epoll_wait/#available-tags","title":"Available Tags","text":"<ul> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/epoll_wait/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/epoll_wait/#sys_epoll_wait","title":"<code>sys_epoll_wait</code>","text":""},{"location":"docs/events/builtin/syscalls/epoll_wait/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/epoll_wait/#purpose","title":"Purpose","text":"<p>To trace I/O events on an epoll file descriptor</p>"},{"location":"docs/events/builtin/syscalls/epoll_wait/#example-use-case","title":"Example Use Case","text":"<p>An example use case for <code>epoll_wait</code> would be a real-time application that needs to process incoming network traffic.</p>"},{"location":"docs/events/builtin/syscalls/epoll_wait/#issues","title":"Issues","text":"<p>There is a known bug in <code>epoll_wait</code> related to the <code>maxevents</code> argument. If the <code>maxevents</code> argument is greater than the number of available events, the <code>timeout</code> argument may not be taken into account correctly.</p>"},{"location":"docs/events/builtin/syscalls/epoll_wait/#related-events","title":"Related Events","text":"<ul> <li><code>epoll_ctl</code> - add or delete file descriptors to/from an epoll file descriptor</li> <li><code>epoll_create</code> - create a new epoll file descriptor</li> <li><code>epoll_create1</code> - create a new epoll file descriptor</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/epoll_wait_old/","title":"epoll_wait_old","text":""},{"location":"docs/events/builtin/syscalls/epoll_wait_old/#intro","title":"Intro","text":"<p>epoll_wait_old - waits for events on an epoll file descriptor</p>"},{"location":"docs/events/builtin/syscalls/epoll_wait_old/#description","title":"Description","text":"<p>The <code>epoll_wait_old</code> function is used to retrieve events associated with an epoll instance. It will block until an event from the epoll instance is available, and then return a list of events that were associated with the epoll instance when the call occurred. The maximum number of events returned by a single call is specified by the <code>maxevents</code> argument. </p> <p>This system call is the older version of the <code>epoll_wait()</code> system call which itself is replaced by the <code>epoll_pwait()</code> system call which allows for setting a timeout value for the total amount of time to wait for events. The <code>epoll_wait_old</code> system call does not support a timeout value and instead only blocks until an event is available. </p> <p>The epoll event type of the returned events can be determined from the <code>events</code> field of the <code>struct epoll_event</code> returned from the call. The data associated with the returned events can be determined from the <code>data</code> field of the struct.</p>"},{"location":"docs/events/builtin/syscalls/epoll_wait_old/#arguments","title":"Arguments","text":"<ul> <li><code>epfd</code>: <code>int</code>[K] - The file descriptor for the epoll instance. Must be a valid file descriptor that was returned from a call to <code>epoll_create()</code>. </li> <li><code>events</code>: <code>struct epoll_event *</code>[K] - A pointer to an array of <code>struct epoll_event</code>s to be filled with events associated with the epoll instance.</li> <li><code>maxevents</code>: <code>int</code>[K] - The maximum number of events to be present in the <code>events</code> array when the call returns. </li> </ul>"},{"location":"docs/events/builtin/syscalls/epoll_wait_old/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/epoll_wait_old/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/epoll_wait_old/#do_sys_epoll_wait","title":"do_sys_epoll_wait()","text":""},{"location":"docs/events/builtin/syscalls/epoll_wait_old/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/epoll_wait_old/#purpose","title":"Purpose","text":"<p>To capture when the system call is called and have access to all the arguments passed to it.</p>"},{"location":"docs/events/builtin/syscalls/epoll_wait_old/#example-use-case","title":"Example Use Case","text":"<p><code>epoll_wait_old</code> might be used in a program that uses asynchronous I/O to read data from multiple sources. The program could use <code>epoll_create()</code> to create an instance of an epoll file descriptor, then use <code>epoll_ctl()</code> to add one or more file descriptors to the instance. The program could then call <code>epoll_wait_old()</code> to wait for events on the epoll file descriptor, when an event is available, the <code>events</code> array will be populated with events related to the epoll instance.</p>"},{"location":"docs/events/builtin/syscalls/epoll_wait_old/#issues","title":"Issues","text":"<ul> <li>This system call does not support a timeout value and instead only blocks until an event is available. This may cause the program to hang if no events occur before the program is killed.</li> </ul>"},{"location":"docs/events/builtin/syscalls/epoll_wait_old/#related-events","title":"Related Events","text":"<ul> <li><code>epoll_pwait()</code> - The newer version of the <code>epoll_wait()</code> system call.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/eventfd/","title":"eventfd","text":""},{"location":"docs/events/builtin/syscalls/eventfd/#intro","title":"Intro","text":"<p>eventfd - A kernel-level event notification system.</p>"},{"location":"docs/events/builtin/syscalls/eventfd/#description","title":"Description","text":"<p>The eventfd() function is used to create a file descriptor for event notification. This is similar to the poll and select system calls, but more efficient and with more features. It allows applications to setup application-level synchronization between processes or between threads. An eventfd descriptor can be used like a file descriptor, and can be monitored using poll, select or epoll, as well as flushing to user space when there is pending data. The initval parameter can be used to determine whether a specific eventfd descriptor has data available or not. The flags parameter is used to control the behavior of the eventfd descriptor.</p>"},{"location":"docs/events/builtin/syscalls/eventfd/#arguments","title":"Arguments","text":"<ul> <li><code>initval</code>:unsigned int[K] - Initial value. This is used to indicate whether a given eventfd descriptor has data available or not.</li> <li><code>flags</code>:int[K] - Flags controlling the behavior of the eventfd descriptor.</li> </ul>"},{"location":"docs/events/builtin/syscalls/eventfd/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/eventfd/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/eventfd/#sys_eventfd","title":"sys_eventfd","text":""},{"location":"docs/events/builtin/syscalls/eventfd/#type","title":"Type","text":"<p>kprobe + uprobe.</p>"},{"location":"docs/events/builtin/syscalls/eventfd/#purpose","title":"Purpose","text":"<p>In order to provide efficient application-level synchronization, the eventfd system call is hooked so that the kernel can trigger an eventfd descriptor when necessary.</p>"},{"location":"docs/events/builtin/syscalls/eventfd/#example-use-case","title":"Example Use Case","text":"<p>The eventfd system call can be used in applications to create synchronization triggers. This can be useful in cases where synchronization between multiple threads is used, such as in the implementation of complex data structures.</p>"},{"location":"docs/events/builtin/syscalls/eventfd/#issues","title":"Issues","text":"<p>No known issues.</p>"},{"location":"docs/events/builtin/syscalls/eventfd/#related-events","title":"Related Events","text":"<p>Other synchronization functions, such as futex.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/eventfd2/","title":"eventfd2","text":""},{"location":"docs/events/builtin/syscalls/eventfd2/#intro","title":"Intro","text":"<p>eventfd2 - create/get an eventfd file descriptor for improved asynchronous handling of events.</p>"},{"location":"docs/events/builtin/syscalls/eventfd2/#description","title":"Description","text":"<p>eventfd2 creates an \"eventfd\" object that can be used as an event wait/notify mechanism by user-space applications, and by the kernel to notify user-space applications of events. It is similar to the pipe system call, but the read/write operations on /dev/eventfd are atomic. The initval argument is a initial value of the counter; The flags argument is a bitmask of flags that affects the semantics of the create.</p>"},{"location":"docs/events/builtin/syscalls/eventfd2/#arguments","title":"Arguments","text":"<ul> <li><code>initval</code>:<code>unsigned int</code>[U] - the initial value of the counter.</li> <li><code>flags</code>:<code>int</code>[U] - a bitmask which can be set to request specific eventfd features and/or classes of behavior.</li> </ul>"},{"location":"docs/events/builtin/syscalls/eventfd2/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/eventfd2/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/eventfd2/#sys_eventfd2","title":"sys_eventfd2","text":""},{"location":"docs/events/builtin/syscalls/eventfd2/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/eventfd2/#purpose","title":"Purpose","text":"<p>To track the execution of eventfd2 syscall.</p>"},{"location":"docs/events/builtin/syscalls/eventfd2/#example-use-case","title":"Example Use Case","text":"<p>An application may use an eventfd object as a notification of an event, for example an overflow of a threshold, by setting initval to zero, and storing the count that triggered the event in the user space, each time the kernel reads the count, it will add the trigger count and set the counter to the initial value.</p>"},{"location":"docs/events/builtin/syscalls/eventfd2/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/eventfd2/#related-events","title":"Related Events","text":"<p>pipe(), poll()</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/execve/","title":"execve","text":""},{"location":"docs/events/builtin/syscalls/execve/#intro","title":"Intro","text":"<p>execve - This system call causes the program referred to by pathname to be executed in a new process using the given parameters and environment.</p>"},{"location":"docs/events/builtin/syscalls/execve/#description","title":"Description","text":"<p>execve is used to start new processes. It takes a pathname and two arrays - argv and envp - as parameters and executes the program found at the given pathname. The argv array is a collection of NULL-terminated strings of command-line options to be passed to the new process, while the envp array is a collection of NULL-terminated strings that defines the environment of the new process. execve overwrites the current process image with a new process image, which is created based on the given parameters and environment. </p> <p>When execve is executed, it is important to keep in mind that the new process image is created but not executed yet. This means that the process might still need to allocate memory for itself, load code and initialize data before it can start executing. This can be vulnerable to Time Of Check, Time Of Use (TOCTOU) attacks, where the process checks the validity of a file at one point in time, and then later uses the file itself assuming the validity of it.</p>"},{"location":"docs/events/builtin/syscalls/execve/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code> - Pathname of the program to be executed.</li> <li><code>argv</code>:<code>const char*const*</code> [K] - Array of null-terminated strings that contain the arguments to be passed to the new process.</li> <li><code>envp</code>:<code>const char*const*</code> [K] - Array of null-terminated strings that contain the environment variables of the new process.</li> </ul>"},{"location":"docs/events/builtin/syscalls/execve/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/execve/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/execve/#sys_execve","title":"sys_execve","text":""},{"location":"docs/events/builtin/syscalls/execve/#type","title":"Type","text":"<p>KProbe</p>"},{"location":"docs/events/builtin/syscalls/execve/#purpose","title":"Purpose","text":"<p>Hooking sys_execve enables tracing of all processes executed on the system, including the process arguments and environment variables.</p>"},{"location":"docs/events/builtin/syscalls/execve/#example-use-case","title":"Example Use Case","text":"<p>Tracing an access control matrix to make sure sensitive programs are not executed without permission.</p>"},{"location":"docs/events/builtin/syscalls/execve/#issues","title":"Issues","text":"<p>execve is vulnerable to TOCTOU attacks, so checks should be done when using the execve call.</p>"},{"location":"docs/events/builtin/syscalls/execve/#related-events","title":"Related Events","text":"<ul> <li>fork - To create a new process before executing it.</li> <li>sigaction - To set the signal handling function of the new process.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/execveat/","title":"execveat","text":""},{"location":"docs/events/builtin/syscalls/execveat/#intro","title":"Intro","text":"<p>execveat - execute a file in a directory relative to a directory file descriptor</p>"},{"location":"docs/events/builtin/syscalls/execveat/#description","title":"Description","text":"<p>The execveat() system call executes the program referred to by the combination of dirfd and pathname.  Pathname could either be an absolute pathname or a relative pathname, and dirfd could either be AT_FDCWD or a file descriptor corresponding to a directory. It is an analogous version of execve() which uses the current working directory.</p> <p>The argument argv and envp are passed to the new program as its argument and environment respectively, and flags could be a combination of the AT_* flags provided by the identically named execve() system call.</p>"},{"location":"docs/events/builtin/syscalls/execveat/#arguments","title":"Arguments","text":"<ul> <li><code>dirfd</code>:<code>int</code>[KU] - file descriptor of the directory to use as a base, relative to which the pathname should be evaluated.</li> <li><code>pathname</code>:<code>const char*</code>[KU] - pathname of the program to execute.</li> <li><code>argv</code>:<code>const char*const*</code>[KU] - array of the arguments for the program, or NULL for none.</li> <li><code>envp</code>:<code>const char*const*</code>[KU] - array of environment variables for the program, or NULL for none.</li> <li><code>flags</code>:<code>int</code>[KU] - optional argument that could be combination of the AT_* flags provided by the identically named execve() system call.</li> </ul>"},{"location":"docs/events/builtin/syscalls/execveat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/execveat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/execveat/#sys_execveat","title":"sys_execveat","text":""},{"location":"docs/events/builtin/syscalls/execveat/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/execveat/#purpose","title":"Purpose","text":"<p>Hook sys_execveat to capture and count the number of times various programs are started.</p>"},{"location":"docs/events/builtin/syscalls/execveat/#example-use-case","title":"Example Use Case","text":"<p>An example of a use case for execveat is in an intrusion detection system. By hooking the system call and monitoring the arguments provided, malicious behavior could be detected and reported.</p>"},{"location":"docs/events/builtin/syscalls/execveat/#issues","title":"Issues","text":"<p>While the execveat system call is a useful tool, it is also susceptible to time-of-check-time-of-use (TOCTOU) race conditions.</p>"},{"location":"docs/events/builtin/syscalls/execveat/#related-events","title":"Related Events","text":"<p>Other exec events, such as execve and execveatv, are related to execveat. In addition, fork and clone could be useful in the context of execveat.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/exit/","title":"Exit","text":""},{"location":"docs/events/builtin/syscalls/exit/#intro","title":"Intro","text":"<p>exit -- Cause normal process termination</p>"},{"location":"docs/events/builtin/syscalls/exit/#description","title":"Description","text":"<p>The <code>exit()</code> syscall is used to terminate the process that called it. All the  resources held by the process, such as open files and memory mappings, are released  as part of the process termination. The status code is passed to other processes  to inform them about the termination of the process.</p>"},{"location":"docs/events/builtin/syscalls/exit/#arguments","title":"Arguments","text":"<ul> <li><code>status</code>:<code>int</code> - The status code of process which is returned to the parent  process. The lower 8 bits of the status code contains the exiting status (please  check the manual for more details). The higher 8 bit bits of the status code  contain certain flags.</li> </ul>"},{"location":"docs/events/builtin/syscalls/exit/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>TOCTOU - vulnerable to TOCTOU (time of check, time of use)</li> </ul>"},{"location":"docs/events/builtin/syscalls/exit/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/exit/#do_exit","title":"do_exit","text":""},{"location":"docs/events/builtin/syscalls/exit/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/exit/#purpose","title":"Purpose","text":"<p>Hook the kernel entry point to trace process termination.</p>"},{"location":"docs/events/builtin/syscalls/exit/#example-use-case","title":"Example Use Case","text":"<p>Analyzing the exit status code of children processes.</p>"},{"location":"docs/events/builtin/syscalls/exit/#issues","title":"Issues","text":"<p>None</p>"},{"location":"docs/events/builtin/syscalls/exit/#related-events","title":"Related Events","text":"<p>The <code>fork()</code> and <code>exec()</code> syscalls are related to this event since they are used  to create and load a new process which will eventually terminate with the <code>exit()</code>  syscall.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/exit_group/","title":"exit_group","text":""},{"location":"docs/events/builtin/syscalls/exit_group/#intro","title":"Intro","text":"<p>exit_group - cause all threads in the calling thread's thread group to exit</p>"},{"location":"docs/events/builtin/syscalls/exit_group/#description","title":"Description","text":"<p>exit_group effectively calls _exit and terminates all threads in the calling thread's thread group. The return status passed to the parent (_exit) is the same as from the  terminating thread.</p> <p>The exit_group syscall is useful for applications requiring the termination of all threads before the application exits. It also has advantages over manual termination of threads, as it provides a reliable way for all threads to terminate, without race conditions and missing threads. However, it does have the limitation that it can only be used for threads within the same process, and not for threads in other processes.</p>"},{"location":"docs/events/builtin/syscalls/exit_group/#arguments","title":"Arguments","text":"<ul> <li><code>status</code>:<code>int</code> - This argument determines the status the process is finished with. It can be a negative number, signifying an error code, or 0 to signify a successful termination.</li> </ul>"},{"location":"docs/events/builtin/syscalls/exit_group/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> </ul>"},{"location":"docs/events/builtin/syscalls/exit_group/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/exit_group/#exit_group_1","title":"exit_group","text":""},{"location":"docs/events/builtin/syscalls/exit_group/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/exit_group/#purpose","title":"Purpose","text":"<p>Collecting information about the exit process</p>"},{"location":"docs/events/builtin/syscalls/exit_group/#example-use-case","title":"Example Use Case","text":"<p>An application may use exit_group to ensure that all threads are properly terminated before the program ends. This can ensure that all resources the threads may be using are cleaned up correctly.</p>"},{"location":"docs/events/builtin/syscalls/exit_group/#issues","title":"Issues","text":"<p>exit_group can only terminate threads within the same process, and not threads from other processes.</p>"},{"location":"docs/events/builtin/syscalls/exit_group/#related-events","title":"Related Events","text":"<ul> <li>clone: used to be able to create multiple threads within the same process for the exit_group syscall to terminate.</li> <li>_exit: called by the exit_group syscall to terminate the process.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/faccessat/","title":"faccessat","text":""},{"location":"docs/events/builtin/syscalls/faccessat/#intro","title":"Intro","text":"<p><code>faccessat</code> - Tests the accessibility of the file or directory referred to by file descriptor</p>"},{"location":"docs/events/builtin/syscalls/faccessat/#description","title":"Description","text":"<p>The <code>faccessat</code> function checks whether the current user can access the file referred to by the file descriptor <code>dirfd</code> and <code>pathname</code>. It checks for the type of access indicated by <code>mode</code>, which is either F_OK (file existence check), R_OK (read permission check), W_OK (write permission check), or X_OK (execute permission check). The <code>flags</code> argument allows additional enhancements to the permission check. If <code>pathname</code> is an empty string, <code>faccessat</code> will check for the same permission in the directory referred to by <code>dirfd</code>.</p> <p>This function is useful when you want to check permissions of a file before opening it, in order to avoid any security issues related to time-of-check to time-of-use (TOCTOU) vulnerabilities.</p>"},{"location":"docs/events/builtin/syscalls/faccessat/#arguments","title":"Arguments","text":"<ul> <li><code>dirfd: int</code> - File descriptor of the directory containing the file to be checked  </li> <li><code>pathname: const char*</code> - Relative or absolute pathname of the file to be checked  </li> <li><code>mode: int</code> - Type of access to be checked, can be one of: </li> <li>F_OK - Permission existence check.</li> <li>R_OK - read permission check.</li> <li>W_OK - write permission check.</li> <li>X_OK - execute permission check. </li> <li><code>flags: int</code>[U,OPT] - Allows additional enhancements to the permission check. Currently only 0 and AT_EACCESS are supported.</li> </ul>"},{"location":"docs/events/builtin/syscalls/faccessat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/faccessat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/faccessat/#sys_faccessat","title":"sys_faccessat","text":""},{"location":"docs/events/builtin/syscalls/faccessat/#type","title":"Type","text":"<p>Kprobes + Kretprobes</p>"},{"location":"docs/events/builtin/syscalls/faccessat/#purpose","title":"Purpose","text":"<p>To capture syscalls made by processes and any errors that occur.</p>"},{"location":"docs/events/builtin/syscalls/faccessat/#example-use-case","title":"Example Use Case","text":"<p>One possible use case is to monitor user account permissions. This could be particularly useful for security monitoring of users and applications by using the <code>faccessat</code> syscall to check for allowed or denied access to files.</p>"},{"location":"docs/events/builtin/syscalls/faccessat/#issues","title":"Issues","text":"<p>There are potential TOCTOU (Time-of-check to Time-of-use) vulnerabilities associated with <code>faccessat</code>, as the permission check done by the syscall is not atomic, i.e. it can lead to inconsistent results because if permission is granted when checked, but then has changed to denied before the file is actually used, then the permission check may not be reliable.</p>"},{"location":"docs/events/builtin/syscalls/faccessat/#related-events","title":"Related Events","text":"<ul> <li><code>openat</code>: Used for opening files, and may be used in conjunction with <code>faccessat</code> to safely open files.</li> <li><code>stat</code>: Used for getting information about files, and can be useful to check for permission changes between checks done by the <code>faccessat</code> syscall.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/faccessat2/","title":"faccessat2","text":""},{"location":"docs/events/builtin/syscalls/faccessat2/#intro","title":"Intro","text":"<p>faccessat2 - check user's permissions for a file</p>"},{"location":"docs/events/builtin/syscalls/faccessat2/#description","title":"Description","text":"<p><code>faccessat2</code> is a system call that checks a given file's permission for the current user. It works by reading the permission bits of the file, then comparing those bits with the given mode. If the user has the requisite permission, the call succeeds; if not, the call fails with an error code. </p> <p>One limitation is that <code>faccessat2</code> works only on regular files - it is not able to make these checks on other kinds of objects such as devices, directories, UNIX sockets and so on. Additionally, the call is affected by Time-of-check/Time-of-use (TOCTOU) race conditions, thus extra care needs to be taken to ensure safety.</p>"},{"location":"docs/events/builtin/syscalls/faccessat2/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - File descriptor from which the name of the file is to be read.</li> <li><code>path</code>:<code>const char*</code>[K,U] - Relative or absolute pathname for the file.</li> <li><code>mode</code>:<code>int</code>[K] - The mode to be checked for the given file descriptor and path.</li> <li><code>flag</code>:<code>int</code>[K,OPT] - Optional flags passed to the system call.</li> </ul>"},{"location":"docs/events/builtin/syscalls/faccessat2/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/faccessat2/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/faccessat2/#faccessat2_1","title":"faccessat2","text":""},{"location":"docs/events/builtin/syscalls/faccessat2/#type","title":"Type","text":"<p>Kprobe.</p>"},{"location":"docs/events/builtin/syscalls/faccessat2/#purpose","title":"Purpose","text":"<p>To monitor the <code>faccessat2</code> syscall and keep track of the results of permission checks on files.</p>"},{"location":"docs/events/builtin/syscalls/faccessat2/#example-use-case","title":"Example Use Case","text":"<p>This syscall can be used to solve the problem of unauthorized users trying to access files that they should not be able to access. Using the syscall one can check for the existence of files and their permission at the same time and in an atomic operation.</p>"},{"location":"docs/events/builtin/syscalls/faccessat2/#issues","title":"Issues","text":"<p>There is a TOCTOU race condition, since between the time that the permission check is done and the time of use, the permission may have changed. Additionally, <code>faccessat2</code> will only work with regular files and not with other types such as directory, devices, etc.</p>"},{"location":"docs/events/builtin/syscalls/faccessat2/#related-events","title":"Related Events","text":"<ul> <li>stat</li> <li>fstat</li> <li>fstatat</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fadvise64/","title":"fadvise64","text":""},{"location":"docs/events/builtin/syscalls/fadvise64/#intro","title":"Intro","text":"<p>fadvise64 - system call that causes an advisory information about access pattern for a file region, in order to optimize file access.</p>"},{"location":"docs/events/builtin/syscalls/fadvise64/#description","title":"Description","text":"<p>The fadvise64 system call advises the kernel about how a file will be accessed in the future, allowing the kernel to optimize its use of resources as appropriate. Given a file's descriptor <code>fd</code>, <code>offset</code> and <code>len</code> specify the size of the region offset that the advice applies to; the <code>advice</code> argument specifies the advice to be given.</p> <p>Advice is advisory only, and need not be followed. The <code>advice</code> argument is a bitmask the can take any combination of the following values:   - <code>POSIX_FADV_NORMAL</code>: No advice to give; the default assumption is that applications expect that read and write operations on the specified region will be performed in a reasonable amount of time.   - <code>POSIX_FADV_SEQUENTIAL</code>: The applications expects that the access will be a sequential access pattern.   - <code>POSIX_FADV_RANDOM</code>: The application expects that the access pattern will be a random access pattern.   - <code>POSIX_FADV_NOREUSE</code>: The application expects that the access pattern will be a read-only pattern and that the data will not be reused in the near future. </p>"},{"location":"docs/events/builtin/syscalls/fadvise64/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:int[K] - File descriptor for the file in question.</li> <li><code>offset</code>:off_t[K] - Offset into the file for the start of the region the advice applies to.</li> <li><code>len</code>:size_t[K] - Length of the region to which advice applies.</li> <li><code>advice</code>:int[K] - Advice given. May be a combination of the available flags in bitmask form.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fadvise64/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fadvise64/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fadvise64/#sys_fadvise64","title":"sys_fadvise64","text":""},{"location":"docs/events/builtin/syscalls/fadvise64/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/fadvise64/#purpose","title":"Purpose","text":"<p>To record information about the usage of fadvise64 and the advice being given.</p>"},{"location":"docs/events/builtin/syscalls/fadvise64/#example-use-case","title":"Example Use Case","text":"<p>An example use case for fadvise64 would be a database application using a large file for its data. The application could call fadvise64 with the advice <code>POSIX_FADV_SEQUENTIAL</code> to indicate to the kernel that the data access on this file is likely to occur in a sequential fashion. This allows the kernel to optimize its disk scheduling, resulting in improved disk performance. </p>"},{"location":"docs/events/builtin/syscalls/fadvise64/#issues","title":"Issues","text":"<p>When an application has not specified an access pattern to the kernel, it is not possible for the kernel to optimize its disk scheduling appropriately. As such, fadvise64 should not be used as a means of improving disk performance - it is only useful when an application can reliably determine an access pattern and communicate it to the kernel.</p>"},{"location":"docs/events/builtin/syscalls/fadvise64/#related-events","title":"Related Events","text":"<ul> <li><code>fsync</code> - synchronizes a file's in-core state with storage device. </li> <li><code>openat</code> - opens a file from a given directory file descriptor. </li> <li><code>madvise</code> - system call advising the kernel about the address space access pattern.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fadvise64_64/","title":"fadvise64_64","text":""},{"location":"docs/events/builtin/syscalls/fadvise64_64/#intro","title":"Intro","text":"<p>fadvise64_64 - Informs the kernel of the application's advice on how it should handle the file associated with the given file descriptor</p>"},{"location":"docs/events/builtin/syscalls/fadvise64_64/#description","title":"Description","text":"<p>The fadvise64_64 syscall is a system call that provides a mechanism for an application to advise the kernel of its behavior and access patterns for a file associated with a specified file descriptor. An application can provide strategies or smartly manage the page cache and associated hardware prefetch (e.g. disk read ahead) without accessing the data. fadvise64_64 provides an application with hints that allow it to better manage and group similar, potentially duplicate, data operations. </p> <p>The benefit of this syscall is that, since the kernel is more aware of an application's expectations, it can efficiently manage the operations, leading to improved performance and decreased user wait time. Additionally, fadvise64_64 allows an application to inform the kernel that a range of bytes, within a file, will not be accessed again in the foreseeable future. Thus, decreasing the work the kernel has to do and, thus, conserving system resources. </p> <p>On the other hand, the trade-off of using this syscall is that the kernel can no longer rely on application patterns in order to determine when to read ahead, or when to evict data from the page cache. This could lead to inefficiencies, as the application will now be responsible for data management.</p>"},{"location":"docs/events/builtin/syscalls/fadvise64_64/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - File descriptor associated with the given data. </li> <li><code>offset</code>:<code>loff_t</code>[K] - Offset to which the advice is required for.</li> <li><code>len</code>:<code>loff_t</code>[K] - Length of the data which it is required to be effected by the given advice.</li> <li><code>advice</code>:<code>int</code>[K] - The advice which needs to be applied on the data associated with the given file descriptor. </li> </ul>"},{"location":"docs/events/builtin/syscalls/fadvise64_64/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fadvise64_64/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fadvise64_64/#sys_fadvise64_64","title":"sys_fadvise64_64","text":""},{"location":"docs/events/builtin/syscalls/fadvise64_64/#type","title":"Type","text":"<p>Kprobe </p>"},{"location":"docs/events/builtin/syscalls/fadvise64_64/#purpose","title":"Purpose","text":"<p>To allow the kernel to efficiently manage the operations of the application, leading to improved performance and decreased user wait time. </p>"},{"location":"docs/events/builtin/syscalls/fadvise64_64/#example-use-case","title":"Example Use Case","text":"<p>As an example, an application that streams large chunks of data from a file to an output device. Since the data will be processed and sent off in large chunks, a streaming application can advise the kernel that the data will not be accessed again, eliminating the costly pagecache eviction operation.</p>"},{"location":"docs/events/builtin/syscalls/fadvise64_64/#issues","title":"Issues","text":"<p>fadvise64_64 is currently unavailable on some architectures and platforms, such as MIPS. In other cases, a supported architecture or platform might be missing some features.</p>"},{"location":"docs/events/builtin/syscalls/fadvise64_64/#related-events","title":"Related Events","text":"<ul> <li>read - to read data from a file descriptor.</li> <li>pread64 - to read from a file descriptor with a given offset.</li> <li>madvise - another syscall to advise the kernel on how it should manage memory.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fallocate/","title":"fallocate","text":""},{"location":"docs/events/builtin/syscalls/fallocate/#intro","title":"Intro","text":"<p>fallocate - System call to preallocate blocks of a file</p>"},{"location":"docs/events/builtin/syscalls/fallocate/#description","title":"Description","text":"<p>The fallocate() system call is used to preallocate blocks for a file. The call guarantees the requested space for the file without allocating a physical storage, resulting in faster file access. This system call is not affected by the current size of a file, but rather allows it to extend the size immediately.  </p> <p>This syscall has some edge cases, such as when the file is on a filesystem which doesn't support fallocation, and when the file is located on a cluster filesystem. In such cases, a part of the requested area will be allocated, with the remaining blocks marked as needing allocation.</p>"},{"location":"docs/events/builtin/syscalls/fallocate/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code> - File descriptor. </li> <li><code>mode</code>:<code>int</code> - Operation type. A bitwise combination of the flags FALLOC_FL_KEEP_SIZE, FALLOC_FL_PUNCH_HOLE, FALLOC_FL_COLLAPSE_RANGE. FALLOC_FL_ZERO_RANGE is not supported from kernel 4.14 onwards.  </li> <li><code>offset</code>:<code>off_t</code> - Starting offset of requested space past the end of file.  </li> <li><code>len</code>:<code>off_t</code> - Length of requested space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fallocate/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/fallocate/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fallocate/#sys_fallocate","title":"sys_fallocate","text":""},{"location":"docs/events/builtin/syscalls/fallocate/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/fallocate/#purpose","title":"Purpose","text":"<p>To gather file descriptor and offset information, as well as the size of the file before and after the fallocation for a process.</p>"},{"location":"docs/events/builtin/syscalls/fallocate/#example-use-case","title":"Example Use Case","text":"<p>This event can be used to track a process' file write operations to disk. This can be helpful for debugging the performance of an application, as the syscall enables us to track how and when the application reserves and uses disk space.</p>"},{"location":"docs/events/builtin/syscalls/fallocate/#issues","title":"Issues","text":"<p>The fallocate syscall is not supported by some filesystems, thus the fallocation wont be completely successful. </p>"},{"location":"docs/events/builtin/syscalls/fallocate/#related-events","title":"Related Events","text":"<ul> <li>pwrite</li> <li>ftruncate</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fanotify_init/","title":"fanotify_init","text":""},{"location":"docs/events/builtin/syscalls/fanotify_init/#intro","title":"Intro","text":"<p>fanotify_init - initialize fanotify handle</p>"},{"location":"docs/events/builtin/syscalls/fanotify_init/#description","title":"Description","text":"<p>The fanotify_init() system call initializes the fanotify handle, which is  used  to  register  fanotify  events  and  mark  paths  and  files  to  be  monitored with the <code>fanotify_mark</code> system call. This call allocates the required structures, sets the given flags and allocates an event queue.</p> <p>A fanotify handle can be used to monitor events in multiple directories by calling the <code>fanotify_mark</code> system call and the returned file descriptor can be monitored with <code>select()</code>, <code>poll()</code> or <code>epoll_wait()</code>.</p> <p>The flags used in fanotify_init determine the behavior of the fanotify handle. Some of the available flags are <code>FAN_CLOEXEC</code>, <code>FAN_NONBLOCK</code> and <code>FAN_UNLIMITED_QUEUE</code>.</p>"},{"location":"docs/events/builtin/syscalls/fanotify_init/#arguments","title":"Arguments","text":"<ul> <li><code>flags</code>:<code>unsigned int</code>[K] - set of flags used to determine the behavior of the fanotify handle.</li> <li><code>event_f_flags</code>:<code>unsigned int</code>[K] - set of event flags used to select the events to report to the fanotify handle.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fanotify_init/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fanotify_init/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fanotify_init/#fanotify_init_1","title":"fanotify_init","text":""},{"location":"docs/events/builtin/syscalls/fanotify_init/#type","title":"Type","text":"<p>Probe</p>"},{"location":"docs/events/builtin/syscalls/fanotify_init/#purpose","title":"Purpose","text":"<p>To monitor events related to fanotify_init.</p>"},{"location":"docs/events/builtin/syscalls/fanotify_init/#example-use-case","title":"Example Use Case","text":"<p>A monitoring tool could use fanotify_init to create handles which it can then use to monitor files and directories for any changes and act on them.</p>"},{"location":"docs/events/builtin/syscalls/fanotify_init/#issues","title":"Issues","text":"<p>There is a known issue that fanotify_init does not support 64-bit arguments.</p>"},{"location":"docs/events/builtin/syscalls/fanotify_init/#related-events","title":"Related Events","text":"<ul> <li>fanotify_mark - set up fanotify notification</li> <li>fanotify_close - close fanotify notification</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fanotify_mark/","title":"fanotify_mark","text":""},{"location":"docs/events/builtin/syscalls/fanotify_mark/#intro","title":"Intro","text":"<p>fanotify_mark - add an fanotify mark to a file or directory</p>"},{"location":"docs/events/builtin/syscalls/fanotify_mark/#description","title":"Description","text":"<p>The <code>fanotify_mark</code> system call adds an fanotify mark to a file or directory. The fanotify mark contains the mask argument, used to indicate the events we want to receive notifications about. This call allows for finer grained control over which filesystem events we monitor. The <code>fanotify_mark</code> system call also allows to set flags which control the behavior of the fanotify marks. This system call can be used to monitor files or directories on both block-level devices and in file systems.</p> <p>There are some drawbacks to using fanotify marks. First, when used on a directory, the <code>fanotify_mark</code> system call will only monitor the events related to the directory itself. It won't monitor any events occurring in the subdirectories or files underneath it. Second, fanotify marks only support limited types of events, such as open, read, write, and delete.</p>"},{"location":"docs/events/builtin/syscalls/fanotify_mark/#arguments","title":"Arguments","text":"<ul> <li><code>fanotify_fd</code>:<code>int</code>[K] - File descriptor identifying fanotify instance.</li> <li><code>flags</code>:<code>unsigned int</code>[K] - Flags which control the behaviour of the fanotify marks.</li> <li><code>mask</code>:<code>u64</code>[K] - Mask of the filesystem events to be monitored.</li> <li><code>dirfd</code>:<code>int</code>[K] - File descriptor identifying the directory.</li> <li><code>pathname</code>:<code>const char*</code>[U] - Pathname Relative to the file descriptor. The fanotify mark will be placed on all files and directories within this pathname, even if the file/directories don\u2019t exist yet.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fanotify_mark/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/fanotify_mark/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fanotify_mark/#inotify_init","title":"inotify_init","text":""},{"location":"docs/events/builtin/syscalls/fanotify_mark/#type","title":"Type","text":"<p>KProbe</p>"},{"location":"docs/events/builtin/syscalls/fanotify_mark/#purpose","title":"Purpose","text":"<p>To monitor the <code>inotify_init</code> functions</p>"},{"location":"docs/events/builtin/syscalls/fanotify_mark/#example-use-case","title":"Example Use Case","text":"<p>The fanotify_mark system call can be used to monitor access and changes made to files or directories. For example, this could be used to gain insight into application behavior. For example, an application could have access to a file and modify it, change the permission of a file, or delete a file, and these events would be tracked using the fanotify_mark system call.</p>"},{"location":"docs/events/builtin/syscalls/fanotify_mark/#issues","title":"Issues","text":"<p>The fanotify_mark system call can only monitor fragments of the filesystem and can\u2019t track events that happen inside subdirectories or files. Also, some flags might not be supported in some kernel versions. </p>"},{"location":"docs/events/builtin/syscalls/fanotify_mark/#related-events","title":"Related Events","text":"<p><code>fanotify_init</code> - create a file access notification event. <code>fanotify_init_group</code> - create a file access notification event (for groups).</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fchdir/","title":"fchdir","text":""},{"location":"docs/events/builtin/syscalls/fchdir/#intro","title":"Intro","text":"<p>fchdir - Change the current working directory by file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/fchdir/#description","title":"Description","text":"<p>The fchdir() system call allows the application to change the current working directory by a file descriptor. This can be useful for applications that want to change the cwd for a child process without having to resort to absolute paths or up and down directory lookup. The file descriptor argument should refer to an open directory.</p> <p>There are some drawbacks to using fchdir(). Since it is an atomic operation, it will not take into account intervening changes to the directory structure. This can have security implications, therefore applications that are using fchdir() should be aware of potential time-of-check, time-of-use (TOCTOU) race conditions.</p>"},{"location":"docs/events/builtin/syscalls/fchdir/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - File descriptor of an open directory that should be used as the new cwd.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fchdir/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fchdir/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fchdir/#fchdir_1","title":"fchdir","text":""},{"location":"docs/events/builtin/syscalls/fchdir/#type","title":"Type","text":"<p>Kprobe </p>"},{"location":"docs/events/builtin/syscalls/fchdir/#purpose","title":"Purpose","text":"<p>To track changes in the current working directory and log the arguments associated with them.</p>"},{"location":"docs/events/builtin/syscalls/fchdir/#example-use-case","title":"Example Use Case","text":"<p>An application wants to change the cwd for its child process without having to resort to absolute paths or up and down directory lookup. </p>"},{"location":"docs/events/builtin/syscalls/fchdir/#issues","title":"Issues","text":"<p>fchdir() is an atomic operation, so it will not take into account intervening changes to the directory structure. This can have security implications, as there may be potential time-of-check, time-of-use (TOCTOU) race conditions. </p>"},{"location":"docs/events/builtin/syscalls/fchdir/#related-events","title":"Related Events","text":"<ul> <li>chdir - Change the current working directory</li> <li>open - Open a file (used to obtain the necessary file descriptor)</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fchmod/","title":"fchmod","text":""},{"location":"docs/events/builtin/syscalls/fchmod/#intro","title":"Intro","text":"<p>fchmod - change the permissions of a file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/fchmod/#description","title":"Description","text":"<p>The fchmod() function shall change the file permission bits of the file referred to by the open file descriptor fd to the value specified by mode. Mode is specified in the same format used for file mode-bits in chmod.</p> <p>The fchmod() function shall not modify ACLs (Access Control Lists), regardless of the effective user ID of the process.</p>"},{"location":"docs/events/builtin/syscalls/fchmod/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - file descriptor</li> <li><code>mode</code>:<code>mode_t</code>[K] - the permissions to be set on the file referred to by the file descriptor</li> </ul>"},{"location":"docs/events/builtin/syscalls/fchmod/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fchmod/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fchmod/#sys_fchmod","title":"sys_fchmod","text":""},{"location":"docs/events/builtin/syscalls/fchmod/#type","title":"Type","text":"<p>Kprobe.</p>"},{"location":"docs/events/builtin/syscalls/fchmod/#purpose","title":"Purpose","text":"<p>To intercept calls to the fchmod system call and log the arguments used.</p>"},{"location":"docs/events/builtin/syscalls/fchmod/#example-use-case","title":"Example Use Case","text":"<p>A system administrator needs to change the permissions of a file for a user in a specific group. The administrator can use the fchmod() system call to change the permissions of that file for that specific user.</p>"},{"location":"docs/events/builtin/syscalls/fchmod/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/fchmod/#related-events","title":"Related Events","text":"<ul> <li>chmod() - change the permissions of a file.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fchmodat/","title":"fchmodat","text":""},{"location":"docs/events/builtin/syscalls/fchmodat/#intro","title":"Intro","text":"<p>fchmodat - change permissions of a file in a given directory</p>"},{"location":"docs/events/builtin/syscalls/fchmodat/#description","title":"Description","text":"<p>The <code>fchmodat</code> system call is used to change the file mode (file-permission bits) of a given file relative to a directory file descriptor. The <code>fchmodat</code> takes four arguments: - A directory file descriptor (<code>dirfd</code>) - A relative pathname of the file to be modified (<code>pathname</code>) - An octal <code>mode</code> value corresponding to the desired file permission bits - A flag (<code>flags</code>) indicating whether the file permission should follow symlinks or not</p> <p>The <code>mode</code> argument is a set of permission bits defined by POSIX and assigns read, write and execute permissions to the file's owner, file's group and other users respectively. The <code>flags</code> argument allows the caller to specify whether the file permission should follow symbolic links or not.</p>"},{"location":"docs/events/builtin/syscalls/fchmodat/#arguments","title":"Arguments","text":"<ul> <li><code>dirfd</code>: <code>int</code>[K] - The directory file descriptor.</li> <li><code>pathname</code>: <code>const char*</code>[K]  - The relative pathname of the file to be modified.</li> <li><code>mode</code>: <code>mode_t</code>[K] - An octal number containing the desired permission bits for the file.</li> <li><code>flags</code>: <code>int</code>[K] - Flag specifying whether the file permission should follow symlinks or not.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fchmodat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fchmodat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fchmodat/#fchmodat_common","title":"fchmodat_common","text":""},{"location":"docs/events/builtin/syscalls/fchmodat/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/fchmodat/#purpose","title":"Purpose","text":"<p>Monitor changes to file permissions in a given directory.</p>"},{"location":"docs/events/builtin/syscalls/fchmodat/#example-use-case","title":"Example Use Case","text":"<p>An application that needs to audit changes in file system permissions in a given directory. By hooking the <code>fchmodat</code> system call, changes in the file permissions can be monitored in real-time and useful information such as the process ID that initiated the changes can be quickly extracted.</p>"},{"location":"docs/events/builtin/syscalls/fchmodat/#issues","title":"Issues","text":"<p>Since the <code>pathname</code> argument is a relative pathname, it is vulnerable to the TOCTOU (Time-of-check, Time-of-use) bug and the behavior is undefined if a file described by the <code>pathname</code> is changed after the system call is initiated.</p>"},{"location":"docs/events/builtin/syscalls/fchmodat/#related-events","title":"Related Events","text":"<ul> <li>fchmod - change permissions of a file by its pathname.</li> <li>umask - Set file mode creation mask.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fchown/","title":"fchown","text":""},{"location":"docs/events/builtin/syscalls/fchown/#intro","title":"Intro","text":"<p><code>fchown</code> - changes the owner and group of the specified file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/fchown/#description","title":"Description","text":"<p><code>fchown</code> changes the owner of the file referred to by the open file descriptor <code>fd</code> to <code>owner</code> and the group to <code>group</code>. The effective user ID of the calling process must match the owner of the file, or the caller must be privileged. Note that in order to change the owner of a file, the caller must have the <code>CAP_CHOWN</code> capability in the user namespace that governs its execution. </p> <p><code>fchown</code> can be used instead of <code>chown</code> if it is necessary to work with an existing open file descriptor instead of relying on a file path.</p>"},{"location":"docs/events/builtin/syscalls/fchown/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code> - file descriptor referring to the file to change ownership.</li> <li><code>owner</code>:<code>uid_t</code> - the user ID of the new owner. </li> <li><code>group</code>:<code>gid_t</code> - the group ID of the new group. </li> </ul>"},{"location":"docs/events/builtin/syscalls/fchown/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/fchown/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fchown/#sys_chown","title":"sys_chown","text":""},{"location":"docs/events/builtin/syscalls/fchown/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/fchown/#purpose","title":"Purpose","text":"<p>To track changes of file ownership.</p>"},{"location":"docs/events/builtin/syscalls/fchown/#example-use-case","title":"Example Use Case","text":"<p>An application that provides file access control has the need to track changes of the owner of files, in order to update the access control list accordingly. By hooking <code>fchown</code>, this application can capture this information with ease.</p>"},{"location":"docs/events/builtin/syscalls/fchown/#issues","title":"Issues","text":"<p>No known issues.</p>"},{"location":"docs/events/builtin/syscalls/fchown/#related-events","title":"Related Events","text":"<ul> <li><code>chown</code>: Similar event, based on a file name instead of a file descriptor.</li> <li><code>fchmod</code>: Changes the mode of the file referred to by the open file descriptor <code>fd</code>. Might be related since permissions rely on owner and group of a file.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fchown16/","title":"fchown16","text":""},{"location":"docs/events/builtin/syscalls/fchown16/#intro","title":"Intro","text":"<p>fchown16 - Change the owner and group of the file referred to by the file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/fchown16/#description","title":"Description","text":"<p>The fchown16() system call changes the ownership of the file referred to by the file descriptor fd.  The effective user ID of the process must match the existing owner of the file, or the process must have the appropriate privilege.</p> <p>This system call is equivalent to using fchownat() with the flag AT_EMPTY_PATH flag set.</p> <p>There are some drawbacks associated with using fchown16. First, fchown16 does not work on systems without a 16-bit UID/GID model, such as the Linux kernel. Second, it can potentially be insecure since it is not atomic, so it can be vulnerable to race conditions like TOCTOU (time of check, time of use).</p>"},{"location":"docs/events/builtin/syscalls/fchown16/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>unsigned int</code>K - The file descriptor of the file.</li> <li><code>user</code>:<code>old_uid_t</code>K - The user ID of the new owner.</li> <li><code>group</code>:<code>old_gid_t</code>K - The group ID of the new group.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fchown16/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU- Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/fchown16/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fchown16/#sys_fchown16","title":"sys_fchown16","text":""},{"location":"docs/events/builtin/syscalls/fchown16/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/fchown16/#purpose","title":"Purpose","text":"<p>To track changes in the ownership of files.</p>"},{"location":"docs/events/builtin/syscalls/fchown16/#example-use-case","title":"Example Use Case","text":"<p>An application might use this system call to ensure that only certain users are able to access certain files or directories.</p>"},{"location":"docs/events/builtin/syscalls/fchown16/#issues","title":"Issues","text":"<p>This system call is not available on systems without a 16-bit UID/GID model, such as the Linux kernel. Additionally, the system call can be vulnerable to race conditions like TOCTOU (time of check, time of use).</p>"},{"location":"docs/events/builtin/syscalls/fchown16/#related-events","title":"Related Events","text":"<ul> <li>fchownat</li> <li>fstat</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fchownat/","title":"fchownat","text":""},{"location":"docs/events/builtin/syscalls/fchownat/#intro","title":"Intro","text":"<p>fchownat - changes the ownership and group of a given file.</p>"},{"location":"docs/events/builtin/syscalls/fchownat/#description","title":"Description","text":"<p>This syscall allows for the changing of the ownership and group of a given file. It works by specifying the file by its name or by its file descriptor (<code>dirfd</code>). It takes an additional argument <code>flags</code>, with which we can specify if the file should be followed if it is a symbolic link (<code>AT_SYMLINK_NOFOLLOW</code> flag) and if the ancestor directories should be created if they don't already exist (<code>AT_CREATE</code>).</p>"},{"location":"docs/events/builtin/syscalls/fchownat/#arguments","title":"Arguments","text":"<ul> <li><code>dirfd</code>:<code>int</code>[K] - dirfd is the file descriptor of a directory used to find the initial pathname. It can be set to <code>AT_FDCWD</code> to specify using the current directory. It must refer to a directory.</li> <li><code>pathname</code>:<code>const char*</code>[U] - pathname is the given file name. It should be an absolute path, relative to the directory given in dirfd.</li> <li><code>owner</code>:<code>uid_t</code>[K] - owner is the given UID for the owner of the file. It will have the given owner's group and permissions.</li> <li><code>group</code>:<code>gid_t</code>[K] - group is the given GID for the group of the file. It will have the given owner's group and permissions.</li> <li><code>flags</code>:<code>int</code>[K] - flags is used to specify if the path should be followed if it is a symbolic link (<code>AT_SYMLINK_NOFOLLOW</code> flag) and if the ancestor directories should be created if they don't already exist (<code>AT_CREATE</code>).</li> </ul>"},{"location":"docs/events/builtin/syscalls/fchownat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/fchownat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fchownat/#do_fchownat","title":"do_fchownat","text":""},{"location":"docs/events/builtin/syscalls/fchownat/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/fchownat/#purpose","title":"Purpose","text":"<p>To capture syscall arguments made to fchownat.</p>"},{"location":"docs/events/builtin/syscalls/fchownat/#example-use-case","title":"Example Use Case","text":"<p>One example use case could be to capture events when a certain user is changing the ownership of a file.</p>"},{"location":"docs/events/builtin/syscalls/fchownat/#issues","title":"Issues","text":"<p>It is possible for this syscall to be vulnerable to a race condition when AT_SYMLINK_NOFOLLOW is used as a flag and the target file is modified between the time that fchownat reads the target stat and the time that it attempts to perform the chown.</p>"},{"location":"docs/events/builtin/syscalls/fchownat/#related-events","title":"Related Events","text":"<ul> <li><code>openat</code> - to open a file given a directory descriptor and a path</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fcntl/","title":"fcntl","text":""},{"location":"docs/events/builtin/syscalls/fcntl/#intro","title":"Intro","text":"<p>fcntl - Manipulates file descriptor</p>"},{"location":"docs/events/builtin/syscalls/fcntl/#description","title":"Description","text":"<p>The fcntl system call is used to manipulate a file descriptor.  It can be used to read and modify the flags associated with a particular file descriptor, including changing the non-blocking status and closing the file descriptor. It can also be used to implement file locking, sharing file descriptors between processes, and more.</p> <p>The function takes three arguments, a file descriptor <code>fd</code>, an action <code>cmd</code>, and an argument <code>arg</code>. Depending on the action, the argument may or may not be used and can contain various values.</p>"},{"location":"docs/events/builtin/syscalls/fcntl/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code> - The file descriptor to manipulate.</li> <li><code>cmd</code>:<code>int</code> - The type of operation to perform.</li> <li><code>arg</code>:<code>unsigned long</code> - An optional argument for some of the operations.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fcntl/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/fcntl/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fcntl/#sys_fcntl","title":"sys_fcntl","text":""},{"location":"docs/events/builtin/syscalls/fcntl/#type","title":"Type","text":"<p>Kprobe + Kretprobe.</p>"},{"location":"docs/events/builtin/syscalls/fcntl/#purpose","title":"Purpose","text":"<p>To trace all calls to sys_fcntl and return values.</p>"},{"location":"docs/events/builtin/syscalls/fcntl/#example-use-case","title":"Example Use Case","text":"<p>Tracking all attempts to change the non-blocking status of any file descriptor for debugging or security purposes.</p>"},{"location":"docs/events/builtin/syscalls/fcntl/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/fcntl/#related-events","title":"Related Events","text":"<ul> <li>open</li> <li>close</li> <li>read</li> <li>write</li> <li>lseek</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fcntl64/","title":"fcntl64","text":""},{"location":"docs/events/builtin/syscalls/fcntl64/#intro","title":"Intro","text":"<p>fcntl64 - Used to manipulate file descriptor. </p>"},{"location":"docs/events/builtin/syscalls/fcntl64/#description","title":"Description","text":"<p><code>fcntl64()</code> is a system call that is used to manipulate or get information about a file descriptor. It allows the caller to perform operations such as reading and writing to the descriptor, setting or clearing flags associated with the descriptor, or partitioning locks between processes.</p> <p>When manipulating file descriptors, there are several actions that can be performed: - <code>F_DUPFD</code>: Duplicates an existing file descriptor - <code>F_GETFD</code>: Gets the descriptor flags associated with the file descriptor - <code>F_SETFD</code>: Sets the descriptor flags associated with the file descriptor - <code>F_GETFL</code>: Gets the file status flags for the file descriptor - <code>F_SETFL</code>: Sets the file status flags for the file descriptor - <code>F_SETLK</code>: Sets a file lock - <code>F_GETLK</code>: Gets an existing lock from a given file</p> <p>When dealing with locks, it is important to note that there are two types of locks: - <code>F_RDLCK</code>: Places a read lock on a file - <code>F_WRLCK</code>: Places a write lock on a file</p> <p>There are also several advantages and drawbacks to using <code>fcntl64()</code>: - Advantage: Allows users to set or clear flags associated with a file descriptor without having to know the actual flag values themselves - Disadvantage: The <code>fcntl()</code> family of functions can be tricky to use correctly and require careful checking of return values to make sure that the desired actions were actually performed correctly</p>"},{"location":"docs/events/builtin/syscalls/fcntl64/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - File descriptor to manipulate or get information about</li> <li><code>cmd</code>:<code>int</code>[K] - Desired action to take on the file descriptor</li> <li><code>arg</code>:<code>unsigned long</code>[K] - Parameter associated with the command to be executed </li> </ul>"},{"location":"docs/events/builtin/syscalls/fcntl64/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/fcntl64/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fcntl64/#sys_fcntl","title":"sys_fcntl","text":""},{"location":"docs/events/builtin/syscalls/fcntl64/#type","title":"Type","text":"<p>KPROBES + KRETPROBES</p>"},{"location":"docs/events/builtin/syscalls/fcntl64/#purpose","title":"Purpose","text":"<p>To monitor requests to manipulate file descriptors.</p>"},{"location":"docs/events/builtin/syscalls/fcntl64/#example-use-case","title":"Example Use Case","text":"<p>A use case could be setting a read lock on a file before accessing it and then removing it immediately after, making sure that no other process can access it while it is being accessed. </p>"},{"location":"docs/events/builtin/syscalls/fcntl64/#issues","title":"Issues","text":"<p>There are no known issues with using <code>fcntl64()</code>.</p>"},{"location":"docs/events/builtin/syscalls/fcntl64/#related-events","title":"Related Events","text":"<ul> <li><code>open()</code> - Used to open a file descriptor.</li> <li><code>close()</code> - Used to close a file descriptor.</li> <li><code>dup()</code> - Used to duplicate a file descriptor.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fdatasync/","title":"fdatasync","text":""},{"location":"docs/events/builtin/syscalls/fdatasync/#intro","title":"Intro","text":"<p>fdatasync - Synchronizes file data on disk with the fd.</p>"},{"location":"docs/events/builtin/syscalls/fdatasync/#description","title":"Description","text":"<p>fdatasync is a system call used to synchronize the data stored in the memory with the disk associated to the fd. It ensures that the file will be written in the disk, as is visible to any process that has the file opened. This differs from fsync, which also synchronizes the file metadata (like access and modification times).</p> <p>The main advantage of using fdatasync is that it can be executed more efficiently, since it does not require a full flush of the file metadata. In addtion, the updated file data can be visible to other processes faster. However, this smaller efficiency comes with the cost of not being able to guarantee the integrity of the file metadata. A possible downside of using fdatasync is that it increases the chances of data corruption in case of power failures</p>"},{"location":"docs/events/builtin/syscalls/fdatasync/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - File descriptor associated to the file that will be synchronize.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fdatasync/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fdatasync/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fdatasync/#sys_fdatasync","title":"sys_fdatasync","text":""},{"location":"docs/events/builtin/syscalls/fdatasync/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/fdatasync/#purpose","title":"Purpose","text":"<p>To monitor when the fdatasync system call is executed.</p>"},{"location":"docs/events/builtin/syscalls/fdatasync/#example-use-case","title":"Example Use Case","text":"<p>fdatasync can be used in a backup software. By calling the fdatasync system call, it will make sure that the file is properly updated and synced in the disk before the backup takes place, thus avoiding any kind of data corruption if the system was to crash in the midst of the backup.</p>"},{"location":"docs/events/builtin/syscalls/fdatasync/#issues","title":"Issues","text":"<p>Since the file metadata is not synced, in a power-loss situation it could lead to data inconsistency or corruption.</p>"},{"location":"docs/events/builtin/syscalls/fdatasync/#related-events","title":"Related Events","text":"<ul> <li>fsync - Will make sure that the file data, and metadata, is correctly synchronize with the disk. This can provide a higher level of security but with a higher cost of performance.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fgetxattr/","title":"fgetxattr","text":""},{"location":"docs/events/builtin/syscalls/fgetxattr/#intro","title":"Intro","text":"<p>fgetxattr - get a extended attribute value in a file or directory</p>"},{"location":"docs/events/builtin/syscalls/fgetxattr/#description","title":"Description","text":"<p>The <code>fgetxattr()</code> function retrieves the value of the extended attribute specified by name and associated with the file fd for the size of size bytes and places the result in value. </p> <p>The name argument points to a null-terminated string. The fd argument  is a file descriptor associated with an open file. The value argument is a pointer to a buffer that is at least size bytes in length. The size argument specifies the size of the buffer in bytes. Thus, if value points to a buffer that is too small a buffer to hold the value of the requested attribute, the size of the attribute is returned in size and no data is returned in value.</p> <p>There are several noteworthy edge cases with <code>fgetxattr()</code>. First, <code>fgetxattr()</code> will not follow symbolic links. Second, when used on relative paths, the path will be interpreted relative to the directory indicated by the fd argument. Lastly, if the value argument is NULL or the size argument is 0, then the size of the attribute will be returned in size without any data being returned in value.</p>"},{"location":"docs/events/builtin/syscalls/fgetxattr/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code> - File descriptor associated with an open file.</li> <li><code>name</code>:<code>const char*</code> - Name of the extended attribute. </li> <li><code>value</code>:<code>void*</code>[U] - Pointer to the buffer that will be filled with the attribute value. </li> <li><code>size</code>:<code>size_t</code> - Size of the buffer in bytes.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fgetxattr/#available-tags","title":"Available Tags","text":"<ul> <li>U - Originated from user space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fgetxattr/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fgetxattr/#do_fgetxattr","title":"do_fgetxattr","text":""},{"location":"docs/events/builtin/syscalls/fgetxattr/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/fgetxattr/#purpose","title":"Purpose","text":"<p>To spy on calls to the underlying <code>do_fgetxattr</code> kernel function and capture information about arguments and return values.</p>"},{"location":"docs/events/builtin/syscalls/fgetxattr/#example-use-case","title":"Example Use Case","text":"<p>Monitoring and auditing of programs that use <code>fgetxattr()</code> to retrieve extended attributes. </p>"},{"location":"docs/events/builtin/syscalls/fgetxattr/#issues","title":"Issues","text":"<p>The value argument must point to a buffer in user space. </p>"},{"location":"docs/events/builtin/syscalls/fgetxattr/#related-events","title":"Related Events","text":"<ul> <li>fsetxattr - Set a extended attribute value in a file or directory</li> <li>flistxattr - List extended attribute keys and associated values</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/finit_module/","title":"finit_module","text":""},{"location":"docs/events/builtin/syscalls/finit_module/#intro","title":"Intro","text":"<p>finit_module - request the kernel to initialize or delete a kernel module</p>"},{"location":"docs/events/builtin/syscalls/finit_module/#description","title":"Description","text":"<p>The finit_module system call requests the kernel to initialize (instantiate) or delete (remove) a kernel module. At the end of the initializing procedure, the module code will be executed. If the module removal is requested, all its resources will be freed. This call is intended to be used by privileged processes.</p> <p>The <code>param_values</code> argument points to a block of memory containing one or more parameters with fixed limit size, passed to the kernel module initialization function. The <code>flags</code> argument is used to control the operation of the module. It can be bitwise ORed of zero or more of the following values:</p> <ul> <li><code>O_TRACE</code> - flag to trace module</li> <li><code>O_DEBUG</code> - debug flag</li> <li><code>O_ASYNC</code> - asynchronous initialization</li> <li><code>O_EXCL</code> - exclusive module initializing</li> </ul>"},{"location":"docs/events/builtin/syscalls/finit_module/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>: <code>int</code> - an open file descriptor for the module file that needs to be loaded.</li> <li><code>param_values</code>: <code>const char*</code> - a pointer to a block of memory containing one or more parameters with a fixed limit size, to be passed to the kernel module initialization function.</li> <li><code>flags</code>: <code>int</code> - a flag which used to control the operation of the module. It can be bitwise ORed of zero or more values.</li> </ul>"},{"location":"docs/events/builtin/syscalls/finit_module/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/finit_module/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/finit_module/#do_init_module","title":"do_init_module","text":""},{"location":"docs/events/builtin/syscalls/finit_module/#type","title":"Type","text":"<p>kprobe </p>"},{"location":"docs/events/builtin/syscalls/finit_module/#purpose","title":"Purpose","text":"<p>To allow userspace to request initialization of a module.</p>"},{"location":"docs/events/builtin/syscalls/finit_module/#finit_module_ret","title":"finit_module_ret","text":""},{"location":"docs/events/builtin/syscalls/finit_module/#type_1","title":"Type","text":"<p>kretprobe </p>"},{"location":"docs/events/builtin/syscalls/finit_module/#purpose_1","title":"Purpose","text":"<p>To allow system-calls tracing and further inspection of the module init process outcome.</p>"},{"location":"docs/events/builtin/syscalls/finit_module/#example-use-case","title":"Example Use Case","text":"<p>When debugging kernel modules, finit_module can be used to manually load and unload the module from userspace and allow the debugging process to continue. </p>"},{"location":"docs/events/builtin/syscalls/finit_module/#issues","title":"Issues","text":"<p>Currently, finit_module cannot be linked with other syscalls, as it does not return any useful data about its outcome or the status of the module.</p>"},{"location":"docs/events/builtin/syscalls/finit_module/#related-events","title":"Related Events","text":"<ul> <li>init_module </li> <li>delete_module</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/flistxattr/","title":"flistxattr","text":""},{"location":"docs/events/builtin/syscalls/flistxattr/#intro","title":"Intro","text":"<p>flistxattr - get a list of extented attributes of the file associated with a given file descriptor</p>"},{"location":"docs/events/builtin/syscalls/flistxattr/#description","title":"Description","text":"<p>The <code>flistxattr</code> system call is used to get the list of extended attribute names associated with a given file descriptor. It returns a buffer containing a list of the names of all of the extended attributes associated with the file, with each name separated by a null byte ('\\0'). The size of the buffer is specified in the argument <code>size</code>. If the size is not large enough, -1 is returned and <code>errno</code> is set to <code>ERANGE</code>.</p> <p>This system call is different from <code>listxattr</code> in the sense that instead of giving the path of the file in question, it receives its file descriptor, which means <code>flistxattr</code> only get the list of attributes of the exact file associated with the given descriptors, whereas <code>listxattr</code> can get the list of attributes of any file given its path.</p>"},{"location":"docs/events/builtin/syscalls/flistxattr/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - file descriptor of the target file, from which the extended attributes should be listed.</li> <li><code>list</code>:<code>char*</code>[U] - pointer to user-space memory, which will be filled with the list of extended attributes associated with <code>fd</code>.</li> <li><code>size</code>:<code>size_t</code>[K] - size of the <code>list</code> buffer. If not large enough to hold the list of all extended attributes associated with <code>fd</code>, the call fails with <code>error</code> set to <code>ERANGE</code>.</li> </ul>"},{"location":"docs/events/builtin/syscalls/flistxattr/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/flistxattr/#do_flistxattr","title":"do_flistxattr","text":""},{"location":"docs/events/builtin/syscalls/flistxattr/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/flistxattr/#purpose","title":"Purpose","text":"<p>Monitor and log calls to <code>flistxattr</code>, as well as their return values, for debugging and security purposes.</p>"},{"location":"docs/events/builtin/syscalls/flistxattr/#example-use-case","title":"Example Use Case","text":"<p>The <code>flistxattr</code> system call can be used as part of a larger application to get a list of all of the extended attributes associated with a file before attempting to access any of them. This can be especially useful for preventing potential Time-Of-Check To Time-Of-Use (TOCTOU) race conditions.</p>"},{"location":"docs/events/builtin/syscalls/flistxattr/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/flistxattr/#related-events","title":"Related Events","text":"<ul> <li><code>listxattr</code> - get the list of extended attributes associated with the file given the path</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/flock/","title":"flock","text":""},{"location":"docs/events/builtin/syscalls/flock/#intro","title":"Intro","text":"<p>flock - applies or removes an advisory lock on an open file</p>"},{"location":"docs/events/builtin/syscalls/flock/#description","title":"Description","text":"<p>The flock() system call applies or removes an advisory lock on an open file. A  lock is associated with an open file description (see open(2)). An open file  description locks a file against access by other open file descriptions. Locks  are established on a per open file description basis; these locks are unrelated to locks associated with the underlying inode.</p> <p>A call to flock() may block if an incompatible lock is held by another process. A nonblocking form of flock is defined in fcntl(2).</p>"},{"location":"docs/events/builtin/syscalls/flock/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>: <code>int</code>[K] - file descriptor of the file to lock/unlock</li> <li><code>operation</code>: <code>int</code>[K] - type of lock to perform (FLOCK_SH, FLOCK_EX, FLOCK_UN, etc)</li> </ul>"},{"location":"docs/events/builtin/syscalls/flock/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/flock/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/flock/#sys_flock","title":"sys_flock","text":""},{"location":"docs/events/builtin/syscalls/flock/#type","title":"Type","text":"<p>Kprobe + Kretprobe.</p>"},{"location":"docs/events/builtin/syscalls/flock/#purpose","title":"Purpose","text":"<p>Identify when processes are locking files.</p>"},{"location":"docs/events/builtin/syscalls/flock/#example-use-case","title":"Example Use Case","text":"<p>This event can be used to analyse how long it takes a process to get a lock,  and also uncover cases of deadlocks.</p>"},{"location":"docs/events/builtin/syscalls/flock/#issues","title":"Issues","text":"<p>Since this is an advisory lock, if a process tries to get a lock on a file  that another process already has a lock on, the second process will block until  the lock is released, but there is no guarantee that the first process won't  modify the file before the second process can acquire the lock.</p>"},{"location":"docs/events/builtin/syscalls/flock/#related-events","title":"Related Events","text":"<ul> <li>fcntl - interfers with asynchronous input and output operations, file descriptor flags, and lock types</li> <li>open - creates or opens a file or devices</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fork/","title":"fork","text":""},{"location":"docs/events/builtin/syscalls/fork/#intro","title":"Intro","text":"<p>fork - create a copy of the process in the same address space.</p>"},{"location":"docs/events/builtin/syscalls/fork/#description","title":"Description","text":"<p>The Linux <code>fork()</code> system call creates a new process by duplicating the calling process. The new process is referred to as the child process and the calling process is referred to as the parent process. The child process created from the fork() system call has a copy of the parent process's entire address space. Therefore, when the parent process makes changes to any of its memory, these changes are visible to the child process - unlike <code>execve()</code> which completely overlays the address space of the creating process with the contents of the specified executable.</p> <p>The <code>fork()</code> system call returns twice; once in the parent process and once in the child process. In the parent process, the <code>fork()</code> system call returns the process ID (PID) of the newly-created child process. In the child process, the <code>fork()</code> system call returns 0.</p> <p>The <code>fork()</code> system call is synchronous, meaning the parent process waits for the child process to complete before proceeding. This is necessary for the parent and child processes to establish communication with each other.</p> <p>There are some drawbacks to using the <code>fork()</code> system call. First, the parent process should not change any of its memory before the child process exists, otherwise the child will inherit these changes which could lead to undefined behavior. Secondly, the overhead of switching between processes may adversely affect the performance of the system. Finally, the Linux <code>fork()</code> system call is limited to a maximum of 32 processes.</p>"},{"location":"docs/events/builtin/syscalls/fork/#arguments","title":"Arguments","text":"<ul> <li><code>flags</code>:<code>int</code>[OPT] - Flags used to modify the behaviour of the <code>fork()</code> system call.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fork/#available-tags","title":"Available Tags","text":"<ol> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ol>"},{"location":"docs/events/builtin/syscalls/fork/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fork/#do_fork","title":"do_fork","text":""},{"location":"docs/events/builtin/syscalls/fork/#type","title":"Type","text":"<p>Tracepoint + Kprobe.</p>"},{"location":"docs/events/builtin/syscalls/fork/#purpose","title":"Purpose","text":"<p>For usage and profiling analysis.</p>"},{"location":"docs/events/builtin/syscalls/fork/#example-use-case","title":"Example Use Case","text":"<p>The <code>fork()</code> system call can be used to create a child process so that the parent process can execute a separate task in parallel and communicate with the child process to return a result. In this way, the parent process does not have to wait for the child process to complete before continuing execution.</p>"},{"location":"docs/events/builtin/syscalls/fork/#issues","title":"Issues","text":"<p>Linux imposes a hard limit of 32 process creations via fork.</p>"},{"location":"docs/events/builtin/syscalls/fork/#related-events","title":"Related Events","text":"<ul> <li><code>execve</code> - execute a program.</li> <li><code>clone</code> - create a child processes or threads.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fremovexattr/","title":"fremovexattr","text":""},{"location":"docs/events/builtin/syscalls/fremovexattr/#intro","title":"Intro","text":"<p>fremovexattr - an event that allows getting or removing an extended attribute associated with a file</p>"},{"location":"docs/events/builtin/syscalls/fremovexattr/#description","title":"Description","text":"<p>The fremovexattr event is used to remove an extended attribute associated with a file specified by the file descriptor. This event allows for the removal of an attribute from any filetype, including regular files and directories. This event does not traverse through directories in order to remove extended attributes from subdirectories. Additionally, this event can also be used to securely delete files as it allows for file data blocks to be marked as deleted in the filesystem, thus preventing their recovery.</p> <p>The fremovexattr event takes two parameters: the filedescriptor of the file for which the attribute is being removed (fd) and the name of the extended attribute (name). This event does not return any information to the user and will return an error if the attribute was not found or if the user does not have the correct priviledges.</p>"},{"location":"docs/events/builtin/syscalls/fremovexattr/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>: <code>int</code>[K] - A valid file descriptor of the file whose extended attribute should be removed.</li> <li><code>name</code>: <code>const char*</code>[K, U, TOCTOU] - Specifies the extended attribute to be removed.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fremovexattr/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/fremovexattr/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fremovexattr/#fremovexattr_1","title":"fremovexattr","text":""},{"location":"docs/events/builtin/syscalls/fremovexattr/#type","title":"Type","text":"<p>Tracepoint.</p>"},{"location":"docs/events/builtin/syscalls/fremovexattr/#purpose","title":"Purpose","text":"<p>Hook this function in order to detect the attempted removal of an extended attribute associated with a file.</p>"},{"location":"docs/events/builtin/syscalls/fremovexattr/#example-use-case","title":"Example Use Case","text":"<p>fremovexattr can be used to detect privilege escalation attempts, as an attacker might try to change the extended attributes of files in order to gain access to confidential data. This event can also be used to detect a malicious user attempting to delete a sensitive file.</p>"},{"location":"docs/events/builtin/syscalls/fremovexattr/#issues","title":"Issues","text":"<p>Because of the TOCTOU vulnerability of this event, if an attacker manages to access the same file descriptor before the event is called, it may be possible for the argument value to change in between the time of check and the time of use.</p>"},{"location":"docs/events/builtin/syscalls/fremovexattr/#related-events","title":"Related Events","text":"<ul> <li>fgetxattr</li> <li>fsetxattr</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fsconfig/","title":"fsconfig","text":""},{"location":"docs/events/builtin/syscalls/fsconfig/#intro","title":"Intro","text":"<p><code>fsconfig</code> - system call allowing to assign configurations to filesystem types</p>"},{"location":"docs/events/builtin/syscalls/fsconfig/#description","title":"Description","text":"<p>The <code>fsconfig</code> system call allows to assign configurations, expressed as a key-value pair, to the filesystem type (defined by the passed <code>fs_fd</code>). </p> <p>It is used as an extensible interface for programs and libraries to define, query and update configuration parameters. </p> <p>The same key might occur multiple times (path, then tag or namespace) so the <code>fsconfig</code> system call requires the passing of an auxiliary argument, the <code>aux</code> argument, to provide context.</p>"},{"location":"docs/events/builtin/syscalls/fsconfig/#arguments","title":"Arguments","text":"<ul> <li><code>fs_fd</code>:<code>int*</code> - Pointer to a file descriptor pointing to the filesystem.</li> <li><code>cmd</code>:<code>unsigned int</code> - Command requesting a specific operation. It should be one of the <code>FSCONFIG_CMD_*</code> definitions defined in the include/uapi/linux/fsconfig.h - include/uapi/linux/fsconfig.h.  </li> <li><code>key</code>:<code>const char*</code> - Null-terminated key string whose format depends on the specific FS and context. Its length must not exceed <code>FSCONFIG_MAX_NAME</code>.</li> <li><code>value</code>:<code>const void*</code> - Pointer to a memory area containing the value for the configuration. Its length must not exceed <code>FSCONFIG_MAX_VALUE</code>.</li> <li><code>aux</code>:<code>int</code> - Auxiliary data used to provide context for the configuration (path, tag or namespace). Its length must not exceed <code>FSCONFIG_MAX_AUX</code>.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fsconfig/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it).</li> </ul>"},{"location":"docs/events/builtin/syscalls/fsconfig/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fsconfig/#fsconfig_1","title":"fsconfig","text":""},{"location":"docs/events/builtin/syscalls/fsconfig/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/fsconfig/#purpose","title":"Purpose","text":"<p>To expose the data of the syscall request, the return code and the response value.</p>"},{"location":"docs/events/builtin/syscalls/fsconfig/#example-use-case","title":"Example Use Case","text":"<p>fsconfig can be used to query and set configuration parameters on a filesystem. One example is setting access control lists on a filesystem in order to provide additional security measures.</p>"},{"location":"docs/events/builtin/syscalls/fsconfig/#issues","title":"Issues","text":"<p>fsconfig is vulnerable to TOCTOU (Time of Check, Time of Use) attacks as its arguments are not checked on entry point and various events might have happened between the check and the use.</p>"},{"location":"docs/events/builtin/syscalls/fsconfig/#related-events","title":"Related Events","text":"<ul> <li>fstatfs: get filesystem status.</li> <li>fscache: query the configuration from the filesystem cache.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fsetxattr/","title":"fsetxattr","text":""},{"location":"docs/events/builtin/syscalls/fsetxattr/#intro","title":"Intro","text":"<p>fsetxattr - Set an extended attribute for a file</p>"},{"location":"docs/events/builtin/syscalls/fsetxattr/#description","title":"Description","text":"<p>The <code>fsetxattr()</code> system call sets an extended attribute for the given file system object relative to the open file descriptor <code>fd</code>. The open file descriptor <code>fd</code> is used to reference the object which should have the attribute set.</p> <p>The <code>flags</code> argument determines how the attribute is set. Attributes are creation, security, scalability and installation related informations.</p> <p>Advantages of using <code>fsetxattr()</code> is that it provides more control than <code>setxattr()</code>, which is an analogous system call, that is used to affect the objects inside a file system.</p>"},{"location":"docs/events/builtin/syscalls/fsetxattr/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - File descriptor. The file descriptor should reference a regular file.</li> <li><code>name</code>:<code>const char*</code>[K] - Name of the attribute.</li> <li><code>value</code>:<code>const void*</code>[K U] - Pointer to the supplied value. Its format is determined by the implementation.</li> <li><code>size</code>:<code>size_t</code>[K] - Size of the value referenced in the <code>value</code> argument.</li> <li><code>flags</code>:<code>int</code>[K] - Flags designating how the attribute should be set.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fsetxattr/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/fsetxattr/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fsetxattr/#do_fsetxattr","title":"do_fsetxattr","text":""},{"location":"docs/events/builtin/syscalls/fsetxattr/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/fsetxattr/#purpose","title":"Purpose","text":"<p>To monitor the execution of <code>fsetxattr()</code> system call.</p>"},{"location":"docs/events/builtin/syscalls/fsetxattr/#example-use-case","title":"Example Use Case","text":"<p>This event could be used to monitor the setting of custom attributes on files through the <code>fsetxattr()</code> system call. This is useful for implementing metadata management, security policies or system customization features.</p>"},{"location":"docs/events/builtin/syscalls/fsetxattr/#issues","title":"Issues","text":"<p>If the <code>flags</code> argument is not being checked, an attacker could set an extended attribute for a file that it shouldn't have access to.</p>"},{"location":"docs/events/builtin/syscalls/fsetxattr/#related-events","title":"Related Events","text":"<ul> <li><code>fgetxattr</code> - Get an extended attribute from a file</li> <li><code>setxattr</code> - Set an extended attribute to a file</li> <li><code>removexattr</code> - Remove an extended attribute from a file</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fsmount/","title":"fsmount","text":""},{"location":"docs/events/builtin/syscalls/fsmount/#intro","title":"Intro","text":"<p>fsmount - Mounts a filesystem from a file descriptor</p>"},{"location":"docs/events/builtin/syscalls/fsmount/#description","title":"Description","text":"<p>The <code>fsmount</code> syscall is used to mount a filesystem from a file descriptor. This syscall was added in Linux 3.3 and does not support old filesystem types such as FAT or msdos. The flags and ms_flags arguments can be used to modify the mount, such as enabling optional mount features or changing mount propagation options.</p>"},{"location":"docs/events/builtin/syscalls/fsmount/#arguments","title":"Arguments","text":"<ul> <li><code>fsfd</code>:<code>int</code> - File descriptor for the existing superblock of the filesystem.</li> <li><code>flags</code>:<code>unsigned int</code> - Flags to modify the mount behavior, as described in the <code>MS_*</code> macros in <code>&lt;sys/mount.h&gt;</code>. This value can be 0 to perform a plain mount.</li> <li><code>ms_flags</code>:<code>unsigned int</code> - Special flags to modify the mount behavior, as described in the <code>MS_*</code> macros in <code>&lt;sys/mount.h&gt;</code>. This value can be 0 to perform a plain mount.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fsmount/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/fsmount/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fsmount/#do_mount","title":"do_mount","text":""},{"location":"docs/events/builtin/syscalls/fsmount/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/fsmount/#purpose","title":"Purpose","text":"<p>Hooked to investigate the mount call, such as which filesystem is being mounted or what arguments are used.</p>"},{"location":"docs/events/builtin/syscalls/fsmount/#example-use-case","title":"Example Use Case","text":"<p>The <code>fsmount</code> syscall can be used when developing distributed file systems, such as Gluster, to mount a remote filesystem in the local system.</p>"},{"location":"docs/events/builtin/syscalls/fsmount/#issues","title":"Issues","text":"<p>There is no direct way to specify the mount point for the filesystem that is being mounted when using <code>fsmount</code>.</p>"},{"location":"docs/events/builtin/syscalls/fsmount/#related-events","title":"Related Events","text":"<ul> <li>do_mount - Used to indicate when the system is mounting a filesystem.</li> <li>execve - Used to initiate processes that will mount a filesystem, such as <code>/sbin/mount</code>.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fsopen/","title":"fsopen","text":""},{"location":"docs/events/builtin/syscalls/fsopen/#intro","title":"Intro","text":"<p>fsopen - opens an existing filesystem for use with an allocated file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/fsopen/#description","title":"Description","text":"<p>The fsopen system call opens an existing filesystem for use with an allocated file descriptor. The file descriptor will provide access to the filesystem, and may be used with other system calls such as fsread, fswrite, and fstat. The filesystem must be specified by its name, which is given in the argument fsname. A set of flags, given in the argument flags, can be used to modify the behaviour of the fsopen system call.</p> <p>There are several potential scenarios and edge-cases in using the fsopen system call. In particular, the system call is vulnerable to TOCTOU (time-of-check-time-of-use) attacks, where the file or filesystem may have been changed between the time it was checked for existence and the time the fsopen system call is actually made. Additionally, the flags argument may not be available in some cases, in which case the call will be invoked with a value of 0.</p>"},{"location":"docs/events/builtin/syscalls/fsopen/#arguments","title":"Arguments","text":"<ul> <li><code>fsname</code>:<code>const char*</code>[KU] - name of the filesystem that is to be opened.</li> <li><code>flags</code>:<code>unsigned int</code>[K] - flags that modify the behaviour of the open system call.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fsopen/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/fsopen/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fsopen/#do_fsopen","title":"do_fsopen","text":""},{"location":"docs/events/builtin/syscalls/fsopen/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/fsopen/#purpose","title":"Purpose","text":"<p>To trace entry point for fsopen system call.</p>"},{"location":"docs/events/builtin/syscalls/fsopen/#example-use-case","title":"Example Use Case","text":"<p>The fsopen system call can be used to open an existing filesystem for access and, with other system calls such as fsread, fswrite, and fstat, allow programs to interact with the filesystem. For example, a program may read and write to files on the filesystem.</p>"},{"location":"docs/events/builtin/syscalls/fsopen/#issues","title":"Issues","text":"<p>The fsopen system call is vulnerable to TOCTOU attacks, where the file or filesystem may have been changed between the time it was checked for existence and the time the fsopen system call is actually made. Additionally, the flags argument may not be available in some cases, in which case the call will be invoked with a value of 0.</p>"},{"location":"docs/events/builtin/syscalls/fsopen/#related-events","title":"Related Events","text":"<ul> <li>fsread</li> <li>fswrite</li> <li>fstat</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fspick/","title":"fspick","text":""},{"location":"docs/events/builtin/syscalls/fspick/#intro","title":"Intro","text":"<p>fspick - Select/open/unlink files in Linux systems.</p>"},{"location":"docs/events/builtin/syscalls/fspick/#description","title":"Description","text":"<p><code>fspick</code> is used to open/select or unlink files from the file system. It is usually used to verify if a particular file exists in a certain directory. The <code>flags</code> parameter can be used to control how to open the file and if it should be opened exclusively.</p> <p>The <code>pathname</code> is supplied either as an absolute path or relative to an open file pointer pointed by <code>dirfd</code>. The value can be obtained from one of the <code>open</code>/<code>creat</code> syscalls. Thus, if the <code>dirfd</code> parameter is set to <code>AT_FDCWD</code>, the <code>pathname</code> should be an absolute path.</p>"},{"location":"docs/events/builtin/syscalls/fspick/#arguments","title":"Arguments","text":"<ul> <li><code>dirfd</code>:<code>int</code>[K] - File descriptor to the directory from which <code>pathname</code> will be evaluated. If the value is set to <code>AT_FDCWD</code>, <code>pathname</code> should be an absolute path.</li> <li><code>pathname</code>:<code>const char*</code>[K] - The target filename or directory to open.</li> <li><code>flags</code>:<code>unsigned int</code>[K] - Flags defining whether or not the file should be opened in an exclusive mode, or just for reading and writing.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fspick/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/fspick/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fspick/#sys_fspick","title":"sys_fspick","text":""},{"location":"docs/events/builtin/syscalls/fspick/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/fspick/#purpose","title":"Purpose","text":"<p>Monitoring of incoming and outgoing calls to the <code>fspick</code> syscall.</p>"},{"location":"docs/events/builtin/syscalls/fspick/#example-use-case","title":"Example Use Case","text":"<p>Using the <code>fspick</code> syscall to verify if a particular file exists in a certain directory before attempting to open it.</p>"},{"location":"docs/events/builtin/syscalls/fspick/#issues","title":"Issues","text":"<p>None known.</p>"},{"location":"docs/events/builtin/syscalls/fspick/#related-events","title":"Related Events","text":"<p><code>open</code>, <code>access</code>, <code>stat</code>, <code>lstat</code>, <code>utimensat</code>.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fstat/","title":"fstat","text":""},{"location":"docs/events/builtin/syscalls/fstat/#intro","title":"Intro","text":"<p>fstat - get file status</p>"},{"location":"docs/events/builtin/syscalls/fstat/#description","title":"Description","text":"<p>The fstat() system call obtains information about an open file based upon the file descriptor fd argument. The information is stored in the stat buffer pointed to by statbuf\u2014which is of type struct stat, defined in . <p>One advantage of fstat() is that it does not require opening the file prior to obtaining information about it. This can be useful for supporting access control, logging file accesses, etc. It has some potential downfalls, including the fact that a file can be removed from the system by the time the fstat() function is executed, making it vulnerable to a Time of Check, Time of Use (TOCTOU) race condition attack.</p>"},{"location":"docs/events/builtin/syscalls/fstat/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - File descriptor provided when the file was opened.</li> <li><code>statbuf</code>:<code>struct stat*</code>[KU] - Pointer to a struct stat that will have the information about the file.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fstat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/fstat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fstat/#fsys_fstat","title":"fsys_fstat","text":""},{"location":"docs/events/builtin/syscalls/fstat/#type","title":"Type","text":"<p>kprobe + uprobe.</p>"},{"location":"docs/events/builtin/syscalls/fstat/#purpose","title":"Purpose","text":"<p>Hook the fstat() syscall entry point to get start latency and count how many times the syscall was called.</p>"},{"location":"docs/events/builtin/syscalls/fstat/#example-use-case","title":"Example Use Case","text":"<p>For example, an application may use fstat() to determine whether or not a file is a directory. This can be useful for implementing access control mechanisms or logging accesses to files.</p>"},{"location":"docs/events/builtin/syscalls/fstat/#issues","title":"Issues","text":"<p>Due to fstat() not requiring a file to be opened before calling the function, hense not locking it, it is vulnerable to TOCTOU race condition attacks.</p>"},{"location":"docs/events/builtin/syscalls/fstat/#related-events","title":"Related Events","text":"<p>close, open, stat.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fstat64/","title":"fstat64","text":""},{"location":"docs/events/builtin/syscalls/fstat64/#intro","title":"Intro","text":"<p>fstat64 - retrieves information about a specific file</p>"},{"location":"docs/events/builtin/syscalls/fstat64/#description","title":"Description","text":"<p>The fstat64() system call is used to retrieve information about a specific file, given a file descriptor. This information includes the file size, the time of last access, etc. The function copies the information into a structure of type stat64, which is then filled with the information about the file. The file descriptor is typically used to identify a previously opened file.</p> <p>The fstat64() system call is most notably used when a file is opened, in order to obtain information about it. However, it can also be used to check the existence of the file and to check the permissions associated with it.</p> <p>The fstat64() system call has some drawbacks. It can only operate on a previously opened file, so it is not applicable if no file descriptor is associated with the file. Furthermore, since it is a system call, it can be expensive in terms of performance, particularly when called on a regular basis.</p>"},{"location":"docs/events/builtin/syscalls/fstat64/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - File Descriptor. The file on which the system call is to operate on. </li> <li><code>statbuf</code>:<code>struct stat64*</code>[U] - Pointer to a struct stat64, which contains the information retrieved by the system call. </li> </ul>"},{"location":"docs/events/builtin/syscalls/fstat64/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/fstat64/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fstat64/#do_fstat64","title":"do_fstat64","text":""},{"location":"docs/events/builtin/syscalls/fstat64/#type","title":"Type","text":"<p>KProbe</p>"},{"location":"docs/events/builtin/syscalls/fstat64/#purpose","title":"Purpose","text":"<p>Hooked function for the fstat64 system call, used to get information about a specific file given a file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/fstat64/#example-use-case","title":"Example Use Case","text":"<p>The fstat64 system call can be used in cases when some basic information about a file is needed, such as its size, access time, or other similar info. For example, it could be used to implement a basic basename command which prints the basename, or file name, of a given file. In this case, fstat64 would be used to get information about the file, and then the basename could be extracted from that information.</p>"},{"location":"docs/events/builtin/syscalls/fstat64/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/fstat64/#related-events","title":"Related Events","text":"<ul> <li>open: opens or creates a file or directory</li> <li>stat: stat() is the generic system call for getting information about a file. It can use the same underlying system call as fstat64() but is not limited to files that are opened using a file descriptor.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fstatfs/","title":"fstatfs","text":""},{"location":"docs/events/builtin/syscalls/fstatfs/#intro","title":"Intro","text":"<p>fstatfs - retrieves information about a mounted file system</p>"},{"location":"docs/events/builtin/syscalls/fstatfs/#description","title":"Description","text":"<p><code>fstatfs()</code> is used to retrieve relevant information about a mounted file system. It returns information like the file system type, size, blocks, and block size. It is useful for getting information about drives and determining their capacity. The <code>fstatfs()</code> system call can be used to check for errors or malfunctioning disks.</p>"},{"location":"docs/events/builtin/syscalls/fstatfs/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>: <code>int</code> - A file descriptor associated with the mounted file system.</li> <li><code>buf</code>: <code>struct statfs*</code> - A pointer to a <code>struct statfs</code> object which will contain information about the mounted file system after the system call returns.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fstatfs/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/fstatfs/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fstatfs/#sys_fstatfs","title":"sys_fstatfs","text":""},{"location":"docs/events/builtin/syscalls/fstatfs/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/fstatfs/#purpose","title":"Purpose","text":"<p>To show when a filesystem is queried for information.</p>"},{"location":"docs/events/builtin/syscalls/fstatfs/#sys_statfs","title":"sys_statfs","text":""},{"location":"docs/events/builtin/syscalls/fstatfs/#type_1","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/fstatfs/#purpose_1","title":"Purpose","text":"<p>To show when a filesystem is queried for information.</p>"},{"location":"docs/events/builtin/syscalls/fstatfs/#example-use-case","title":"Example Use Case","text":"<p>The <code>fstatfs()</code> system call can be used to check for errors or malfunctioning disks. For example, there may be an application that regularly checks disk space and reports errors if a disk is malfunctioning or full. The <code>fstatfs()</code> system call can be used to get the disk size, detect any errors, and report any issue to the user.</p>"},{"location":"docs/events/builtin/syscalls/fstatfs/#issues","title":"Issues","text":"<p>There is no issue known with <code>fstatfs()</code>.</p>"},{"location":"docs/events/builtin/syscalls/fstatfs/#related-events","title":"Related Events","text":"<p><code>fstatfs64()</code>, <code>statfs()</code>, <code>statfs64()</code></p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fstatfs64/","title":"fstatfs64","text":""},{"location":"docs/events/builtin/syscalls/fstatfs64/#intro","title":"Intro","text":"<p>fstatfs64 - get information about a mounted file system</p>"},{"location":"docs/events/builtin/syscalls/fstatfs64/#description","title":"Description","text":"<p>The <code>fstatfs64()</code> system call is used to get file system statistics about a mounted file system. It is similar to the <code>statfs()</code> system call, but it uses a <code>struct statfs64</code> for the buffer argument. Since file systems can have large size values up to 8 bytes, this system call also allows for 8-byte aligned <code>struct statfs64</code> arguments.</p> <p>The <code>fstatfs64()</code> system call can be used to obtain information about mounted block devices or image files, and the returned information includes the mounted location, file system type, number of free blocks and free inodes, the block size, and the optimal transfer size.</p>"},{"location":"docs/events/builtin/syscalls/fstatfs64/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[U] - file descriptor of a mounted file system</li> <li><code>sz</code>:<code>size_t</code>[K] - size of the <code>struct statfs64</code> which stores the information about the given file system</li> <li><code>buf</code>:<code>struct statfs64*</code>[U TOCTOU] - pointer to an allocated <code>struct statfs64</code> where the file system information will be stored</li> </ul>"},{"location":"docs/events/builtin/syscalls/fstatfs64/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/fstatfs64/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fstatfs64/#sys_fstatfs64","title":"sys_fstatfs64","text":""},{"location":"docs/events/builtin/syscalls/fstatfs64/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/fstatfs64/#purpose","title":"Purpose","text":"<p>The purpose of the sys_fstatfs64 hooks is to monitor the use of this system call by user processes.</p>"},{"location":"docs/events/builtin/syscalls/fstatfs64/#mount_fs","title":"mount_fs","text":""},{"location":"docs/events/builtin/syscalls/fstatfs64/#type_1","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/fstatfs64/#purpose_1","title":"Purpose","text":"<p>The purpose of the mount_fs hook is to monitor when a filesystem is mounted or unmounted.</p>"},{"location":"docs/events/builtin/syscalls/fstatfs64/#example-use-case","title":"Example Use Case","text":"<p>Using the fstatfs64 system call it is possible to get information about all mounted file systems. This information can be used to generate reports about system state or can be used to compare different mounts for various reasons.</p>"},{"location":"docs/events/builtin/syscalls/fstatfs64/#issues","title":"Issues","text":"<p>Since fstatfs64 uses a time of check to time of use technique, that means that the information might become outdated during the process. When this system call is used, it is important to consider if this type of race condition can occur and how it affects the application logic.</p>"},{"location":"docs/events/builtin/syscalls/fstatfs64/#related-events","title":"Related Events","text":"<ul> <li>statfs - similar system call but uses a <code>struct statfs</code> argument instead.</li> <li>getdents64 - get directory entries in a directory</li> <li>open - open a file or directory</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/fsync/","title":"fsync","text":""},{"location":"docs/events/builtin/syscalls/fsync/#intro","title":"Intro","text":"<p>fsync - synchronizes a file's in-memory state with the physical storage device</p>"},{"location":"docs/events/builtin/syscalls/fsync/#description","title":"Description","text":"<p>The fsync function is a system call that is used to flush, or synchronize, the in-memory state of a file with the device containing the file. This is useful for ensuring that important data is not lost in the case of a system crash or  loss of power. The fsync call ensures that the contents of the file, as well  as associated data structures (such as the inode) are correctly written out to  the device before the call returns. It is also used when programs want to be  sure that their changes have been written back to the device.</p> <p>One of the drawbacks of using fsync is that it can be computationally expensive as it must ensure that all of the relevant data structures are correctly written out to the device.</p>"},{"location":"docs/events/builtin/syscalls/fsync/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - file descriptor of the file to be synchronized with the device.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fsync/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/fsync/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/fsync/#sys_fsync","title":"sys_fsync","text":""},{"location":"docs/events/builtin/syscalls/fsync/#type","title":"Type","text":"<p>kprobe + prof</p>"},{"location":"docs/events/builtin/syscalls/fsync/#purpose","title":"Purpose","text":"<p>To track the invocation of the fsync syscall and evaluate its impact on performance or system resources.</p>"},{"location":"docs/events/builtin/syscalls/fsync/#example-use-case","title":"Example Use Case","text":"<p>fsync could be used when a user wants to make sure that the changes they have made to a file have been written to the device before they do something else with the file.</p>"},{"location":"docs/events/builtin/syscalls/fsync/#issues","title":"Issues","text":"<p>Some systems can be vulnerable to a Resource Attack when fsync is used. This can occur if an attacker is able to send a large number of requests which trigger the fsync call.</p>"},{"location":"docs/events/builtin/syscalls/fsync/#related-events","title":"Related Events","text":"<ul> <li>open - used to open a file descriptor for use with fsync.</li> <li>close - used to close the file descriptor after the fsync call has been completed.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/ftime/","title":"ftime","text":""},{"location":"docs/events/builtin/syscalls/ftime/#intro","title":"Intro","text":"<p>ftime - Get and set the current system time</p>"},{"location":"docs/events/builtin/syscalls/ftime/#description","title":"Description","text":"<p>The ftime() function gets the current time of day, expressed in seconds and milliseconds since the Epoch (00:00:00 UTC, January 1, 1970). It has the following parameters:</p> <ul> <li><code>buf</code>:<code>struct timeb *</code>[K] - a pointer to a <code>struct timeb</code> which will be filled in with the current time and date.</li> <li><code>tz</code>:<code>struct timezone *</code>[K] - an optional pointer to a <code>struct timezone</code>, which if supplied, is filled in with information about the local timezone.</li> </ul> <p>For both of these parameters, passing <code>NULL</code> will simply indicate that you do not want to receive the corresponding information.</p> <p>Using ftime() is not recommended for obtaining the current date and time, as there are more accurate methods, but it is most commonly used for calculating the execution time of a program.</p>"},{"location":"docs/events/builtin/syscalls/ftime/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/ftime/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/ftime/#ftime_1","title":"ftime","text":""},{"location":"docs/events/builtin/syscalls/ftime/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/ftime/#purpose","title":"Purpose","text":"<p>To observe the execution of ftime and observe the arguments passed to it.</p>"},{"location":"docs/events/builtin/syscalls/ftime/#example-use-case","title":"Example Use Case","text":"<p>One use case for ftime would be to measure the time taken for a certain process or program to be completed. This can be done by obtaining the current time with ftime() before and after an operation, then subtracting the two to get the execution time.</p>"},{"location":"docs/events/builtin/syscalls/ftime/#issues","title":"Issues","text":"<p>The resolution of ftime() is limited at milliseconds, so it is not suitable for performance tuning operations for which higher accuracy is required.</p>"},{"location":"docs/events/builtin/syscalls/ftime/#related-events","title":"Related Events","text":"<p>clock_gettime</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/ftruncate/","title":"ftruncate","text":""},{"location":"docs/events/builtin/syscalls/ftruncate/#intro","title":"Intro","text":"<p>ftruncate - scan event that occurs when the function is called to truncate a file</p>"},{"location":"docs/events/builtin/syscalls/ftruncate/#description","title":"Description","text":"<p>The ftruncate() function truncates the file referenced by fd to the length specified by length. If the file previously was larger than length, the extra data is discarded. If the file previously was shorter, it is extended and the extended part reads as null bytes.</p> <p>The ftruncate() function can be used to resize just the size of the file, without altering its contents.</p>"},{"location":"docs/events/builtin/syscalls/ftruncate/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:int[K] - file descriptor for the file to be truncated </li> <li><code>length</code>:off_t[K] - desired length of the file</li> </ul>"},{"location":"docs/events/builtin/syscalls/ftruncate/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/ftruncate/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/ftruncate/#sys_ftruncate","title":"sys_ftruncate","text":""},{"location":"docs/events/builtin/syscalls/ftruncate/#type","title":"Type","text":"<p>kprobes</p>"},{"location":"docs/events/builtin/syscalls/ftruncate/#purpose","title":"Purpose","text":"<p>To measure the size of the file before and after the truncate.</p>"},{"location":"docs/events/builtin/syscalls/ftruncate/#example-use-case","title":"Example Use Case","text":"<p>ftruncate() can be used to truncate a log file after it has exceeded a certain size. </p>"},{"location":"docs/events/builtin/syscalls/ftruncate/#issues","title":"Issues","text":"<p>If the ftruncate operation fails, it returns -1 and sets errno.</p>"},{"location":"docs/events/builtin/syscalls/ftruncate/#related-events","title":"Related Events","text":"<ul> <li>fstat - to obtain information about file size prior to truncating </li> <li>open - to obtain a file descriptor for a given file </li> <li>write - to write to a file </li> <li>read - to reed from a file</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/ftruncate64/","title":"ftruncate64","text":""},{"location":"docs/events/builtin/syscalls/ftruncate64/#intro","title":"Intro","text":"<p>ftruncate64 - Truncate a file to a specified length, 64 bit version.</p>"},{"location":"docs/events/builtin/syscalls/ftruncate64/#description","title":"Description","text":"<p>ftruncate64() truncates the given file to a specified length. It should not be assumed that the file offset is maintained or set to zero after a call to ftruncate64().  The specified length can be larger or smaller than the current size of the file, with the latter case causing the file to be truncated. The new size of the file can be obtained using fstat64().</p> <p>Edge-cases or drawbacks appear mostly if the file is opened in append mode or the file size is greater than the size allowed in the filesystem.</p>"},{"location":"docs/events/builtin/syscalls/ftruncate64/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code> - File descriptor for the file to be truncated.</li> <li><code>length</code>:<code>off_t</code> - Desired length of the file, after truncation.</li> </ul>"},{"location":"docs/events/builtin/syscalls/ftruncate64/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/ftruncate64/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/ftruncate64/#sys_ftruncate64","title":"sys_ftruncate64","text":""},{"location":"docs/events/builtin/syscalls/ftruncate64/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/ftruncate64/#purpose","title":"Purpose","text":"<p>Observe the behavior of the ftruncate64 syscall.</p>"},{"location":"docs/events/builtin/syscalls/ftruncate64/#example-use-case","title":"Example Use Case","text":"<p>ftruncate64() could be used to improve performance of a program that reads and writes large chunks of data to the same file, when multiple threads are used for the task. When the thread reading from the file is finished, the file length can be reduced and the other thread will not need to process the extra data, as it will no longer be available.</p>"},{"location":"docs/events/builtin/syscalls/ftruncate64/#issues","title":"Issues","text":"<p>If the file is opened in append mode, it can lead to unexpected results.</p>"},{"location":"docs/events/builtin/syscalls/ftruncate64/#related-events","title":"Related Events","text":"<ul> <li>ftruncate() - The same functionality without the 64-bit length support.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/futex/","title":"Futex","text":""},{"location":"docs/events/builtin/syscalls/futex/#intro","title":"Intro","text":"<p>Futex - a syscall to facilitate fast user-space locking.</p>"},{"location":"docs/events/builtin/syscalls/futex/#description","title":"Description","text":"<p>The <code>futex()</code> system call provides a method for a program to wait until a certain condition becomes true, or to signal that a certain condition has become true. The program specifies a pointer to the memory address (<code>uaddr</code>) in which it saves the condition, a value (<code>val</code>) which indicates the condition, and a timeout (<code>timeout</code>) after which the wait returns automatically. Additionally, a set of operations (<code>futex_op</code>) can be specified which act on the condition represented by <code>uaddr</code>.</p> <p>The <code>futex()</code> system call is useful for coordinating access to shared data structures between multiple processes, as the operations it provides can be used to create simple mutexes. It is typically used by higher-level libraries like POSIX Threads, which allows for the use of <code>pthread_mutex_lock()</code> and related functions to control access to shared memory.</p>"},{"location":"docs/events/builtin/syscalls/futex/#arguments","title":"Arguments","text":"<ul> <li><code>uaddr</code>:<code>int*</code>[K, TOCTOU] - A pointer to the memory address in which the caller saves the condition. If a valid pointer is passed, the system call will inspect and modify the value this pointer points to.</li> <li><code>futex_op</code>:<code>int</code>[K] - A set of flags which control the operation that should be performed on the wait queue.</li> <li><code>val</code>:<code>int</code>[K] - An integral value which represents the condition. This will be compared to the value pointed to by <code>uaddr</code> on each operation.</li> <li><code>timeout</code>: <code>const struct timespec*</code>[K] - A pointer to a <code>struct timespec</code> that indicates the timeout after which the wait returns automatically. If the pointer passed is a NULL pointer, the wait does not time out. </li> <li><code>uaddr2</code>:<code>int*</code>[K, TOCTOU] - A pointer to a second memory address with a second condition.</li> <li><code>val3</code>:<code>int</code>[K] - The second condition value. This will be compared to the value pointed to by  <code>uaddr2</code> on each operation.</li> </ul>"},{"location":"docs/events/builtin/syscalls/futex/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/futex/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/futex/#sys_futex","title":"sys_futex","text":""},{"location":"docs/events/builtin/syscalls/futex/#type","title":"Type","text":"<p>Kprobes + Jprobes</p>"},{"location":"docs/events/builtin/syscalls/futex/#purpose","title":"Purpose","text":"<p>To allow deeper analysis of the system call, including arguments and its return value.</p>"},{"location":"docs/events/builtin/syscalls/futex/#example-use-case","title":"Example Use Case","text":"<p>The <code>futex()</code> system call is used to create simple user-space locks that can be used to coordinate access to shared resources in a multi-process environment.</p>"},{"location":"docs/events/builtin/syscalls/futex/#issues","title":"Issues","text":"<ul> <li>The values of both <code>uaddr</code> and <code>uaddr2</code> arguments are vulnerable to TOCTOU attacks, which may allow an attacker to bypass the lock and gain access to a shared resource.</li> <li>If the timeout is set too short, requests might not be able to complete in time and the application might deadlock.</li> </ul>"},{"location":"docs/events/builtin/syscalls/futex/#related-events","title":"Related Events","text":"<p><code>futex_wait</code>, <code>futex_wake</code>, <code>futextime64</code>, <code>futextime64_wait</code>, <code>futex_wake_op</code>, <code>futex_wake_op_pi</code>, <code>futex_lock_pi</code>, <code>futex_unlock_pi</code></p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/futex_time32/","title":"futex_time32","text":""},{"location":"docs/events/builtin/syscalls/futex_time32/#intro","title":"Intro","text":"<p>futex_time32 - wait on/fetch a word from user-space and potentially wait for a timeout</p>"},{"location":"docs/events/builtin/syscalls/futex_time32/#description","title":"Description","text":"<p>The <code>futex_time32</code> system call provides the ability to wait on a given word in user-space memory, potentially with a timeout. It allows the caller to specify an absolute timeout or a relative timeout with <code>CLOCK_MONOTONIC</code>. The return value contains information about the current value of the word at the address and whether a timeout was specified and/or was triggered.</p> <p>The <code>futex_time32</code> system call is atomic and requires no extra synchronization mechanisms. In addition, it supports operations like <code>FUTEX_WAIT</code> and <code>FUTEX_WAKE</code> using a single call, which can be useful in certain situations. However, the system call is vulnerable to the TOCTOU (Time of Check, Time of Use) race condition, as the user-space memory address is checked prior to being acted upon.</p>"},{"location":"docs/events/builtin/syscalls/futex_time32/#arguments","title":"Arguments","text":"<ul> <li><code>uaddr</code>:<code>u32*</code>[KU] - pointer to a user-space word variable.</li> <li><code>op</code>:<code>int</code>[K] - operation to perform, one of the FUTEX_* constants listed in <code>&lt;linux/futex.h&gt;</code>.</li> <li><code>val</code>:<code>u32</code>[K] - operation-dependent value.</li> <li><code>utime</code>:<code>struct old_timespec32</code>[K] - timeout value in milliseconds or CLOCK_MONOTONIC based absolute value.</li> <li><code>uaddr2</code>:<code>u32*</code>[KU OPT] - second user-space word variable if two FUTEX_* operations need to be performed atomically.</li> <li><code>val3</code>:<code>u32</code>[K OPT] - second operaion-dependent value.</li> </ul>"},{"location":"docs/events/builtin/syscalls/futex_time32/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/futex_time32/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/futex_time32/#futex_wait_setup","title":"futex_wait_setup","text":""},{"location":"docs/events/builtin/syscalls/futex_time32/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/futex_time32/#purpose","title":"Purpose","text":"<p>Called before a FUTEX_WAIT system call is processed, which allows tracing of the arguments and the variable before the system call is executed.</p>"},{"location":"docs/events/builtin/syscalls/futex_time32/#example-use-case","title":"Example Use Case","text":"<p>A multithreaded application might use <code>futex_time32</code> to synchronize between threads, performing an operation in an atomic manner and waiting on a condition with the possibility of a timeout.</p>"},{"location":"docs/events/builtin/syscalls/futex_time32/#issues","title":"Issues","text":"<p>The <code>futex_time32</code> system call is vulnerable to the TOCTOU (Time of Check, Time of Use) race condition, as the user-space memory address is checked prior to being acted upon.</p>"},{"location":"docs/events/builtin/syscalls/futex_time32/#related-events","title":"Related Events","text":"<p>The <code>futex_time32</code> system call is related to other futex system calls like <code>futex_wait</code> and <code>futex_wake</code>. In addition, it is related to futex-related events such as <code>futex_lock_contended</code> and <code>futex_lock_released</code>.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/futimesat/","title":"futimesat","text":""},{"location":"docs/events/builtin/syscalls/futimesat/#intro","title":"Intro","text":"<p>futimesat - sets file access and modification times of a given file</p>"},{"location":"docs/events/builtin/syscalls/futimesat/#description","title":"Description","text":"<p>The futimesat() system call is used to set the access and modification times of the file that is referenced by the dirfd argument, or the file at pathname relative to the current working directory, if dirfd is the specially defined value AT_FDCWD. The times argument points to a struct timeval type that contains the new time, in the form of seconds and microseconds, to be set. </p> <p>The futimesat() system call has a few advantages over its counterpart utimes() which is limited to modifying the time of a file pathname provided by its argument, as opposted to a file descriptor. Additionally, this system call can provide better performance than others if the file descriptor is already known. </p>"},{"location":"docs/events/builtin/syscalls/futimesat/#arguments","title":"Arguments","text":"<ul> <li><code>dirfd</code>:<code>int</code>[K] - file descriptor that points to the directory containing the target file for the futimesat() system call.</li> <li><code>pathname</code>:<code>const char*</code>[K] - string that contains the relative path from the directory specified by dirfd to the target file for the futimesat() system call.</li> <li><code>times</code>:<code>struct timeval*</code>[K] - pointer to the struct timeval type that stores two time specifiers, each consisting of seconds and microseconds, to be set as the new access and modification times of the target file.</li> </ul>"},{"location":"docs/events/builtin/syscalls/futimesat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/futimesat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/futimesat/#sys_futimesat","title":"sys_futimesat","text":""},{"location":"docs/events/builtin/syscalls/futimesat/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/futimesat/#purpose","title":"Purpose","text":"<p>Hooked to capture detailed information about the system call argumetns used, like the file descriptor and relative path.</p>"},{"location":"docs/events/builtin/syscalls/futimesat/#example-use-case","title":"Example Use Case","text":"<p>An example use case of futimesat() could include an application that keeps track of activity associated with a certain file, such as when it was last modified. This system call can be used to update the time of the file so that the application can have accurate data. </p>"},{"location":"docs/events/builtin/syscalls/futimesat/#issues","title":"Issues","text":"<p>The futimesat() system call is not available in some older versions of Linux, or in their respective glibc libraries, and has been replaced by the <code>utimensat</code> system call. </p>"},{"location":"docs/events/builtin/syscalls/futimesat/#related-events","title":"Related Events","text":"<ul> <li>utimes() - similar system call for setting access and modification times for only pathname specified by user.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/get_kernel_syms/","title":"get_kernel_syms","text":""},{"location":"docs/events/builtin/syscalls/get_kernel_syms/#intro","title":"Intro","text":"<p>get_kernel_syms - export the symbol table of the kernel for use by other programs.</p>"},{"location":"docs/events/builtin/syscalls/get_kernel_syms/#description","title":"Description","text":"<p>The get_kernel_syms system call declares, to a calling user program, the current set of symbols exported by the running Linux kernel. This system call is not often used, as most of its work has been supplanted by /proc/kallsyms, /boot/System.map and other interfaces that enable applications to easily reach the symbols they need.</p>"},{"location":"docs/events/builtin/syscalls/get_kernel_syms/#arguments","title":"Arguments","text":"<ul> <li><code>symtab</code>:<code>struct kernel_symbol *</code>[K] - a pointer to a structure containing an array of symbol information.</li> <li><code>strtab</code>:<code>char *</code>[K] - a pointer to a string table corresponding to the symbols in the array.</li> <li><code>_syscalls</code>:<code>struct sysent *</code>[K] - a pointer to a table of system call descriptions.</li> </ul>"},{"location":"docs/events/builtin/syscalls/get_kernel_syms/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/get_kernel_syms/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/get_kernel_syms/#sys_get_kernel_syms","title":"sys_get_kernel_syms","text":""},{"location":"docs/events/builtin/syscalls/get_kernel_syms/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/get_kernel_syms/#purpose","title":"Purpose","text":"<p>To introduce a hook for the purpose of tracing the get_kernel_syms system call.</p>"},{"location":"docs/events/builtin/syscalls/get_kernel_syms/#example-use-case","title":"Example Use Case","text":"<p>The get_kernel_syms syscall can be used by an application to obtain symbol information from the kernel. The returned symbols can be used to better understand the behavior of the kernel, or for further debugging purposes.</p>"},{"location":"docs/events/builtin/syscalls/get_kernel_syms/#issues","title":"Issues","text":"<p>This system call may be subject to TOCTOU (Time Of Check, Time Of Use) attacks, as the symbol table and string table return by the system call may change during the use of the call.</p>"},{"location":"docs/events/builtin/syscalls/get_kernel_syms/#related-events","title":"Related Events","text":"<ul> <li>kprobed/sys_get_kernel_syms - this event is used to trace the get_kernel_syms system call.</li> <li>sys_set_kernel_syms - this system call is used to modify the symbol table and string table of the kernel.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/get_mempolicy/","title":"get_mempolicy","text":""},{"location":"docs/events/builtin/syscalls/get_mempolicy/#intro","title":"Intro","text":"<p>get_mempolicy - retrieve the current process memory placement policy</p>"},{"location":"docs/events/builtin/syscalls/get_mempolicy/#description","title":"Description","text":"<p>The get_mempolicy system call retrieves the current process memory placement policy. It can be used to find out if the process is in a specific NUMA (non-uniform memory access) node and to retrieve the preferred node or list of allowed nodes to allocate memory. The function reads the effective process memory placement policy and not necessarily the configurable policy. It can be used to set up a process-wide policy via a call to mbind.</p> <p>The <code>mode</code> argument can be either MPOL_F_NODE (retrieve a list of nodes) or MPOL_F_ADDR (retrieve a single node). If <code>mode</code> is set to MPOL_F_NODE and <code>maxnode</code> is greater than zero, the first <code>maxnode</code> numbers of the node set of <code>nodemask</code> will be copied to the policy. Note that no optional MPOL_F_MEMS_ALLOWED flag is supported by this call.</p> <p>The <code>addr</code> argument can be used when <code>mode</code> is set to MPOL_F_ADDR, which will report the local node on which the memory address resides.</p>"},{"location":"docs/events/builtin/syscalls/get_mempolicy/#arguments","title":"Arguments","text":"<ul> <li><code>mode</code>: <code>int*</code>[K] - set to MPOL_F_NODE to copy a set of nodes and MPOL_F_ADDR to get a specific node for the address.</li> <li><code>nodemask</code>: <code>unsigned long*</code>[KU] - pointer to a node bitmask, from which a node set is returned.</li> <li><code>maxnode</code>: <code>unsigned long</code>[K] - maximum number of nodes to return. Must be non-zero if <code>mode</code> is set to MPOL_F_NODE.</li> <li><code>addr</code>: <code>void*</code>[KU] - pointer to an address in virtual memory. Must be set if and only if <code>mode</code> is set to MPOL_F_ADDR.</li> <li><code>flags</code>: <code>unsigned long</code>[K] - flags to control the system call behavior.</li> </ul>"},{"location":"docs/events/builtin/syscalls/get_mempolicy/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/get_mempolicy/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/get_mempolicy/#sys_get_mempolicy","title":"sys_get_mempolicy","text":""},{"location":"docs/events/builtin/syscalls/get_mempolicy/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/get_mempolicy/#purpose","title":"Purpose","text":"<p>To collect information about changes in the current process memory placement policy.</p>"},{"location":"docs/events/builtin/syscalls/get_mempolicy/#example-use-case","title":"Example Use Case","text":"<p>If a process is spawned from a parent process, it can be useful to check the memory placement policy of the given process. The get_mempolicy syscall can be used to check if a process is in a specific NUMA node, and to retrieve the preferred node or list of allowed nodes to allocate memory.</p>"},{"location":"docs/events/builtin/syscalls/get_mempolicy/#issues","title":"Issues","text":"<p>No MPOL_F_MEMS_ALLOWED flag is supported by this call.</p>"},{"location":"docs/events/builtin/syscalls/get_mempolicy/#related-events","title":"Related Events","text":"<ul> <li>mbind - set the memory policy for a region of memory</li> <li>set_mempolicy - change the current process memory placement policy</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/get_robust_list/","title":"get_robust_list","text":""},{"location":"docs/events/builtin/syscalls/get_robust_list/#intro","title":"Intro","text":"<p>get_robust_list - get the list of robust futexes owned by the current task</p>"},{"location":"docs/events/builtin/syscalls/get_robust_list/#description","title":"Description","text":"<p>The get_robust_list() system call gets the robust futex list owned by the task pointed to by its first argument. In addition, it stores a length of the list into the memory pointed to by the second argument.</p> <p>The robust futex list is a collection of robust futexes which have the FUTEX_WAITERS flag set. Such futexes are owned by the task, and can be used in conjunction with the FUTEX_WAIT and FUTEX_WAKE system calls to provide synchronization between threads.</p> <p>Robust futexes also ensure that all threads waiting for a given futex receive all the wake-up calls belonging to the futex, even if the owner of the futex dies (e.g. due to a kernel panic).</p>"},{"location":"docs/events/builtin/syscalls/get_robust_list/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>int</code>[U] - define the task structure for the process for which the robust list is to be retrieved.</li> <li><code>head_ptr</code>:<code>struct robust_list_head**</code>[U] - location of the head of the returned list.</li> <li><code>len_ptr</code>:<code>size_t*</code>[U] - location of a size_t containing the length of the returned list, in bytes.</li> </ul>"},{"location":"docs/events/builtin/syscalls/get_robust_list/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/get_robust_list/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/get_robust_list/#sys_get_robust_list","title":"SyS_get_robust_list","text":""},{"location":"docs/events/builtin/syscalls/get_robust_list/#type","title":"Type","text":"<p>Kprobes + Tracepoints</p>"},{"location":"docs/events/builtin/syscalls/get_robust_list/#purpose","title":"Purpose","text":"<p>To monitor the usage of the get_robust_list system call.</p>"},{"location":"docs/events/builtin/syscalls/get_robust_list/#example-use-case","title":"Example Use Case","text":"<p>The get_robust_list system call can be used to synchronizing events between threads in a multithreaded application.</p>"},{"location":"docs/events/builtin/syscalls/get_robust_list/#issues","title":"Issues","text":"<p>This system call is not available on all Linux system and is not available on some architectures.</p>"},{"location":"docs/events/builtin/syscalls/get_robust_list/#related-events","title":"Related Events","text":"<p>FUTEX_WAIT, FUTEX_WAKE, robust_list_del, set_robust_list</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/get_thread_area/","title":"get_thread_area","text":""},{"location":"docs/events/builtin/syscalls/get_thread_area/#intro","title":"Intro","text":"<p>get_thread_area - Retrieves the thread-local storage (TLS) area for the current process</p>"},{"location":"docs/events/builtin/syscalls/get_thread_area/#description","title":"Description","text":"<p>The get_thread_area() system call retrieves the thread-local storage (TLS) area for the current process. It is used during the initialization of a thread to find the address of the thread's TLS segment. The TLS area consists of one or more segments, each of which contains zero or more thread-specific copies of TLS variables, with each variable in turn having a specific data type. This system call is only available in the x86 architecture.</p> <p>This call is typically used with the user_desc structure, which is used by the set_thread_area() system call to set a thread's TLS.</p>"},{"location":"docs/events/builtin/syscalls/get_thread_area/#arguments","title":"Arguments","text":"<ul> <li><code>u_info</code>:<code>struct user_desc*</code>[U] - Pointer to a user_desc structure that will contain the thread's TLS information.</li> </ul>"},{"location":"docs/events/builtin/syscalls/get_thread_area/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/get_thread_area/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/get_thread_area/#sys_get_thread_area","title":"sys_get_thread_area","text":""},{"location":"docs/events/builtin/syscalls/get_thread_area/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/get_thread_area/#purpose","title":"Purpose","text":"<p>Hooked to check when and how this syscall is used.</p>"},{"location":"docs/events/builtin/syscalls/get_thread_area/#example-use-case","title":"Example Use Case","text":"<p>The get_thread_area() system call is used to retrieve the thread-local storage (TLS) area for the current process. This can be used in conjunction with the set_thread_area() system call to configure the thread's TLS.</p>"},{"location":"docs/events/builtin/syscalls/get_thread_area/#issues","title":"Issues","text":"<p>N/A</p>"},{"location":"docs/events/builtin/syscalls/get_thread_area/#related-events","title":"Related Events","text":"<ul> <li>set_thread_area() - Used to set the TLS area for the current thread.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getcpu/","title":"getcpu","text":""},{"location":"docs/events/builtin/syscalls/getcpu/#intro","title":"Intro","text":"<p>getcpu - Find the current processors system call.</p>"},{"location":"docs/events/builtin/syscalls/getcpu/#description","title":"Description","text":"<p>The getcpu() system call returns both the CPU and NUMA node on which the calling thread is currently executing as well as an abstract \u2018cache\u2019 (whose contents are only of use and meaning to the kernel) into two user-space arguments. This allows applications to, for instance, optimize data locality; i.e. determine if the data the thread is presently operating on is allocated in a way that the thread can maximize cache hits given its current CPU and node.</p> <p>There are no edge-cases, drawbacks or advantages of using getcpu() as compared to other system calls as its purpose is simply to report the current processor and NUMA node for the calling thread of execution and nothing else.</p>"},{"location":"docs/events/builtin/syscalls/getcpu/#arguments","title":"Arguments","text":"<ul> <li><code>cpu</code>:<code>unsigned int*</code>[KU] - pointer to an integer into which the CPU number will be written. If a null value is passed, no CPU number is returned.</li> <li><code>node</code>:<code>unsigned int*</code>[KU] - pointer to an integer into which the NUMA node number will be written. If a null value is passed, no NUMA node number is returned.</li> <li><code>tcache</code>:<code>struct getcpu_cache*</code>[KU] - pointer to a getcpu cache structure. If a null value is passed, no getcpu cache structure is returned.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getcpu/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/getcpu/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getcpu/#sys_getcpu","title":"sys_getcpu()","text":""},{"location":"docs/events/builtin/syscalls/getcpu/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/getcpu/#purpose","title":"Purpose","text":"<p>To track the usage of the getcpu() syscall and log any data that might be relevant to the developers.</p>"},{"location":"docs/events/builtin/syscalls/getcpu/#example-use-case","title":"Example Use Case","text":"<p>The getcpu() system call can be used in applications to optimize data locality, i.e. determine if the data the thread is presently operating on is allocated in a way that the thread can maximize cache hits given its current CPU and node. This can be especially useful for applications that are running on large systems with multiple processors and NUMA nodes.</p>"},{"location":"docs/events/builtin/syscalls/getcpu/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/getcpu/#related-events","title":"Related Events","text":"<ul> <li>sched_migrate_task() - Used to migrate a task between different CPUs or NUMA nodes. </li> <li>sched_setaffinity() - Used to set an affinity mask for a process or thread.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getcwd/","title":"getcwd","text":""},{"location":"docs/events/builtin/syscalls/getcwd/#intro","title":"Intro","text":"<p>getcwd - returns the working directory path of the current process</p>"},{"location":"docs/events/builtin/syscalls/getcwd/#description","title":"Description","text":"<p>The getcwd() function uses the buf parameter to store the path of the current working directory of the process. The buf argument should point to a user allocated buffer of sufficient size (specified by the size argument) that can hold the absolute pathname of the working directory. If the size argument is greater than zero, the path string will be null-terminated. If size is 0, then buf must be a null pointer. If size is greater than zero and buf is NULL, error occurs.</p> <p>getcwd() returns a pointer to the user allocated buffer which stores the pathname of the working directory upon success. If there are issues relating to the size parameter being insufficient (too small) then the error \"ERANGE\" is returned.</p>"},{"location":"docs/events/builtin/syscalls/getcwd/#arguments","title":"Arguments","text":"<ul> <li><code>buf</code>:<code>char*</code>[U] - <code>buf</code> should point to a user allocated buffer of sufficient size to hold the absolute pathname of the working directory.</li> <li><code>size</code>:<code>size_t</code>[U] - specifies the size of the user allocated buffer.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getcwd/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/getcwd/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getcwd/#do_getcwd","title":"do_getcwd","text":""},{"location":"docs/events/builtin/syscalls/getcwd/#type","title":"Type","text":"<p>Tracepoint</p>"},{"location":"docs/events/builtin/syscalls/getcwd/#purpose","title":"Purpose","text":"<p>To track the getcwd syscall.</p>"},{"location":"docs/events/builtin/syscalls/getcwd/#example-use-case","title":"Example Use Case","text":"<p>An example use case for getcwd is to use it to obtain the working directory of a process so it can be compared with a parent directory to validate that the process is in the correct directory.</p>"},{"location":"docs/events/builtin/syscalls/getcwd/#issues","title":"Issues","text":"<p>The errors returned by getcwd() are non-standard, so they may not be comparable across different systems.</p>"},{"location":"docs/events/builtin/syscalls/getcwd/#related-events","title":"Related Events","text":"<p>The readlink() and realpath() syscalls may be used in conjunction with getcwd() to normalize given paths.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getdents/","title":"<code>getdents</code>","text":""},{"location":"docs/events/builtin/syscalls/getdents/#intro","title":"Intro","text":"<p><code>getdents</code> - Reads directory entries from a file descriptor</p>"},{"location":"docs/events/builtin/syscalls/getdents/#description","title":"Description","text":"<p><code>getdents()</code> system call is used to read directory entries from an open file descriptor into a buffer. The entries are returned one after the other, and the entries contain information, such as the inode number, offset and type, of the entry. It is used by programs to read and parse directories in the filesystem. </p> <p>One of the advantages of using <code>getdents()</code> is that it is an efficient way to read directory entries without requiring the overhead of <code>opendir()</code> and <code>readdir()</code> system calls required for looking up a particular directory entry. On the other hand, one of the drawbacks is that <code>getdents()</code> does not guarantee that the file descriptor provided is a directory.</p>"},{"location":"docs/events/builtin/syscalls/getdents/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>: <code>int</code> - File descriptor from which to read the entries.</li> <li><code>dirp</code>: <code>struct linux_dirent*</code> - Pointer to buffer of size <code>count</code> for the results.</li> <li><code>count</code>: <code>unsigned int</code> - Number of bytes of data that can be stored in <code>dirp</code>.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getdents/#available-tags","title":"Available Tags","text":"<p>N/A</p>"},{"location":"docs/events/builtin/syscalls/getdents/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getdents/#sys_getdents","title":"<code>sys_getdents</code>","text":""},{"location":"docs/events/builtin/syscalls/getdents/#type","title":"Type","text":"<p>Tracepoint</p>"},{"location":"docs/events/builtin/syscalls/getdents/#purpose","title":"Purpose","text":"<p>To trace directory entries read from a file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/getdents/#example-use-case","title":"Example Use Case","text":"<p>This event can be used to trace files and directories read by a process. This can be used to aid debugging as you can easily trace a program\u2019s file access operations to find out if it is reading unexpected files or directories.</p>"},{"location":"docs/events/builtin/syscalls/getdents/#issues","title":"Issues","text":"<p>The <code>count</code> argument must be large enough to accommodate the data returned. Due to a kernel limitation, the maximum size of one <code>struct linux_dirent</code> is <code>2044</code> bytes. If the <code>count</code> argument is smaller than that, the syscall can read more data than the <code>count</code> argument allows, potentially leading to a buffer overflow.</p>"},{"location":"docs/events/builtin/syscalls/getdents/#related-events","title":"Related Events","text":"<ul> <li><code>open()</code> - Reads directory entries from a file descriptor. </li> <li><code>readdir()</code> - Reads directory entries.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getdents64/","title":"getdents64","text":""},{"location":"docs/events/builtin/syscalls/getdents64/#intro","title":"Intro","text":"<p>getdents64 - get directory entries from a file descriptor</p>"},{"location":"docs/events/builtin/syscalls/getdents64/#description","title":"Description","text":"<p>The getdents64() system call is used to read the contents of an open directory  into a buffer. It gives the caller access to an array of the directory entries  each containing information about a single file or subdirectory. This system  call is often used in conjunction with opendir() to allow an application to  walk a directory tree structure. </p> <p>One drawback of getdents64 is that data it returns is big-endian, while  some architectures are little-endian. This can be circumvented by using the  non-standard readdir64() function, which returns data in little-endian format. </p>"},{"location":"docs/events/builtin/syscalls/getdents64/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>unsigned int</code>[K] - file descriptor of an open directory.</li> <li><code>dirp</code>:<code>struct linux_dirent64*</code>[KU] - pointer to  a buffer where the results are written.</li> <li><code>count</code>:<code>unsigned int</code>[K] - size of the buffer pointed by dirp.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getdents64/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/getdents64/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getdents64/#sys_getdents64","title":"SYS_getdents64","text":""},{"location":"docs/events/builtin/syscalls/getdents64/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/getdents64/#purpose","title":"Purpose","text":"<p>Produce extra information about the file and directory entries read from the directory.</p>"},{"location":"docs/events/builtin/syscalls/getdents64/#example-use-case","title":"Example Use Case","text":"<p>The getdents64 system call can be used, for example, to list the files and  sub-directories inside a given directory, in order to search for a specific  file.</p>"},{"location":"docs/events/builtin/syscalls/getdents64/#issues","title":"Issues","text":"<p>Due to the way getdents64 is implemented, it can not be used as a generic  directory iteration mechanism, since it is affected by the directory structure, which can vary across filesystems.</p>"},{"location":"docs/events/builtin/syscalls/getdents64/#related-events","title":"Related Events","text":"<p>The related events to getdents64 are open(), close(), readdir64(),  write_dirent64() and unlink().</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getegid/","title":"getegid","text":""},{"location":"docs/events/builtin/syscalls/getegid/#intro","title":"Intro","text":"<p>getegid - get process effective group ID</p>"},{"location":"docs/events/builtin/syscalls/getegid/#description","title":"Description","text":"<p>The getegid() system call returns the effective group ID of the calling process. This is the group ID that the kernel uses when checking group permissions for the calling process. </p>"},{"location":"docs/events/builtin/syscalls/getegid/#arguments","title":"Arguments","text":"<p>This syscall does not accept any arguments.</p>"},{"location":"docs/events/builtin/syscalls/getegid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getegid/#getegid_1","title":"getegid","text":""},{"location":"docs/events/builtin/syscalls/getegid/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/getegid/#purpose","title":"Purpose","text":"<p>This function is hooked to collect data on process effective group ID </p>"},{"location":"docs/events/builtin/syscalls/getegid/#example-use-case","title":"Example Use Case","text":"<p>getegid() is useful in multi-user systems to ensure that every user has the correct set of resource access permissions.</p>"},{"location":"docs/events/builtin/syscalls/getegid/#issues","title":"Issues","text":"<p>None</p>"},{"location":"docs/events/builtin/syscalls/getegid/#related-events","title":"Related Events","text":"<ul> <li>geteuid() - get process effective user ID</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getegid16/","title":"getegid16","text":""},{"location":"docs/events/builtin/syscalls/getegid16/#intro","title":"Intro","text":"<p>getegid16 - get real group ID for the calling process</p>"},{"location":"docs/events/builtin/syscalls/getegid16/#description","title":"Description","text":"<p>getegid16 returns the real group ID of the calling process, as seen by the kernel. This call is functionally identical to getegid except that it takes a 16-bit argument, and returns 16-bit. </p> <p>The underlying system call returnes a 32-bit value, which is truncated and returned as a 16-bit integer. This call is mainly present on older systems, but new programs should rather use the getegid call if possible.</p>"},{"location":"docs/events/builtin/syscalls/getegid16/#arguments","title":"Arguments","text":"<p>This syscall does not take any arguments.</p>"},{"location":"docs/events/builtin/syscalls/getegid16/#available-tags","title":"Available Tags","text":"<p>N/A</p>"},{"location":"docs/events/builtin/syscalls/getegid16/#hooks","title":"Hooks","text":"<p>The <code>sys_getegid16</code> function can be hooked.</p>"},{"location":"docs/events/builtin/syscalls/getegid16/#sys_getegid16","title":"sys_getegid16","text":""},{"location":"docs/events/builtin/syscalls/getegid16/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/getegid16/#purpose","title":"Purpose","text":"<p>Kprobes provide the highest level of kernel instrumentation and can measure time at any byte-code level in any part of the kernel. By hooking into this function, it is possible to measure the kernel execution time for system calls.</p>"},{"location":"docs/events/builtin/syscalls/getegid16/#example-use-case","title":"Example Use Case","text":"<p>For example, this call can be used for measuring the latency of the system call in an embedded system or a system under high load.</p>"},{"location":"docs/events/builtin/syscalls/getegid16/#issues","title":"Issues","text":"<p>N/A</p>"},{"location":"docs/events/builtin/syscalls/getegid16/#related-events","title":"Related Events","text":"<ul> <li><code>getegid</code> - returns the real group ID of the calling process.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/geteuid/","title":"geteuid","text":""},{"location":"docs/events/builtin/syscalls/geteuid/#intro","title":"Intro","text":"<p>geteuid - Retrieve the effective user ID.</p>"},{"location":"docs/events/builtin/syscalls/geteuid/#description","title":"Description","text":"<p>geteuid is a syscall used to retrieve the effective user ID of the current process. This value is used by the kernel when determining which operations are allowed to be executed by the current process. It can be used to enforce access control policies.</p> <p>The geteuid syscall does not take any parameters, which makes it simpler to use than other syscalls. However, it is important to note that the effective user ID may be different from the real user ID, as the kernel may allow certain processes to temporarily execute in a different user context.</p>"},{"location":"docs/events/builtin/syscalls/geteuid/#arguments","title":"Arguments","text":"<p>None</p>"},{"location":"docs/events/builtin/syscalls/geteuid/#available-tags","title":"Available Tags","text":"<p>None</p>"},{"location":"docs/events/builtin/syscalls/geteuid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/geteuid/#geteuid_1","title":"geteuid","text":""},{"location":"docs/events/builtin/syscalls/geteuid/#type","title":"Type","text":"<p>Probe</p>"},{"location":"docs/events/builtin/syscalls/geteuid/#purpose","title":"Purpose","text":"<p>To monitor the effective user ID of the current process</p>"},{"location":"docs/events/builtin/syscalls/geteuid/#example-use-case","title":"Example Use Case","text":"<p>Using geteuid can be useful in a system that enforces access control policies, by ensuring that privileged operations are only allowed to be performed by processes with an effective user ID matching the expected one.</p>"},{"location":"docs/events/builtin/syscalls/geteuid/#issues","title":"Issues","text":"<p>None</p>"},{"location":"docs/events/builtin/syscalls/geteuid/#related-events","title":"Related Events","text":"<p>getuid - Retrieve the real user ID.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/geteuid16/","title":"geteuid16","text":""},{"location":"docs/events/builtin/syscalls/geteuid16/#intro","title":"Intro","text":"<p>geteuid16 - Get the user ID of the current user.</p>"},{"location":"docs/events/builtin/syscalls/geteuid16/#description","title":"Description","text":"<p>geteuid16 is a system call in Linux which returns the user id of the user associated with the current process. It does not take any arguments, and simply returns the requested user ID type. It is notable for being a compatibility call for older binaries which were intended to be used with different architectures.</p> <p>The advantages of using geteuid16 are that it is very simple to use, does not take any arguments and does not depend on any context; the user ID is simply returned as trivially as possible.</p>"},{"location":"docs/events/builtin/syscalls/geteuid16/#arguments","title":"Arguments","text":"<ul> <li>This syscall does not take any arguments. </li> </ul>"},{"location":"docs/events/builtin/syscalls/geteuid16/#available-tags","title":"Available Tags","text":"<p>This syscall does not have any tags.</p>"},{"location":"docs/events/builtin/syscalls/geteuid16/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/geteuid16/#sys_geteuid16","title":"sys_geteuid16","text":""},{"location":"docs/events/builtin/syscalls/geteuid16/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/geteuid16/#purpose","title":"Purpose","text":"<p>To detect when the geteuid16 system call has been called.</p>"},{"location":"docs/events/builtin/syscalls/geteuid16/#example-use-case","title":"Example Use Case","text":"<p>A security policy may include the requirement that only privileged users should be able to call geteuid16. This syscall can be used in conjunction with other monitoring systems to detect any unauthorized access attempts.</p>"},{"location":"docs/events/builtin/syscalls/geteuid16/#issues","title":"Issues","text":"<p>As geteuid16 is a compatibility syscall, there is a slight chance of it being obsolete and/or unavailable if its intended architecture is no longer supported.</p>"},{"location":"docs/events/builtin/syscalls/geteuid16/#related-events","title":"Related Events","text":"<ul> <li>getuid16</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getgid/","title":"getgid","text":""},{"location":"docs/events/builtin/syscalls/getgid/#intro","title":"Intro","text":"<p>getgid - Returns the real group ID of the calling process. </p>"},{"location":"docs/events/builtin/syscalls/getgid/#description","title":"Description","text":"<p>The getgid function returns the real group ID of the calling process. This function can be used to get the group ID of a process, which is used to determine the group of the calling process. The group ID is set when the process is created, and can be modified using the setgid system call. The getgid function is a wrapper around the getgid system call. </p> <p>When called, getgid returns the real group ID of the calling process. It is important to note that this function will only return the real group ID, not the effective group ID or saved group ID. The real group ID is tied to the user credentials assigned to the process when it was created. </p>"},{"location":"docs/events/builtin/syscalls/getgid/#arguments","title":"Arguments","text":"<ul> <li><code>void</code>:<code>void</code> - No arguments.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getgid/#available-tags","title":"Available Tags","text":"<p>N/A</p>"},{"location":"docs/events/builtin/syscalls/getgid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getgid/#sys_getgid","title":"sys_getgid","text":""},{"location":"docs/events/builtin/syscalls/getgid/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/getgid/#purpose","title":"Purpose","text":"<p>Hooks the getgid system call to capture its output.</p>"},{"location":"docs/events/builtin/syscalls/getgid/#example-use-case","title":"Example Use Case","text":"<p>The getgid function could be used to capture a process' group ID. This can be useful in situations where the group ID needs to be checked to ensure that a process is running with the correct group credentials. </p>"},{"location":"docs/events/builtin/syscalls/getgid/#issues","title":"Issues","text":"<p>The output from the getgid function only reflects the real group ID of the process. If the effective or saved group ID of the process is desired, other system calls such as getegid, or getresgid need to be used.</p>"},{"location":"docs/events/builtin/syscalls/getgid/#related-events","title":"Related Events","text":"<ul> <li>setgid - Sets the real, effective and saved group IDs of the calling process. </li> <li>getegid - Gets the effective group ID of the calling process. </li> <li>getresgid - Gets the real, effective and saved group IDs of the calling process.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getgid16/","title":"getgid16","text":""},{"location":"docs/events/builtin/syscalls/getgid16/#intro","title":"Intro","text":"<p>getgid16 - Get the real group ID of the calling process</p>"},{"location":"docs/events/builtin/syscalls/getgid16/#description","title":"Description","text":"<p>This system call gets the real group ID of the calling process.  This is a wrapper for the 64-bit system call, which is expected to be faster than the 32-bit system call. There are no edge cases, drawbacks or advantages when using this system call.</p>"},{"location":"docs/events/builtin/syscalls/getgid16/#arguments","title":"Arguments","text":"<ul> <li><code>None</code>: void - No arguments used</li> </ul>"},{"location":"docs/events/builtin/syscalls/getgid16/#available-tags","title":"Available Tags","text":"<ul> <li>None - This call does not have any available tags.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getgid16/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getgid16/#sys_getgid16","title":"sys_getgid16","text":""},{"location":"docs/events/builtin/syscalls/getgid16/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/getgid16/#purpose","title":"Purpose","text":"<p>Hooking this function is used for debugging and inspecting the state of the system call in order to gain insight into how the real group ID of the calling process is determined.</p>"},{"location":"docs/events/builtin/syscalls/getgid16/#example-use-case","title":"Example Use Case","text":"<p>This system call is used to get the group ID of the user that executed a specific process. This is useful for getting access control information or writing scripts based on process identities.</p>"},{"location":"docs/events/builtin/syscalls/getgid16/#issues","title":"Issues","text":"<p>There are no known issues with this system call. </p>"},{"location":"docs/events/builtin/syscalls/getgid16/#related-events","title":"Related Events","text":"<ul> <li>getuid16 - Get the real user ID of the calling process</li> <li>setgid16 - Set the real group ID of the calling process</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getgroups/","title":"getgroups","text":""},{"location":"docs/events/builtin/syscalls/getgroups/#intro","title":"Intro","text":"<p>getgroups - get group access list for user</p>"},{"location":"docs/events/builtin/syscalls/getgroups/#description","title":"Description","text":"<p>The getgroups() system call gets the group access list for the current user, and places it in the array pointed to by list. It returns the size of the group access list in size.</p> <p>Access list is that set of supplementary group IDs associated with the calling process, initialised from the /etc/passwd file when each user first logs in. </p>"},{"location":"docs/events/builtin/syscalls/getgroups/#arguments","title":"Arguments","text":"<ul> <li><code>size</code>:<code>int</code>[K] - the size of the array in list</li> <li><code>list</code>:<code>gid_t*</code>[KU] - pointer to an array of gid_t which will be filled with the group access list</li> </ul>"},{"location":"docs/events/builtin/syscalls/getgroups/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/getgroups/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getgroups/#sys_getgroups","title":"sys_getgroups","text":""},{"location":"docs/events/builtin/syscalls/getgroups/#type","title":"Type","text":"<p>Kprobes </p>"},{"location":"docs/events/builtin/syscalls/getgroups/#purpose","title":"Purpose","text":"<p>To get group access list for user.</p>"},{"location":"docs/events/builtin/syscalls/getgroups/#example-use-case","title":"Example Use Case","text":"<p>getgroups() is often used before setgroups() to obtain the list of current group IDs associated with the calling process, so it can be used for auditing and logging changes to the group access list. </p>"},{"location":"docs/events/builtin/syscalls/getgroups/#issues","title":"Issues","text":"<p>No known issues.</p>"},{"location":"docs/events/builtin/syscalls/getgroups/#related-events","title":"Related Events","text":"<p>setgroups() - set group access list for user</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getgroups16/","title":"getgroups16","text":""},{"location":"docs/events/builtin/syscalls/getgroups16/#intro","title":"Intro","text":"<p>getgroups16 - returns the supplementary group IDs of the calling process.</p>"},{"location":"docs/events/builtin/syscalls/getgroups16/#description","title":"Description","text":"<p>getgroups16 is a syscall used to retrieve a list of supplementary group IDs of the calling process. This list is stored as an array of group IDs, with a size given by the first parameter. This array is written to the second parameter. The syscall is equivalent to calling getgroups() with a maximum of 16 entries in the array. </p> <p>If the flag <code>parse-arguments</code> is given, the list is parsed and written to a buffer containing a null-terminated array of strings, delimited by index numbers. This allows for a more user-friendly representation of the output. This can be a useful utility when kprobing related to supplementary groups.</p>"},{"location":"docs/events/builtin/syscalls/getgroups16/#arguments","title":"Arguments","text":"<ul> <li><code>size</code>:<code>int</code>[K] - number of entries in the supplementary group array. If <code>parse-arguments</code> is given, this is the maximum length of the output buffer.</li> <li><code>list</code>:<code>old_gid_t*</code>[K] - pointer to the array in which the list of group IDs is stored. If <code>parse-arguments</code> is given, this is a pointer to the output buffer.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getgroups16/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getgroups16/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getgroups16/#getgroups16_1","title":"getgroups16","text":""},{"location":"docs/events/builtin/syscalls/getgroups16/#type","title":"Type","text":"<p>Kprobe.</p>"},{"location":"docs/events/builtin/syscalls/getgroups16/#purpose","title":"Purpose","text":"<p>Hooking getgroups16 allows for recording when the process attempts to fetch its supplementary group IDs. By observing when and where this happens, performance and security issues can be detected, such as authentication problems, or attempts to access data that the user should not have access to, violating the principle of least privilege.</p>"},{"location":"docs/events/builtin/syscalls/getgroups16/#example-use-case","title":"Example Use Case","text":"<p>getgroups16 can be used to watch for processes that fetch their supplementary group IDs and make sure that those calls happen when expected, such as during authentication. It can help identify processes that are misusing the supplementary groups for which it is not intended and give detailed information about where and when this happens, should that be occurring.</p>"},{"location":"docs/events/builtin/syscalls/getgroups16/#issues","title":"Issues","text":"<p>The flag <code>parse-arguments</code> has not been tested thoroughly, so any issues while using it should be reported in order to ensure that the user gets the expected output.</p>"},{"location":"docs/events/builtin/syscalls/getgroups16/#related-events","title":"Related Events","text":"<p>getgroups() - similar to getgroups16, but with a higher (32) limit for supplementary group IDs.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getitimer/","title":"getitimer","text":""},{"location":"docs/events/builtin/syscalls/getitimer/#getitimer","title":"getitimer","text":""},{"location":"docs/events/builtin/syscalls/getitimer/#intro","title":"Intro","text":"<p>getitimer - retrieves the current value of an interval timer</p>"},{"location":"docs/events/builtin/syscalls/getitimer/#description","title":"Description","text":"<p>The getitimer function is used to retrieve the current value of an interval timer. The interval timer must have been set previously with the setitimer function.</p> <p>If the value curr_value is non-NULL, the getitimer function fills out the structure pointed to by curr_value with the current value of the timer.</p> <p>The which argument must be one of the flags, ITIMER_REAL, ITIMER_VIRTUAL or ITIMER_PROF.</p> <p>The main advantage of using the getitimer syscall is to retrieve the current value of an interval timer previously set with the setitimer syscall. A potential drawback is that the curr_value argument must be initialized before calling this syscall, and must point to valid memory. </p>"},{"location":"docs/events/builtin/syscalls/getitimer/#arguments","title":"Arguments","text":"<ul> <li><code>which</code>:<code>int</code>[K] - the timer to retrieve, must be one of ITIMER_REAL, ITIMER_VIRTUAL or ITIMER_PROF. </li> <li><code>curr_value</code>:<code>struct itimerval*</code>[KU] - pointer to the structure that will contain the retrieved current value.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getitimer/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/getitimer/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getitimer/#sys_getitimer","title":"sys_getitimer","text":""},{"location":"docs/events/builtin/syscalls/getitimer/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/getitimer/#purpose","title":"Purpose","text":"<p>To track the usage and parameters of the getitimer syscall.</p>"},{"location":"docs/events/builtin/syscalls/getitimer/#example-use-case","title":"Example Use Case","text":"<p>The getitimer syscall can be used by an application to retrieve the current value of an interval timer previously set with the setitimer syscall. This allows an application to accurately keep track of how much time has elapsed until the next interrupts.   </p>"},{"location":"docs/events/builtin/syscalls/getitimer/#issues","title":"Issues","text":"<p>None. </p>"},{"location":"docs/events/builtin/syscalls/getitimer/#related-events","title":"Related Events","text":"<p>setitimer</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getpeername/","title":"getpeername","text":""},{"location":"docs/events/builtin/syscalls/getpeername/#intro","title":"Intro","text":"<p>getpeername - Retrieve the name of the peer connected to the socket.</p>"},{"location":"docs/events/builtin/syscalls/getpeername/#description","title":"Description","text":"<p>getpeername is a system call that allows for the retrieval of the name of the peer socket connected to the given socket. Additionally, the system call can return more information about the peer, such as its address family, port, and more. By default, the system call does not check for the validity of the socket descriptor, so it is possible that an error is returned even when the arguments are valid. </p>"},{"location":"docs/events/builtin/syscalls/getpeername/#arguments","title":"Arguments","text":"<ul> <li><code>sockfd</code>:<code>int</code> - The file descriptor referring to the socket.</li> <li><code>addr</code>:<code>struct sockaddr*</code>[U] - A pointer to a buffer where the address of the remote socket is stored.</li> <li><code>addrlen</code>:<code>int*</code>[U] - A pointer to an integer indicating the size of the <code>addr buffer</code>.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getpeername/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/getpeername/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getpeername/#sys_socketcall","title":"sys_socketcall","text":""},{"location":"docs/events/builtin/syscalls/getpeername/#type","title":"Type","text":"<p>Tracepoint</p>"},{"location":"docs/events/builtin/syscalls/getpeername/#purpose","title":"Purpose","text":"<p>To trace all calls to the socketcall syscall.</p>"},{"location":"docs/events/builtin/syscalls/getpeername/#example-use-case","title":"Example Use Case","text":"<p>getpeername can be used to determine the address of the peer in a peer to peer networking setup. It can also be used to differentiate between different connection types, such as UDP or TCP.</p>"},{"location":"docs/events/builtin/syscalls/getpeername/#issues","title":"Issues","text":"<p>getpeername can cause a race condition in a multi-threaded application if the underlying socket is modified while the system call is in progress. </p>"},{"location":"docs/events/builtin/syscalls/getpeername/#related-events","title":"Related Events","text":"<ul> <li>accept</li> <li>connect</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getpgid/","title":"getpgid","text":""},{"location":"docs/events/builtin/syscalls/getpgid/#intro","title":"Intro","text":"<p>getpgid - Get the process group ID of a process</p>"},{"location":"docs/events/builtin/syscalls/getpgid/#description","title":"Description","text":"<p>The getpgid() system call retrieves the process group ID of the process that corresponds to the given PID. It is used to check if the process still exists, as well as its process group ID. It can be used with any PID - even a parent or its own process ID - but there are some restrictions, such as the process having to be in the same session and the process must have the same UID or effective UID as the process doing the syscall. Additionally, a process group can consist of multiple processes and one process can be part of multiple groups.</p>"},{"location":"docs/events/builtin/syscalls/getpgid/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>pid_t</code>[N] - The process ID of the process for which the process group ID should be queried.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getpgid/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/getpgid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getpgid/#sys_getpgid","title":"sys_getpgid()","text":""},{"location":"docs/events/builtin/syscalls/getpgid/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/getpgid/#purpose","title":"Purpose","text":"<p>To track the process group ID of a process.</p>"},{"location":"docs/events/builtin/syscalls/getpgid/#example-use-case","title":"Example Use Case","text":"<p>An example use case for getpgid() might be a process tracking application. This application wants to track the process group IDs of all processes running. To do this, it would hook the sys_getpgid() function using a kprobe and store the retuned process group ID in its own database.</p>"},{"location":"docs/events/builtin/syscalls/getpgid/#issues","title":"Issues","text":"<p>No major issues were found with this syscall. </p>"},{"location":"docs/events/builtin/syscalls/getpgid/#related-events","title":"Related Events","text":"<ul> <li>setpgid() - Set the process group ID of a process</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getpgrp/","title":"getpgrp","text":""},{"location":"docs/events/builtin/syscalls/getpgrp/#intro","title":"Intro","text":"<p>getpgrp - get the process group ID of the calling process</p>"},{"location":"docs/events/builtin/syscalls/getpgrp/#description","title":"Description","text":"<p>The getpgrp() function returns the process group ID of the calling process. Process groups are the mechanism used by drivers implementing job control.</p> <p>getpgrp() is the equivalent of getpgid(0), getpgid() can be used to get the process group ID for another process; see getpgid(2). </p> <p>The main advantage of using getpgrp() is that it saves an expensive system call (in the case of getpgid(2)). On the other hand, getpgrp() can be only used with the calling process.</p>"},{"location":"docs/events/builtin/syscalls/getpgrp/#arguments","title":"Arguments","text":"<p>No arguments for this system call.</p>"},{"location":"docs/events/builtin/syscalls/getpgrp/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getpgrp/#sys_getpgrp","title":"sys_getpgrp","text":""},{"location":"docs/events/builtin/syscalls/getpgrp/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/getpgrp/#purpose","title":"Purpose","text":"<p>To log a trace when the getpgrp() system call is called.</p>"},{"location":"docs/events/builtin/syscalls/getpgrp/#example-use-case","title":"Example Use Case","text":"<p>This system call can be used by a service or daemon that needs to change the process group ID in order to run a command or to determine the process group ID to check if it is a child process.</p>"},{"location":"docs/events/builtin/syscalls/getpgrp/#issues","title":"Issues","text":"<p>This system call does not have any known issues.</p>"},{"location":"docs/events/builtin/syscalls/getpgrp/#related-events","title":"Related Events","text":"<p>getpgid(2) - get a process group ID of another process</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getpid/","title":"getpid","text":""},{"location":"docs/events/builtin/syscalls/getpid/#intro","title":"Intro","text":"<p>getpid - get process identification</p>"},{"location":"docs/events/builtin/syscalls/getpid/#description","title":"Description","text":"<p>getpid() calls the kernel API which returns the identification (ID) of the calling process. The ID returned is the Process ID (PID) which is a unique value that identifies each process within the system. </p> <p>This API is often used when a process needs to obtain its own pid for use within other API calls, such as getppid(), for example. While getting the PID for a process is relatively easy, some difficulties arise when the call needs to work across processes. This is where some synchronization is needed between processes to ensure that the correct PID value is returned.</p> <p>The getpid() API is usually found in the child process section of Linux, as it is one of the very few ways of obtaining the parent's PID from a child process. There are also other uses of getpid(), such as when checking whether or not a particular process is running, or when sending signals or associated information to a process that is running.</p>"},{"location":"docs/events/builtin/syscalls/getpid/#arguments","title":"Arguments","text":"<p>There are no arguments for the getpid() API.</p>"},{"location":"docs/events/builtin/syscalls/getpid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getpid/#syscalltable","title":"SysCallTable","text":""},{"location":"docs/events/builtin/syscalls/getpid/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/getpid/#purpose","title":"Purpose","text":"<p>To prevent malicious processes from replacing the getpid() system call entry point with a malicious one, this function is hooked to verify that the system call operation is performed correctly.</p>"},{"location":"docs/events/builtin/syscalls/getpid/#example-use-case","title":"Example Use Case","text":"<p>The getpid() system call can be used in any process to obtain the identifier (PID) of that process. It is a commonly used API for getting the parent process's PID from its child process. For example, a child process can use getpid() to obtain its own PID, and then use that to obtain the PID of its parent process using the getppid() API call.</p> <p>This system call can also be used to verify that a process is running, by obtaining its PID from the system and using this to check if it is running. In addition, it can also be used for sending signals and associated data to a running process.</p>"},{"location":"docs/events/builtin/syscalls/getpid/#issues","title":"Issues","text":"<p>None</p>"},{"location":"docs/events/builtin/syscalls/getpid/#related-events","title":"Related Events","text":"<ul> <li>getppid() - get parent process identification</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getpmsg/","title":"getpmsg","text":""},{"location":"docs/events/builtin/syscalls/getpmsg/#intro","title":"Intro","text":"<p>getpmsg - delivers the next message on a STREAMS pipe</p>"},{"location":"docs/events/builtin/syscalls/getpmsg/#description","title":"Description","text":"<p>The getpmsg() system call is used to read message from a STREAMS pipe. A message from the pipe is either read into the buffers that are specified by the <code>ctrlptr</code>, <code>datptr</code>, <code>flags</code> and <code>bandp</code> arguments, or it is skipped depending on the settings of <code>flags</code>.</p> <p>getpmsg() is useful in applications dealing with STREAMS pipes where messages have different priority and should be read in different order than they are available.</p>"},{"location":"docs/events/builtin/syscalls/getpmsg/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - file descriptor associated with the STREAMS pipe</li> <li><code>ctrlptr</code>:<code>void *</code>[K] - pointer to buffer for control information</li> <li><code>datptr</code>:<code>void *</code>[K] - pointer to buffer for data</li> <li><code>bandp</code>:<code>int *</code>[K] - pointer to a variable for indicating the band of the message</li> <li><code>flags</code>:<code>int</code>[K] - flags indicating how the messages should be delivered</li> </ul>"},{"location":"docs/events/builtin/syscalls/getpmsg/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getpmsg/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getpmsg/#getpmsg_1","title":"getpmsg","text":""},{"location":"docs/events/builtin/syscalls/getpmsg/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/getpmsg/#purpose","title":"Purpose","text":"<p>To measure the time taken by the getpmsg syscall.</p>"},{"location":"docs/events/builtin/syscalls/getpmsg/#example-use-case","title":"Example Use Case","text":"<p>getpmsg() can be used in applications that read messages from STREAMS pipes. For example, a text editor can use getpmsg() to read messages from a STREAMS pipe and display them in the application window.</p>"},{"location":"docs/events/builtin/syscalls/getpmsg/#issues","title":"Issues","text":"<p>Due to the asynchronous nature of STREAMS pipes, it is possible that getpmsg() will read an invalid message, or a message intended for a different application.</p>"},{"location":"docs/events/builtin/syscalls/getpmsg/#related-events","title":"Related Events","text":"<ul> <li>getmsg</li> <li>putmsg</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getppid/","title":"getppid","text":""},{"location":"docs/events/builtin/syscalls/getppid/#intro","title":"Intro","text":"<p>getppid - return the process ID of the parent of the calling process</p>"},{"location":"docs/events/builtin/syscalls/getppid/#description","title":"Description","text":"<p>The <code>getppid()</code> system call is used to determine the PID of the parent of the calling process. This is an important information for parent-child process relationships, as the PPID value for the parent of the process can be used to separate process hierarchies. The return value is a positive number, or zero if the parent process does not exist. </p> <p>There are some edge cases and drawbacks to using <code>getppid()</code>. For example, a process can check its parent process ID with <code>getppid()</code> but this value is not guaranteed to stay the same over the course of execution. Furthermore, if the parent process has exited, then getppid will return zero, which is not very helpful. </p>"},{"location":"docs/events/builtin/syscalls/getppid/#arguments","title":"Arguments","text":"<p>No arguments</p>"},{"location":"docs/events/builtin/syscalls/getppid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getppid/#sys_getppid","title":"sys_getppid","text":""},{"location":"docs/events/builtin/syscalls/getppid/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/getppid/#purpose","title":"Purpose","text":"<p>To trace all calls to <code>getppid()</code> in the kernel.</p>"},{"location":"docs/events/builtin/syscalls/getppid/#example-use-case","title":"Example Use Case","text":"<p>By generating trace events at each <code>sys_getppid</code> occurrence, one can get all of the process IDs in the parent-child process tree and maintain a timeline of process creation and exits.</p>"},{"location":"docs/events/builtin/syscalls/getppid/#issues","title":"Issues","text":"<p>If the parent of a process exits and is replaced with a different process of the same PID, then <code>getppid</code> would return the same value, leading to potential confusion.</p>"},{"location":"docs/events/builtin/syscalls/getppid/#related-events","title":"Related Events","text":"<ul> <li><code>execve</code> - checks whether the current process is the parent of a given process</li> <li><code>fork</code> - creates a new process that is the parent of the calling process</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getpriority/","title":"getpriority","text":""},{"location":"docs/events/builtin/syscalls/getpriority/#intro","title":"Intro","text":"<p>getpriority - get the priority of a process or process group.</p>"},{"location":"docs/events/builtin/syscalls/getpriority/#description","title":"Description","text":"<p>getpriority() gets the priority of a specified process (by the which and who arguments) compared to the priority of all other processes in the same process group. The return value is the priority value, which ranges from -20 (high priority) to 20 (low priority). It can also be used to get the priority of the specified process relative to the other processes in the same user ID.</p> <p>This function is useful for allowing privileged processes to set the priority of other processes. It is important to note that the values returned are dependent on the system's scheduling policy, and may not always return meaningful values for a given process.</p>"},{"location":"docs/events/builtin/syscalls/getpriority/#arguments","title":"Arguments","text":"<ul> <li><code>which</code>:<code>int</code>[K] - The which argument specifies what information to retrieve. The value PRIO_PROCESS retrieves the priority of the specified process. The value PRIO_PGRP retrieves the priority of the processes in the specified process group.</li> <li><code>who</code>:<code>int</code>[K] - The who argument specifies the process ID or process group ID whose priority should be retrieved.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getpriority/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getpriority/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getpriority/#sys_getpriority","title":"sys_getpriority","text":""},{"location":"docs/events/builtin/syscalls/getpriority/#type","title":"Type","text":"<p>Tracepoint.</p>"},{"location":"docs/events/builtin/syscalls/getpriority/#purpose","title":"Purpose","text":"<p>To trace calls to the getpriority() system call.</p>"},{"location":"docs/events/builtin/syscalls/getpriority/#example-use-case","title":"Example Use Case","text":"<p>getpriority() can be used to control the process execution times for tasks with different priorities. For example, when running multiple jobs on a server or setting the priority of processes in a real-time system.</p>"},{"location":"docs/events/builtin/syscalls/getpriority/#issues","title":"Issues","text":"<p>This function is dependent on the system scheduling policy, which may not always return meaningful values for a given process.</p>"},{"location":"docs/events/builtin/syscalls/getpriority/#related-events","title":"Related Events","text":"<ul> <li>setpriority() - set the priority of a process or process group.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getrandom/","title":"Getrandom","text":""},{"location":"docs/events/builtin/syscalls/getrandom/#intro","title":"Intro","text":"<p>Getrandom - Retrieves randomness from the kernel entropy pool</p>"},{"location":"docs/events/builtin/syscalls/getrandom/#description","title":"Description","text":"<p>The getrandom() system call returns up to buflen bytes of randomness from the kernel entropy pool into the buffer pointed to by buf. The returned value is internally generated.</p> <p>This function has the advantage of providing a cryptographically secure source of randomness as it is based on an entropy pool of randomness that is maintained in the kernel. It is also faster than other random number generation functions as it does not have to perform any computationally intensive calculations. </p> <p>There are some potential drawbacks to using the getrandom() system call such as potential race conditions, where two or more processes are using the same getrandom() system call and may end up getting the same data in the same buffer. This means that the data returned by getrandom() can potentially be compromised. Additionally, the getrandom() system call will return an error instead of waiting for enough entropy to become available, so if it is called in a situation where there is not enough entropy available it will fail.</p>"},{"location":"docs/events/builtin/syscalls/getrandom/#arguments","title":"Arguments","text":"<ul> <li><code>buf</code>:<code>void*</code>[K] - Pointer to the buffer which will hold the random data.</li> <li><code>buflen</code>:<code>size_t</code>[K] - Size of the buffer pointed to by buf, in bytes.</li> <li><code>flags</code>:<code>unsigned int</code>[K] - If flags is set to 0, getrandom() will not return until it has retrieved the requested amount of data. If flags is set to GRND_NONBLOCK, getrandom() will return instantly, with the actual amount of retrieved data stored in the buffer pointed to by buf. If there is not enough entropy available immediately, getrandom will return -1 with errno set to EAGAIN.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getrandom/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getrandom/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getrandom/#get_random_bytes","title":"get_random_bytes","text":""},{"location":"docs/events/builtin/syscalls/getrandom/#type","title":"Type","text":"<p>Kprobes + Kretprobes</p>"},{"location":"docs/events/builtin/syscalls/getrandom/#purpose","title":"Purpose","text":"<p>To monitor the results of the getrandom() system call and log any attempts to retrieve random data from the kernel entropy pool.</p>"},{"location":"docs/events/builtin/syscalls/getrandom/#example-use-case","title":"Example Use Case","text":"<p>This is often used for cryptographic operations, or when developers need a secure source of randomness for their application.</p>"},{"location":"docs/events/builtin/syscalls/getrandom/#issues","title":"Issues","text":"<p>The getrandom() system call does not guarantee that the randomness returned will be unique as there is a potential for race conditions during execution. Additionally, there may not be enough entropy available when the call is made, so it is important to check that enough entropy is available before the call is made.</p>"},{"location":"docs/events/builtin/syscalls/getrandom/#related-events","title":"Related Events","text":"<ul> <li>getentropy() - similar system call - but with different parameters.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getresgid/","title":"getresgid","text":""},{"location":"docs/events/builtin/syscalls/getresgid/#intro","title":"Intro","text":"<p>getresgid - gets the real, effective and saved user group IDs of the calling process</p>"},{"location":"docs/events/builtin/syscalls/getresgid/#description","title":"Description","text":"<p>The getresgid() is used to get the current real, effective and saved user group ids of the calling process. These values are stored in the different parameters passed as pointers to the getresgid() syscall, and can be used for different process management operations, such as setting or rescinding privileges of specific users or groups, as well as for user authentication. The group IDs are stored as gid_t type values, which should be capable of holding the group IDs used in the system. </p> <p>There are some edge-cases that have to be taken into consideration when using getresgid() from within the kernel or from user space. In the kernel, getresgid() might return -1 if there is an error in accessing the user group ids, while from user space this is a valid return value. Furthermore, when using getresgid() from user space, the real, effective and saved user group ids should all be valid, as the kernel will check them against the user IDs in the system.</p>"},{"location":"docs/events/builtin/syscalls/getresgid/#arguments","title":"Arguments","text":"<ul> <li><code>rgid</code>:<code>gid_t*</code>[K] - pointer to a gid_t type value where the real user group id of the calling process is stored.</li> <li><code>egid</code>:<code>gid_t*</code>[K] - pointer to a gid_t type value where the effective user group id of the calling process is stored.</li> <li><code>sgid</code>:<code>gid_t*</code>[K] - pointer to a gid_t type value where the saved user group id of the calling process is stored.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getresgid/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getresgid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getresgid/#ptrace_traceme","title":"ptrace_traceme","text":""},{"location":"docs/events/builtin/syscalls/getresgid/#type","title":"Type","text":"<p>kprobe + ftrace</p>"},{"location":"docs/events/builtin/syscalls/getresgid/#purpose","title":"Purpose","text":"<p>Hooking the ptrace_traceme function with both kprobes and ftrace allows for more precise control over the tracing of processes.</p>"},{"location":"docs/events/builtin/syscalls/getresgid/#example-use-case","title":"Example Use Case","text":"<p>Suppose we want to authenticate a user, as well as ensure that all privileges given to his user should only be used within a certain context. We can use the getresgid() syscall to get the real, effective and saved user group ids, and compare them with the ones stored in the system. If they match, the user is authenticated, and if not, the user has to be rejected.</p>"},{"location":"docs/events/builtin/syscalls/getresgid/#issues","title":"Issues","text":"<p>getresgid() is vulnerable to TOCTOU issues when used from user space, as the gid_t values could be manipulated between the time the user checks them and the time he uses them.</p>"},{"location":"docs/events/builtin/syscalls/getresgid/#related-events","title":"Related Events","text":"<p> setresgid() </p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getresgid16/","title":"getresgid16","text":""},{"location":"docs/events/builtin/syscalls/getresgid16/#intro","title":"Intro","text":"<p>getresgid16 - get the real, effective, and saved group IDs of the calling process</p>"},{"location":"docs/events/builtin/syscalls/getresgid16/#description","title":"Description","text":"<p>The getresgid16() system call gets the real, effective, and saved group IDs of the calling process (in that order).</p> <p>Using this call, a process can be sure that its real, effective and saved group IDs are the same.  This can help with privilege elevation when changing credentials.</p> <p>Since it takes no arguments, there are no edge-cases or drawbacks, however, in kernel versions prior to 4.20 the <code>allocated</code> argument was present and had to be set to the size of the <code>old_gid_t</code> type, which might be confusing for some.</p>"},{"location":"docs/events/builtin/syscalls/getresgid16/#arguments","title":"Arguments","text":"<ul> <li><code>rgid</code>:<code>old_gid_t*</code>[K] - Pointer to the real group ID of the caller.</li> <li><code>egid</code>:<code>old_gid_t*</code>[K] - Pointer to the effective group ID of the caller.</li> <li><code>sgid</code>:<code>old_gid_t*</code>[K] - Pointer to the saved group ID of the caller.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getresgid16/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getresgid16/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getresgid16/#do_getresgid16","title":"do_getresgid16","text":""},{"location":"docs/events/builtin/syscalls/getresgid16/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/getresgid16/#purpose","title":"Purpose","text":"<p>To allow users to trace or monitor calls to the getresgid16() system call from user space.</p>"},{"location":"docs/events/builtin/syscalls/getresgid16/#example-use-case","title":"Example Use Case","text":"<p>Monitoring the progress of setting the caller's real, effective, and saved group IDs.</p>"},{"location":"docs/events/builtin/syscalls/getresgid16/#issues","title":"Issues","text":"<p>In some kernels, the <code>allocated</code> argument had to be set to the size of the <code>old_gid_t</code> type, but this was deprecated in kernel 4.20.</p>"},{"location":"docs/events/builtin/syscalls/getresgid16/#related-events","title":"Related Events","text":"<ul> <li>setresgid16 - set the real, effective, and saved group IDs of the calling process</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getresuid/","title":"Getresuid","text":""},{"location":"docs/events/builtin/syscalls/getresuid/#intro","title":"Intro","text":"<p>getresuid - Get the real, effective and saved user identity</p>"},{"location":"docs/events/builtin/syscalls/getresuid/#description","title":"Description","text":"<p>The getresuid() system call gets the real, effective and saved user identity of the calling process, storing the results in the buffer pointed to by ruid, euid and suid, respectively.</p> <p>The real user ID is the user ID of the owner of the process. The effective user ID is the user ID used when checking user permissions. The saved user ID is the user ID used when the process calls execve().</p>"},{"location":"docs/events/builtin/syscalls/getresuid/#arguments","title":"Arguments","text":"<ul> <li><code>ruid</code>:<code>uid_t*</code>[K,U] - Pointer to a uid_t buffer where the real user ID will be stored.</li> <li><code>euid</code>:<code>uid_t*</code>[K,U] - Pointer to a uid_t buffer where the effective user ID will be stored. </li> <li><code>suid</code>:<code>uid_t*</code>[K,U] - Pointer to a uid_t buffer where the saved user ID will be stored.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getresuid/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/getresuid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getresuid/#do_getrusage","title":"do_getrusage","text":""},{"location":"docs/events/builtin/syscalls/getresuid/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/getresuid/#purpose","title":"Purpose","text":"<p>To monitor when a process requests its own resource usage.</p>"},{"location":"docs/events/builtin/syscalls/getresuid/#sys_getresuid","title":"sys_getresuid","text":""},{"location":"docs/events/builtin/syscalls/getresuid/#type_1","title":"Type","text":"<p>Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/getresuid/#purpose_1","title":"Purpose","text":"<p>To retrieve the real, effective and saved user ID of the calling process.</p>"},{"location":"docs/events/builtin/syscalls/getresuid/#example-use-case","title":"Example Use Case","text":"<p>The getresuid() system call can be used to check if a process has the same real and effective user ID.</p>"},{"location":"docs/events/builtin/syscalls/getresuid/#issues","title":"Issues","text":"<p>There are no known issues with this system call.</p>"},{"location":"docs/events/builtin/syscalls/getresuid/#related-events","title":"Related Events","text":"<ul> <li>getresgid() - Get the real, effective and saved group identity of the calling process.</li> <li>getuid() - Get the real user ID of the calling process.</li> <li>geteuid() - Get the effective user ID of the calling process.</li> <li>getegid() - Get the effective group ID of the calling process.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getresuid16/","title":"getresuid16","text":""},{"location":"docs/events/builtin/syscalls/getresuid16/#intro","title":"Intro","text":"<p>getresuid16 - get the real user, effective user, and saved-set user IDs of the calling process</p>"},{"location":"docs/events/builtin/syscalls/getresuid16/#description","title":"Description","text":"<p>The <code>getresuid16</code> system call is used to get the current real user ID, effective user ID, and saved-set user ID of the calling process. This is useful for probing the security context of the running process, as the context changes when different user IDs are used. The real user ID is the original user ID of the process and cannot be changed; the effective user ID is what the process uses to determine file permissions, and the saved-set user ID is the user ID used when the effective user ID is reset, such as when the process drops privileges. </p> <p>Since the kernel view of user IDs is 32-bit while the user space view of them is 16-bit, this system call allows for the conversion between the two views. </p>"},{"location":"docs/events/builtin/syscalls/getresuid16/#arguments","title":"Arguments","text":"<ul> <li><code>ruid</code>:<code>old_uid_t*</code>[KU] - a pointer to a user-space memory where the real user ID of the calling process is written to. The pointer must be 16-bit.</li> <li><code>euid</code>:<code>old_uid_t*</code>[KU] - a pointer to a user-space memory where the effective user ID of the calling process is written to. The pointer must be 16-bit.</li> <li><code>suid</code>:<code>old_uid_t*</code>[KU] - a pointer to a user-space memory where the saved-set user ID of the calling process is written to. The pointer must be 16-bit.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getresuid16/#available-tags","title":"Available Tags","text":"<ul> <li>K \u2013 Originated from kernel-space.</li> <li>U \u2013 Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU \u2013 Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT \u2013 Optional argument \u2013 might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/getresuid16/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getresuid16/#sys_getresuid16","title":"sys_getresuid16","text":""},{"location":"docs/events/builtin/syscalls/getresuid16/#type","title":"Type","text":"<p>Kprobe + Uprobe</p>"},{"location":"docs/events/builtin/syscalls/getresuid16/#purpose","title":"Purpose","text":"<p>Hooked to get the real, effective and saved-set user IDs of the calling process.</p>"},{"location":"docs/events/builtin/syscalls/getresuid16/#example-use-case","title":"Example Use Case","text":"<p>This event can be used to monitor privileged processes, such as daemons, to ensure that they are running with the appropriate level of authority.</p>"},{"location":"docs/events/builtin/syscalls/getresuid16/#issues","title":"Issues","text":"<p>Because this system call is only intended to perform a conversion between kernel and user space views of the user ID, it is vulnerable to TOCTOU attacks.</p>"},{"location":"docs/events/builtin/syscalls/getresuid16/#related-events","title":"Related Events","text":"<ul> <li><code>getresgid16</code> - get the real group, effective group, and saved-set group IDs of the calling process.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getrlimit/","title":"getrlimit","text":""},{"location":"docs/events/builtin/syscalls/getrlimit/#intro","title":"Intro","text":"<p>getrlimit - get resource limits on the process</p>"},{"location":"docs/events/builtin/syscalls/getrlimit/#description","title":"Description","text":"<p>getrlimit() returns the current value of a resource limit for the process identified by pid. Resource limits are kernel-imposed limits on the resources that a process can consume. The resource parameter is a resource to be retrieved; a list of known resources is given in the manual page. If a call to setrlimit() has not been made previously, then the returned limits will reflect the operating system's default limit values. </p> <p>There are some limitations associated with this syscall. The granularity of the returned data depends on the limits imposed by the underlying operating system. For example, some architectures may not support setting a limit for a resource type. Additionally, the returned resource limit may not exactly match the value that was set, as it is rounded up to the nearest valid limit by the kernel before it is returned. </p>"},{"location":"docs/events/builtin/syscalls/getrlimit/#arguments","title":"Arguments","text":"<ul> <li><code>resource</code>:<code>int</code> - specifies the resource to retrieve information about.</li> <li><code>rlim</code>:<code>struct rlimit*</code>[K | U] - specifies the location of the buffer that should contain the resource limit. This buffer must be provided by user-space and must have enough space to contain the resource limit that is being requested.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getrlimit/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/getrlimit/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getrlimit/#sys_getrlimit","title":"sys_getrlimit","text":""},{"location":"docs/events/builtin/syscalls/getrlimit/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/getrlimit/#purpose","title":"Purpose","text":"<p>To monitor the resource limits of the process and gather information about resource consumption.</p>"},{"location":"docs/events/builtin/syscalls/getrlimit/#example-use-case","title":"Example Use Case","text":"<p>getrlimit() can be used to track how many resources, like memory and file descriptors, a process is consuming and, potentially, help identify process that are growing in a very short amount of time or have too many resources allocated. </p>"},{"location":"docs/events/builtin/syscalls/getrlimit/#issues","title":"Issues","text":"<p>The granularity of the resource limits depends on the system and there may not be support for some resource types. </p>"},{"location":"docs/events/builtin/syscalls/getrlimit/#related-events","title":"Related Events","text":"<p>setrlimit() - set resource limits on the process.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getrusage/","title":"getrusage","text":""},{"location":"docs/events/builtin/syscalls/getrusage/#intro","title":"Intro","text":"<p>getrusage - get resource usage </p>"},{"location":"docs/events/builtin/syscalls/getrusage/#description","title":"Description","text":"<p>The getrusage() system call returns information about usage of system resources and accounting information of the current process or one of its children. This information can be used to determine from which parts of the program the time was spent or to estimate the current capacity of the process to perform operations.</p> <p>The <code>who</code> argument should be set to <code>RUSAGE_SELF</code> to return information about the current process, or <code>RUSAGE_CHILDREN</code> to return information about the process's children. The <code>usage</code> argument points to a structure, rusage, which upon the system call's return, is filled with the specified usage information.</p>"},{"location":"docs/events/builtin/syscalls/getrusage/#arguments","title":"Arguments","text":"<ul> <li><code>who</code>:int[KU] - The who argument describes which process the usage information is requested for. Must be set to <code>RUSAGE_SELF</code> or <code>RUSAGE_CHILDREN</code>.</li> <li><code>usage</code>:struct rusage*[K] - The usage argument is a pointer to a struct rusage, which upon the system call's return, is filled with the specified usage information.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getrusage/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/getrusage/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getrusage/#do_getrusage","title":"do_getrusage","text":""},{"location":"docs/events/builtin/syscalls/getrusage/#type","title":"Type","text":"<p>Kprobes </p>"},{"location":"docs/events/builtin/syscalls/getrusage/#purpose","title":"Purpose","text":"<p>To observe the system call arguments and return values of getrusage for a given process.</p>"},{"location":"docs/events/builtin/syscalls/getrusage/#example-use-case","title":"Example Use Case","text":"<p>getrusage can be used to get resource usage information from a specific process, such as the CPU usage or the size of used memory. This information can be used to create performance profiles for a running program.</p>"},{"location":"docs/events/builtin/syscalls/getrusage/#issues","title":"Issues","text":"<p>When using the <code>RUSAGE_CHILDREN</code> flag, the information returned can be inconsistent  when dealing with processes that exit until all exited processes are reaped.</p>"},{"location":"docs/events/builtin/syscalls/getrusage/#related-events","title":"Related Events","text":"<ul> <li>getpid - gets the process id of the calling process</li> <li>wait4 - waits on a process or group of processes</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getsid/","title":"getsid","text":""},{"location":"docs/events/builtin/syscalls/getsid/#intro","title":"Intro","text":"<p>getsid - get the session ID of a process</p>"},{"location":"docs/events/builtin/syscalls/getsid/#description","title":"Description","text":"<p>getsid() returns the session ID of the process specified in pid. If pid is zero, the  call applies to the calling process.  If pid is not a member of the current  session, getsid() returns -1 and sets errno to ESRCH. The current session ID is  determined by a call to getsid() for the process specified in pid equal to 0.</p>"},{"location":"docs/events/builtin/syscalls/getsid/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>pid_t</code> - the PID of the process whose session ID will be returned.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getsid/#available-tags","title":"Available Tags","text":"<p>N/A</p>"},{"location":"docs/events/builtin/syscalls/getsid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getsid/#sys_getsid","title":"sys_getsid","text":""},{"location":"docs/events/builtin/syscalls/getsid/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/getsid/#purpose","title":"Purpose","text":"<p>Enable more fine-grained tracing in the user and system level by tracing  through the process executed code.</p>"},{"location":"docs/events/builtin/syscalls/getsid/#example-use-case","title":"Example Use Case","text":"<p>Example of a use case for getsid would be implementing a process that  replaces the current session's leader process with a new one, or getting  the PID and session ID of newly created processes to ensure they were not  orphaned.</p>"},{"location":"docs/events/builtin/syscalls/getsid/#issues","title":"Issues","text":"<p>It needs to be monitored carefully when using getsid() on processes that  do not belong to the calling process\u2019s session in order to prevent malicious  actions such as hijacking of processes running in different sessions.</p>"},{"location":"docs/events/builtin/syscalls/getsid/#related-events","title":"Related Events","text":"<p>getpgid, setpgid, setsid</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getsockname/","title":"getsockname","text":""},{"location":"docs/events/builtin/syscalls/getsockname/#intro","title":"Intro","text":"<p>getsockname - get the name of the socket and the local address of a socket.</p>"},{"location":"docs/events/builtin/syscalls/getsockname/#description","title":"Description","text":"<p>The getsockname() function retrieves the current address to which the socket 'sockfd' is bound, and stores it in the sockaddr structure pointed to by the 'addr' argument. The 'addrlen' argument should be initialized to indicate the amount of space pointed to by 'addr'. On return it contains the actual size of the socket address.</p> <p>The getsockname() function provides the address of an unnamed socket, the address of a named socket that has not yet been bound to an address, or the address of a bound stream-oriented socket.</p> <p>There are not many advantages of using getsockname() over other socket functions, but one of the benefits is that a socket can be used to obtain the local address even before bind() is called.</p>"},{"location":"docs/events/builtin/syscalls/getsockname/#arguments","title":"Arguments","text":"<ul> <li><code>sockfd</code>:<code>int</code>[K] - Socket file descriptor.</li> <li><code>addr</code>:<code>struct sockaddr*</code>[U] - Pointer to a sockaddr type that will be filled with the local address. </li> <li><code>addrlen</code>:<code>int*</code>[U] - Pointer to the size of the sockaddr struct.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getsockname/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/getsockname/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getsockname/#sys_getsockname","title":"sys_getsockname","text":""},{"location":"docs/events/builtin/syscalls/getsockname/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/getsockname/#purpose","title":"Purpose","text":"<p>Trace calls to sys_getsockname to get information about the local address.</p>"},{"location":"docs/events/builtin/syscalls/getsockname/#example-use-case","title":"Example Use Case","text":"<p>This event can be used to monitor incoming and outgoing connections to a socket.</p>"},{"location":"docs/events/builtin/syscalls/getsockname/#issues","title":"Issues","text":"<p>This event may omit some addresses if they are not set yet, or if they are not bound to a socket yet.</p>"},{"location":"docs/events/builtin/syscalls/getsockname/#related-events","title":"Related Events","text":"<ul> <li>bind()</li> <li>connect()</li> <li>getpeername()</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getsockopt/","title":"getsockopt","text":""},{"location":"docs/events/builtin/syscalls/getsockopt/#intro","title":"Intro","text":"<p>getsockopt - Queries the state of a socket for the options associated with a given level.</p>"},{"location":"docs/events/builtin/syscalls/getsockopt/#description","title":"Description","text":"<p>The getsockopt() system call allows a program to determine the current value of an option associated with a socket. This call takes the socket descriptor, the level at which the option is defined, and the number of the option to be retrieved. The value of the option is returned in the buffer pointed to by the optval argument.</p> <p>There are a number of possible options, depending on the protocol, level and particular option requested. The optlen argument should be initialized to the size of the buffer associated with the optval argument, and modified on return to indicate the actual size of the value returned. If no option value is to be supplied or returned, optval and optlen should be NULL.</p> <p>Advantages of using getsockopt() include having a flexible and standards-compliant way to query a socket for the value of options associated with it. Likewise, drawbacks stem from being protocol- and implementation-dependent.</p>"},{"location":"docs/events/builtin/syscalls/getsockopt/#arguments","title":"Arguments","text":"<ul> <li><code>sockfd</code>:<code>int</code>[K] - Specifies a socket created with the socket() system call. </li> <li><code>level</code>:<code>int</code>[K] - Defines the protocol level at which the option resides. The supported levels include: SOL_SOCKET for options at the socket-level; IPPROTO_IP, IPPROTO_IPV6, IPPROTO_TCP, and IPPROTO_UDP for options at the IP, IPv6, TCP, and UDP levels respectively.</li> <li><code>optname</code>:<code>int</code>[K] - Defines the type of option. The available types of options depend on the particular protocol in use.</li> <li><code>optval</code>:<code>void*</code>[K] - Pointer to a buffer which is used to store the option value.</li> <li><code>optlen</code>:<code>int*</code>[K] - Size of the buffer provided in optval. It is modified on return to indicate the actual size of the option value stored in optval.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getsockopt/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getsockopt/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getsockopt/#sys_getsockopt","title":"sys_getsockopt","text":""},{"location":"docs/events/builtin/syscalls/getsockopt/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/getsockopt/#purpose","title":"Purpose","text":"<p>Hooked by ftrace to measure execution time and other performance data.</p>"},{"location":"docs/events/builtin/syscalls/getsockopt/#example-use-case","title":"Example Use Case","text":"<p>The getsockopt() system call is commonly used to retrieve information related to network communication, such as socket options, protocol information, and IP address binding.</p>"},{"location":"docs/events/builtin/syscalls/getsockopt/#issues","title":"Issues","text":"<p>No known issues with this system call.</p>"},{"location":"docs/events/builtin/syscalls/getsockopt/#related-events","title":"Related Events","text":"<p>Other socket-related system calls that may be related to getsockopt(): * socket() * bind() * connect() * accept()</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/gettid/","title":"gettid","text":""},{"location":"docs/events/builtin/syscalls/gettid/#intro","title":"Intro","text":"<p>gettid - return the caller's thread ID (TID)</p>"},{"location":"docs/events/builtin/syscalls/gettid/#description","title":"Description","text":"<p>gettid() returns the caller's thread ID.  On success, the thread ID of the calling thread is returned.  On  error,  (pid_t)-1 is returned, and errno is set to indicate the cause of the error.</p> <p>A thread ID is only guaranteed to be unique within a process.  There are no two threads in the same process whose thread IDs are the same.</p>"},{"location":"docs/events/builtin/syscalls/gettid/#arguments","title":"Arguments","text":"<ul> <li><code>None</code>:<code>N/A</code>[K] - gettid does not require any arguments</li> </ul>"},{"location":"docs/events/builtin/syscalls/gettid/#available-tags","title":"Available Tags","text":"<p>K - Originated from kernel-space.</p>"},{"location":"docs/events/builtin/syscalls/gettid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/gettid/#gettid_1","title":"gettid","text":""},{"location":"docs/events/builtin/syscalls/gettid/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/gettid/#purpose","title":"Purpose","text":"<p>To get information about the thread ID of the calling thread.</p>"},{"location":"docs/events/builtin/syscalls/gettid/#example-use-case","title":"Example Use Case","text":"<p>This event can be used in a multi-threaded program to get information about the threads running in the program.</p>"},{"location":"docs/events/builtin/syscalls/gettid/#issues","title":"Issues","text":"<p>None</p>"},{"location":"docs/events/builtin/syscalls/gettid/#related-events","title":"Related Events","text":"<p>getpid - return the caller's process ID</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/gettimeofday/","title":"gettimeofday","text":""},{"location":"docs/events/builtin/syscalls/gettimeofday/#intro","title":"Intro","text":"<p>gettimeofday - get the current time</p>"},{"location":"docs/events/builtin/syscalls/gettimeofday/#description","title":"Description","text":"<p>gettimeofday is a system call used to retrieve the current system time in seconds and microseconds. It allows an application to read the date and time stamp of the system and also to be notified of significant timers occurrences. The system time is used for managing resources such as network services or for evidence of user activities.</p> <p>The call supports two argument parameters, <code>tv</code> and <code>tz</code>, either of which may be <code>null</code>. The <code>tv</code> parameter provides the seconds and microseconds since the epoch, and the <code>tz</code> parameter is used to provide an additional time-zone information, which is required by some standards or rules.</p> <p>Edge cases of using this system call include potential race conditions in programs using this call, since the exact time of execution cannot be guaranteed when multiple processes are running.</p>"},{"location":"docs/events/builtin/syscalls/gettimeofday/#arguments","title":"Arguments","text":"<ul> <li><code>tv</code>:<code>struct timeval*</code>[U] - Pointer to a <code>struct timeval</code>, which will be filled with the time.</li> <li><code>tz</code>:<code>struct timezone*</code>[U] - Pointer to a <code>struct timezone</code>, which will be filled with the time zone information, or <code>null</code> if there is no need for this information.</li> </ul>"},{"location":"docs/events/builtin/syscalls/gettimeofday/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from the kernel-space.</li> <li>U - Originated from user-space (for example, a pointer to user-space memory used to get it).</li> </ul>"},{"location":"docs/events/builtin/syscalls/gettimeofday/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/gettimeofday/#sys_gettimeofday","title":"sys_gettimeofday","text":""},{"location":"docs/events/builtin/syscalls/gettimeofday/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/gettimeofday/#purpose","title":"Purpose","text":"<p>To trace the invocation of this function so that its timestamp, tz argument value and argument length information can be retrieved. </p>"},{"location":"docs/events/builtin/syscalls/gettimeofday/#example-use-case","title":"Example Use Case","text":"<p>An example use case for gettimeofday would be a social media platform using the system time to limit the frequency of notifications to users. By using gettimeofday, the platform can keep track of when a notification was sent in order to ensure that the user does not receive multiple notifications in a set amount of time.</p>"},{"location":"docs/events/builtin/syscalls/gettimeofday/#issues","title":"Issues","text":"<p>When using gettimeofday, it is important to note that although this syscall provides accurate and reliable results, it still may suffer from clock jitter due to the multicore systems and timer interruptions, causing the resulting time value to be inconsistent.</p>"},{"location":"docs/events/builtin/syscalls/gettimeofday/#related-events","title":"Related Events","text":"<ul> <li>settimeofday - sets the system date and time</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getuid/","title":"getuid","text":""},{"location":"docs/events/builtin/syscalls/getuid/#intro","title":"Intro","text":"<p>getuid - Retrieve user identity</p>"},{"location":"docs/events/builtin/syscalls/getuid/#description","title":"Description","text":"<p>This event retrieves the user identity of the calling process. This is usually the real user ID of the calling process, but may be changed to the effective user ID or saved user ID depending on the implementation of the calling process.</p> <p>The getuid event is useful for authentication of process and user identities in systems which require privilege separation. However, there are some potential drawbacks: it may not be possible to differentiate processes across userid boundaries, or between related userids in certain implementations.</p>"},{"location":"docs/events/builtin/syscalls/getuid/#arguments","title":"Arguments","text":"<p>no arguments</p>"},{"location":"docs/events/builtin/syscalls/getuid/#available-tags","title":"Available Tags","text":"<p>none</p>"},{"location":"docs/events/builtin/syscalls/getuid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getuid/#getuid_1","title":"getuid","text":""},{"location":"docs/events/builtin/syscalls/getuid/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/getuid/#purpose","title":"Purpose","text":"<p>For auditing, logging or tracing purposes, the getuid event can be used to monitor and log the user identity of a process.</p>"},{"location":"docs/events/builtin/syscalls/getuid/#example-use-case","title":"Example Use Case","text":"<p>The getuid event can be used to trace users who are using a program or an application in order to track the usage of the program.</p>"},{"location":"docs/events/builtin/syscalls/getuid/#issues","title":"Issues","text":"<p>The getuid event may not be able to differentiate between processes running with different userids in certain implementations.</p>"},{"location":"docs/events/builtin/syscalls/getuid/#related-events","title":"Related Events","text":"<ul> <li>geteuid - Retrieve effective user identity</li> <li>getresuid - Get real, effective and saved user identity</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getuid16/","title":"getuid16","text":""},{"location":"docs/events/builtin/syscalls/getuid16/#intro","title":"Intro","text":"<p>getuid16 - get the real user ID of the calling process</p>"},{"location":"docs/events/builtin/syscalls/getuid16/#description","title":"Description","text":"<p>The getuid16() system call returns the real user ID of the calling process. It may be used to check if the user has the appropriate privileges to perform certain operations. getuid16() and geteuid16() pair together in order to determine the effective and real user ID that the process is running under. There are no edge cases or drawbacks to using this system call, however, it is important to note that a process can only view the real user ID of itself, as opposed to other processes.</p>"},{"location":"docs/events/builtin/syscalls/getuid16/#arguments","title":"Arguments","text":"<ul> <li><code>void</code>: <code>void</code> - This system call takes no arguments.</li> </ul>"},{"location":"docs/events/builtin/syscalls/getuid16/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getuid16/#sys_getuid16","title":"sys_getuid16","text":""},{"location":"docs/events/builtin/syscalls/getuid16/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/getuid16/#purpose","title":"Purpose","text":"<p>To examine the processes that are making this system call.</p>"},{"location":"docs/events/builtin/syscalls/getuid16/#example-use-case","title":"Example Use Case","text":"<p>This system call can be used to check for certain privileges or access rights of the user in order to allow certain operations to be executed. For example, a web application could use this system call to check for the user ID of the currently logged in user and then determine if that user has permission to delete or modify certain content.</p>"},{"location":"docs/events/builtin/syscalls/getuid16/#issues","title":"Issues","text":"<p>There are no known issues with this system call.</p>"},{"location":"docs/events/builtin/syscalls/getuid16/#related-events","title":"Related Events","text":"<ul> <li>geteuid16 - get the effective user ID of the calling process</li> <li>setuid16 - set the real user ID and effective user ID of the calling process</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/getxattr/","title":"getxattr","text":""},{"location":"docs/events/builtin/syscalls/getxattr/#intro","title":"Intro","text":"<p>getxattr - retrieves the value of the extended attribute identified by name and associated with the given path in the file system.</p>"},{"location":"docs/events/builtin/syscalls/getxattr/#description","title":"Description","text":"<p>The getxattr() system call gets the value of an extended attribute identified by name and associated with the given path in the file system. It is intended to be a companion to the setxattr(2) system call, which sets extended attributes. </p> <p>There are a number of advantages and edge-cases to using getxattr(). One major advantage is that extended attributes can store data not defined by standard file attributes, such as security labels and access control lists, and more. Furthermore, the value and size of an extended attribute may change from one call to the next, with certain flags and options. This makes getxattr() a useful tool for implementing certain security schemes that require precise control over data.</p> <p>A potential issue with using getxattr() is that it is vulnerable to Time of Check to Time of Use (TOCTOU) race conditions, which can be problematic for security-enhanced applications.</p>"},{"location":"docs/events/builtin/syscalls/getxattr/#arguments","title":"Arguments","text":"<ul> <li><code>path</code>:<code>const char*</code>[KU] - the relative or absolute path name of the file or directory.</li> <li><code>name</code>:<code>const char*</code>[KU] - the name of the attribute to retrieve.</li> <li><code>value</code>:<code>void*</code>[K] - a buffer to store the attribute's value.</li> <li><code>size</code>:<code>size_t</code>[K] - the size of the buffer (size of the attribute's value).</li> </ul>"},{"location":"docs/events/builtin/syscalls/getxattr/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/getxattr/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/getxattr/#getxattr_1","title":"getxattr","text":""},{"location":"docs/events/builtin/syscalls/getxattr/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/getxattr/#purpose","title":"Purpose","text":"<p>To monitor and audit when getxattr() system calls occur and what their associated arguments are.</p>"},{"location":"docs/events/builtin/syscalls/getxattr/#example-use-case","title":"Example Use Case","text":"<p>getxattr() can be used to determine the value of security labels or access control lists on files and directories. This is often necessary for implementing robust security systems for applications that must maintain the integrity of the data on the system.</p>"},{"location":"docs/events/builtin/syscalls/getxattr/#issues","title":"Issues","text":"<p>getxattr() is vulnerable to TOCTOU race conditions, which can result in unintended side-effects if not handled correctly.</p>"},{"location":"docs/events/builtin/syscalls/getxattr/#related-events","title":"Related Events","text":"<p>setxattr(2)</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/gtty/","title":"gtty","text":""},{"location":"docs/events/builtin/syscalls/gtty/#intro","title":"Intro","text":"<p>gtty - Set or get terminal attributes</p>"},{"location":"docs/events/builtin/syscalls/gtty/#description","title":"Description","text":"<p>The gtty syscall is used to enable/disable certain terminal attributes. This includes toggling echoing of typed characters, the end-of-line behavior and special control characters. Additionally, these attributes can be set for the controlling terminal as well.</p> <p>The syscall also allows querying current terminal attributes. This can be useful for some applications to determine the current state of the terminal and set the same for the output.</p>"},{"location":"docs/events/builtin/syscalls/gtty/#arguments","title":"Arguments","text":"<p>No arguments</p>"},{"location":"docs/events/builtin/syscalls/gtty/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/gtty/#gtty_1","title":"gtty","text":""},{"location":"docs/events/builtin/syscalls/gtty/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/gtty/#purpose","title":"Purpose","text":"<p>To monitor the manipulation of terminal parameters.</p>"},{"location":"docs/events/builtin/syscalls/gtty/#example-use-case","title":"Example Use Case","text":"<p>An application that uses several terminal attributes, like an ANSI escape sequence enabled terminal emulator. By using gtty, these terminal parameters can be applied to the terminal to ensure a correct display.</p>"},{"location":"docs/events/builtin/syscalls/gtty/#issues","title":"Issues","text":"<p>There are no known issues with this syscall.</p>"},{"location":"docs/events/builtin/syscalls/gtty/#related-events","title":"Related Events","text":"<ul> <li>stty: Set or get terminal attributes</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/idle/","title":"idle","text":""},{"location":"docs/events/builtin/syscalls/idle/#intro","title":"Intro","text":"<p>idle - the system call for resource de-allocation in kernel scheduling.</p>"},{"location":"docs/events/builtin/syscalls/idle/#description","title":"Description","text":"<p>The idle system call allows an application or processes to de-allocate CPU resources. The kernel scheduler can be instructed to keep the CPU available to process other threads without the application or process being interrupted. It is a blocking call and therefore can result in improved performance as it frees up resources to be used elsewhere. Using the idle system call may result in improved responsiveness, lower power consumption and better system utilization.</p>"},{"location":"docs/events/builtin/syscalls/idle/#arguments","title":"Arguments","text":"<p>No arguments are provided for this system call.</p>"},{"location":"docs/events/builtin/syscalls/idle/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/idle/#idle_1","title":"idle","text":""},{"location":"docs/events/builtin/syscalls/idle/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/idle/#purpose","title":"Purpose","text":"<p>To detect when an application or process de-allocates CPU resources.</p>"},{"location":"docs/events/builtin/syscalls/idle/#example-use-case","title":"Example Use Case","text":"<p>Idle can be used for monitoring in a variety of different contexts. It can be used to detect and understand general resource allocation and de-allocation behavior, as well as to look out for applications or processes utilizing too much CPU resources. It might also be used to monitor programs for unexpected CPU utilization, or to detect when an application is stalled for some reason.</p>"},{"location":"docs/events/builtin/syscalls/idle/#issues","title":"Issues","text":"<p>The idle system call may result in higher power consumption as it allows unneeded processes to keep running instead of being interrupted. This can be especially true when lower latency is needed, as the scheduler cannot pre-empt or adjust the process or application as it would with pre-emption.</p>"},{"location":"docs/events/builtin/syscalls/idle/#related-events","title":"Related Events","text":"<ul> <li><code>wait</code>: System call which allows a process to suspend execution until a certain condition is met.</li> <li><code>setpriority</code>: System call that allows a process to modify its scheduling priority.</li> <li><code>sched_yield</code>: System call to voluntarily relinquish the processor.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/init_module/","title":"init_module","text":""},{"location":"docs/events/builtin/syscalls/init_module/#intro","title":"Intro","text":"<p>init_module - loads a kernel module into the kernel</p>"},{"location":"docs/events/builtin/syscalls/init_module/#description","title":"Description","text":"<p>The <code>init_module</code> system call is used to initiate (load) a kernel module into kernel memory. The module itself is provided in the form of a binary image pointed to by <code>module_image</code>, and its size is specified in bytes through the <code>len</code> argument. Additionally, any parameters that need to be passed to the module at initialization may be specified via the <code>param_values</code> argument. </p> <p>Using this system call enables users to extend the kernel's functionality with the use of kernel modules. However, users must be aware of any potential issues with loading and executing a module, as well as any compatibility issues should the module not be designed for the kernel version being used.</p>"},{"location":"docs/events/builtin/syscalls/init_module/#arguments","title":"Arguments","text":"<ul> <li><code>module_image</code>:<code>void*</code>[U] - A pointer to the binary image of the module to load. Must have been allocated through dynamic memory allocation.</li> <li><code>len</code>:<code>unsigned long</code>[K] - The size in bytes of the binary image of the module being loaded.</li> <li><code>param_values</code>:<code>const char*</code>[U] - Pointer to a buffer containing the parameters for the module as a single string. </li> </ul>"},{"location":"docs/events/builtin/syscalls/init_module/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/init_module/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/init_module/#sys_init_module","title":"sys_init_module","text":""},{"location":"docs/events/builtin/syscalls/init_module/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/init_module/#purpose","title":"Purpose","text":"<p>This function is hooked in order to record module initialization parameters.</p>"},{"location":"docs/events/builtin/syscalls/init_module/#example-use-case","title":"Example Use Case","text":"<p>Recording any kernel module initialization parameters can be useful in analyzing rootkit or malicious code infections that may occur in the kernel. </p>"},{"location":"docs/events/builtin/syscalls/init_module/#issues","title":"Issues","text":"<p>Since kernel-space operations are generally privileged, any malicious or unauthorized additions to the kernel may be difficult to detect if this system call is used.</p>"},{"location":"docs/events/builtin/syscalls/init_module/#related-events","title":"Related Events","text":"<ul> <li>delete_module - to unload a kernel module.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/inotify_add_watch/","title":"inotify_add_watch","text":""},{"location":"docs/events/builtin/syscalls/inotify_add_watch/#intro","title":"Intro","text":"<p>inotify_add_watch - add watch for an open inotify instance</p>"},{"location":"docs/events/builtin/syscalls/inotify_add_watch/#description","title":"Description","text":"<p>inotify_add_watch is a system call used to watch a given file or directory for certain events. It will return a watch descriptor that identifies the watch instance. This descriptor is used as an argument for other functions that manipulate the watch instance. Events such as changes in access time, modification time, deletion and close- write operations will trigger notifications. With this system call, the user can specify different types of events that should be monitored.</p>"},{"location":"docs/events/builtin/syscalls/inotify_add_watch/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - the file descriptor associated with an open inotify instance</li> <li><code>pathname</code>:<code>const char*</code>[U] - the path to the file or directory to watch</li> <li><code>mask</code>:<code>u32</code>[K] - a bit mask of events to watch for</li> </ul>"},{"location":"docs/events/builtin/syscalls/inotify_add_watch/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/inotify_add_watch/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/inotify_add_watch/#do_inotify_add_watch","title":"do_inotify_add_watch","text":""},{"location":"docs/events/builtin/syscalls/inotify_add_watch/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/inotify_add_watch/#purpose","title":"Purpose","text":"<p>This function is used to hook inotify_add_watch in order to obtain notifications when a new watch is registered.</p>"},{"location":"docs/events/builtin/syscalls/inotify_add_watch/#example-use-case","title":"Example Use Case","text":"<p>inotify_add_watch could be used to detect access attempts to certain sensitive files on a system. Whenever the file is accessed, a notification will be sent to the user, allowing them to take appropriate action.</p>"},{"location":"docs/events/builtin/syscalls/inotify_add_watch/#issues","title":"Issues","text":"<p>Due to the asynchronous nature of inotify_add_watch, there is potential for a race condition when multiple watches are registered on the same file concurrently. Care must be taken to ensure that concurrent update operations don't make use of inconsistent data.</p>"},{"location":"docs/events/builtin/syscalls/inotify_add_watch/#related-events","title":"Related Events","text":"<ul> <li>inotify_rm_watch - remove watch associated with a given inotify instance associated with given file descriptor</li> <li>inotify_get_events - read the pending events on an inotify file descriptor</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/inotify_init/","title":"inotify_init","text":""},{"location":"docs/events/builtin/syscalls/inotify_init/#intro","title":"Intro","text":"<p>inotify_init -  creates and initializes an inotify event queue</p>"},{"location":"docs/events/builtin/syscalls/inotify_init/#description","title":"Description","text":"<p>The inotify_init() system call is used to create an inotify event queue. Inotify event queues allow processes to monitor the file system for changes such as files being opened, deleted, or modified. Any process that has initiated a monitoring operation can be notified asynchronously when a monitored event occurs. </p> <p>Inotify event queues are global and persist until explicitly closed by the process that created them;  thus, inotify provides a means for tracking file changes across multiple processes. It is also useful for many other purposes such as detecting when a file is modified, deleted, or renamed. </p> <p>One of the advantages of using inotify is that it is easy to set up and monitor events in multiple locations; however, its biggest drawback is that it can be quite CPU and I/O intensive as it is eagerly waiting for file system changes.</p>"},{"location":"docs/events/builtin/syscalls/inotify_init/#arguments","title":"Arguments","text":"<ul> <li><code>flags</code>: <code>int</code> - Flags from inotify_init.</li> </ul>"},{"location":"docs/events/builtin/syscalls/inotify_init/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/inotify_init/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/inotify_init/#do_sys_open","title":"do_sys_open","text":""},{"location":"docs/events/builtin/syscalls/inotify_init/#type","title":"Type","text":"<p>kprobes</p>"},{"location":"docs/events/builtin/syscalls/inotify_init/#purpose","title":"Purpose","text":"<p>To track the opening of files.</p>"},{"location":"docs/events/builtin/syscalls/inotify_init/#sys_inotify_init","title":"sys_inotify_init","text":""},{"location":"docs/events/builtin/syscalls/inotify_init/#type_1","title":"Type","text":"<p>kprobes</p>"},{"location":"docs/events/builtin/syscalls/inotify_init/#purpose_1","title":"Purpose","text":"<p>To track the inotify_init syscall.</p>"},{"location":"docs/events/builtin/syscalls/inotify_init/#example-use-case","title":"Example Use Case","text":"<p>A use case for inotify might be tracking whether a specific list of files has been modified. A process can call inotify_init, then loop through the list of files and add a watch for each, then wait on the inotify event queue to be notified that a listed file has been modified. </p>"},{"location":"docs/events/builtin/syscalls/inotify_init/#issues","title":"Issues","text":"<p>Certain kernel features may cause inotify to miss events or provide false positives. For example, the kernel may prefetch files, set modification times, and provide optimistic file reads, all of which can lead to unexpected notifications.</p>"},{"location":"docs/events/builtin/syscalls/inotify_init/#related-events","title":"Related Events","text":"<ul> <li>inotify_add_watch \u2013 adds a watch to an existing inotify event queue</li> <li>inotify_rm_watch \u2013 removes a watch from an existing inotify event queue</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/inotify_init1/","title":"inotify_init1","text":""},{"location":"docs/events/builtin/syscalls/inotify_init1/#intro","title":"Intro","text":"<p>inotify_init1 - create and initialize an inotify instance</p>"},{"location":"docs/events/builtin/syscalls/inotify_init1/#description","title":"Description","text":"<p><code>inotify_init1</code> is a system call that is used to create and initialize an inotify instance. It has one parameter, flags, which is used to pass flags for modifying the behavior of the inotify instance. If the flags are 0, then the instances is initialized with the default behavior.</p> <p>The inotify API provides a mechanism for monitoring file system events. Inotify supports watching a single file, a directory tree, or recursively all subdirectories.</p> <p>There are some drawbacks to using inotify API. For example, if an application is monitoring a lot of files or directories, then it may require a large amount of memory and kernel resources, as well as negatively impact the performance. Additionally, if too many watches are set up, the kernel may run out of inotify resources and fail the system call.</p>"},{"location":"docs/events/builtin/syscalls/inotify_init1/#arguments","title":"Arguments","text":"<ul> <li><code>flags</code>:<code>int</code>[K] - flags that are used to modify the behavior of the inotify instance.</li> </ul>"},{"location":"docs/events/builtin/syscalls/inotify_init1/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/inotify_init1/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/inotify_init1/#inotify_init1_1","title":"inotify_init1","text":""},{"location":"docs/events/builtin/syscalls/inotify_init1/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/inotify_init1/#purpose","title":"Purpose","text":"<p>To monitor when inotify_init1 is called and for what flags values.</p>"},{"location":"docs/events/builtin/syscalls/inotify_init1/#example-use-case","title":"Example Use Case","text":"<p>Inotify API can be used to monitor file system events. For example, an application can detect when a file is modified, renamed, or deleted.</p>"},{"location":"docs/events/builtin/syscalls/inotify_init1/#issues","title":"Issues","text":"<p>Due to the large memory and kernel resources requirements, large numbers of watches can adversely affect the performance of the system. Additionally, if too many watches are set up, the kernel may run out of inotify resources and fail the system call.</p>"},{"location":"docs/events/builtin/syscalls/inotify_init1/#related-events","title":"Related Events","text":"<ul> <li><code>inotify_add_watch</code> - add a file or directory watch to an inotify instance</li> <li><code>inotify_rm_watch</code> - remove a file or directory watch from an inotify instance</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/inotify_rm_watch/","title":"Inotify_rm_watch","text":""},{"location":"docs/events/builtin/syscalls/inotify_rm_watch/#intro","title":"Intro","text":"<p>inotify_rm_watch - remove an existing watch on a file system object</p>"},{"location":"docs/events/builtin/syscalls/inotify_rm_watch/#description","title":"Description","text":"<p>Inotify_rm_watch is a system call that removes existing watches on a file system object, specified by the watch descriptor <code>wd</code> created by the call <code>inotify_add_watch</code> for the file system object associated with the file descriptor <code>fd</code>.</p> <p>Inotify_rm_watch does not change the reference count of the file system object, so if a watch is removed for an object for twice, the object is still watched after the second <code>inotify_rm_watch</code> system call.</p>"},{"location":"docs/events/builtin/syscalls/inotify_rm_watch/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>: <code>int</code>[K] - file descriptor associated to the filesystem object.</li> <li><code>wd</code>: <code>int</code>[K] - watch descriptor created by the call <code>inotify_add_watch</code> for the file system object associated with the file descriptor <code>fd</code>.</li> </ul>"},{"location":"docs/events/builtin/syscalls/inotify_rm_watch/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/inotify_rm_watch/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/inotify_rm_watch/#inotify_rm_watch_1","title":"inotify_rm_watch","text":""},{"location":"docs/events/builtin/syscalls/inotify_rm_watch/#type","title":"Type","text":"<p>Kprobes + Kretprobes</p>"},{"location":"docs/events/builtin/syscalls/inotify_rm_watch/#purpose","title":"Purpose","text":"<p>Used to identify calls to the system call <code>inotify_rm_watch</code>. Used for applications that are performing malicious operations on files or directories.</p>"},{"location":"docs/events/builtin/syscalls/inotify_rm_watch/#example-use-case","title":"Example Use Case","text":"<p>Inotify_rm_watch can be used in a security system that keeps tracks on all changes in a directory. The system can set a watch on a directory and track the changes of all files and sub directories. Whenever a new file is created or a existing file is modified, the system can take the appropriate actions.</p>"},{"location":"docs/events/builtin/syscalls/inotify_rm_watch/#issues","title":"Issues","text":"<p>There is currently no known issues with this event.</p>"},{"location":"docs/events/builtin/syscalls/inotify_rm_watch/#related-events","title":"Related Events","text":"<ul> <li><code>inotify_add_watch</code> - used to add watch on a filesystem object.</li> <li><code>inotify_init</code> - used to initialize an inotify instance.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/io_cancel/","title":"io_cancel","text":""},{"location":"docs/events/builtin/syscalls/io_cancel/#intro","title":"Intro","text":"<p>io_cancel() - cancels asynchronously submitted I/O operations</p>"},{"location":"docs/events/builtin/syscalls/io_cancel/#description","title":"Description","text":"<p>io_cancel() cancels asynchronous I/O operations previously submitted using the io_submit() system call or other related system calls. The ctx_id argument specifies the I/O context from which cancellations are done. This argument must point to an existing I/O context which must initially be obtained using the io_setup() system call. The iocb argument points to the I/O control block previously submitted for the corresponding I/O operation which should be cancelled. Finally, the result argument, if non NULL, points to a struct io_event structure which will be written to with the results of the cancelled op. If NULL is passed as the result argument, this indicates that no results should be returned.</p> <p>This call is useful when attempting to cancel previously-submitted I/O operations; however, since the I/O operations are already in progress, some operations may complete before being cancelled. Therefore, it is possible that some I/O operations may return even after this call. If this behaviour is undesired, an application should use the io_getevents() system call with a timeout of 0 and/or a small number of events to drain completed I/O operations before calling io_cancel().</p>"},{"location":"docs/events/builtin/syscalls/io_cancel/#arguments","title":"Arguments","text":"<ul> <li><code>ctx_id</code>:<code>io_context_t</code> - the I/O context from which cancellations are done</li> <li><code>iocb</code>:<code>struct iocb*</code> - pointer to the I/O control block previously submitted for an I/O operation</li> <li><code>result</code>:<code>struct io_event*</code>[OPT] - pointer to the<code>struct io_event</code> structure which will be written to with the results of the cancelled op.</li> </ul>"},{"location":"docs/events/builtin/syscalls/io_cancel/#available-tags","title":"Available Tags","text":"<p>K - Originated from kernel-space. U - Originated from user space (for example, pointer to user space memory used to get it)</p>"},{"location":"docs/events/builtin/syscalls/io_cancel/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/io_cancel/#do_io_cancel","title":"do_io_cancel()","text":""},{"location":"docs/events/builtin/syscalls/io_cancel/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/io_cancel/#purpose","title":"Purpose","text":"<p>Hooked to capture instances of the io_cancel() syscall.</p>"},{"location":"docs/events/builtin/syscalls/io_cancel/#example-use-case","title":"Example Use Case","text":"<p>The io_cancel() syscall can be used to cancel asynchronous I/O operations that have already been submitted, allowing the application to reclaim resources and/or abort operations that are no longer necessary.</p>"},{"location":"docs/events/builtin/syscalls/io_cancel/#issues","title":"Issues","text":"<p>It is possible that some I/O operations may return even after the io_cancel() syscall. If this behaviour is undesired, an application should use the io_getevents() system call with a timeout of 0 and/or a small number of events to drain completed I/O operations before calling io_cancel().</p>"},{"location":"docs/events/builtin/syscalls/io_cancel/#related-events","title":"Related Events","text":"<ul> <li>io_submit()</li> <li>io_setup()</li> <li>io_getevents()</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/io_destroy/","title":"io_destroy","text":""},{"location":"docs/events/builtin/syscalls/io_destroy/#intro","title":"Intro","text":"<p>'io_destroy' - destroys an io_context.</p>"},{"location":"docs/events/builtin/syscalls/io_destroy/#description","title":"Description","text":"<p>The io_destroy() system call function is used to destroy the io_context structure and free operation associated with it. The io_context structure may be freed after all operations have finished executing. The return value specified the remaining number of IO contexts associated with this context_fd number. </p> <p>Generally this syscall is useful when multiple threads, or processes, require service from an asynchronous IO context and the context needs to be destroyed once the operations have completed. It's also possible to use this call with a NULL context_fd, which will temporarily suspend all operations associated with the current context.</p>"},{"location":"docs/events/builtin/syscalls/io_destroy/#arguments","title":"Arguments","text":"<ul> <li><code>ctx_id</code>:<code>io_context_t</code>[KU] - a pointer to an existing io context structure. </li> </ul>"},{"location":"docs/events/builtin/syscalls/io_destroy/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/io_destroy/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/io_destroy/#io_destroy_1","title":"io_destroy","text":""},{"location":"docs/events/builtin/syscalls/io_destroy/#type","title":"Type","text":"<p>Kprobe </p>"},{"location":"docs/events/builtin/syscalls/io_destroy/#purpose","title":"Purpose","text":"<p>Trace asynchronous io operations.</p>"},{"location":"docs/events/builtin/syscalls/io_destroy/#example-use-case","title":"Example Use Case","text":"<p>Tracking the progress of an asynchronous IO operation, or group of IO operations, from start to completion.</p>"},{"location":"docs/events/builtin/syscalls/io_destroy/#issues","title":"Issues","text":"<p>No known issues.</p>"},{"location":"docs/events/builtin/syscalls/io_destroy/#related-events","title":"Related Events","text":"<ul> <li>io_submit</li> <li>io_cancel</li> <li>io_getevents</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/io_getevents/","title":"io_getevents","text":""},{"location":"docs/events/builtin/syscalls/io_getevents/#intro","title":"Intro","text":"<p>io_getevents - system call which get events from the completion queue</p>"},{"location":"docs/events/builtin/syscalls/io_getevents/#description","title":"Description","text":"<p>io_getevents() is a system call which can be used to retrieve events from the completion queue of specified <code>io_context_t</code> context, identified by ctx_id, if there was something written to the completion queue by an <code>io_io_submit</code> call. The number of events reads from the completion queue is equal to the returned <code>long</code> number, nr, which is equal to the requested maximum nr, or less if the queue doesn't have enough events. The <code>min_nr</code> parameter is the minimum number of events which should be available in the queue, else the call will be blocked. The <code>events</code> array will be filled with the events from the completion queue, or it will be allocated if the <code>events</code> parameter is null. Timeout will specify the time in which the call should finish, otherwise io_getevents will fail.  </p>"},{"location":"docs/events/builtin/syscalls/io_getevents/#arguments","title":"Arguments","text":"<ul> <li><code>ctx_id</code>:<code>io_context_t</code>[K] - io context which will hold the completion queue. </li> <li><code>min_nr</code>:<code>long</code>[K] - minimum number of events which should be available in the completion queue.</li> <li><code>nr</code>:<code>long</code>[K] - maximum number of events which should be read from the completion queue. </li> <li><code>events</code>:<code>struct io_event*</code>[KU] - array which should be filled with the events from the completion queue. If the argument is null, the array will be allocated.</li> <li><code>timeout</code>:<code>struct timespec*</code>[K] - time in which the call should finish. </li> </ul>"},{"location":"docs/events/builtin/syscalls/io_getevents/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/io_getevents/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/io_getevents/#io_getevents_1","title":"io_getevents","text":""},{"location":"docs/events/builtin/syscalls/io_getevents/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/io_getevents/#purpose","title":"Purpose","text":"<p>Tracing the io_getevents syscall, with the goal of monitoring its behaviour.</p>"},{"location":"docs/events/builtin/syscalls/io_getevents/#example-use-case","title":"Example Use Case","text":"<p>If a user needs to track when io_getevents is called, the io_getevents event is the ideal solution. It will provide information about the syscall such as parameters and duration. This is useful for monitoring low level kernel behavior or for performance analysis.</p>"},{"location":"docs/events/builtin/syscalls/io_getevents/#issues","title":"Issues","text":"<p>If the <code>events</code> array is allocated in the user space, it could trigger a TOCTOU attack.</p>"},{"location":"docs/events/builtin/syscalls/io_getevents/#related-events","title":"Related Events","text":"<ul> <li><code>io_submit</code> - This syscall is related to <code>io_getevents</code>, since its responsible for writing to the completion queue which is read by <code>io_getevents</code>.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/io_pgetevents/","title":"<code>io_pgetevents</code>","text":""},{"location":"docs/events/builtin/syscalls/io_pgetevents/#intro","title":"Intro","text":"<p><code>io_pgetevents</code> - retrieves at least min_nr and at most nr of completed and ready aio operations</p>"},{"location":"docs/events/builtin/syscalls/io_pgetevents/#description","title":"Description","text":"<p>The <code>io_pgetevents</code> syscall retrieves at least <code>min_nr</code> and at most <code>nr</code> of completed and ready aio operations (submitted via <code>io_submit</code>) and up to <code>nr</code> jopbs wich have been canceled. The operations are identified by <code>ctx_id</code> - the AIO context which contains them.</p> <p><code>events</code> is a pointer to an array of <code>io_event</code> structures - to which the completed/ready events' results will be stored. <code>timeout</code> specifies a timeout which limits the amount of time this call will block. <code>usig</code> can be used to request a signal to be sent when ready/completed events are available.</p> <p>The buffers which were submitted with <code>io_submit</code> must not be changed until <code>io_pgetevents</code> is finished.</p>"},{"location":"docs/events/builtin/syscalls/io_pgetevents/#arguments","title":"Arguments","text":"<ul> <li><code>ctx_id</code>:<code>aio_context_t</code> - The aio context which contains the operations to be retrieved.</li> <li><code>min_nr</code>:<code>long</code> - The minimum amount of operations to retrieve. If less than this amount of operations are available, the call will block until the desired amount is ready.</li> <li><code>nr</code>:<code>long</code> - The maximum amount of operations to retrieve.</li> <li><code>events</code>:<code>struct io_event*</code>[K] - A pointer to an array of <code>io_event</code> structures, to be filled in with the operations' results.</li> <li><code>timeout</code>:<code>struct timespec*</code>[K] - A timeout value - the call will block no longer than this.</li> <li><code>usig</code>:<code>const struct __aio_sigset*</code>[K] - A pointer to an <code>__aio_sigset</code> structure which specifies an optional signal to be sent when events become available.</li> </ul>"},{"location":"docs/events/builtin/syscalls/io_pgetevents/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/io_pgetevents/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/io_pgetevents/#sys_io_pgetevents","title":"<code>sys_io_pgetevents</code>","text":""},{"location":"docs/events/builtin/syscalls/io_pgetevents/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/io_pgetevents/#purpose","title":"Purpose","text":"<p>Analyze and profile AIO  operations in order to debug and improve system performance.</p>"},{"location":"docs/events/builtin/syscalls/io_pgetevents/#example-use-case","title":"Example Use Case","text":"<p>An application utilizing AIO operations needs to be tested in order to find out if there are any issues with operation latency or the amount of calls with the same arguments. Using <code>io_pgetevents</code> in conjunction with a tracing software to retrieve AIO operation data can help identify issues and improve performance.</p>"},{"location":"docs/events/builtin/syscalls/io_pgetevents/#issues","title":"Issues","text":"<p>Care must be taken with arguments which might change between the time they are checked (\"time of check\") and the time they are used (\"time of use\"), as they might result in errors.</p>"},{"location":"docs/events/builtin/syscalls/io_pgetevents/#related-events","title":"Related Events","text":"<ul> <li><code>io_submit</code> - Submitting AIO operations</li> <li><code>io_cancel</code> - Cancel AIO operations</li> <li><code>aio_sigset</code> - Update aio code's signal settings.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/io_pgetevents_time32/","title":"io_pgetevents_time32","text":""},{"location":"docs/events/builtin/syscalls/io_pgetevents_time32/#intro","title":"Intro","text":"<p>io_pgetevents_time32 - syscall to retrieve data from an I/O controller</p>"},{"location":"docs/events/builtin/syscalls/io_pgetevents_time32/#description","title":"Description","text":"<p>This system call reads (with a timeout) events generated by an I/O controller. The platforms that support this system call are x86-64,  arm64 and ia64. </p> <p>The timeout argument sets an upper bound on the amount of time that the call will block. Setting the timeout to <code>NULL</code> makes the call block until an event is generated. Data of the event is written  into the struct <code>io_event_t</code> which is passed to this call.</p>"},{"location":"docs/events/builtin/syscalls/io_pgetevents_time32/#arguments","title":"Arguments","text":"<ul> <li><code>ctx</code>: <code>struct iocb *</code>[U] - pointer to an array of  <code>io_context_t</code> structures. </li> <li><code>nr</code>: <code>long</code>[U] - number of events requested.</li> <li><code>events</code>: <code>struct io_event_t *</code>[U] - pointer to an array of <code>io_event_t</code> structures.</li> <li><code>timeout</code>: <code>struct timespec *</code>[U, TOCTOU] - pointer to a <code>timespec</code> structure.</li> </ul>"},{"location":"docs/events/builtin/syscalls/io_pgetevents_time32/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/io_pgetevents_time32/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/io_pgetevents_time32/#sys_io_pgetevents_time32","title":"sys_io_pgetevents_time32","text":""},{"location":"docs/events/builtin/syscalls/io_pgetevents_time32/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/io_pgetevents_time32/#purpose","title":"Purpose","text":"<p>To trace all invocation of <code>io_pgetevents_time32</code> and get the context of each invocation.</p>"},{"location":"docs/events/builtin/syscalls/io_pgetevents_time32/#example-use-case","title":"Example Use Case","text":"<p>This system call can be used to test the responsiveness of a tracee. For example, when checking if a given process is unresponsive or hangs.</p>"},{"location":"docs/events/builtin/syscalls/io_pgetevents_time32/#issues","title":"Issues","text":"<p>This system call is vulnerable to Time Of Check/Time Of Use (TOCTOU) race conditions. </p>"},{"location":"docs/events/builtin/syscalls/io_pgetevents_time32/#related-events","title":"Related Events","text":"<ul> <li>io_destroy - destroys an I/O context assigned to a user</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/io_setup/","title":"io_setup","text":""},{"location":"docs/events/builtin/syscalls/io_setup/#intro","title":"Intro","text":"<p>io_setup - sets up a new asynchronous I/O context</p>"},{"location":"docs/events/builtin/syscalls/io_setup/#description","title":"Description","text":"<p>The io_setup() system call prepares the data structures and initialization for subsequent use of asynchronous I/O operations. It creates a new asyncronous I/O context with the value nr_events being the maximum number of expected events to be queued for this context. ctx_idp is an output parameter that has null at the start and is assigned to the identifier of the AIO context created.</p>"},{"location":"docs/events/builtin/syscalls/io_setup/#arguments","title":"Arguments","text":"<ul> <li><code>nr_events</code>: <code>unsigned int</code> - Maximum number of expected event requests to be queued for this context.</li> <li><code>ctx_idp</code>: <code>io_context_t *</code>[U] - Address to store the identifier of the created AIO context.</li> </ul>"},{"location":"docs/events/builtin/syscalls/io_setup/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/io_setup/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/io_setup/#do_io_setup","title":"do_io_setup","text":""},{"location":"docs/events/builtin/syscalls/io_setup/#type","title":"Type","text":"<p>Kprobes </p>"},{"location":"docs/events/builtin/syscalls/io_setup/#purpose","title":"Purpose","text":"<p>Used to identify when a new asynchronous I/O context is being set up</p>"},{"location":"docs/events/builtin/syscalls/io_setup/#example-use-case","title":"Example Use Case","text":"<p>The io_setup system call can be used in order to monitor the start of new asynchronous I/O operations.</p>"},{"location":"docs/events/builtin/syscalls/io_setup/#issues","title":"Issues","text":"<p>None</p>"},{"location":"docs/events/builtin/syscalls/io_setup/#related-events","title":"Related Events","text":"<p>io_submit, io_cancel, io_destroy</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/io_submit/","title":"io_submit","text":""},{"location":"docs/events/builtin/syscalls/io_submit/#intro","title":"Intro","text":"<p>io_submit - submit I/O request(s) to an io_context</p>"},{"location":"docs/events/builtin/syscalls/io_submit/#description","title":"Description","text":"<p>io_submit requests the kernel to perform I/O specified in the given iocb array, which is a list of I/O request blocks. All the I/O operations occur in the given context. This can be used to submit multiple I/O operations within a single system call, reducing the overhead of invoking a system call for each I/O operation. </p> <p>The I/O request list may contain I/O operations on different types of files such as regular files, pipes, block devices, etc. However, it is circular in nature and any links pointing outside the given context must not be followed, since the context stores only the local file descriptors.</p> <p>Although this syscall is usually considered less error-prone than other syscalls that require manual memory management in the user space, it can be vulnerable to Time Of Check-Time Of Use (TOCTOU) attacks on the io_context_t structure. If a race condition exists between the io_context_t structure copying in the user space and the corresponding io_context_t structure's modification in the kernel space, an attacker can exploit this vulnerability to get the system call to fail.</p>"},{"location":"docs/events/builtin/syscalls/io_submit/#arguments","title":"Arguments","text":"<ul> <li><code>ctx_id</code>:<code>io_context_t</code>[K] - This is an opaque context structure which is used to send multiple I/O operations within a single system call. </li> <li><code>nr</code>:<code>long</code>[K] - This is the number of elements in the iocbpp array. </li> <li><code>iocbpp</code>:<code>struct iocb**</code>[K] - This is the array of iocb structures which define the I/O operations to be performed.</li> </ul>"},{"location":"docs/events/builtin/syscalls/io_submit/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/io_submit/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/io_submit/#cond_resched","title":"cond_resched","text":""},{"location":"docs/events/builtin/syscalls/io_submit/#type","title":"Type","text":"<p>NONE</p>"},{"location":"docs/events/builtin/syscalls/io_submit/#purpose","title":"Purpose","text":"<p>To prevent unbounded execution in kernel space.</p>"},{"location":"docs/events/builtin/syscalls/io_submit/#example-use-case","title":"Example Use Case","text":"<p>One example use case of io_submit is to submit multiple read requests to the kernel in one system call. This reduces the overhead of invoking a system call for each read operation, thereby improving the performance of the program.</p>"},{"location":"docs/events/builtin/syscalls/io_submit/#issues","title":"Issues","text":"<p>No known issues.</p>"},{"location":"docs/events/builtin/syscalls/io_submit/#related-events","title":"Related Events","text":"<ul> <li>io_prep_pwrite</li> <li>io_cancel</li> <li>io_getevents</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/io_uring_enter/","title":"io_uring_enter","text":""},{"location":"docs/events/builtin/syscalls/io_uring_enter/#intro","title":"Intro","text":"<p>io_uring_enter - a system call that submits and optionally waits on a set of I/O operations</p>"},{"location":"docs/events/builtin/syscalls/io_uring_enter/#description","title":"Description","text":"<p>The io_uring_enter system call allows processes to perform I/O operations and optionally wait for their completion. This call combines the submission of a set of I/O operations with the ability to wait on them without making additional system calls. The operations used to fulfill the request are submitted via an io_uring instance associated with the process. The number of operations submitted is given in the to_submit argument and is expected to be a positive integer. </p> <p>The min_complete argument tells the system how many I/O operations need to be completed (or failed) before returning from the io_uring_enter call. This value is also expected to be a positive integer, or zero, if the caller is not interested in waiting on individual I/O completion events. The flags argument is a bitmask of flags that modify the caller's request. The flags can be used to indicate if I/O operations should remain in the submission queue on error, if any registered buffers can be safely reused without the caller double-checking their contents, or if the caller should be woken up if any operation within their submission set completes or fails. </p> <p>The sig argument contains a pointer to a signal set that may be used to unblock system calls being waited on. If set to NULL, the behavior will be the same as that of a call to io_uring_enter without a signal set.</p>"},{"location":"docs/events/builtin/syscalls/io_uring_enter/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>unsigned int</code>\u00a0- file descriptor associated with the io_uring instance used to submit I/O requests.</li> <li><code>to_submit</code>:<code>unsigned int</code>[OPT] - the number of I/O requests to submit. </li> <li><code>min_complete</code>:<code>unsigned int</code>[OPT] - the number of I/O requests that need to be completed before io_uring_enter returns.</li> <li><code>flags</code>:<code>unsigned int</code>[OPT] - flags modifying the request submission and completion.</li> <li><code>sig</code>:<code>sigset_t*</code>[U] - pointer to a signal set that may unblock system calls.</li> </ul>"},{"location":"docs/events/builtin/syscalls/io_uring_enter/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (in this case, the sig argument is a pointer to a signal set located in user space).</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/io_uring_enter/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/io_uring_enter/#io_uring_enter_1","title":"io_uring_enter","text":""},{"location":"docs/events/builtin/syscalls/io_uring_enter/#type","title":"Type","text":"<p>Kprobe + Ringbuffer </p>"},{"location":"docs/events/builtin/syscalls/io_uring_enter/#purpose","title":"Purpose","text":"<p>To monitor the submission and completion of I/O operations.</p>"},{"location":"docs/events/builtin/syscalls/io_uring_enter/#example-use-case","title":"Example Use Case","text":"<p>A use case for the io_uring_enter system call could be in an application that needs to monitor the status of a large number of I/O operations. This application could submit requests using the io_uring system and then use the io_uring_enter system call to wait on their completion, without the need to make additional system calls. </p>"},{"location":"docs/events/builtin/syscalls/io_uring_enter/#issues","title":"Issues","text":"<p>The signal set passed to io_uring_enter is potentially vulnerable to a time of check to time of use (TOCTOU) attack if an unprivileged process can manipulate it before the system call is made.</p>"},{"location":"docs/events/builtin/syscalls/io_uring_enter/#related-events","title":"Related Events","text":"<p>The io_uring_submit and io_uring_wait system calls are related to, and should be used in conjunction with, io_uring_enter.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/io_uring_register/","title":"io_uring_register","text":""},{"location":"docs/events/builtin/syscalls/io_uring_register/#intro","title":"Intro","text":"<p>io_uring_register - register an io_uring instance with the kernel</p>"},{"location":"docs/events/builtin/syscalls/io_uring_register/#description","title":"Description","text":"<p>The io_uring_register() system call is used to register an io_uring instance with the kernel. It sets up various parameters such as io_uring buffers, the io_uring timeout, and the io_uring polled queue depths. It also attaches an io_uring instance to an existing file descriptor.</p> <p>The call allows for registering files, events, memory ranges and other data in an io_uring instance. The io_uring can then be used for operations such as application controlled buffering and queuing, as well as notifying when data is available. </p> <p>This system call is convenient when dealing with a range of I/O operations, as it only needs to be called once. </p>"},{"location":"docs/events/builtin/syscalls/io_uring_register/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>unsigned int</code> - a file descriptor for the io_uring instance.</li> <li><code>opcode</code>:<code>unsigned int</code> - the type of registration to perform with the kernel.</li> <li><code>arg</code>:<code>void*</code> - pointer to an array of structures that describe the data to register.</li> <li><code>nr_args</code>:<code>unsigned int</code> - the number of structures in said array.</li> </ul>"},{"location":"docs/events/builtin/syscalls/io_uring_register/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/io_uring_register/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/io_uring_register/#io_uring_register_1","title":"io_uring_register()","text":""},{"location":"docs/events/builtin/syscalls/io_uring_register/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/io_uring_register/#purpose","title":"Purpose","text":"<p>Observe behavior of I/O threads undergoing registration </p>"},{"location":"docs/events/builtin/syscalls/io_uring_register/#example-use-case","title":"Example Use Case","text":"<p>The io_uring_register system call is useful for monitoring the activity around I/O complex operations such as file access and network communication. It can be used to identify latency issues, detect anomalous behavior, and catch system issues.</p>"},{"location":"docs/events/builtin/syscalls/io_uring_register/#issues","title":"Issues","text":"<p>The kernel documentation warns that while most of the features of the io_uring_register system call are stable, some internal details (as of 5.3) may still be in flux and may change in future releases.</p>"},{"location":"docs/events/builtin/syscalls/io_uring_register/#related-events","title":"Related Events","text":"<ul> <li>io_uring_submit</li> <li>io_uring_enter</li> <li>io_uring_cq_advance</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/io_uring_setup/","title":"io_uring_setup","text":""},{"location":"docs/events/builtin/syscalls/io_uring_setup/#intro","title":"Intro","text":"<p>io_uring_setup - Setup/initialize an io_uring instance.</p>"},{"location":"docs/events/builtin/syscalls/io_uring_setup/#description","title":"Description","text":"<p>The io_uring_setup() syscall sets up the io_uring instance associated with the file descriptor returned by the io_uring_get_fd() syscall. It returns -1 on error, or 0 on success. The io_uring_setup() syscall is used to configure various options on the io_uring instance, such as the sq_ring_size (the size of the submission queue ring in number of elements), cq_ring_size (the size of the completion queue ring in number of elements), flags (various IORING_SETUP_* flags, see below for a list), and other parameters.</p> <p>The io_uring_setup() syscall is used for initializing and configuring the io_uring instance. The caller should fill in the io_uring_params structure pointed to by the p argument, with the desired parameter values prior to calling io_uring_setup().</p>"},{"location":"docs/events/builtin/syscalls/io_uring_setup/#arguments","title":"Arguments","text":"<ul> <li><code>entries</code>:<code>unsigned int</code>[K] - Number of sq and cq entries, must be a power of 2, and size must be &gt;= IORING_MIN_ENTRIES and &lt;= IORING_MAX_ENTRIES. This argument is required.</li> <li><code>p</code>:<code>struct io_uring_params*</code>[K] - Points to struct io_uring_params containing various options. Optional unless the IORING_SETUP_PARAM_* flags are set.</li> </ul>"},{"location":"docs/events/builtin/syscalls/io_uring_setup/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/io_uring_setup/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/io_uring_setup/#system_call_after_io_uring_setup","title":"system_call_after_io_uring_setup","text":""},{"location":"docs/events/builtin/syscalls/io_uring_setup/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/io_uring_setup/#purpose","title":"Purpose","text":"<p>To trace the return value of the io_uring_setup syscall.</p>"},{"location":"docs/events/builtin/syscalls/io_uring_setup/#example-use-case","title":"Example Use Case","text":"<p>The io_uring_setup syscall can be used to collect latency data for a particular request. By hooking the io_uring_setup syscall and instrumenting the request with a tracepoint, one can measure the time elapsed between a request being submitted and the completion being returned by the io_uring.</p>"},{"location":"docs/events/builtin/syscalls/io_uring_setup/#issues","title":"Issues","text":"<p>N/A</p>"},{"location":"docs/events/builtin/syscalls/io_uring_setup/#related-events","title":"Related Events","text":"<ul> <li>io_uring_get_fd - get a file descriptor from an io_uring instance.</li> <li>io_uring_enter - submit IO requests to an io_uring instance.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/ioctl/","title":"ioctl","text":""},{"location":"docs/events/builtin/syscalls/ioctl/#intro","title":"Intro","text":"<p>ioctl - manipulate the device parameters of special files</p>"},{"location":"docs/events/builtin/syscalls/ioctl/#description","title":"Description","text":"<p>A program can control device by performing ioctl operations on the  relevant device files. It takes three parameters, an open file descriptor, a  request that indicates which device control is requested and an argument.  Most devices use their own specific ioctl commands for configuration. Some individual requests may be vulnerable to Time-of-check Time-of-use (TOCTOU)  race conditions.</p>"},{"location":"docs/events/builtin/syscalls/ioctl/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K]  - File descriptor for the device to be controlled.</li> <li><code>request</code>:<code>unsigned long</code>[K]  -  Refers to a device specific request code.</li> <li><code>arg</code>:<code>unsigned long</code>[K] - Argument for the request. Optional and might not always be available (passed with null value), indicated by [OPT] tag.</li> </ul>"},{"location":"docs/events/builtin/syscalls/ioctl/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/ioctl/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/ioctl/#vfs_ioctl","title":"vfs_ioctl","text":""},{"location":"docs/events/builtin/syscalls/ioctl/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/ioctl/#purpose","title":"Purpose","text":"<p>The ioctl syscall is hooked to gather information when it is executed.</p>"},{"location":"docs/events/builtin/syscalls/ioctl/#example-use-case","title":"Example Use Case","text":"<p>An example of an use case for the ioctl syscall could be in a program that  reads and writes the content of user space memory from a device driver.</p>"},{"location":"docs/events/builtin/syscalls/ioctl/#issues","title":"Issues","text":"<p>Race conditions can occur between the moment the request is checked and the  values are used.</p>"},{"location":"docs/events/builtin/syscalls/ioctl/#related-events","title":"Related Events","text":"<p>The syscall <code>ioctl</code> is related to other syscalls like <code>read</code> and <code>write</code>.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/ioperm/","title":"ioperm","text":""},{"location":"docs/events/builtin/syscalls/ioperm/#intro","title":"Intro","text":"<p>ioperm - set/get I/O permissions</p>"},{"location":"docs/events/builtin/syscalls/ioperm/#description","title":"Description","text":"<p>The ioperm system call allows a user to set/get I/O port permissions. It takes a 16-bit starting I/O port, the number of ports to affect, and an enable/disable value (1 or 0). All the I/O ports, from the starting port to the starting port + num - 1, will be set according to the enable/disable value. It affects only the current thread/process.</p> <p>The ioperm system call is used to allow or disallow certain I/O operations on certain parts of the I/O address space. It is used for situations where low-level I/O operations are required, such as when writing device drivers or device access programs.</p>"},{"location":"docs/events/builtin/syscalls/ioperm/#arguments","title":"Arguments","text":"<ul> <li><code>from</code>:<code>unsigned long</code>[K] - The starting I/O port.</li> <li><code>num</code>:<code>unsigned long</code>[K] - The number of ports to affect.</li> <li><code>turn_on</code>:<code>int</code>[K] - Enable/disable value.</li> </ul>"},{"location":"docs/events/builtin/syscalls/ioperm/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/ioperm/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/ioperm/#sys_ioperm","title":"sys_ioperm","text":""},{"location":"docs/events/builtin/syscalls/ioperm/#type","title":"Type","text":"<p>Kprobes + ftrace</p>"},{"location":"docs/events/builtin/syscalls/ioperm/#purpose","title":"Purpose","text":"<p>Hook to trace when ioperm system call is invoked.</p>"},{"location":"docs/events/builtin/syscalls/ioperm/#example-use-case","title":"Example Use Case","text":"<p>An example use case of the ioperm system call is writing a device driver. If the device driver needs to access I/O ports and it needs low-level I/O operations, the ioperm system call can be used to enable/disable access to I/O ports as needed.</p>"},{"location":"docs/events/builtin/syscalls/ioperm/#issues","title":"Issues","text":"<p>This system call is limited in that it can only be used on the current thread/process. Additionally, it is only available on x86 architectures. This limits its use-case somewhat.</p>"},{"location":"docs/events/builtin/syscalls/ioperm/#related-events","title":"Related Events","text":"<ul> <li>iopl - manipulate I/O privilege level.</li> <li>ioctls (ioctl) - control device.</li> <li>perf_event_open - open a performance monitoring event.</li> <li>userfaultfd - create a userland fault handler.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/iopl/","title":"iopl","text":""},{"location":"docs/events/builtin/syscalls/iopl/#intro","title":"Intro","text":"<p>iopl - set the I/O privilege level of the current process</p>"},{"location":"docs/events/builtin/syscalls/iopl/#description","title":"Description","text":"<p>The <code>iopl</code> syscall sets the I/O privilege level of the current process. It allows a process to have access to I/O port addresses that would otherwise be unavailable. It requires supervisor privileges to execute. If the argument is 0, the I/O privilege level of the current process is set to 0, disabling I/O port access. </p> <p>The I/O privilege level is a construct used by some operating systems that allow for a higher level of control when performing input/output operations. The idea is that certain restricted operations can only be performed by processes that have been granted supervisory privileges.</p> <p>There are several drawbacks to using <code>iopl</code>, such as system instability and security risks. Since the caller has full access to the I/O ports, they could gain unauthorized access, modify or remove critical data, or cause the system to crash.</p>"},{"location":"docs/events/builtin/syscalls/iopl/#arguments","title":"Arguments","text":"<ul> <li><code>level</code>:<code>int</code>[K] - the privilege level the current process should be set to. If the argument is 0, all I/O port access for the current process is disabled.</li> </ul>"},{"location":"docs/events/builtin/syscalls/iopl/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/iopl/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/iopl/#sys_iopl","title":"sys_iopl","text":""},{"location":"docs/events/builtin/syscalls/iopl/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/iopl/#purpose","title":"Purpose","text":"<p>To capture and monitor calls to the <code>iopl</code> syscall, and the arguments passed to it. </p>"},{"location":"docs/events/builtin/syscalls/iopl/#example-use-case","title":"Example Use Case","text":"<p>The <code>iopl</code> syscall can be used by security moniroting applications to detect attempts to set the I/O privilege level, and log the corresponding information.</p>"},{"location":"docs/events/builtin/syscalls/iopl/#issues","title":"Issues","text":"<p>This syscall is not available on all architectures. Furthermore, it cannot be used on kernel versions before 4.7. </p>"},{"location":"docs/events/builtin/syscalls/iopl/#related-events","title":"Related Events","text":"<p>Other syscalls related to accessing I/O ports: <code>ioperm</code>, <code>iopl</code>, <code>portio_in</code>, <code>portio_out</code></p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/ioprio_get/","title":"ioprio_get","text":""},{"location":"docs/events/builtin/syscalls/ioprio_get/#intro","title":"Intro","text":"<p>ioprio_get - get the I/O priority of a process, process group, or user</p>"},{"location":"docs/events/builtin/syscalls/ioprio_get/#description","title":"Description","text":"<p>This system call returns the I/O priority of a process, process group, or user. It takes two parameters, which and who, which specify the entity for which the I/O priority is queried. The which parameter can be set to IOPRIO_WHO_PROCESS to query a process identified by the ID passed in the who parameter, IOPRIO_WHO_PGRP to query all processes in the process group specified by the who parameter, or IOPRIO_WHO_USER to query for all processes belonging to the user specified by the who parameter. The return value contains both the I/O priority class and the I/O priority value.</p> <p>The I/O priorities are used to order operations from I/O-bound processes so that I/O load on a system is distributed in an equitable manner.</p>"},{"location":"docs/events/builtin/syscalls/ioprio_get/#arguments","title":"Arguments","text":"<ul> <li><code>which</code>:<code>int</code> - Specifies the entity for which the I/O priority is queried.</li> <li><code>who</code>:<code>int</code> - Specifies the process, process group, or user ID to query.</li> </ul>"},{"location":"docs/events/builtin/syscalls/ioprio_get/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/ioprio_get/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/ioprio_get/#sys_ioprio_get","title":"sys_ioprio_get","text":""},{"location":"docs/events/builtin/syscalls/ioprio_get/#type","title":"Type","text":"<p>Kprobe + Kretprobe.</p>"},{"location":"docs/events/builtin/syscalls/ioprio_get/#purpose","title":"Purpose","text":"<p>To measure the I/O priority of a process, process group, or user.</p>"},{"location":"docs/events/builtin/syscalls/ioprio_get/#ioprio_get_1","title":"ioprio_get","text":""},{"location":"docs/events/builtin/syscalls/ioprio_get/#type_1","title":"Type","text":"<p>Kprobe.</p>"},{"location":"docs/events/builtin/syscalls/ioprio_get/#purpose_1","title":"Purpose","text":"<p>To record the process ID of all processes passed to the I/O priority getter.</p>"},{"location":"docs/events/builtin/syscalls/ioprio_get/#example-use-case","title":"Example Use Case","text":"<p>The ioprio_get syscall can be used to measure the efficiency of I/O load balancing in real-world workloads in order to optimize system performance.</p>"},{"location":"docs/events/builtin/syscalls/ioprio_get/#issues","title":"Issues","text":"<p>No known issues.</p>"},{"location":"docs/events/builtin/syscalls/ioprio_get/#related-events","title":"Related Events","text":"<ul> <li>ioprio_set - set the I/O priority of a process, process group, or user</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/ioprio_set/","title":"ioprio_set","text":""},{"location":"docs/events/builtin/syscalls/ioprio_set/#intro","title":"Intro","text":"<p>ioprio_set - set the I/O scheduling class and priority of a process</p>"},{"location":"docs/events/builtin/syscalls/ioprio_set/#description","title":"Description","text":"<p>The <code>ioprio_set()</code> system call is used to set the I/O scheduling class and priority of a process, or thread group. The <code>ioprio_set()</code> call takes three parameters: which, who and ioprio and sets the I/O scheduling class and priority of the process specified by which and who to the value specified by ioprio. The class of scheduling is determined by the upper bits of the ioprio argument; the lower bits of ioprio determine the actual priority within the class. The four classes available are IOPRIO_CLASS_RT (real-time class), IOPRIO_CLASS_BE (best effort class), IOPRIO_CLASS_IDLE (idle priority class) and IOPRIO_CLASS_NONE (no class, just the priority).</p> <p>The <code>ioprio_set()</code> call is advantageous because it allows the user to specify the I/O scheduling class and priority for individual applications, threads or thread-groups which makes it possible to ensure that only certain processes receive the I/O resources they need. However, it is important to remember that using this system call in conjunction with unscheduling classes can have adverse effects on other applications and the overall system performance.</p>"},{"location":"docs/events/builtin/syscalls/ioprio_set/#arguments","title":"Arguments","text":"<ul> <li><code>which</code>: <code>int</code> - Specifies whether to apply the setting to the current process or thread group (0=current, 1=thread group).</li> <li><code>who</code>: <code>int</code> - Specifies which pid or thread group (tgid) to apply the setting to. Set to 0 for the current thread.</li> <li><code>ioprio</code>: <code>int</code> - Specifies the I/O scheduling class and priority. The value consists of two parts: the class (the 5 most significant bits, bits 4-0 inclusive), and the priority within the class (the 19 least significant bits).</li> </ul>"},{"location":"docs/events/builtin/syscalls/ioprio_set/#available-tags","title":"Available Tags","text":"<ul> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/ioprio_set/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/ioprio_set/#doiopriority","title":"DoIOPriority","text":""},{"location":"docs/events/builtin/syscalls/ioprio_set/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/ioprio_set/#purpose","title":"Purpose","text":"<p>To register IOPriority operations.</p>"},{"location":"docs/events/builtin/syscalls/ioprio_set/#example-use-case","title":"Example Use Case","text":"<p><code>ioprio_set()</code> could be used to ensure that specific applications receive a higher priority, or more resources, than others. For example, a multimedia application needs access to the disk more often than an e-mail application, so setting the I/O priority of the multimedia application to a higher level might help improve the performance of that application.</p>"},{"location":"docs/events/builtin/syscalls/ioprio_set/#issues","title":"Issues","text":"<p>This system call is sensitive to changes and may have unexpected results or have a performance impact if used indiscriminately. It is important to consider the implications before changing the default I/O scheduling class of a process.</p>"},{"location":"docs/events/builtin/syscalls/ioprio_set/#related-events","title":"Related Events","text":"<ul> <li><code>ioprio_get()</code> - get the I/O scheduling class and priority of a process</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/ipc/","title":"ipc","text":""},{"location":"docs/events/builtin/syscalls/ipc/#intro","title":"Intro","text":"<p>ipc - System call used traditionally to communicate between processes over a network or through I/O channels.</p>"},{"location":"docs/events/builtin/syscalls/ipc/#description","title":"Description","text":"<p>The <code>ipc</code> system call is used to communicate between processes, either over a network or through I/O channels. It takes a set of arguments which indicate the direction of communication and the parameters needed to set up the communication. The call can be used to either send or receive messages and data to/from a remote process or I/O channel.</p> <p>This system call is useful for the exchange of information between processes without the need for a separate protocol or application-level code. It can also be used for process synchronization, where two or more processes wait for one another to take certain actions before proceeding.</p>"},{"location":"docs/events/builtin/syscalls/ipc/#arguments","title":"Arguments","text":"<ul> <li><code>call</code>:<code>unsigned int</code> -  Specifies which action to take (e.g. send, receive, etc.)</li> <li><code>first</code>:<code>int</code> - Generally a process ID, or an identifier for the resource to be accessed.</li> <li><code>second</code>:<code>unsigned long</code>[OPT] - Additional information for the call, such as the address of a buffer for data transfer.</li> <li><code>third</code>:<code>unsigned long</code>[K] -  Optional data buffer address, used in some commands to transfer data between processes.</li> <li><code>ptr</code>:<code>void*</code>[K] - Pointer to a variable where the actual result of the call is stored if the call was successful.</li> <li><code>fifth</code>:<code>long</code>[OPT] - Used to specify additional flags or options for the call, such as permissions or timeouts.</li> </ul>"},{"location":"docs/events/builtin/syscalls/ipc/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/ipc/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/ipc/#sys_ipc","title":"sys_ipc","text":""},{"location":"docs/events/builtin/syscalls/ipc/#type","title":"Type","text":"<p>Kprobes / Kretprobes </p>"},{"location":"docs/events/builtin/syscalls/ipc/#purpose","title":"Purpose","text":"<p>To monitor the interaction between processes and the IPC channels.</p>"},{"location":"docs/events/builtin/syscalls/ipc/#example-use-case","title":"Example Use Case","text":"<p>The <code>ipc</code> system call could be used to send a simple message from one process to another. In this case, the message and all associated data could be sent and received within a single call.</p>"},{"location":"docs/events/builtin/syscalls/ipc/#issues","title":"Issues","text":"<p>The <code>ipc</code> call is vulnerable to race conditions when used with the <code>IPC_NOWAIT</code> option, as the command may return before the requested operation is complete.</p>"},{"location":"docs/events/builtin/syscalls/ipc/#related-events","title":"Related Events","text":"<ul> <li><code>msgget</code> - creates a System V message queue</li> <li><code>msgsnd</code> - sends a message to a System V message queue</li> <li><code>msgrcv</code> - receives a message from a System V message queue</li> <li><code>shmget</code> - creates a System V shared memory segment</li> <li><code>shmat</code> - attaches a System V shared memory segment to the calling process</li> <li><code>semget</code> - creates a System V semaphore set</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/kcmp/","title":"kcmp","text":""},{"location":"docs/events/builtin/syscalls/kcmp/#intro","title":"Intro","text":"<p>kcmp - system call used to compare two process id's</p>"},{"location":"docs/events/builtin/syscalls/kcmp/#description","title":"Description","text":"<p>kcmp() is a system call used to compare two process identifiers and see if they have objects with the same index of a given type. This is useful for debugging and other system-level activities, such as running another process with similar resources.</p> <p>The arguments, pid1 and pid2, provide the process identifiers of the two processes to be compared. The type argument provides the type of object to compare and the idx1 and idx2, the indices within the corresponding objects of the two processes.</p> <p>The possible types and corresponding objects are:</p> <ul> <li>0: File descriptors</li> <li>1: Virtual memory areas</li> <li>2: Signals</li> <li>3: Timers</li> <li>4: Tasks (thread groups)</li> <li>5: Process Shared Semaphores</li> <li>6: Futexes</li> </ul> <p>If the two objects compared have the same index and type, the call returns 0. Otherwise, the call returns -1 and errno is set to ESRCH.</p> <p>Advantages of using this system call:</p> <ul> <li>It can be used to compare two processes quickly and safely.</li> <li>Can be used in debugging scenarios.</li> <li>Can detect any differences between two processes accurately.</li> </ul> <p>One of the drawbacks of kcmp is that it takes a long time to execute, since it has to traverse the objects of both processes.</p>"},{"location":"docs/events/builtin/syscalls/kcmp/#arguments","title":"Arguments","text":"<ul> <li><code>pid1</code>:<code>pid_t</code> - The process identifier of the first process</li> <li><code>pid2</code>:<code>pid_t</code> - The process identifier of the second process</li> <li><code>type</code>:<code>int</code> - The type of object to compare. See description for a list of possible types</li> <li><code>idx1</code>:<code>unsigned long</code> - The index of the object in the first process</li> <li><code>idx2</code>:<code>unsigned long</code> - The index of the object in the second process</li> </ul>"},{"location":"docs/events/builtin/syscalls/kcmp/#available-tags","title":"Available Tags","text":"<p>No tags applicable.</p>"},{"location":"docs/events/builtin/syscalls/kcmp/#hooks","title":"Hooks","text":"<p>No hooks applicable.</p>"},{"location":"docs/events/builtin/syscalls/kcmp/#example-use-case","title":"Example Use Case","text":"<p>This system call could be used to compare two processes in order to find any differences between them. This could be useful for debugging or for comparing resources between the two.</p>"},{"location":"docs/events/builtin/syscalls/kcmp/#issues","title":"Issues","text":"<p>No known issues.</p>"},{"location":"docs/events/builtin/syscalls/kcmp/#related-events","title":"Related Events","text":"<ul> <li>ptrace - system call used to trace a process</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/kexec_file_load/","title":"kexec_file_load","text":""},{"location":"docs/events/builtin/syscalls/kexec_file_load/#intro","title":"Intro","text":"<p>kexec_file_load - Parse a kexec file and load it into memory.</p>"},{"location":"docs/events/builtin/syscalls/kexec_file_load/#description","title":"Description","text":"<p>This system call enables the ability to load a kernel image from a file descriptor into the kernel for later execution. It can be used to make changes to the kernel faster, such as with version upgrades or hardware-related updates. This executes from kernel space, so the file descriptors are coming from kernel space.</p> <p>It also has a few drawbacks, such as: * It can be hard to verify that the kernel image is correct and free from malicious code.  * It may be slow to execute, depending on the hardware and how large the kernel image is.</p>"},{"location":"docs/events/builtin/syscalls/kexec_file_load/#arguments","title":"Arguments","text":"<ul> <li><code>kernel_fd</code>:<code>int</code>[K] - File descriptor containing the kernel image.</li> <li><code>initrd_fd</code>:<code>int</code>[K] - File descriptor containing the kernel initrd.</li> <li><code>cmdline_len</code>:<code>unsigned long</code>[K] - Length of the kernel command line, in bytes.</li> <li><code>cmdline</code>:<code>const char*</code>[K] - Pointer to kernel command line, in kernel mode memory.</li> <li><code>flags</code>:<code>unsigned long</code>[K] - Optional flags to modify the behavior of the system call.</li> </ul>"},{"location":"docs/events/builtin/syscalls/kexec_file_load/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/kexec_file_load/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/kexec_file_load/#do_modify_ldt","title":"do_modify_ldt","text":""},{"location":"docs/events/builtin/syscalls/kexec_file_load/#type","title":"Type","text":"<p>kprobes</p>"},{"location":"docs/events/builtin/syscalls/kexec_file_load/#purpose","title":"Purpose","text":"<p>To ensure that the system call does not modify user-space address tables. </p>"},{"location":"docs/events/builtin/syscalls/kexec_file_load/#example-use-case","title":"Example Use Case","text":"<p>For example, kexec_file_load can be used to quickly switch from one kernel version to another in order to update the system or to reap the benefits of a newer kernel version.</p>"},{"location":"docs/events/builtin/syscalls/kexec_file_load/#issues","title":"Issues","text":"<p>It can be susceptible to a Time-of-Check Time-of-Use (TOCTOU) vulnerability if not properly guarded against.</p>"},{"location":"docs/events/builtin/syscalls/kexec_file_load/#related-events","title":"Related Events","text":"<ul> <li>kexec_load: Allows loading of a kernel image without parsing it first.</li> <li>kexec_file_unload: Unloads a previously loaded kexec file.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/kexec_load/","title":"kexec_load","text":""},{"location":"docs/events/builtin/syscalls/kexec_load/#intro","title":"Intro","text":"<p>kexec_load - loads a new kernel for later execution.</p>"},{"location":"docs/events/builtin/syscalls/kexec_load/#description","title":"Description","text":"<p>kexec_load allows loading or relocating the currently running kernel for later execution. It loads the new kernel from the values provided by its arguments. It allows to perform sanity and memory integrity checks on the new kernel before it is loaded. It also allows for kexec_file_load which does the same job, except it loads the new kernel from a binary on the filesystem.</p> <p>The main advantage of using 'kexec_load' is that it allows the user to safely hotpatch the kernel without rebooting the system. The drawbacks are the relatively low speed of kernel hotpatching and the complexity of relocating the kernel.</p>"},{"location":"docs/events/builtin/syscalls/kexec_load/#arguments","title":"Arguments","text":"<ul> <li><code>entry</code>:<code>unsigned long</code>[K] - Contains the starting address of the new kernel.</li> <li><code>nr_segments</code>:<code>unsigned long</code>[K] - Contains the number of segments of the new kernel.</li> <li><code>segments</code>: <code>struct kexec_segment*</code>[K] - Contains an array of kexec_segment structures, representing the different address ranges of the new kernel.</li> <li><code>flags</code>:<code>unsigned long</code>[K] - Contains the flags used to load the new kernel. Possible flags are KEXEC_ARCH_MASK, KEXEC_FILE_UNLOAD, KEXEC_ON_CRASH, KEXEC_PRESERVE_CONTEXT, KEXEC_CLONE_KERNEL, KEXEC_ON_CRASH_UNLOAD, KEXEC_CLONE_INIT, KEXEC_PRESERVE_PCI and KEXEC_IGNORE_SEGV.</li> </ul>"},{"location":"docs/events/builtin/syscalls/kexec_load/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/kexec_load/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/kexec_load/#do_sys_kexec","title":"do_sys_kexec","text":""},{"location":"docs/events/builtin/syscalls/kexec_load/#type","title":"Type","text":"<p>kprobe + kretprobe</p>"},{"location":"docs/events/builtin/syscalls/kexec_load/#purpose","title":"Purpose","text":"<p>Identify kexec system calls, arguments, return values and execution times. </p>"},{"location":"docs/events/builtin/syscalls/kexec_load/#load_segments","title":"load_segments","text":""},{"location":"docs/events/builtin/syscalls/kexec_load/#type_1","title":"Type","text":"<p>kretprobe </p>"},{"location":"docs/events/builtin/syscalls/kexec_load/#purpose_1","title":"Purpose","text":"<p>Identify the segments used for the new kernel loading.</p>"},{"location":"docs/events/builtin/syscalls/kexec_load/#example-use-case","title":"Example Use Case","text":"<p>An example of kexec_load being used is when the user wants to hotpatch the kernel without rebooting the system. The 'kexec_load' will load the new kernel from the values provided and perform sanity and memory checks to ensure the integrity. It can be used to identify kernel bugs and other system inconsistencies without having to reboot the system. </p>"},{"location":"docs/events/builtin/syscalls/kexec_load/#issues","title":"Issues","text":"<p>The main issue with kexec_load is that it is relatively slow compared to other hotpatching methods. It also requires a certain level of complexity as there is a need to relocate the kernel.</p>"},{"location":"docs/events/builtin/syscalls/kexec_load/#related-events","title":"Related Events","text":"<ul> <li>kexec_file_load - Similar to kexec_load, but it loads the kernel from a file on the filesystem instead. </li> <li>kexec_unload - Unloads a previously loaded kernel.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/keyctl/","title":"keyctl","text":""},{"location":"docs/events/builtin/syscalls/keyctl/#intro","title":"Intro","text":"<p>keyctl - is a system call for manipulating the kernel\u2019s key management facility. </p>"},{"location":"docs/events/builtin/syscalls/keyctl/#description","title":"Description","text":"<p>keyctl is a function in the Linux kernel through which applications can request to manage the kernel's key management facility. It has several operations for creating, accessing, and destroying keys. Creating and accessing keys are usually done in process-local or session-wide aspects. The call can accept up to five arguments, with <code>operation</code> being the first one used to describe what the kernel should do.</p> <p>The use of this call can be advantageous, since it helps in facilitating secure communication between applications and services, in addition to better access control over system calls. This can also be used to ensure secure storage of sensitive data such as encryption keys.</p>"},{"location":"docs/events/builtin/syscalls/keyctl/#arguments","title":"Arguments","text":"<ul> <li><code>operation</code>: <code>int</code> - type of operation to be carried out. It is specified as one of the KEYCTL_ macros.</li> <li><code>arg2</code>: <code>unsigned long</code> - argument associated with the specified operation.</li> <li><code>arg3</code>: <code>unsigned long</code> - argument associated with the specified operation.</li> <li><code>arg4</code>: <code>unsigned long</code> - argument associated with the specified operation.</li> <li><code>arg5</code>: <code>unsigned long</code> - argument associated with the specified operation.</li> </ul>"},{"location":"docs/events/builtin/syscalls/keyctl/#available-tags","title":"Available Tags","text":"<ul> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use).</li> </ul>"},{"location":"docs/events/builtin/syscalls/keyctl/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/keyctl/#_1","title":"keyctl","text":"<p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/kill/","title":"kill","text":""},{"location":"docs/events/builtin/syscalls/kill/#intro","title":"Intro","text":"<p>kill - send a signal to a process</p>"},{"location":"docs/events/builtin/syscalls/kill/#description","title":"Description","text":"<p>The kill syscall allows a process to send a signal to another process. This can be used to \"kill\" or terminate the process, or send other signals to it, such as for pausing or restarting the process. The signal that is sent will depend on the value of the sig argument, which can take values from any of the signal constants defined in the signal.h header file. The privileged version of this syscall, kill(), can be used to send signals to any process running on the system, while the unprivileged version, tkill(), can only be used to send signals to processes owned by the calling process.</p> <p>One disadvantage of using kill() is that it is vulnerable to a TOCTOU race condition. If the process being killed has changed its state in the window between the time of check and the time of use, the kill() might be attempted on the wrong process.</p>"},{"location":"docs/events/builtin/syscalls/kill/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>pid_t</code>[K] - Identifier of the process the signal is being sent to.</li> <li><code>sig</code>:<code>int</code>[K] - Signal that is being sent. Can be one of the constants defined in the signal.h header file.</li> </ul>"},{"location":"docs/events/builtin/syscalls/kill/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/kill/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/kill/#do_kill","title":"do_kill","text":""},{"location":"docs/events/builtin/syscalls/kill/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/kill/#purpose","title":"Purpose","text":"<p>To trace when a process is killed by another process.</p>"},{"location":"docs/events/builtin/syscalls/kill/#sys_kill","title":"sys_kill","text":""},{"location":"docs/events/builtin/syscalls/kill/#type_1","title":"Type","text":"<p>Kretprobes</p>"},{"location":"docs/events/builtin/syscalls/kill/#purpose_1","title":"Purpose","text":"<p>To trace when a process is killed by another process and retrieve the arguments passed. </p>"},{"location":"docs/events/builtin/syscalls/kill/#example-use-case","title":"Example Use Case","text":"<p>The kill syscall can be used in a monitoring system, where a signal can be sent to a particular process to pause it, then analyse the data and restart it. This can be used to understand how a particular processes behaves over time or over different input values.</p>"},{"location":"docs/events/builtin/syscalls/kill/#issues","title":"Issues","text":"<p>The kill() syscall is vulnerable to a TOCTOU race condition, meaning that the signal might be sent to the wrong process if the one being killed changes its state in the window between the time of check and the time of use.</p>"},{"location":"docs/events/builtin/syscalls/kill/#related-events","title":"Related Events","text":"<p>The kill syscall is often used with the fork() syscall. The fork() syscall allows a process to create a new process, while the kill() syscall can be used to terminate the new process when it is no longer needed.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/landlock_add_rule/","title":"<code>landlock_add_rule</code>","text":""},{"location":"docs/events/builtin/syscalls/landlock_add_rule/#intro","title":"Intro","text":"<p><code>landlock_add_rule</code> - adds a security rule to the specified ruleset</p>"},{"location":"docs/events/builtin/syscalls/landlock_add_rule/#description","title":"Description","text":"<p><code>landlock_add_rule</code> is a system call used to add a security rule to a particular ruleset. The ruleset is specified by an <code>ruleset_fd</code> of type int, which identifies a particular rule set. The security rule itself is identified by the <code>rule_type</code> of type <code>landlock_rule_type</code> which specifies the type of rule being added. The <code>rule_attr</code> is of type <code>void</code> and is a pointer to a buffer that holds the attributes of the rule. The <code>flags</code> argument is of type <code>u32</code> and it is used to control the behavior of the call.</p> <p>This system call can be used to add a security rule to a particular ruleset which is useful to control the behavior of applications and resources. However, it is important to note that this system call should be used with caution as incorrect rules may create a vulnerability that could be exploited.</p>"},{"location":"docs/events/builtin/syscalls/landlock_add_rule/#arguments","title":"Arguments","text":"<ul> <li><code>ruleset_fd</code>:<code>int</code>[K] - file descriptor of the ruleset.</li> <li><code>rule_type</code>:<code>landlock_rule_type</code>[K] - type of security rule being added.</li> <li><code>rule_attr</code>:<code>void*</code>[K] - pointer to a buffer containing the attributes of the rule.</li> <li><code>flags</code>:<code>u32</code>[K] - flags to control the behavior of the call.</li> </ul>"},{"location":"docs/events/builtin/syscalls/landlock_add_rule/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/landlock_add_rule/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/landlock_add_rule/#sys_landlock_add_rule","title":"<code>sys_landlock_add_rule</code>","text":""},{"location":"docs/events/builtin/syscalls/landlock_add_rule/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/landlock_add_rule/#purpose","title":"Purpose","text":"<p>Monitoring of the syscall being executed.</p>"},{"location":"docs/events/builtin/syscalls/landlock_add_rule/#example-use-case","title":"Example Use Case","text":"<p><code>landlock_add_rule</code> could be used to limit access to a file by a particular user or group. The ruleset could be configured to deny any access from particular users or groups. This could be used to implement a more granular access control policy.</p>"},{"location":"docs/events/builtin/syscalls/landlock_add_rule/#issues","title":"Issues","text":"<p>There are no known issues related to this system call.</p>"},{"location":"docs/events/builtin/syscalls/landlock_add_rule/#related-events","title":"Related Events","text":"<ul> <li><code>landlock_remove_rule</code> - removes a security rule from the specified ruleset.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/landlock_create_ruleset/","title":"landlock_create_ruleset","text":""},{"location":"docs/events/builtin/syscalls/landlock_create_ruleset/#intro","title":"Intro","text":"<p><code>landlock_create_ruleset</code> - create a security ruleset</p>"},{"location":"docs/events/builtin/syscalls/landlock_create_ruleset/#description","title":"Description","text":"<p><code>landlock_create_ruleset</code> creates a Landlock security ruleset. This system call allows the caller to specify the attributes of the new ruleset \u2014 what memory objects can be affected by the ruleset, read/write permissions, and other properties of the ruleset \u2014 as well as the size of the ruleset, and any flags that should be applied. The returned ruleset is private to the calling process, and should not be shared with (or communicated to) other processes. </p> <p>There are a few edge-cases to be aware of when creating rulesets. If a ruleset is created with too low of a size, then it won't be able to hold all of the possible rules that the caller might request. Additionally, a ruleset created with higher size than needed would waste system resources. It's also possible for two or more processes to interfere with each other by attempting to create overlapping rulesets, which could result in policy-level violations.</p>"},{"location":"docs/events/builtin/syscalls/landlock_create_ruleset/#arguments","title":"Arguments","text":"<ul> <li><code>attr</code>:<code>struct landlock_ruleset_attr*</code>[U] - pointer to the Landlock attribute for the new ruleset. Contains options like the target object and access permissions.</li> <li><code>size</code>:<code>size_t</code>[U] - the size of the new ruleset, in bytes.</li> <li><code>flags</code>:<code>u32</code>[K] - flags determining optional features when creating the ruleset.</li> </ul>"},{"location":"docs/events/builtin/syscalls/landlock_create_ruleset/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/landlock_create_ruleset/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/landlock_create_ruleset/#__x64_sys_landlock_create_ruleset","title":"__x64_sys_landlock_create_ruleset","text":""},{"location":"docs/events/builtin/syscalls/landlock_create_ruleset/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/landlock_create_ruleset/#purpose","title":"Purpose","text":"<p>Hooks the landlock_create_ruleset function so that its arguments can be processed and the ruleset can be monitored.</p>"},{"location":"docs/events/builtin/syscalls/landlock_create_ruleset/#__do_landlock_create_ruleset","title":"__do_landlock_create_ruleset","text":""},{"location":"docs/events/builtin/syscalls/landlock_create_ruleset/#type_1","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/landlock_create_ruleset/#purpose_1","title":"Purpose","text":"<p>Hooks the do_landlock_create_ruleset kernel entry point so that the arguments and their values can be inspected.</p>"},{"location":"docs/events/builtin/syscalls/landlock_create_ruleset/#example-use-case","title":"Example Use Case","text":"<p><code>landlock_create_ruleset</code> can be used as part of a security policy enforcement system. By creating a ruleset with the appropriate access permissions, an application can ensure that processes in its security domain can only access the memory objects that are necessary for their work and no additional objects.</p>"},{"location":"docs/events/builtin/syscalls/landlock_create_ruleset/#issues","title":"Issues","text":"<p>Due to the fact that Landlock rulesets are private to the calling process, it's possible for processes to interact in unexpected ways and interfere with each other by attempting to create overlapping rulesets. Care should be taken to ensure that Landlock rulesets are sufficiently large and are properly scoped so that they do not cause any policy-level violations. Additionally, since this system call relies on user-space pointers, it is vulnerable to TOCTOU attacks.</p>"},{"location":"docs/events/builtin/syscalls/landlock_create_ruleset/#related-events","title":"Related Events","text":"<ul> <li>landlock_init - initialize landlock</li> <li>landlock_apply - apply ruleset to specified memory object</li> <li>landlock_remove - remove ruleset from specified memory object</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/landlock_restrict_self/","title":"landlock_restrict_self","text":""},{"location":"docs/events/builtin/syscalls/landlock_restrict_self/#intro","title":"Intro","text":"<p><code>landlock_restrict_self</code> - restrict the current process from creating new objects </p>"},{"location":"docs/events/builtin/syscalls/landlock_restrict_self/#description","title":"Description","text":"<p>This system call creates the specified restrictions on the current process. Specifically, it prevents the process from creating any new objects or changing the labels or container of existing objects. This is useful when a process needs to be restricted from unintended activities, such as creating new executable files, opening a socket, or executing code. The restrictions are enforced on the entire process and cannot be circumvented by the process itself.</p> <p>The system call takes two parameters - a file descriptor, <code>ruleset_fd</code>, to a ruleset object that defines the restrictions and <code>flags</code> that control the behavior of the system call. The ruleset file descriptor can point to either a ruleset object or a filesystem object. </p> <p>The <code>flags</code> parameter can be used to control how the new restriction is applied. For example, setting the <code>PARSE_ARGUMENT</code> flag will cause the system call to parse the arguments before applying the new restriction. This can help prevent undesired system call behaviors. </p>"},{"location":"docs/events/builtin/syscalls/landlock_restrict_self/#arguments","title":"Arguments","text":"<ul> <li><code>ruleset_fd</code>: <code>int</code>[U] - a file descriptor pointing to a ruleset object or a filesystem object.</li> <li><code>flags</code>: <code>u32</code>[U] - a bitmask of flags that control the behavior of the system call.</li> </ul>"},{"location":"docs/events/builtin/syscalls/landlock_restrict_self/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/landlock_restrict_self/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/landlock_restrict_self/#sys_landlock_restrict_self","title":"sys_landlock_restrict_self","text":""},{"location":"docs/events/builtin/syscalls/landlock_restrict_self/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/landlock_restrict_self/#purpose","title":"Purpose","text":"<p>This system call is hooked to restrict the current process from creating new objects or changing the labels or container of existing objects.</p>"},{"location":"docs/events/builtin/syscalls/landlock_restrict_self/#example-use-case","title":"Example Use Case","text":"<p><code>landlock_restrict_self</code> can be used to limit the capabilities of an untrusted process, such as one downloaded from an unverified source on the internet. By setting the appropriate restrictions on the file descriptor supplied as an argument, it is possible to limit the actions taken by a potentially malicious process.</p>"},{"location":"docs/events/builtin/syscalls/landlock_restrict_self/#issues","title":"Issues","text":"<p>The <code>flags</code> argument is optional, which can create issues where certain side effects of the system call are not taken into consideration.</p>"},{"location":"docs/events/builtin/syscalls/landlock_restrict_self/#related-events","title":"Related Events","text":"<ul> <li>landlock_unrestrict_self: remove the previously set restrictions imposed by <code>landlock_restrict_self</code> </li> <li>landlock_get_restrictions: retrieve the restrictions previously set by <code>landlock_restrict_self</code></li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/lchown/","title":"lchown","text":""},{"location":"docs/events/builtin/syscalls/lchown/#intro","title":"Intro","text":"<p>lchown - changing the ownership of a file or symlink</p>"},{"location":"docs/events/builtin/syscalls/lchown/#description","title":"Description","text":"<p>The lchown() system call changes the owner and the group of a given file or symlink. This syscall differs from the chown syscall in that it does not follow symlinks. This can be useful in certain scenarios, for example, when setting the owner of a mount point, or when changing the ownership of files in a readable directory that has been exposed on the target system. The lchown() system call may be vulnerable to a race condition known as TOCTOU (time of check, time of use), as this syscall does not provide atomic guarantee on the ownership change.</p>"},{"location":"docs/events/builtin/syscalls/lchown/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>: <code>const char*</code>[KU] - Pathname of the file or symlink to be changed.</li> <li><code>owner</code>: <code>uid_t</code>[K] - User ID of the new owner.</li> <li><code>group</code>: <code>gid_t</code>[K] - Group ID of the new group.</li> </ul>"},{"location":"docs/events/builtin/syscalls/lchown/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/lchown/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/lchown/#sys_lchown","title":"sys_lchown","text":""},{"location":"docs/events/builtin/syscalls/lchown/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/lchown/#purpose","title":"Purpose","text":"<p>What the probes are designed to achieve. Instrumentation of the file or symlink ownership change operation.</p>"},{"location":"docs/events/builtin/syscalls/lchown/#example-use-case","title":"Example Use Case","text":"<p>A use case for this event could be creating an audit trail of ownership changes on sensitive files in the system, such as config files and binaries.</p>"},{"location":"docs/events/builtin/syscalls/lchown/#issues","title":"Issues","text":"<p>If there is an issue with this event, this is the place to write it.</p>"},{"location":"docs/events/builtin/syscalls/lchown/#related-events","title":"Related Events","text":"<ul> <li><code>chown</code> - For changing ownership on a pathname, including symlinks</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/lchown16/","title":"lchown16","text":""},{"location":"docs/events/builtin/syscalls/lchown16/#intro","title":"Intro","text":"<p>lchown16 - the lchown16() function changes the ownership and group of the file referenced by pathname to the numeric uid and gid.</p>"},{"location":"docs/events/builtin/syscalls/lchown16/#description","title":"Description","text":"<p>The lchown16() function is a system call used to change the user ID and group ID of the file referenced by pathname. This can only be done by the user who owns the file or by the superuser. It does not affect symbolic links. This system call does not dereference pathname, so the ownership of a symbolic link itself is modified rather than the file referenced.</p> <p>This system call applies to Linux systems with an old 32-bit user ID space and should not be used on current systems.</p>"},{"location":"docs/events/builtin/syscalls/lchown16/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code>[K] - Path of the file to change the owner and group.</li> <li><code>owner</code>:<code>old_uid_t</code>[K] - Numeric ID of the owner.</li> <li><code>group</code>:<code>old_gid_t</code>[K] - Numeric ID of the group.</li> </ul>"},{"location":"docs/events/builtin/syscalls/lchown16/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/lchown16/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/lchown16/#sys_lchown16","title":"sys_lchown16","text":""},{"location":"docs/events/builtin/syscalls/lchown16/#type","title":"Type","text":"<p>Kprobes.</p>"},{"location":"docs/events/builtin/syscalls/lchown16/#purpose","title":"Purpose","text":"<p>Hook this function to monitor ownership changes of files on the system.</p>"},{"location":"docs/events/builtin/syscalls/lchown16/#example-use-case","title":"Example Use Case","text":"<p>This system call can be used by an application to make sure that a file or directory has the expected user and group ownership before it is created.</p>"},{"location":"docs/events/builtin/syscalls/lchown16/#issues","title":"Issues","text":"<p>The lchown16() system call should not be used on current systems with the new 64-bit user ID and group ID spaces.</p>"},{"location":"docs/events/builtin/syscalls/lchown16/#related-events","title":"Related Events","text":"<ul> <li>chown() - similar system call for files in the current ID space. </li> <li>stat() - used to get file and ownership information. </li> <li>geteuid() - used to get the effective user ID.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/lgetxattr/","title":"lgetxattr","text":""},{"location":"docs/events/builtin/syscalls/lgetxattr/#intro","title":"Intro","text":"<p>lgetxattr - Get the value of an extended attribute for a given file.</p>"},{"location":"docs/events/builtin/syscalls/lgetxattr/#description","title":"Description","text":"<p>lgetxattr returns the value of an extended attribute associated with the given file to the variable pointed to by value. The size of the extended attribute should be no more than size, and will be stored in the variable pointed to by size. Extended attributes are associated with a file, directory, or other filesystem object, and are extensions to the normal attributes associated with every filesystem object, such as its size or permissions.</p> <p>Due to kernel implementation details and filesystem limitations, detailed information about extended attributes may not be available until lgetxattr returns. In such cases, the size returned in size may not properly reflect the size of the extended attribute, meaning that the value returned in value may not be the whole of what is expected. Additionally, extended attribute values may include special values and certain filesystem attributes that may require additional processing prior to use. If the actual size of the extended attribute exceeds the specified size, the value contained in value will be truncated and only the first size bytes will be returned in value. </p>"},{"location":"docs/events/builtin/syscalls/lgetxattr/#arguments","title":"Arguments","text":"<ul> <li><code>path</code>:<code>const char*</code>[K] - Path of the file whose attribute is to be retrieved.</li> <li><code>name</code>:<code>const char*</code>[K] - Name of the attribute being retrieved.</li> <li><code>value</code>:<code>void*</code>[K U] - Pointer to user-space address that will store the attribute value.</li> <li><code>size</code>:<code>size_t</code>[K U] - Size of the buffer pointed to by *value.</li> </ul>"},{"location":"docs/events/builtin/syscalls/lgetxattr/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use) </li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/lgetxattr/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/lgetxattr/#lgetxattr_1","title":"lgetxattr","text":""},{"location":"docs/events/builtin/syscalls/lgetxattr/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/lgetxattr/#purpose","title":"Purpose","text":"<p>To retrieve the extended attribute value for a given file.</p>"},{"location":"docs/events/builtin/syscalls/lgetxattr/#example-use-case","title":"Example Use Case","text":"<p>lgetxattr could be used to retrieve xattrs (including security labels) from files, to enable security audits, tracing or other requirements such as mandatory access control.</p>"},{"location":"docs/events/builtin/syscalls/lgetxattr/#issues","title":"Issues","text":"<p>Due to its nature, lgetxattr can potentially be subject to TOCTOU (time of check, time of use) race condition attacks. Care should be taken to ensure that the requested attribute is consistent between syscall entry and exit.</p>"},{"location":"docs/events/builtin/syscalls/lgetxattr/#related-events","title":"Related Events","text":"<p>sys_getxattr, sys_listxattr, sys_fgetxattr, sys_setxattr, sys_fsetxattr</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/link/","title":"link","text":""},{"location":"docs/events/builtin/syscalls/link/#intro","title":"Intro","text":"<p>link - create hard links to a file </p>"},{"location":"docs/events/builtin/syscalls/link/#description","title":"Description","text":"<p>The link() system call is used to create a link or hard link between two files. It creates a new name for an existing file. A hard link is essentially a directory entry that associates a name with a file on a particular file system. If a file has multiple hard links, any of these names can be used to read, write, open, or delete from the file. </p> <p>There are some edge cases that might arise when using this system call. One of them is that the user does not have privileges to create a link in the specified directory. Another is that if the user tries to make a link to a file that is located in another file system, then it will be rejected. Also, there is no way to restrict the number of hard links to a file, which means that it can easily consume a lot of storage space.</p> <p>However, there are advantages in using the link() system call. Creating hard links is a fast process since it does not require any disk block transfer. Moreover, since files are linked together, operations done in one file are reflected in the other. This can be useful when then need to update multiple copies of the same file simultaneously.</p>"},{"location":"docs/events/builtin/syscalls/link/#arguments","title":"Arguments","text":"<ul> <li><code>oldpath</code>: <code>const char*</code>[U] - Path to existing file.  </li> <li><code>newpath</code>:<code>const char*</code>[U] - Path to create the link at.  </li> </ul>"},{"location":"docs/events/builtin/syscalls/link/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/link/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/link/#sys-link","title":"sys-link","text":""},{"location":"docs/events/builtin/syscalls/link/#type","title":"Type","text":"<p>Kprobes  </p>"},{"location":"docs/events/builtin/syscalls/link/#purpose","title":"Purpose","text":"<p>To detect and trace creating of directory links</p>"},{"location":"docs/events/builtin/syscalls/link/#example-use-case","title":"Example Use Case","text":"<p>The link() system call can be used to detect and trace malicious or suspicious file modification. For example, if a malicious user is trying to modify or delete files in a system, creating/deleting a hard link to the file is one way to do this. Tracking the link() system call will notify if any files are modified in this way.</p>"},{"location":"docs/events/builtin/syscalls/link/#issues","title":"Issues","text":"<p>The link() system call is vulnerable to TOCTOU (time of check, time of use) race conditions, in which different users can execute different instruction sequences between check and use of file links, with potential security implications.</p>"},{"location":"docs/events/builtin/syscalls/link/#related-events","title":"Related Events","text":"<ul> <li><code>unlink</code> - system call that deletes the given file name.  </li> <li><code>unlinkat</code> - system call that deletes the file at the specified directory.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/linkat/","title":"linkat","text":""},{"location":"docs/events/builtin/syscalls/linkat/#intro","title":"Intro","text":"<p>linkat - create a link to a file or directory</p>"},{"location":"docs/events/builtin/syscalls/linkat/#description","title":"Description","text":"<p>The <code>linkat</code> system call creates a new link to an existing file or directory, with the pathname specified by <code>oldpath</code> and <code>newpath</code>. This can be used to create hard links across different file systems, and is especially useful when multiple copies of a file are present in different directories. The <code>flags</code> argument can be used to control the behavior of <code>linkat</code> with regard to symlinks, directory structure, and other aspects of the call.</p>"},{"location":"docs/events/builtin/syscalls/linkat/#arguments","title":"Arguments","text":"<ul> <li><code>olddirfd</code>:<code>int</code>[K] - file descriptor for the old directory. If <code>AT_EMPTY_PATH</code>, interpret <code>oldpath</code> relative to the current working directory.</li> <li><code>oldpath</code>:<code>const char*</code>[U] - path to the existing file or directory to link from. Must be a relative or absolute path.</li> <li><code>newdirfd</code>:<code>int</code>[K] - file descriptor for the new directory. If <code>AT_EMPTY_PATH</code>, interpret <code>newpath</code> relative to the current working directory.</li> <li><code>newpath</code>:<code>const char*</code>[U] - path to the existing file or directory to link to. Must be a relative or absolute path.</li> <li><code>flags</code>:<code>unsigned int</code>[K] - control behavior of <code>linkat</code>. Flag values may include <code>AT_DONTFORK</code>, <code>AT_FOLLOW</code>, <code>AT_SYMLINK_FOLLOW</code>, and <code>AT_EMPTY_PATH</code>. If a negative flag value is passed, then the <code>flags</code> parameter is ignored.</li> </ul>"},{"location":"docs/events/builtin/syscalls/linkat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/linkat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/linkat/#sys_linkat","title":"sys_linkat","text":""},{"location":"docs/events/builtin/syscalls/linkat/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/linkat/#purpose","title":"Purpose","text":"<p>To trace the system call linkat</p>"},{"location":"docs/events/builtin/syscalls/linkat/#example-use-case","title":"Example Use Case","text":"<p>To monitor a system running multiple different file systems and identify links being created between them.</p>"},{"location":"docs/events/builtin/syscalls/linkat/#issues","title":"Issues","text":"<p>If <code>AT_EMPTY_PATH</code> is used to pass the <code>oldpath</code> or <code>newpath</code> argument, the path name is resolved with the current working directory. If a process changes its working directory, the result may differ from the result from the previous call, so this could be a security issue.</p>"},{"location":"docs/events/builtin/syscalls/linkat/#related-events","title":"Related Events","text":"<ul> <li>renameat </li> <li>symlinkat </li> <li>unlinkat</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/listen/","title":"listen","text":""},{"location":"docs/events/builtin/syscalls/listen/#intro","title":"Intro","text":"<p>listen - listen for incoming connection requests from the network.</p>"},{"location":"docs/events/builtin/syscalls/listen/#description","title":"Description","text":"<p>The listen syscall determines the conditions for incoming connection requests from the network. Under normal circumstances, a socket created using the socket syscall is used for this purpose. The listen syscall informs the kernel that the socket is to be used as a listening socket, and it is used to accept incoming connection requests.</p> <p>The listen syscall is used to mark a socket as being ready to accept incoming connection requests. There are no edge-cases, drawbacks or advantages of using this syscall, as it is simply a necessary step in the process of setting up a server.</p>"},{"location":"docs/events/builtin/syscalls/listen/#arguments","title":"Arguments","text":"<ul> <li><code>sockfd</code>:<code>int</code>[K] - This is the file descriptor for the socket. It must refer to a socket that has been created with the socket syscall and not yet bound to a local address.</li> <li><code>backlog</code>:<code>int</code>[K] - This is the maximum size of the queue of pending connections. This is the number of connections that can be waiting while the process is handling a particular connection.</li> </ul>"},{"location":"docs/events/builtin/syscalls/listen/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/listen/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/listen/#sys_listen","title":"sys_listen","text":""},{"location":"docs/events/builtin/syscalls/listen/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/listen/#purpose","title":"Purpose","text":"<p>To measure the time it takes for the listen syscall to complete and gather information about the various syscall arguments.</p>"},{"location":"docs/events/builtin/syscalls/listen/#example-use-case","title":"Example Use Case","text":"<p>The listen syscall can be used to set up a server that will accept incoming connection requests from the network. A common use case would be a web server that listens for incoming requests from web browsers. </p>"},{"location":"docs/events/builtin/syscalls/listen/#issues","title":"Issues","text":"<p>There are no known issues with the listen syscall.</p>"},{"location":"docs/events/builtin/syscalls/listen/#related-events","title":"Related Events","text":"<p>The socket syscall is the syscall used to create a socket and is related to the listen syscall. The accept syscall is used to actually accept incoming connections after listen has been used.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/listxattr/","title":"listxattr","text":""},{"location":"docs/events/builtin/syscalls/listxattr/#intro","title":"Intro","text":"<p>listxattr - retrieves the list of extended attributes associated with a file.</p>"},{"location":"docs/events/builtin/syscalls/listxattr/#description","title":"Description","text":"<p>listxattr retrieves the list of extended attributes associated with file referenced by path and stores it in list. The argument size specifies the size of the buffer pointed to by list and may be 0 for when only the size of the attribute list is needed.</p> <p>The returned attributes are in the form of a list of null-terminated attribute names. No attribute values are retrieved by this call. Attributes can have sizes up to 128 bytes (XATTR_SIZE_MAX).</p> <p>listxattr can be used to query the list of supported xattrs if the maximum size of an xattr is not known.</p>"},{"location":"docs/events/builtin/syscalls/listxattr/#arguments","title":"Arguments","text":"<ul> <li><code>path</code>:<code>const char*</code> - A pathname of item for which to list extended attributes.</li> <li><code>list</code>:<code>char*</code> - A list of the extended attributes associated with the file.</li> <li><code>size</code>:<code>size_t</code> - Max buffer size of the buf argument.</li> </ul>"},{"location":"docs/events/builtin/syscalls/listxattr/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/listxattr/#fcntl","title":"fcntl","text":""},{"location":"docs/events/builtin/syscalls/listxattr/#type","title":"Type","text":"<p>Tracepoint</p>"},{"location":"docs/events/builtin/syscalls/listxattr/#purpose","title":"Purpose","text":"<p>To observe sys calls of applications and kernel activity.</p>"},{"location":"docs/events/builtin/syscalls/listxattr/#do_listxattr","title":"do_listxattr","text":""},{"location":"docs/events/builtin/syscalls/listxattr/#type_1","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/listxattr/#purpose_1","title":"Purpose","text":"<p>To profile the listxattr syscall.</p>"},{"location":"docs/events/builtin/syscalls/listxattr/#example-use-case","title":"Example Use Case","text":"<p>listxattr can be used to list or inspect the extended attributes of a file or directory.  For example, on a filesystem with POSIX Access Control Lists enabled, listxattr can be used to determine if a user has the correct permissions for a file or directory.</p>"},{"location":"docs/events/builtin/syscalls/listxattr/#issues","title":"Issues","text":"<p>listxattr does not traverse mounted filesystems, so it will not list an extended attribute located on a mounted filesystem.</p>"},{"location":"docs/events/builtin/syscalls/listxattr/#related-events","title":"Related Events","text":"<p>getxattr, removexattr, setxattr</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/llistxattr/","title":"llistxattr","text":""},{"location":"docs/events/builtin/syscalls/llistxattr/#intro","title":"Intro","text":"<p>llistxattr - get extended attribute names for a file</p>"},{"location":"docs/events/builtin/syscalls/llistxattr/#description","title":"Description","text":"<p>The <code>llistxattr</code> syscall is used to retrieve the list of names of extended attributes associated with the specified file path. The names are stored as a NULL-terminated array of strings in the buffer pointed to by <code>list</code>. The buffer should have a size of <code>size</code> bytes. The size can be found by calling <code>fgetxattr</code> on the file with a NULL buffer. If the list size exceeds <code>size</code>, then <code>ERANGE</code> is returned, and a higher size should be used.</p>"},{"location":"docs/events/builtin/syscalls/llistxattr/#arguments","title":"Arguments","text":"<ul> <li><code>path</code>:<code>const char*</code>[K] - path to the file or directory</li> <li><code>list</code>:<code>char*</code>[K,U] - buffer used to transfer attribute names</li> <li><code>size</code>:<code>size_t</code>[K] - size of buffer for attribute list</li> </ul>"},{"location":"docs/events/builtin/syscalls/llistxattr/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/llistxattr/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/llistxattr/#sys_listxattr","title":"sys_listxattr","text":""},{"location":"docs/events/builtin/syscalls/llistxattr/#type","title":"Type","text":"<p>Kprobes and Uprobe.</p>"},{"location":"docs/events/builtin/syscalls/llistxattr/#purpose","title":"Purpose","text":"<p>Capturing attempts to retrieve a list of extended attributes associated with a file.</p>"},{"location":"docs/events/builtin/syscalls/llistxattr/#example-use-case","title":"Example Use Case","text":"<p>A monitoring app is monitoring and securing user data to determine if a user is engaging in a forbidden behavior. The app uses the <code>llistxattr</code> syscall to determine what extended attributes are associated with the user files.</p>"},{"location":"docs/events/builtin/syscalls/llistxattr/#issues","title":"Issues","text":"<p>This syscall may be vulnerable to TOCTOU (time-of-check-time-of-use) race conditions.</p>"},{"location":"docs/events/builtin/syscalls/llistxattr/#related-events","title":"Related Events","text":"<ul> <li><code>fgetxattr</code> - get the value of a single extended attribute for a file</li> <li><code>lgetxattr</code> - get the value of an extended attribute for a file</li> <li><code>setxattr</code> - set an extended attribute for a file</li> <li><code>lsetxattr</code> - set an extended attribute for a file relative to a directory</li> <li><code>removexattr</code> - remove an extended attribute for a file or directory</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/llseek/","title":"llseek","text":""},{"location":"docs/events/builtin/syscalls/llseek/#intro","title":"Intro","text":"<p>llseek - used to change the file position of a file descriptor</p>"},{"location":"docs/events/builtin/syscalls/llseek/#description","title":"Description","text":"<p>llseek is a system call used for setting the file pointer of the open file descriptor to a specified offset. It is useful for accessing random locations of a file instead of sequentially. When using this syscall, the offset specified is a 64-bit unsigned long number which is divided into two parts, the 'offset high' and 'offset low' parts. The 'whence` parameter is used to determine the location in the file from which the offset is determined. The resulting file position is stored in the user-supplied 'result' argument which is an loff_t pointer. </p> <p>There are some important drawbacks when using llseek. Firstly, the whence argument is not atomic, so if the file position is changed by another process during the call, the call will become invalid. Secondly, the offsets specified with this call do not exceed the maximum offset available when using 32 bit systems. This can be a problem when trying to access the very end of a large file. Lastly, since the loff_t pointer is user-supplied, it is vulnerable to TOCTOU (time of check, time of use) and to being incorrectly passed as an argument. </p>"},{"location":"docs/events/builtin/syscalls/llseek/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>unsigned int</code>[K] - The file descriptor associated with the file which the user wants to change the position of. </li> <li><code>offset_high</code>:<code>unsigned long</code>[U] - The high part of the 64-bit offset which the user wishes to set the file position to.</li> <li><code>offset_low</code>:<code>unsigned long</code>[U] - The low part of the 64-bit offset which the user wishes to set the file position to.</li> <li><code>result</code>:<code>loff_t*</code>[K] - The pointer to the user-supplied variable which will hold the resulting file position after llseek is called.</li> <li><code>whence</code>:<code>unsigned int</code>[U] - Integer which determines the location from which the offset is determined, as specified in the linux manual page for llseek.</li> </ul>"},{"location":"docs/events/builtin/syscalls/llseek/#available-tags","title":"Available Tags","text":"<p>K - Originated from kernel-space. U - Originated from user space (for example, pointer to user space memory used to get it) TOCTOU - Vulnerable to TOCTOU (time of check, time of use) OPT - Optional argument - might not always be available (passed with null value)</p>"},{"location":"docs/events/builtin/syscalls/llseek/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/llseek/#sys_llseek","title":"sys_llseek","text":""},{"location":"docs/events/builtin/syscalls/llseek/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/llseek/#purpose","title":"Purpose","text":"<p>This function is hooked to allow tracing of the llseek syscall.</p>"},{"location":"docs/events/builtin/syscalls/llseek/#example-use-case","title":"Example Use Case","text":"<p>The llseek syscall could be used in a program which needed to access portions of a file randomly without reading the entire file.</p>"},{"location":"docs/events/builtin/syscalls/llseek/#issues","title":"Issues","text":"<p>Since the loff_t pointer is user-supplied and not checked to the kernel, the pointer is vulnerable to TOCTOU and incorrect arguments.</p>"},{"location":"docs/events/builtin/syscalls/llseek/#related-syscalls","title":"Related Syscalls","text":"<ul> <li>lseek - used to set the file position of a file descriptor without needing to pass two arguments for the offset.</li> <li>pread - used to read from a specific offset in a file without needing to set the file pointer manually.</li> <li>pwrite - used to write from a specific offset in a file without needing to set the file pointer manually.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/lock/","title":"lock","text":""},{"location":"docs/events/builtin/syscalls/lock/#intro","title":"Intro","text":"<p>lock -  locks a file or an entire filesystem.</p>"},{"location":"docs/events/builtin/syscalls/lock/#description","title":"Description","text":"<p>The lock syscall is used to set, reset or test for the presence of a lock on a file or an entire filesystem. It can be used to prevent concurrent access to a file by multiple processes. When a lock is set, other processes are prevented from accessing the file until the lock is released. The lock allows synchronizing the access to the file and this may improve performance if multiple processes need to use the same data. However, the lock syscall itself prevents the access to a file and should be used only when absolutely necessary, otherwise it can cause performance degradation and even deadlocks. </p>"},{"location":"docs/events/builtin/syscalls/lock/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - a file descriptor that must be open for reading or writing</li> <li><code>cmd</code>:<code>int</code>[K] - specifies the operation to be performed. This can be <code>F_SETLK</code>, <code>F_SETLKW</code> or <code>F_GETLK</code></li> <li><code>lock</code>:<code>struct flock</code>[K] - points to a <code>struct flock</code> which contains the members <code>l_type</code>, <code>l_whence</code>, <code>l_start</code>, <code>l_len</code> and <code>l_pid</code>. </li> </ul>"},{"location":"docs/events/builtin/syscalls/lock/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/lock/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/lock/#do_fcntl","title":"do_fcntl","text":""},{"location":"docs/events/builtin/syscalls/lock/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/lock/#purpose","title":"Purpose","text":"<p>The kernel function do_fcntl is the entry point for the fcntl syscall, one of the primary system calls for file control. Specifically, it handles the lock operation, which is used for locking files and filesystems.</p>"},{"location":"docs/events/builtin/syscalls/lock/#example-use-case","title":"Example Use Case","text":"<p>The lock syscall can be used to ensure file access by multiple processes is mutually exclusive and can improve performance when working with the same data.</p>"},{"location":"docs/events/builtin/syscalls/lock/#issues","title":"Issues","text":"<p>If the lock is not properly released, due to a crash or program being terminated, it can cause a deadlock and all following processes will be blocked.</p>"},{"location":"docs/events/builtin/syscalls/lock/#related-events","title":"Related Events","text":"<ul> <li>fcntl - gathers generic information about the fcntl syscall.</li> <li>read - triggers when a number of bytes was read from a file descriptor.</li> <li>write - triggers when a number of bytes was written to a file descriptor.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/lookup_dcookie/","title":"lookup_dcookie","text":""},{"location":"docs/events/builtin/syscalls/lookup_dcookie/#intro","title":"Intro","text":"<p>lookup_dcookie - assigns a process identification number (pid) to the given cookie</p>"},{"location":"docs/events/builtin/syscalls/lookup_dcookie/#description","title":"Description","text":"<p>The lookup_dcookie syscall relates a cookie value with a process identification (pid). The cookie is an unsigned long integer, usually obtained by get_pid_list() syscall. The syscall has a buffer of type char*, and its size is given by the argument len. The buffer contains the path of the executable related with the pid. The result is negative if the search fails.</p> <p>This syscall can be used to obtain a process related information such as its executable path.</p>"},{"location":"docs/events/builtin/syscalls/lookup_dcookie/#arguments","title":"Arguments","text":"<ul> <li><code>cookie</code>:<code>u64</code> - unsigned long integer containing the cookie value.</li> <li><code>buffer</code>:<code>char*</code>[KU] - user space pointer to a buffer of type char*, where the path of the executable will be written.</li> <li><code>len</code>:<code>size_t</code>[KU] - user space pointer to the size of the buffer.</li> </ul>"},{"location":"docs/events/builtin/syscalls/lookup_dcookie/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/lookup_dcookie/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/lookup_dcookie/#sys_lookup_dcookie","title":"sys_lookup_dcookie","text":""},{"location":"docs/events/builtin/syscalls/lookup_dcookie/#type","title":"Type","text":"<p>kretprobe</p>"},{"location":"docs/events/builtin/syscalls/lookup_dcookie/#purpose","title":"Purpose","text":"<p>Hooked to gain visibility into the system calls that assign a process identification to the given cookie.</p>"},{"location":"docs/events/builtin/syscalls/lookup_dcookie/#example-use-case","title":"Example Use Case","text":"<p>The lookup_dcookie syscall can be used to identify the executable responsible for a particular process running on the system. It can also be used to monitor the system for processes initiating with a same cookie value.</p>"},{"location":"docs/events/builtin/syscalls/lookup_dcookie/#issues","title":"Issues","text":"<p>If the buffer is too small, the syscall may fail, leading to an incomplete path.</p>"},{"location":"docs/events/builtin/syscalls/lookup_dcookie/#related-events","title":"Related Events","text":"<ul> <li>get_pid_list</li> <li>read_exec</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/lremovexattr/","title":"lremovexattr","text":""},{"location":"docs/events/builtin/syscalls/lremovexattr/#intro","title":"Intro","text":"<p>lremovexattr - remove an extended attribute from a file or directory.</p>"},{"location":"docs/events/builtin/syscalls/lremovexattr/#description","title":"Description","text":"<p>The lremovexattr() system call removes the extended attribute specified by <code>name</code> from the file specified by <code>path</code>. Extended attributes are metadata associated with a file or directory, which may include things such as access control lists, security labels, and file system capabilities. If the <code>path</code> argument refers to a symbolic link, the attributes of the symbolic link itself are modified, rather than the attributes of the file or directory referenced by the symbolic link.</p>"},{"location":"docs/events/builtin/syscalls/lremovexattr/#arguments","title":"Arguments","text":"<ul> <li><code>path</code> : <code>const char*</code> [K] - Path to the file or directory.</li> <li><code>name</code> : <code>const char*</code> [K] - Name of the attribute to be removed.</li> </ul>"},{"location":"docs/events/builtin/syscalls/lremovexattr/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/lremovexattr/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/lremovexattr/#sys_removexattr","title":"sys_removexattr","text":""},{"location":"docs/events/builtin/syscalls/lremovexattr/#type","title":"Type","text":"<p>kprobe + kretprobe</p>"},{"location":"docs/events/builtin/syscalls/lremovexattr/#purpose","title":"Purpose","text":"<p>To detect calls and returns of the lremovexattr() syscall.</p>"},{"location":"docs/events/builtin/syscalls/lremovexattr/#example-use-case","title":"Example Use Case","text":"<p>An application might use lremovexattr() to remove extended attributes such as an ACL from a file or directory.</p>"},{"location":"docs/events/builtin/syscalls/lremovexattr/#issues","title":"Issues","text":"<p>The lremovexattr() system call is not supported on many systems.</p>"},{"location":"docs/events/builtin/syscalls/lremovexattr/#related-events","title":"Related Events","text":"<ul> <li>lgetxattr</li> <li>llistxattr</li> <li>lsetxattr</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/lseek/","title":"lseek","text":""},{"location":"docs/events/builtin/syscalls/lseek/#intro","title":"Intro","text":"<p>lseek - Moves read/write file offset</p>"},{"location":"docs/events/builtin/syscalls/lseek/#description","title":"Description","text":"<p>This event is used to move the file offset of a specified file descriptor. The <code>fd</code> argument specifies the file descriptor on which to move the offset and the <code>offset</code> argument specifies the offset relative to <code>whence</code>. The <code>whence</code> argument specifies the location for the offset relative to the beginning of the file, the current position, or the end of the file, respectively.</p> <p>There are some edge cases to be aware of when using lseek. If lseek is used with <code>whence</code> set to SEEK_END and offset set to 0, it logically sets the read/write pointer of the original file. This can make it difficult to track the offset of the original file. Additionally, lseek can be used to extend the file size, allowing users to write beyond the current file size without an explicit write system call. This is not secure and should be use carefully.</p>"},{"location":"docs/events/builtin/syscalls/lseek/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - File descriptor value.</li> <li><code>offset</code>:<code>off_t</code>[K] - Offset to move the read/write pointer to.</li> <li><code>whence</code>:<code>unsigned int</code>[K] - Specifies the location for the offset relative the beginning of the file, the current position, or the end of the file.</li> </ul>"},{"location":"docs/events/builtin/syscalls/lseek/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/lseek/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/lseek/#sys_lseek","title":"sys_lseek","text":""},{"location":"docs/events/builtin/syscalls/lseek/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/lseek/#purpose","title":"Purpose","text":"<p>Track the syscall invocation and returns.</p>"},{"location":"docs/events/builtin/syscalls/lseek/#example-use-case","title":"Example Use Case","text":"<p>The lseek event can be used to monitor any attempts at shrinking or extending the size of an open file. A program can use the lseek event to detect an attempt to extend the file size and alert the user accordingly.</p>"},{"location":"docs/events/builtin/syscalls/lseek/#issues","title":"Issues","text":"<p>In certain cases, lseek can be used to extend the length of a file without explicitly calling a write systemcall. This lack of control can lead to security vulnerabilities in programs which process files of a predefined length.</p>"},{"location":"docs/events/builtin/syscalls/lseek/#related-events","title":"Related Events","text":"<ul> <li>fstat - Monitor calls to fstat to detect changes in the file size.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/lsetxattr/","title":"lsetxattr","text":""},{"location":"docs/events/builtin/syscalls/lsetxattr/#intro","title":"Intro","text":"<p>lsetxattr - sets the value of a extended attribute in the filesystem</p>"},{"location":"docs/events/builtin/syscalls/lsetxattr/#description","title":"Description","text":"<p>The lsetxattr() system call sets the value of an extended attribute associated  with a file or directory referenced by path. The attributes are interpreted  according to the namespace indicated by the prefix argument. The value  parameter is a byte array of size size that will be associated with the  attribute identified by the pair of arguments (path, name).</p> <p>The flags argument is currently undefined on Linux systems, and should be  specified as 0.</p>"},{"location":"docs/events/builtin/syscalls/lsetxattr/#arguments","title":"Arguments","text":"<ul> <li><code>path</code>:<code>const char*</code>[K] - A pointer to a string indicating the path of the file or directory.</li> <li><code>name</code>:<code>const char*</code>[K] - A pointer to a string with the name of the extended attribute to set.</li> <li><code>value</code>:<code>const void*</code>[K] - A pointer to a buffer with the value for the extended attribute.</li> <li><code>size</code>:<code>size_t</code>[K] - The size of the buffer.</li> <li><code>flags</code>:<code>int</code>[K] - A value that is currently undefined on Linux and should be specified as 0.</li> </ul>"},{"location":"docs/events/builtin/syscalls/lsetxattr/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/lsetxattr/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/lsetxattr/#lsetxattr_1","title":"lsetxattr","text":""},{"location":"docs/events/builtin/syscalls/lsetxattr/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/lsetxattr/#purpose","title":"Purpose","text":"<p>To monitor the activity of lsetxattr syscalls.</p>"},{"location":"docs/events/builtin/syscalls/lsetxattr/#example-use-case","title":"Example Use Case","text":"<p>Real-time monitoring of lsetxattr syscalls being called to provide insights into  the access and modification of extended file attributes on a system.</p>"},{"location":"docs/events/builtin/syscalls/lsetxattr/#issues","title":"Issues","text":"<p>None</p>"},{"location":"docs/events/builtin/syscalls/lsetxattr/#related-events","title":"Related Events","text":"<p>lgetxattr, fsetxattr, fgetxattr, listxattr, removexattr.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/lstat/","title":"lstat","text":""},{"location":"docs/events/builtin/syscalls/lstat/#intro","title":"Intro","text":"<p>lstat() - Get file status</p>"},{"location":"docs/events/builtin/syscalls/lstat/#description","title":"Description","text":"<p>The lstat() system call is used to get information about the file at a certain location in the filesystem. The information is stored in the struct stat and can be used for various purposes including permissions checking, file size, time stamps, etc. The lstat() does not follow symbolic links, so it should be called for each link in order to get its status. </p>"},{"location":"docs/events/builtin/syscalls/lstat/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char *</code>[U] - A pointer to a character string with the pathname of the file which status is wanted.</li> <li><code>statbuf</code>:<code>struct stat *</code>[K] - A pointer to a stat structure where the status information will be stored. </li> </ul>"},{"location":"docs/events/builtin/syscalls/lstat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/lstat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/lstat/#sys_lstat","title":"sys_lstat","text":""},{"location":"docs/events/builtin/syscalls/lstat/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/lstat/#purpose","title":"Purpose","text":"<p>To capture system events related to the lstat() system call.</p>"},{"location":"docs/events/builtin/syscalls/lstat/#example-use-case","title":"Example Use Case","text":"<p>Using lstat() in order to check the permissions of a certain file before actually accessing it.</p>"},{"location":"docs/events/builtin/syscalls/lstat/#issues","title":"Issues","text":"<p>The lstat() system call might not work properly in some systems.</p>"},{"location":"docs/events/builtin/syscalls/lstat/#related-events","title":"Related Events","text":"<p>open(), read(), write(), close(), fstat()</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/lstat64/","title":"lstat64","text":""},{"location":"docs/events/builtin/syscalls/lstat64/#intro","title":"Intro","text":"<p>lstat64 - Retrieve information about a file</p>"},{"location":"docs/events/builtin/syscalls/lstat64/#description","title":"Description","text":"<p>The lstat64() system call is used to retrieve information about a file or symbolic link stored in the file system. The information returned by lstat64() is similar to that returned by stat64(), but lstat64() does not follow symbolic links. The lstat64() system call is useful if the application needs to check the file type of a symbolic link, or if the target of the link might be a directory.</p> <p>The lstat64() system call is also useful for finding out whether the file is a regular file, a symbolic link, a directory, a char special device, a block special device, a named pipe, a socket, or an executable image.</p> <p>The lstat64() system call is part of the Base Specifications Issue 6 (SUSv6) and conforms to IEEE Std 1003.1-2008 (POSIX.1).</p>"},{"location":"docs/events/builtin/syscalls/lstat64/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>: <code>const char*</code>[K] - File or directory path.</li> <li><code>statbuf</code>: <code>struct stat64*</code>[U] - Pointer to the given structure, containing information about the file.</li> </ul>"},{"location":"docs/events/builtin/syscalls/lstat64/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/lstat64/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/lstat64/#fmode_create","title":"fmode_create","text":""},{"location":"docs/events/builtin/syscalls/lstat64/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/lstat64/#purpose","title":"Purpose","text":"<p>To detect when the lstat64 system call is invoked.</p>"},{"location":"docs/events/builtin/syscalls/lstat64/#example-use-case","title":"Example Use Case","text":"<p>A file integrity monitoring system or a logging system that needs to keep track of information about the files present in the system can use the lstat64 system call to retrieve information about a given file.</p>"},{"location":"docs/events/builtin/syscalls/lstat64/#issues","title":"Issues","text":"<p>The lstat64 system call is vulnerable to TOCTOU (Time of check, time of use) race condition, where the state of the file can change between the moment it was checked and the moment the system call is executed.</p>"},{"location":"docs/events/builtin/syscalls/lstat64/#related-events","title":"Related Events","text":"<ul> <li>stat64</li> <li>fstatat64</li> <li>fstat64</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/madvise/","title":"madvise","text":""},{"location":"docs/events/builtin/syscalls/madvise/#intro","title":"Intro","text":"<p>madvise - Allows potentially optimization advice about the memory in the specified address range.</p>"},{"location":"docs/events/builtin/syscalls/madvise/#description","title":"Description","text":"<p>The madvise() system call provides advice about the use of memory addresses in the specified range. This range is defined by the starting address pointer addr and length. The advice is specified by the advice argument in the form of a value defined in <code>&lt;sys/mman.h&gt;</code>. Valid values of advice are MADV_NORMAL, MADV_RANDOM, MADV_SEQUENTIAL, MADV_WILLNEED, MADV_DONTNEED, MADV_REMOVE, or MADV_HUGEPAGE.</p> <p>This call will not generate any errors if the advice is not honored, but it can be used as a hint for performance optimization. For example, MADV_WILLNEED can be used to inform the kernel that an application intends to access the memory addresses in the range and that the kernel should not only immediately load the page from swap into memory but it should keep it in memory even if memory pressure increases in order to avoid having to re-fetch the page from swap.</p> <p>It is also important to note that the kernel is not obligated to honor the advice, as the kernel can choose to ignore the advice if it needs to free up memory or if the system loading is too high.</p>"},{"location":"docs/events/builtin/syscalls/madvise/#arguments","title":"Arguments","text":"<ul> <li><code>addr</code>:<code>void*</code>[U] - Pointer to the starting address of the range.</li> <li><code>length</code>:<code>size_t</code>[U] - Length of the range in bytes.</li> <li><code>advice</code>:<code>int</code>[U] - Integer representing an advice on how to handle the memory in the specified address range, defined in <code>&lt;sys/mman.h&gt;</code> as MADV_NORMAL, MADV_RANDOM, MADV_SEQUENTIAL, MADV_WILLNEED, MADV_DONTNEED, MADV_REMOVE, or MADV_HUGEPAGE.</li> </ul>"},{"location":"docs/events/builtin/syscalls/madvise/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/madvise/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/madvise/#sys_madvise","title":"sys_madvise","text":""},{"location":"docs/events/builtin/syscalls/madvise/#type","title":"Type","text":"<p>Kprobe + Kretprobe </p>"},{"location":"docs/events/builtin/syscalls/madvise/#purpose","title":"Purpose","text":"<p>To monitor the execution of madvise syscall, analyze arguments and detect usage.</p>"},{"location":"docs/events/builtin/syscalls/madvise/#example-use-case","title":"Example Use Case","text":"<p>A complex application uses madvise to tell the kernel that it will be accessing a certain address range with hot data, which helps the kernel know that it should not be swapped out until the application no longer needs it.</p>"},{"location":"docs/events/builtin/syscalls/madvise/#issues","title":"Issues","text":"<p>madvise is prone to TOCTOU vulnerability, in which the behavior of the call may differ from the expecting behavior since the memory state can change between the time it is checked and the time it is used.</p>"},{"location":"docs/events/builtin/syscalls/madvise/#related-events","title":"Related Events","text":"<ul> <li>mincore - Determine whether pages are resident in memory</li> <li>mremap - Remap an existing memory range</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mbind/","title":"mbind","text":""},{"location":"docs/events/builtin/syscalls/mbind/#intro","title":"Intro","text":"<p>mbind - binds an area of process memory to a set of CPUs in the system</p>"},{"location":"docs/events/builtin/syscalls/mbind/#description","title":"Description","text":"<p>The <code>mbind()</code> system call sets the process memory policy of a given address range to a preferred list of nodes. This call is used to control the distribution of physical memory pages to nodes on a NUMA system. The main goal is to optimize the process execution speed. The policy might be applied to a specified range of virtual address space, but the underlying physical pages might be scattered across the nodes according to the underlying memory distribution of the physical system.</p> <p>The efficacy of an mbind() call depends on various factors, like the underlying memory distribution of the physical system, the access pattern of the calling process, the hardware topology and the kernel scheduling algorithms. It is important to note that the mbind() call is advisory, meaning that the kernel might ignore the preferred placement of memory pages as long as it provides reasonable performance for the given workload.</p> <p>Are there any edge-cases, drawbacks or advantages of using it?</p> <p>The main disadvantage of using the mbind() call is that it might not provide the best possible results. To ensure optimal results, the kernel might need to be tuned for the particular task. Additionally, calls to mbind() that involve moving large amounts of memory might be expensive, as they involve page table updates, page potentially being read out of memory and distributed across nodes, and possibly need to be avoided in production scenarios.</p>"},{"location":"docs/events/builtin/syscalls/mbind/#arguments","title":"Arguments","text":"<ul> <li><code>addr</code>:<code>void*</code>[K] - the starting address of the memory range that should be affected by the policy.</li> <li><code>len</code>:<code>unsigned long</code>[K] - the length in bytes of the memory range that should be affected.</li> <li><code>mode</code>:<code>int</code>[K] - the memory policy that should be applied, as specified by the given constants.</li> <li><code>nodemask</code>:<code>const unsigned long*</code>[K] - a list of preferred nodes for the process memory pages.</li> <li><code>maxnode</code>:<code>unsigned long</code>[K] - the highest node number in the system that the nodemask applies to.</li> <li><code>flags</code>:<code>unsigned int</code>[K] - flags that might modify the default behavior of mbind(), such as MPOL_MF_STRICT, MPOL_MF_MOVE, MPOL_MF_MOVE_ALL or MPOL_MF_INTERNAL.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mbind/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mbind/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mbind/#mbind_1","title":"mbind","text":""},{"location":"docs/events/builtin/syscalls/mbind/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/mbind/#purpose","title":"Purpose","text":"<p>To collect information about process memory policy.</p>"},{"location":"docs/events/builtin/syscalls/mbind/#example-use-case","title":"Example Use Case","text":"<p>When a developer needs to profile an application across nodes to determine which nodes provide the best performance. </p>"},{"location":"docs/events/builtin/syscalls/mbind/#issues","title":"Issues","text":"<p>The mbind() system call is advisory, meaning the kernel might ignore the preferred placement of memory pages as long as it provides reasonable performance for the given workload.</p>"},{"location":"docs/events/builtin/syscalls/mbind/#related-events","title":"Related Events","text":"<p>get_mempolicy, set_mempolicy, move_pages.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/membarrier/","title":"membarrier","text":""},{"location":"docs/events/builtin/syscalls/membarrier/#intro","title":"Intro","text":"<p>membarrier - executes a memory barrier on a set of threads.</p>"},{"location":"docs/events/builtin/syscalls/membarrier/#description","title":"Description","text":"<p>The membarrier() system call is used to execute a memory barrier inside live application threads. Memory barriers ensure that the read and write operations issued before a barrier operation are visible to all other threads before any of the operations issued after the barrier finish their execution. This enables synchronization between threads in an application without the need for explicit locks.</p> <p>Administrators can use this system call to control the order of writes to shared memory areas between different threads, as well as to make sure that all writes memory operations performed before the syscall will take effect before any further operations are executed.</p>"},{"location":"docs/events/builtin/syscalls/membarrier/#arguments","title":"Arguments","text":"<ul> <li><code>cmd</code>:<code>int</code>[K] - specifies the type of barrier to execute. Possible values are: MEMBARRIER_CMD_SHARED (wait for the completion of all memory operations started before the call) and MEMBARRIER_CMD_PRIVATE (wait for the completion of all memory operations started by the calling thread).</li> <li><code>flags</code>:<code>int</code>[K] - a bitmask of flags to customize the behavior of the membarrier() function.</li> </ul>"},{"location":"docs/events/builtin/syscalls/membarrier/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/membarrier/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/membarrier/#membarrier_1","title":"membarrier","text":""},{"location":"docs/events/builtin/syscalls/membarrier/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/membarrier/#purpose","title":"Purpose","text":"<p>To intercept the system call before it is executed.</p>"},{"location":"docs/events/builtin/syscalls/membarrier/#example-use-case","title":"Example Use Case","text":"<p>A useful example of membarrier() would be to make sure that two threads accessing the same variable in a shared memory area coordinate their access without the need to explicitly use locks.</p>"},{"location":"docs/events/builtin/syscalls/membarrier/#issues","title":"Issues","text":"<p>It is important to note that membarrier() only guarantees an ordering between memory operations issued within the same thread, or between threads. Any operations that occur within the same thread before or after the membarrier() call are not necessarily ordered.</p>"},{"location":"docs/events/builtin/syscalls/membarrier/#related-events","title":"Related Events","text":"<p>sync_file_range(), msync(), fdatasync()</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/memfd_create/","title":"memfd_create","text":""},{"location":"docs/events/builtin/syscalls/memfd_create/#intro","title":"Intro","text":"<p>memfd_create - Creates an anonymous file and return a file descriptor associated with the file</p>"},{"location":"docs/events/builtin/syscalls/memfd_create/#description","title":"Description","text":"<p>The memfd_create system call creates an anonymous file and return a file descriptor associated with the file. The file behaves like any other file and can be mmap'ed or used with any of the other file operations. Despite being anonymous it can also have a name associated with it, as long as no other file with the same name already exists. The main use case of this syscall is to create an interface to memory that behaves like a file and is able to pass through a certain set of filters, such as virus scanners.</p>"},{"location":"docs/events/builtin/syscalls/memfd_create/#arguments","title":"Arguments","text":"<ul> <li><code>name</code>:<code>const char*</code>[K] - The name of the file, can be null or a unique name. </li> <li><code>flags</code>:<code>unsigned int</code>[K] - Flags specifying the behaviour of the file, such as size, permissions, etc.</li> </ul>"},{"location":"docs/events/builtin/syscalls/memfd_create/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/memfd_create/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/memfd_create/#sys_memfd_create","title":"sys_memfd_create","text":""},{"location":"docs/events/builtin/syscalls/memfd_create/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/memfd_create/#purpose","title":"Purpose","text":"<p>To trace the syscall to memfd_create</p>"},{"location":"docs/events/builtin/syscalls/memfd_create/#example-use-case","title":"Example Use Case","text":"<p>The memfd_create syscall can be used to create a lightweight anonymous file that can be passed through virus scanners, or other filters, to confirm the integrity of data that is to be passed through a certain system.</p>"},{"location":"docs/events/builtin/syscalls/memfd_create/#issues","title":"Issues","text":"<p>None</p>"},{"location":"docs/events/builtin/syscalls/memfd_create/#related-events","title":"Related Events","text":"<p>None</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/memfd_secret/","title":"memfd_secret","text":""},{"location":"docs/events/builtin/syscalls/memfd_secret/#intro","title":"Intro","text":"<p>memfd_secret - creates an anonymous file backed by memory, with the ability to lock a portion of the file.</p>"},{"location":"docs/events/builtin/syscalls/memfd_secret/#description","title":"Description","text":"<p>The memfd_secret() system call creates a file descriptor that refers to an anonymous, in-memory file. It differs from memfd_create() in that it has a secret option, which allows a portion of the file to be locked in memory, preventing it from being swapped to disk. This can be useful for sensitive data, such as cryptographic key material, which should not be written to persistent storage.</p> <p>The <code>flags</code> argument determines how the file is created, and is a bitmask of permission bits. It can be used to control whether read and write operations are allowed on the file.</p>"},{"location":"docs/events/builtin/syscalls/memfd_secret/#arguments","title":"Arguments","text":"<ul> <li><code>flags</code>: <code>unsigned int</code>[K] - bitmask of permission bits to control whether read and write operations are allowed on the file.</li> </ul>"},{"location":"docs/events/builtin/syscalls/memfd_secret/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/memfd_secret/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/memfd_secret/#memfd_secret_1","title":"memfd_secret","text":""},{"location":"docs/events/builtin/syscalls/memfd_secret/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/memfd_secret/#purpose","title":"Purpose","text":"<p>To monitor and log when the system call is called.</p>"},{"location":"docs/events/builtin/syscalls/memfd_secret/#example-use-case","title":"Example Use Case","text":"<p>This system call can be used to create a file that is stored in memory, with the ability to lock a portion of the file. This could be used to store sensitive data, such as cryptographic keys, preventing it from being written to persistent storage.</p>"},{"location":"docs/events/builtin/syscalls/memfd_secret/#issues","title":"Issues","text":"<p>None known.</p>"},{"location":"docs/events/builtin/syscalls/memfd_secret/#related-events","title":"Related Events","text":"<ul> <li>memfd_create() - creates an anonymous file backed by memory</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/migrate_pages/","title":"Migrate_pages","text":""},{"location":"docs/events/builtin/syscalls/migrate_pages/#intro","title":"Intro","text":"<p>migrate_pages - Moves pages from one node set to another</p>"},{"location":"docs/events/builtin/syscalls/migrate_pages/#description","title":"Description","text":"<p>Migrate_pages is a syscall that moves pages from one node set to another. It does so by taking the pages from the old_nodes nodes, moving them to the new_nodes nodes, and counting the number of pages moved successfully. The process used is specified by the pid argument.  </p> <p>Migrate_pages can be beneficial when used properly. It can move pages around a node set quickly and with minimal effort. However, this syscall can be vulnerable to TOCTOU (time-of-check to time-of-use) attacks. Furthermore, if the nodes are not setup properly, pages may not move.</p>"},{"location":"docs/events/builtin/syscalls/migrate_pages/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>int</code>[K] - The pid of the process to migrate pages from.</li> <li><code>maxnode</code>:<code>unsigned long</code>[K] - The maximum number of nodes to migrate between.</li> <li><code>old_nodes</code>:<code>const unsigned long*</code>[K] - Pointer to an array of unsigned long representing the nodes that the pages to be moved away from.</li> <li><code>new_nodes</code>:<code>const unsigned long*</code>[K] - Pointer to an array of unsigned long representing the nodes that the pages to be migrated to.</li> </ul>"},{"location":"docs/events/builtin/syscalls/migrate_pages/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/migrate_pages/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/migrate_pages/#sys_migrate_pages","title":"sys_migrate_pages","text":""},{"location":"docs/events/builtin/syscalls/migrate_pages/#type","title":"Type","text":"<p>KProbes</p>"},{"location":"docs/events/builtin/syscalls/migrate_pages/#purpose","title":"Purpose","text":"<p>Tracking page movements across nodes.</p>"},{"location":"docs/events/builtin/syscalls/migrate_pages/#example-use-case","title":"Example Use Case","text":"<p>migrate_pages can be used when migrations need to happen quickly and resources are limited. For example, when a system needs to be partitioned in order to reserve resources for a certain process.</p>"},{"location":"docs/events/builtin/syscalls/migrate_pages/#issues","title":"Issues","text":"<p>migrate_pages is vulnerable to TOCTOU attacks and should be used with caution. Furthermore, as the maximum number of nodes to be migrated can be specified, migration may fail depending on how the nodes are setup.</p>"},{"location":"docs/events/builtin/syscalls/migrate_pages/#related-events","title":"Related Events","text":"<ul> <li>move_pages</li> <li>get_mempolicy</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mincore/","title":"mincore","text":""},{"location":"docs/events/builtin/syscalls/mincore/#intro","title":"Intro","text":"<p>mincore - Read the memory mapping of a given address.</p>"},{"location":"docs/events/builtin/syscalls/mincore/#description","title":"Description","text":"<p>mincore is a Linux system call that retrieves the page-level memory usage of a specified range of virtual addresses. The system call takes 3 arguments; the virtual address at which to start, the length of the mapping to query, and an array of bytes to write the retrieved data to. The system returns a vector of bytes whose bits indicate the usage of pages in the specified address range. </p> <p>There are some noteworthy edge cases and drawbacks that may come into effect for this system call. It is not designed for large ranges of virtual address, and thus can quickly become slow if affected. Also, the information retrieved may not be up to date when polled, meaning that it may not accurately reflect the usage of the specified virtual address range.</p>"},{"location":"docs/events/builtin/syscalls/mincore/#arguments","title":"Arguments","text":"<ul> <li><code>addr</code>: <code>void*</code>[U] - A pointer to the starting virtual address of the memory region to query.</li> <li><code>length</code>: <code>size_t</code>[U] - The length of the memory region to query.</li> <li><code>vec</code>: <code>unsigned char*</code>[U] - A pointer to an array of bytes that mincore will write the results to.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mincore/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/mincore/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mincore/#sys_mincore","title":"sys_mincore","text":""},{"location":"docs/events/builtin/syscalls/mincore/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/mincore/#purpose","title":"Purpose","text":"<p>To trace and monitor memory usage.</p>"},{"location":"docs/events/builtin/syscalls/mincore/#example-use-case","title":"Example Use Case","text":"<p>mincore could be used to detect page faults in areas of memory the program is subscribed to. This can be used to help determin specific areas of memory which are actively in-use.</p>"},{"location":"docs/events/builtin/syscalls/mincore/#issues","title":"Issues","text":"<p>mincore is not designed to determine memory access patterns, as this system call is not able to capture the accessed pages once they have been accessed.</p>"},{"location":"docs/events/builtin/syscalls/mincore/#related-events","title":"Related Events","text":"<p>The mincore system call can be used effectively in conjunction with the mprotect and mlock system calls. Mprotect modifies the protection access of a memory region, while mlock locks a memory region in RAM, while mincore can help determine usage of the regions.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mkdir/","title":"mkdir","text":""},{"location":"docs/events/builtin/syscalls/mkdir/#intro","title":"Intro","text":"<p>mkdir - Creates a directory named pathname.</p>"},{"location":"docs/events/builtin/syscalls/mkdir/#description","title":"Description","text":"<p>The mkdir() system call creates a directory named pathname.  It is eight  bits of the Mode that contain the Unix permission bits for the newly created directory. The permissions of new directories are as follows:</p> <p>Usr/Grp/Oth: rwxr-xr-x</p> <p>The newly created directory inherits its group identity from the parent directory. This system call follows symbolic links and fails if the  directory  already  exists  or  if  a  directory  component  in pathname does  not  exist or is a dangling  symbolic link. On success, zero is returned.</p>"},{"location":"docs/events/builtin/syscalls/mkdir/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code>[K,U] - Pointer to a string containing the name of the directory to be created.</li> <li><code>mode</code>:<code>mode_t</code>[K,U] - A bit pattern that serves as the file permission bits for the new directory.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mkdir/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/mkdir/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mkdir/#sys_mkdir","title":"sys_mkdir","text":""},{"location":"docs/events/builtin/syscalls/mkdir/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/mkdir/#purpose","title":"Purpose","text":"<p>Monitor and observe when mkdir system calls are invoked with specific argument values, or to monitor and observe mkdir system calls in general.</p>"},{"location":"docs/events/builtin/syscalls/mkdir/#example-use-case","title":"Example Use Case","text":"<p>The mkdir system call could be used to monitor new directory creation. This can be useful to detect malicious activities such as directory traversal or privilege escalation.</p>"},{"location":"docs/events/builtin/syscalls/mkdir/#issues","title":"Issues","text":"<p>No known issues</p>"},{"location":"docs/events/builtin/syscalls/mkdir/#related-events","title":"Related Events","text":"<ul> <li>open </li> <li>access</li> <li>stat</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mkdirat/","title":"mkdirat","text":""},{"location":"docs/events/builtin/syscalls/mkdirat/#intro","title":"Intro","text":"<p>mkdirat - create a directory with a given path relative to the directory referenced by the file descriptor</p>"},{"location":"docs/events/builtin/syscalls/mkdirat/#description","title":"Description","text":"<p>The mkdirat() system call creates a new directory with the given name relative to the directory referenced by the file descriptor. The argument mode specifies the permissions to use. The newly created directory will be an empty directory and will be owned by the effective user ID of the process.</p> <p>The call is useful when you want to restrict the creation of new directories to a certain directory, due to security matters. When dirfd is AT_FDCWD, the current working directory is used as the starting point. Edge-cases to consider are when the pathname argument is not absolute, when the pathname is longer than PATH_MAX, when the dirfd argument is invalid, or when the mode argument is invalid.</p>"},{"location":"docs/events/builtin/syscalls/mkdirat/#arguments","title":"Arguments","text":"<ul> <li><code>dirfd</code>:<code>int</code>[K] - open directory file descriptor used as the relative path for the new directory.</li> <li><code>pathname</code>:<code>const char*</code>[KU] - pathname of the created directory.</li> <li><code>mode</code>:<code>mode_t</code>[K] - File permission bits for the created directory.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mkdirat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/mkdirat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mkdirat/#do_mkdirat","title":"do_mkdirat","text":""},{"location":"docs/events/builtin/syscalls/mkdirat/#type","title":"Type","text":"<p>Kprobes </p>"},{"location":"docs/events/builtin/syscalls/mkdirat/#purpose","title":"Purpose","text":"<p>To track when the directory is created </p>"},{"location":"docs/events/builtin/syscalls/mkdirat/#example-use-case","title":"Example Use Case","text":"<p>mkdirat() can be useful when tracking the creation of directories, for security reasons. For example, it can be used to detect malicious activity where a process is creating multiple malicious directories in quick succession.</p>"},{"location":"docs/events/builtin/syscalls/mkdirat/#issues","title":"Issues","text":"<p>mkdirat() may fail due to missing or insufficient permissions, or due to a long pathname argument. </p>"},{"location":"docs/events/builtin/syscalls/mkdirat/#related-events","title":"Related Events","text":"<ul> <li>openat()</li> <li>access()</li> <li>chmod()</li> <li>rmdir()</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mknod/","title":"mknod","text":""},{"location":"docs/events/builtin/syscalls/mknod/#intro","title":"Intro","text":"<p>mknod - creates a filesystem node (file, device special file or named pipe)</p>"},{"location":"docs/events/builtin/syscalls/mknod/#description","title":"Description","text":"<p>The <code>mknod</code> system call is used to create a filesystem node (file, device special file or named pipe) named by the pathname referred to by <code>pathname</code>. It has associated permissions determined by <code>mode</code> (modified by the process\u2019s umask) and is given the user ID and group ID specified by <code>dev</code>. On success (returning 0), the inode creation time is set to the current time and the last data modification and last file status change times are set to the current time.</p>"},{"location":"docs/events/builtin/syscalls/mknod/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code>[KU] - pathname refers the name of the new file or directory.</li> <li><code>mode</code>:<code>mode_t</code>[KU] - expresses the mode of the new file in both symbolic and absolute ways. The symbolic mode can use the alphabetical characters \u201cr\u201d, \u201cw\u201d, and \u201cx\u201d.</li> <li><code>dev</code>:<code>dev_t</code>[KU] - is an unsigned integer specifying the file or directory user ID and group ID.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mknod/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/mknod/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mknod/#do_mknod","title":"do_mknod","text":""},{"location":"docs/events/builtin/syscalls/mknod/#type","title":"Type","text":"<p>Kprobes </p>"},{"location":"docs/events/builtin/syscalls/mknod/#purpose","title":"Purpose","text":"<p>To track an event when a program calls mknod.</p>"},{"location":"docs/events/builtin/syscalls/mknod/#example-use-case","title":"Example Use Case","text":"<p>An example use-case when mknod can be used is in an application making use of named pipes. The mknod system call can be used to create a named pipe whose pathname is provided by <code>pathname</code> and whose permissions are given by <code>mode</code>.</p>"},{"location":"docs/events/builtin/syscalls/mknod/#issues","title":"Issues","text":"<p>If the application creating the node points to an existing one, it will fail to be created and will return an EEXIST error.</p>"},{"location":"docs/events/builtin/syscalls/mknod/#related-events","title":"Related Events","text":"<p><code>stat</code>, <code>fstat</code>, <code>lstat</code> - to obtain information about a file or directory specified by pathname. <code>unlink</code> - to remove the specific node.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mknodat/","title":"mknodat","text":""},{"location":"docs/events/builtin/syscalls/mknodat/#intro","title":"Intro","text":"<p>mknodat - create a special or ordinary file relative to open directory</p>"},{"location":"docs/events/builtin/syscalls/mknodat/#description","title":"Description","text":"<p>The mknodat() system call operates in exactly the same way as mknod(), except for the differences described in this manual page.</p> <p>The mknodat() system call creats a special or ordinary file (named by pathname) with permission defined by mode. It is identical to the mknod() system call. The only difference is that the pathname relative to a directory file descriptor, rather than to the working directory.</p> <p>The user ID and group ID of the created file are set to the effective user ID and group ID of the process, respectively.</p>"},{"location":"docs/events/builtin/syscalls/mknodat/#arguments","title":"Arguments","text":"<ul> <li><code>dirfd</code>:<code>int</code>[K] - Directory file descriptor.</li> <li><code>pathname</code>:<code>const char*</code>[K] - Pathname of the created file.</li> <li><code>mode</code>:<code>mode_t</code>[K] - File type and access mode of the created file.</li> <li><code>dev</code>:<code>dev_t</code>[K, TOCTOU] - Pointer to a dev_t structure that is used to store the major or minor device numbers (only for character or block special files).</li> </ul>"},{"location":"docs/events/builtin/syscalls/mknodat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/mknodat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mknodat/#sys_mknodat","title":"sys_mknodat","text":""},{"location":"docs/events/builtin/syscalls/mknodat/#type","title":"Type","text":"<p>kprobes + tracepoints</p>"},{"location":"docs/events/builtin/syscalls/mknodat/#purpose","title":"Purpose","text":"<p>To record when mknodat() is called, what parameters were passed and which return value was returned.</p>"},{"location":"docs/events/builtin/syscalls/mknodat/#example-use-case","title":"Example Use Case","text":"<p>The mknodat() system call can be used by a privileged process to create a directory and file located inside a user-defined directory. This can be used to deploy basic IPC (inter-process communication) infrastructure between processes that run under the same user ID.</p>"},{"location":"docs/events/builtin/syscalls/mknodat/#issues","title":"Issues","text":"<p>No known issues.</p>"},{"location":"docs/events/builtin/syscalls/mknodat/#related-events","title":"Related Events","text":"<ul> <li>openat()</li> <li>fstatat()</li> <li>fchownat()</li> <li>mkdirat()</li> <li>readdirat()</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mlock/","title":"mlock","text":""},{"location":"docs/events/builtin/syscalls/mlock/#intro","title":"Intro","text":"<p>mlock - lock the given range of memory so it won't be swapped to disk.</p>"},{"location":"docs/events/builtin/syscalls/mlock/#description","title":"Description","text":"<p>The <code>mlock</code> syscall locks the given range of memory into RAM so it won't be swapped to disk. This is useful in scenarios where you need to access or modify data stored in memory, but don't want it to get overwritten or written to disk by the kernel's virtual memory system. While this syscall ensures that the data will stay in RAM, it can still be accessed by other processes in the system, so caution should be used when using this syscall. One common misuse is allocating too much memory that cannot possibly fit in RAM, resulting in the system becoming unresponsive.</p>"},{"location":"docs/events/builtin/syscalls/mlock/#arguments","title":"Arguments","text":"<ul> <li><code>addr</code>:<code>const void*</code>[K] - starting address of the range of pages to lock.</li> <li><code>len</code>:<code>size_t</code>[K] - length of the range of pages to lock.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mlock/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mlock/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mlock/#sys_mlock","title":"sys_mlock","text":""},{"location":"docs/events/builtin/syscalls/mlock/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/mlock/#purpose","title":"Purpose","text":"<p>Monitoring the parameters of the mlock syscall and its return value.</p>"},{"location":"docs/events/builtin/syscalls/mlock/#example-use-case","title":"Example Use Case","text":"<p>An example use case for this event could be monitoring suspicous memory locking activity. This could facilitate the detection of malware that attempts to protect its data from scrutiny by using mlock.</p>"},{"location":"docs/events/builtin/syscalls/mlock/#issues","title":"Issues","text":"<p>This syscall requires root level privileges, so it can potentially be used by malicious actors to lock critical system memory that may cause the system to become unresponsive.</p>"},{"location":"docs/events/builtin/syscalls/mlock/#related-events","title":"Related Events","text":"<ul> <li>mlockall - lock all the process's virtual pages into RAM.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mlock2/","title":"mlock2","text":""},{"location":"docs/events/builtin/syscalls/mlock2/#intro","title":"Intro","text":"<p>mlock2 - Lock part of the calling process's memory into RAM.</p>"},{"location":"docs/events/builtin/syscalls/mlock2/#description","title":"Description","text":"<p>The mlock2 system call is used to lock a region of memory in a calling process' virtual  address space into RAM. This prevents the kernel from using the memory for other system purposes. The memory region's address and size are specified, as well as optional flags  that modify the behavior of the call. mlock2 allows for a more fine-grained control of  the memory lockout than mlock, including the ability to specify individual page frames. This system call is used to guarantee that a region is not swapped out, preventing  latencies in execution due to paging. It is often used for sensitive operations like  encryption and hashing, however due to the resource intensive nature of the system call  it should be used sparingly.</p>"},{"location":"docs/events/builtin/syscalls/mlock2/#arguments","title":"Arguments","text":"<ul> <li><code>addr</code>:<code>const void*</code>[KU] - address of the starting memory region that should be locked.</li> <li><code>len</code>:<code>size_t</code>[K] - length of the memory region to be locked, in bytes. Must be a multiple of PAGE_SIZE.</li> <li><code>flags</code>:<code>int</code>[K] - optional flags that modify the behavior of the call, either MLOCK_ or MLOCK2_ flags can be specified.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mlock2/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/mlock2/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mlock2/#do_mlock2","title":"do_mlock2","text":""},{"location":"docs/events/builtin/syscalls/mlock2/#type","title":"Type","text":"<p>Kprobes + Uprobes.</p>"},{"location":"docs/events/builtin/syscalls/mlock2/#purpose","title":"Purpose","text":"<p>Used to monitor when a process is trying to lock a region of memory.</p>"},{"location":"docs/events/builtin/syscalls/mlock2/#example-use-case","title":"Example Use case","text":"<p>mlock2 can be used in applications that need to prevent data from being swapped  out of memory. This can be used when working with encryption algorithms such as AES  that need to keep the key in a secure region of memory.</p>"},{"location":"docs/events/builtin/syscalls/mlock2/#issues","title":"Issues","text":"<p>mlock2 can pose an issue in resource intensive applications, as it requires memory to  be locked in RAM, reducing the amount of memory available for other tasks.</p>"},{"location":"docs/events/builtin/syscalls/mlock2/#related-events","title":"Related Events","text":"<ul> <li>mmap2</li> <li>munmap</li> <li>mlockall</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mlockall/","title":"mlockall","text":""},{"location":"docs/events/builtin/syscalls/mlockall/#intro","title":"Intro","text":"<p>mlockall - lock all mapped pages into physical memory. </p>"},{"location":"docs/events/builtin/syscalls/mlockall/#description","title":"Description","text":"<p>mlockall allows the calling process to lock all its pages into physical memory. This means that the pages can not be swapped out, will not cause page faults, and will never be moved by any operation. The effect of this can, in some cases, offer better performance. </p> <p>There are two flags which can be used with mlockall: </p> <ul> <li>MCL_CURRENT: Lock only currently mapped pages.</li> <li>MCL_FUTURE: Lock all pages which are mapped in the future.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mlockall/#arguments","title":"Arguments","text":"<ul> <li><code>flags</code>:<code>int</code>[K] - flags for mlockall operation. An ORed combination of values from mlockall(2) can be used.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mlockall/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mlockall/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mlockall/#mlockall_1","title":"mlockall","text":""},{"location":"docs/events/builtin/syscalls/mlockall/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/mlockall/#purpose","title":"Purpose","text":"<p>To monitor processes which make use of mlockall and their interaction with the physical memory. </p>"},{"location":"docs/events/builtin/syscalls/mlockall/#example-use-case","title":"Example Use Case","text":"<p>On a real-time embedded system, processes may have a large total number of pages mapped. Under heavy workload, the pages may be swapped out during times of heavy system load. By using mlockall, the real-time processes may be preserved in physical memory. </p>"},{"location":"docs/events/builtin/syscalls/mlockall/#issues","title":"Issues","text":"<p>The main drawbacks of mlockall is its high resource usage. When used, the amount of RAM available to the system will be limited. As a result, memory pressure can be an issue when mlockall is used on a system with multiple processes.</p>"},{"location":"docs/events/builtin/syscalls/mlockall/#related-events","title":"Related Events","text":"<ul> <li>mlock(2)</li> <li>munlockall(2)</li> <li>mlock2(2)</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mmap/","title":"mmap","text":""},{"location":"docs/events/builtin/syscalls/mmap/#intro","title":"Intro","text":"<p>mmap - map a region of memory in a process address space</p>"},{"location":"docs/events/builtin/syscalls/mmap/#description","title":"Description","text":"<p>The mmap() system call maps a region of memory in a process address space. It can be used to share a region of memory between processes, or to map a region of a file or device into a process's address space. The <code>flags</code> parameter is a bitwise combination of various options that control the mapping of a region of memory. The <code>prot</code> parameter is the protection level of the region. The <code>fd</code> parameter, if set, specifies the file descriptor of a regular file or device that is mapped into the calling process address space. The <code>off</code> parameter specifies the offset from the start of the file, if file-associated memory is being mapped.</p> <p>The <code>mmap()</code> system call is useful for allocating a fixed-size region of memory for use in a larger system. It can be used for applications such as kernel code, device drivers, shared libraries, or for any other region of memory that needs to be allocated.</p>"},{"location":"docs/events/builtin/syscalls/mmap/#arguments","title":"Arguments","text":"<ul> <li><code>addr</code>:<code>void*</code>[K] - a pointer to the memory location where the mapping will begin. If this value is NULL, page-aligned memory will be allocated and used.</li> <li><code>length</code>:<code>size_t</code>[K] - the size of the mapping in bytes.</li> <li><code>prot</code>:<code>int</code>[K] - the protection flags for the mapping; a combination of <code>PROT_READ</code>, <code>PROT_WRITE</code> and <code>PROT_EXEC</code>.</li> <li><code>flags</code>:<code>int</code>[K] - the flags for the mapping; a combination of <code>MAP_SHARED</code> or <code>MAP_PRIVATE</code>, and other flags to define the access.</li> <li><code>fd</code>:<code>int</code>[K] - the file descriptor of a regular file or device that is mapped into the calling process address space. If this parameter is -1, no file is mapped. </li> <li><code>off</code>:<code>off_t</code>[K] - the offset from the start of the file, if file-associated memory is being mapped.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mmap/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/mmap/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mmap/#do_mmap_pgoff","title":"do_mmap_pgoff","text":""},{"location":"docs/events/builtin/syscalls/mmap/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/mmap/#purpose","title":"Purpose","text":"<p>To monitor mmap system calls from user space.</p>"},{"location":"docs/events/builtin/syscalls/mmap/#sys_mmap","title":"sys_mmap","text":""},{"location":"docs/events/builtin/syscalls/mmap/#type_1","title":"Type","text":"<p>Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/mmap/#purpose_1","title":"Purpose","text":"<p>To monitor the return value of mmap system calls from the kernel.</p>"},{"location":"docs/events/builtin/syscalls/mmap/#example-use-case","title":"Example Use Case","text":"<p>A typical use of the <code>mmap()</code> system call is to map a file into memory and then access it directly. This allows applications to read and write the file, without having to use the slow I/O operations, as the data is in memory. This is especially useful for applications that need to read a large file quickly, but don't need to write it.</p>"},{"location":"docs/events/builtin/syscalls/mmap/#issues","title":"Issues","text":"<p>To use <code>mmap()</code>, the process must have sufficient memory available to map the file. If not, the <code>mmap()</code> call will return a memory allocation error and the file will not be mapped.</p>"},{"location":"docs/events/builtin/syscalls/mmap/#related-events","title":"Related Events","text":"<ul> <li><code>munmap()</code> - to unmap previously mapped memory regions.</li> <li><code>mremap()</code> - to remap memory regions.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mmap2/","title":"mmap2","text":""},{"location":"docs/events/builtin/syscalls/mmap2/#intro","title":"Intro","text":"<p>mmap2 - establish a mapping to a memory region in the virtual address space of a process</p>"},{"location":"docs/events/builtin/syscalls/mmap2/#description","title":"Description","text":"<p>The mmap2() system call creates a new mapping in the virtual address space of the calling process. The region is populated using the file descriptor passed in via the fd argument. These mappings may or may not be backed by physical memory or it could be mapped to the device I/O (found mostly in the kernel Space). This system call is mainly used to map a certain piece of memory to an I/O device or device buffers.</p> <p>The addr argument allows the caller to specify a preferred starting address for the mapping, although this is not honoured in all cases. The length argument specifies the length of the mapping. The prot argument determines the protection of the mapping. It may contain any bitwise combination of the following flags:</p> <ul> <li>PROT_NONE: no access to the mapped region</li> <li>PROT_READ: reads from the mapped region allowed</li> <li>PROT_WRITE: writes to the mapped region allowed</li> <li>PROT_EXEC: execution from the mapped region allowed</li> </ul> <p>The flags argument allows the caller to specify the type of mapping. It may contain any bitwise combination of:</p> <ul> <li>MAP_SHARED: The mapping is shared, thus changes in its contents reflect to all processes that have access to it.</li> <li>MAP_PRIVATE: The mapping is private to the calling process.</li> <li>MAP_HUGETLB: Allocate memory in units of huge pages.</li> </ul> <p>The fd argument is used to specify the file descriptor to be used for the mapping. If it is set to -1, a anonymous mapping is created.</p> <p>If the flags argument contains MAP_FIXED, the mapping will be placed at the address specified in the addr argument. Otherwise it is unspecified, although the kernel attempts to locate the mapping near the address given.</p> <p>The pgoffset argument is used to specify a file-offset when mapping from a file.</p>"},{"location":"docs/events/builtin/syscalls/mmap2/#arguments","title":"Arguments","text":"<ul> <li><code>addr</code>:<code>unsigned long</code>[U] - the address of the mapped memory.</li> <li><code>length</code>:<code>unsigned long</code>[U] - the length of the mapped memory. </li> <li><code>prot</code>:<code>unsigned long</code>[U] - the protection of the memory. </li> <li><code>flags</code>:<code>unsigned long</code>[U] - flags that determine how the mapping is established. </li> <li><code>fd</code>:<code>unsigned long</code>[K] - file descriptor used to map the memory from. </li> <li><code>pgoffset</code>:<code>unsigned long</code>[K] - the file-offset used when mapping from a file.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mmap2/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/mmap2/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mmap2/#do_mmap2","title":"do_mmap2","text":""},{"location":"docs/events/builtin/syscalls/mmap2/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/mmap2/#purpose","title":"Purpose","text":"<p>To monitor memory mapping requests from user space.</p>"},{"location":"docs/events/builtin/syscalls/mmap2/#example-use-case","title":"Example Use Case","text":"<p>The mmap2 system call provides a way to map a certain piece of memory to an I/O device or device buffers. This could be useful when engineers need to access a device's memory without having to access memory directly in the kernel address space.</p>"},{"location":"docs/events/builtin/syscalls/mmap2/#issues","title":"Issues","text":"<p>mmap2 can fail with errors -EINVAL, -ENOMEM, and -EACCES if the given parameters do not meet the kernel requirements.</p>"},{"location":"docs/events/builtin/syscalls/mmap2/#related-events","title":"Related Events","text":"<p>mmap, unmmap, msync</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/modify_ldt/","title":"modify_ldt","text":""},{"location":"docs/events/builtin/syscalls/modify_ldt/#intro","title":"Intro","text":"<p>modify_ldt - Changes the definition of local descriptor table entries.</p>"},{"location":"docs/events/builtin/syscalls/modify_ldt/#description","title":"Description","text":"<p>The modify_ldt() system call provides a way to read and modify the local descriptor table (LDT) entries as well as to determine the current size of the table. Upon success, it returns the amount of memory actually read or written. Upon failure, it returns -1 and sets errno to indicate the error. </p> <p>The flags argument is a bit mask composed of the OR'ed value of constants defined in . This provides a way to tell the kernel which operation should be performed and what data should be included. <p>Using this system call allows the programmer to inspect and modify the LDT entries from user space. This can be useful for debugging, sandboxing, creating segmentation modules with user-space applications, or for any other reason.</p>"},{"location":"docs/events/builtin/syscalls/modify_ldt/#arguments","title":"Arguments","text":"<ul> <li><code>func</code>:<code>int</code>[K] - Specifies the operation to be performed. See   for available constants. <li><code>ptr</code>:<code>void*</code>[K] - Pointer to an ldt_entry struct, which specifies what the LDT entry should be set to.</li> <li><code>bytecount</code>:<code>unsigned long</code>[K] - Amount of memory to read/write from/to the LDT entry.</li>"},{"location":"docs/events/builtin/syscalls/modify_ldt/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/modify_ldt/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/modify_ldt/#sys_modify_ldt","title":"sys_modify_ldt","text":""},{"location":"docs/events/builtin/syscalls/modify_ldt/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/modify_ldt/#purpose","title":"Purpose","text":"<p>Hooked to inspect and modify the LDT entries from user space.</p>"},{"location":"docs/events/builtin/syscalls/modify_ldt/#example-use-case","title":"Example Use Case","text":"<p>Create a segmentation module with user-space applications.</p>"},{"location":"docs/events/builtin/syscalls/modify_ldt/#issues","title":"Issues","text":"<p>None known.</p>"},{"location":"docs/events/builtin/syscalls/modify_ldt/#related-events","title":"Related Events","text":"<ul> <li>modify_ldt_entry </li> <li>modify_ldt64</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mount/","title":"mount","text":""},{"location":"docs/events/builtin/syscalls/mount/#intro","title":"Intro","text":"<p>mount - Call the mount() system call to mount a filesystem </p>"},{"location":"docs/events/builtin/syscalls/mount/#description","title":"Description","text":"<p>The mount() system call serves to attach the filesystem specified by source (which is often a device name, but can also be a directory name or other), to the directory specified by the argument target. The filesystemtype argument specifies the filesystem type. Mount flags that control the behavior of the mount command are specified by mountflags, and data about the mount is determined by data.</p> <p>The mount() system call is used by system administrators and users to control the mounting of filesystems. It allows users to modify the filesystem tree without needing root privileges, for example, to mount a CDROM. It can be used to mount filesystems from one machine to another (e.g., remote NFS shares), in addition to filesystems on the local system.</p> <p>When mounting a filesystem, all the data contained within is accessible. It is important, therefore, to use the appropriate mount flags to ensure that the right levels of security and access are applied to a filesystem.</p>"},{"location":"docs/events/builtin/syscalls/mount/#arguments","title":"Arguments","text":"<ul> <li><code>source</code>:<code>const char*</code>[K] - The pathname or device-name of the filesystem that is to be mounted.</li> <li><code>target</code>:<code>const char*</code>[K] - The directory where the filesystem is to be mounted.</li> <li><code>filesystemtype</code>:<code>const char*</code>[K] - The name of the filesystem type, such as \"ext4\", \"btrfs\" etc. </li> <li><code>mountflags</code>:<code>unsigned long</code>[K] - The mount flags to control the behavior of the mount command. </li> <li><code>data</code>:<code>const void*</code>[K] - Data about the mount, such as the desired mount options and device type.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mount/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/mount/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mount/#do_mount","title":"do_mount()","text":""},{"location":"docs/events/builtin/syscalls/mount/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/mount/#purpose","title":"Purpose","text":"<p>Hooking into the do_mount() function gives us deeper insight into the mount() system call, allowing us to track and inspect the lower-level kernel-space operations that take place during mount.</p>"},{"location":"docs/events/builtin/syscalls/mount/#do_add_mount","title":"do_add_mount()","text":""},{"location":"docs/events/builtin/syscalls/mount/#type_1","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/mount/#purpose_1","title":"Purpose","text":"<p>Hooking into the do_add_mount() function allows us to monitor the data added to the VFS mount table as a result of the mount() system call.</p>"},{"location":"docs/events/builtin/syscalls/mount/#example-use-case","title":"Example Use Case","text":"<p>Mounting a disk partition or remote file system on a running system requires the mount() system call. It can also be used to mount a disk partition or a remote file system while the system is booting. This can be setup in the fstab or manually in the init scripts that run at boot.</p>"},{"location":"docs/events/builtin/syscalls/mount/#issues","title":"Issues","text":"<p>The mount() system call is vulnerable to a time-of-check-time-of-use race condition, which can lead to security vulnerabilities. </p>"},{"location":"docs/events/builtin/syscalls/mount/#related-events","title":"Related Events","text":"<ul> <li>umount() - syscall to unmount a filesystem</li> <li>fsconfig() - syscall for querying and configuring a filesystem</li> <li>chroot() - syscall for changing the root directory of the current process</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mount_setattr/","title":"mount_setattr","text":""},{"location":"docs/events/builtin/syscalls/mount_setattr/#intro","title":"Intro","text":"<p>mount_setattr - set per-mount attributes on a mount</p>"},{"location":"docs/events/builtin/syscalls/mount_setattr/#description","title":"Description","text":"<p>The system call mount_setattr() allows an application to set mount-level attributes on the specified mount. Currently, only two flags are defined: <code>MOUNT_ATTR_NOEXEC</code>, which will prevent mount from executing any code, and <code>MOUNT_ATTR_NOSUID</code>, which will prevent mount from allowing setuid and setgid execution for any files.</p> <p>The <code>dfd</code> and <code>path</code> parameters specify a mount to modify using a file descriptor or file path respectively. The <code>flags</code> parameter is an unsigned int describing the flags to set (or reset) on the mount. Lastly, the <code>uattr</code> parameter is either NULL or points to a struct mount_attr which holds the mount-level attributes to set.</p>"},{"location":"docs/events/builtin/syscalls/mount_setattr/#arguments","title":"Arguments","text":"<ul> <li><code>dfd</code>:<code>int</code>[K] - The mount's file descriptor. </li> <li><code>path</code>:<code>char*</code>[K] - The mount\u2019s path.</li> <li><code>flags</code>:<code>unsigned int</code>[K] - An unsigned int describing the flags to set (or reset) on the mount.</li> <li><code>uattr</code>:<code>struct mount_attr*</code>[U, TOCTOU, OPT] - If this argument is not NULL, and it is pointing to a valid struct mount_attr, then it will set the mount-level attributes, otherwise it will reset the mount-level attributes.  </li> <li><code>usize</code>:<code>size_t</code>[K, OPT] - The size of the <code>uattr</code> buffer.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mount_setattr/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/mount_setattr/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mount_setattr/#sys_mount","title":"sys_mount","text":""},{"location":"docs/events/builtin/syscalls/mount_setattr/#type","title":"Type","text":"<p>Kprobe.</p>"},{"location":"docs/events/builtin/syscalls/mount_setattr/#purpose","title":"Purpose","text":"<p>To monitor mount_setattr syscall activity.</p>"},{"location":"docs/events/builtin/syscalls/mount_setattr/#example-use-case","title":"Example Use Case","text":"<p>The mount_setattr system call can be used to set mount-level attributes, such as <code>MOUNT_ATTR_NOEXEC</code> to prevent execution of code, or <code>MOUNT_ATTR_NOSUID</code> to prevent setuid and setgid execution of any files located on the mount.</p>"},{"location":"docs/events/builtin/syscalls/mount_setattr/#issues","title":"Issues","text":"<p>The <code>uattr</code> parameter is vulnerable to time of check/time of use (TOCTOU) race conditions since the credentials of the calling process are checked when the call is made, but not when the mount_setattr system call is executed.</p>"},{"location":"docs/events/builtin/syscalls/mount_setattr/#related-events","title":"Related Events","text":"<p>The mount_isattr() system call can be used to fetch the mount-level attributes of a mount.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/move_mount/","title":"move_mount","text":""},{"location":"docs/events/builtin/syscalls/move_mount/#intro","title":"Intro","text":"<p>move_mount - move a mount point to a new location</p>"},{"location":"docs/events/builtin/syscalls/move_mount/#description","title":"Description","text":"<p>This event is used for moving a mount point from one location to another in a file system. This syscall can be used to move mount points both on the same filesystem or on a different filesystem. When used on a different filesystem, the existing mount and its underlying data will be be preserved. The edge cases to be aware of when using this event are that it is not possible to move mount points across filesystems with different mount namespaces. Also, moving mount points within the same mount namespace may create conflicts, which can cause unexpected behaviour.</p>"},{"location":"docs/events/builtin/syscalls/move_mount/#arguments","title":"Arguments","text":"<ul> <li><code>from_dfd</code>:<code>int</code>[K] - file descriptor of a directory, a relative pathname will be used.</li> <li><code>from_path</code>:<code>const char*</code>[K] - the directory pathname relative to from_dfd.</li> <li><code>to_dfd</code>:<code>int</code>[K] - file descriptor of a directory, a relative pathname will be used.</li> <li><code>to_path</code>:<code>const char*</code>[K] - the directory pathname relative to to_dfd.</li> <li><code>flags</code>:<code>unsigned int</code>[K] - flags that control the mount operation.</li> </ul>"},{"location":"docs/events/builtin/syscalls/move_mount/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/move_mount/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/move_mount/#move_mount_1","title":"move_mount","text":""},{"location":"docs/events/builtin/syscalls/move_mount/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/move_mount/#purpose","title":"Purpose","text":"<p>Used to capture the arguments of the move_mount system call</p>"},{"location":"docs/events/builtin/syscalls/move_mount/#example-use-case","title":"Example Use Case","text":"<p>move_mount can be used to move an existing mount point to a new location in order to increase the space available for a particular file system or to avoid running out of space in a given files system.</p>"},{"location":"docs/events/builtin/syscalls/move_mount/#issues","title":"Issues","text":"<p>There is no way to separate a mount point and its underlying data when moving it across filesystems, meaning the mount and its underlying data will always be preserved. This could lead to unexpected behavior (i.e. data being accessed from unexpected file locations).</p>"},{"location":"docs/events/builtin/syscalls/move_mount/#related-events","title":"Related Events","text":"<ul> <li>mount: used to create a new mount point.</li> <li>pivot_root: used to change the root filesystem of a process and the rest of the system.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/move_pages/","title":"move_pages","text":""},{"location":"docs/events/builtin/syscalls/move_pages/#intro","title":"Intro","text":"<p>move_pages - Migrate process pages between node</p>"},{"location":"docs/events/builtin/syscalls/move_pages/#description","title":"Description","text":"<p>The move_pages() system call moves pages from one NUMA node to another on behalf  of the children of a process. It supports a subset of normal memory mappings,  possibly shared between multiple processes - specifically just private anonymous  mappings and shared mappings created with the mmap(2) MAP_SHARED and MAP_SHARED_VALIDATE flags.</p> <p>Although the system call may be used on any process, the special semantics of  the system call are only applicable to processes whose page tables are managed  by a PowerPC hardware page table walker, such as POWER7 and later chips.</p> <p>This system call allows processes and kernels to organize their working set  into specific NUMA nodes, by placing pages and nodes. This can be used to speed  up memory accesses and also to allow the user or administrator to move process  pages into near-memory storage (such as the embedded DRAM available on some  PowerPC machines) in order to save energy.</p>"},{"location":"docs/events/builtin/syscalls/move_pages/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>int</code>[K] - The PID of the process whose pages should be moved.</li> <li><code>count</code>:<code>unsigned long</code>[U+K] - The number of pages to move. </li> <li><code>pages</code>:<code>const void**</code>[U] - The addresses of the pages to be moved.</li> <li><code>nodes</code>:<code>const int*</code>[K] - The array of nodes to which the pages should be moved.</li> <li><code>status</code>:<code>int*</code>[U] - The array that will contain the result for each page (0 for success, -EFAULT for failure).</li> <li><code>flags</code>:<code>int</code>[K] - Flags to specify behaviour (0 for regular mode, MPOL_MF_MOVE_ALL to exchange pages if the source or destination node is already full).</li> </ul>"},{"location":"docs/events/builtin/syscalls/move_pages/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/move_pages/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/move_pages/#sys_move_pages","title":"sys_move_pages","text":""},{"location":"docs/events/builtin/syscalls/move_pages/#type","title":"Type","text":"<p>Kprobe + Kretprobes</p>"},{"location":"docs/events/builtin/syscalls/move_pages/#purpose","title":"Purpose","text":"<p>To monitor the execution of the move_pages system call and its return value.</p>"},{"location":"docs/events/builtin/syscalls/move_pages/#example-use-case","title":"Example Use Case","text":"<p>If an application running on a multi-socketed system depends heavily on the  transparency of the NUMA architecture in order to get good performance, then this system call can be used to move pages around in order to optimize its memory accesses. </p>"},{"location":"docs/events/builtin/syscalls/move_pages/#issues","title":"Issues","text":"<p>This system call is limited to pages that are anonymous private mappings or shared mappings that were created with the mmap(2) MAP_SHARED and MAP_SHARED_VALIDATE flags, making it incompatible with many memory sharing strategies.</p> <p>Also, it is not supported on Power7 and later chips, which could lead to unexpected results when running on such systems.</p>"},{"location":"docs/events/builtin/syscalls/move_pages/#related-events","title":"Related Events","text":"<ul> <li>munmap(2) - System call used to unmap pages from memory</li> <li>mmap(2) - System call used to map files or devices into memory.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mprotect/","title":"mprotect","text":""},{"location":"docs/events/builtin/syscalls/mprotect/#intro","title":"Intro","text":"<p>mprotect - Change protection on a region of memory</p>"},{"location":"docs/events/builtin/syscalls/mprotect/#description","title":"Description","text":"<p>The mprotect() system call is used to change the protection of a region of memory. This system call is useful for preventing malicious code from writing to a region of memory. It can also be used to manually allocate and/or deallocate memory for an application.</p> <p>The mprotect() system call modifies the page protection bits of any valid mapped pages in the address range starting at addr and continuing for len bytes. If a page is not valid or not mapped, or if it is locked, then it will not be modified by mprotect(). If a page is in read-only mode, then it cannot be set writable by mprotect(), as long as the page is still mapped.</p> <p>The prot argument must include either PROT_READ or PROT_WRITE or both, as well as any of the other flags (they are all cumulative).</p>"},{"location":"docs/events/builtin/syscalls/mprotect/#arguments","title":"Arguments","text":"<ul> <li><code>addr</code>:<code>void*</code>[K] -  Start address</li> <li><code>len</code>:<code>size_t</code>[K] - Length in bytes</li> <li><code>prot</code>:<code>int</code>[K] - Protection flags (PROT_READ, PROT_WRITE, PROT_EXEC, PROT_SEM and PROT_NONE are provided)</li> </ul>"},{"location":"docs/events/builtin/syscalls/mprotect/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/mprotect/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mprotect/#sys_mprotect","title":"sys_mprotect","text":""},{"location":"docs/events/builtin/syscalls/mprotect/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/mprotect/#purpose","title":"Purpose","text":"<p>Monitor access to memory and enforce memory protections</p>"},{"location":"docs/events/builtin/syscalls/mprotect/#example-use-case","title":"Example Use Case","text":"<p>The mprotect() syscall can be used to enforce memory protections on a region of memory. This can be useful for detecting and preventing malicious code from writing to a region of memory. It can also be used to manually allocate and/or deallocate memory for an application.</p>"},{"location":"docs/events/builtin/syscalls/mprotect/#issues","title":"Issues","text":"<p>Currently, mprotect() does not check permissions when PROT_READ or PROT_EXEC is specified. This can lead to security vulnerabilities if an attacker is able to control a pointer that is passed to mprotect().</p>"},{"location":"docs/events/builtin/syscalls/mprotect/#related-events","title":"Related Events","text":"<ul> <li>mmap - Map pages of memory</li> <li>munmap - Unmap pages of memory</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mpx/","title":"mpx","text":""},{"location":"docs/events/builtin/syscalls/mpx/#intro","title":"Intro","text":"<p>mpx - manage memory protection keys</p>"},{"location":"docs/events/builtin/syscalls/mpx/#description","title":"Description","text":"<p>The mpx system call is used to create, enable, disable, or get the status of a memory protection key (MPX) on a system. The MPX system call requires a key set register and a bound register, both of which are only available on x86-64 CPUs with the MPX feature enabled. Using the key set register, a process can set and change the memory area to be protected using the MPX key. The bound register specifies boundaries to the portion of memory applicable to the key.</p> <p>MPX is useful for distinguishing between memory areas that must be kept secure and those that do not need to be protected from malicious or erroneous accesses. For example, a process may want to mark a memory region as \"private\" so that it can't be accessed by any other process. This can be done using the MPX system call, enabling the process to protect itself from malicious or erroneous accesses within that region.</p>"},{"location":"docs/events/builtin/syscalls/mpx/#arguments","title":"Arguments","text":"<ul> <li><code>addr</code>:<code>void *</code>[U,TOCTOU] - pointer to an address space area.</li> <li><code>len</code>:<code>int</code>[U,TOCTOU] - length of the address space area.</li> <li><code>key</code>:<code>unsigned int</code>[U] - MPX key used to protect the given area.</li> <li><code>op</code>:<code>int</code>[U] - Operation to perform (e.g. set or get).</li> </ul>"},{"location":"docs/events/builtin/syscalls/mpx/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/mpx/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mpx/#sys_mpx","title":"sys_mpx","text":""},{"location":"docs/events/builtin/syscalls/mpx/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/mpx/#purpose","title":"Purpose","text":"<p>Monitor the process accesses to keys and its associated protections.</p>"},{"location":"docs/events/builtin/syscalls/mpx/#example-use-case","title":"Example Use Case","text":"<p>A security-based application that monitors memory access requests, and uses MPX to protect a specific memory region. The application can use the hooks to be notified when a process modifies keys or attempts to access its corresponding protection regions. The application can then take the necessary actions to protect the system.</p>"},{"location":"docs/events/builtin/syscalls/mpx/#issues","title":"Issues","text":"<p>The main issue with mpx is that it only works with x86-64 Architecture segments, which limits its ability to provide protection against malicious or erroneous accesses on older systems.</p>"},{"location":"docs/events/builtin/syscalls/mpx/#related-events","title":"Related Events","text":"<ul> <li>msr: Used to access and modify model-specific registers.</li> <li>set_thread_area: Used to set up and modify thread local storage areas.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mq_getsetattr/","title":"mq_getsetattr","text":""},{"location":"docs/events/builtin/syscalls/mq_getsetattr/#intro","title":"Intro","text":"<p>mq_getsetattr - sets and gets message queue attributes.</p>"},{"location":"docs/events/builtin/syscalls/mq_getsetattr/#description","title":"Description","text":"<p>mq_getsetattr is responsible for setting and getting the attributes associated with a message queue.</p> <p>When setting attributes, the process must own, or have superuser permissions, the message queue referenced by the mqdes argument.</p> <p>When getting attributes, the process must have read, write, or execute permissions for the message queue referenced by the mqdes argument.</p> <p>This event provides an efficient way to get the current attributes of an existing message queue or to change certain attribute values.</p> <p>The possible attribute values that can be changed are those inside struct mq_attr (defined in /usr/include/bits/mqueue.h).</p>"},{"location":"docs/events/builtin/syscalls/mq_getsetattr/#arguments","title":"Arguments","text":"<ul> <li><code>mqdes</code>:<code>mqd_t</code>[K,U] - holds a file descriptor that refers to an open message queue.</li> <li><code>newattr</code>:<code>const struct mq_attr*</code>[K,U] - points to a struct mq_attr that sets the attributes of the message queue.</li> <li><code>oldattr</code>:<code>struct mq_attr*</code>[K,U] - points to the buffer that retrieves the current attributes of the message queue.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mq_getsetattr/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/mq_getsetattr/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mq_getsetattr/#sys_mq_getsetattr","title":"sys_mq_getsetattr","text":""},{"location":"docs/events/builtin/syscalls/mq_getsetattr/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/mq_getsetattr/#purpose","title":"Purpose","text":"<p>Hook this event so the attributes of the message queue can be monitored.</p>"},{"location":"docs/events/builtin/syscalls/mq_getsetattr/#example-use-case","title":"Example Use Case","text":"<p>The mq_getsetattr event may be useful in situations where it is important to track the current value of attributes associated with a particular message queue. For example, if an application is submitting messages to a queue and expecting responses, mq_getsetattr can be used to track the current time-out value of the queue or to see if the queue is still in a valid state.</p>"},{"location":"docs/events/builtin/syscalls/mq_getsetattr/#issues","title":"Issues","text":"<p>When hooking sys_mq_getsetattr and collecting the return value, due to the possibility of userspace-triggered events, kernel-space values may contain invalid user address data.</p>"},{"location":"docs/events/builtin/syscalls/mq_getsetattr/#related-events","title":"Related Events","text":"<ul> <li>mq_open</li> <li>mq_unlink </li> <li>mq_timedsend </li> <li>mq_timedreceive</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mq_notify/","title":"mq_notify","text":""},{"location":"docs/events/builtin/syscalls/mq_notify/#intro","title":"Intro","text":"<p>mq_notify - register notification request on a message queue</p>"},{"location":"docs/events/builtin/syscalls/mq_notify/#description","title":"Description","text":"<p>The mq_notify() system call establishes or modifies a notification request on the message queue specified by the mqdes argument. If the sevp argument is not a null pointer, then the notification will be as specified in the referenced structure.</p> <p>The receiving process will be sent a SIGEV_SIGNAL signal with si_value equal to the sival_ptr member of the sigevent structure when (1) a message arrives on the empty queue specified by mqdes and (2) a message is removed from the queue and the number of messages on the queue subsequently becomes lower than the current value of the queue's notification threshold, mq_notify(). This signal will be sent to the process that registered the notification, provided that the notification request is still active by the time the message arrives or is removed from the queue.</p> <p>A process can register at most one notification request for each message queue.</p> <p>If the sevp argument is a null pointer, any previously registered notification request for the message queue specified by the mqdes argument will be canceled.</p> <p>Some of the advantages of using mq_notify() include the ability to register for notification of any incoming message, being able to specify a custom signal handler function that is called when the signal is received, and the ability to register multiple notification requests on different queues.</p>"},{"location":"docs/events/builtin/syscalls/mq_notify/#arguments","title":"Arguments","text":"<ul> <li><code>mqdes</code>:<code>mqd_t</code> - a message queue descriptor.</li> <li><code>sevp</code>:<code>const struct sigevent*</code> - pointer to a structure that specifies the type of notification to set. If the value of this argument is NULL, the notification for the specified message queue is canceled.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mq_notify/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/mq_notify/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mq_notify/#mq_notify_entry","title":"mq_notify_entry","text":""},{"location":"docs/events/builtin/syscalls/mq_notify/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/mq_notify/#purpose","title":"Purpose","text":"<p>To trace the system call entry point.</p>"},{"location":"docs/events/builtin/syscalls/mq_notify/#mq_notify_exit","title":"mq_notify_exit","text":""},{"location":"docs/events/builtin/syscalls/mq_notify/#type_1","title":"Type","text":"<p>Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/mq_notify/#purpose_1","title":"Purpose","text":"<p>To trace the system call exit point.</p>"},{"location":"docs/events/builtin/syscalls/mq_notify/#example-use-case","title":"Example Use Case","text":"<p>mq_notify() can be used to be notified when a message is sent to a queue, or when a message is taken off a queue that was previously emptied. This is useful for applications that need to react to messages in a timely manner or are interested in knowing what messages are being sent and taken from a queue.</p>"},{"location":"docs/events/builtin/syscalls/mq_notify/#issues","title":"Issues","text":"<p>Because the notification is triggered by either a message coming in or a message being taken out, this function is vulnerable to Time of Check Time of Use (TOCTOU) race conditions.</p>"},{"location":"docs/events/builtin/syscalls/mq_notify/#related-events","title":"Related Events","text":"<p>mq_open, mq_send, mq_receive</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mq_open/","title":"mq_open","text":""},{"location":"docs/events/builtin/syscalls/mq_open/#intro","title":"Intro","text":"<p>mq_open - open a message queue</p>"},{"location":"docs/events/builtin/syscalls/mq_open/#description","title":"Description","text":"<p>The <code>mq_open</code> function opens a POSIX message queue, attempting to create it if <code>O_CREAT</code> is specified in the <code>oflag</code> argument. If successful, it returns a message queue descriptor for use in later <code>mq_*</code> calls.</p> <p>The <code>name</code> argument gives the name of the message queue and <code>mode</code> is the working mode, which is related to the protection of the created message queue. The <code>oflag</code> argument is a flag argument that may be made up of one or more of the following specified in <code>&lt;fcntl.h&gt;</code>:</p> <ul> <li><code>O_RDONLY</code> - Open the message queue for reading only.</li> <li><code>O_WRONLY</code> - Open the message queue for writing only.</li> <li><code>O_RDWR</code> - Open the message queue for both reading and writing.</li> <li><code>O_CREAT</code> - Create the message queue if it does not already exist.</li> <li><code>O_EXCL</code> - When used with <code>O_CREAT</code>, if the queue already exists, the call fails.</li> </ul> <p>If the <code>O_CREAT</code> is specified in <code>oflag</code> the <code>mode</code> argument specifies the initial permissions of the newly created queue, as in <code>open(2)</code>. It is modified by the process's <code>umask</code> in the usual way. The <code>attr</code> argument pointer can be used to set the initial attributes of the queue.</p>"},{"location":"docs/events/builtin/syscalls/mq_open/#arguments","title":"Arguments","text":"<ul> <li><code>name</code>:<code>const char*</code>[KU] - Name of the message queue to be opened. Must begin with a '/' character.</li> <li><code>oflag</code>:<code>int</code>[KU] - Flag argument used to determine how the queue should be opened.</li> <li><code>mode</code>:<code>mode_t</code>[KU] - Permission bits used when setting the queue's initial permissions.</li> <li><code>attr</code>:<code>struct mq_attr*</code>[KU] - Pointer to a structure containing the queue's initial attributes.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mq_open/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/mq_open/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mq_open/#do_mq_open","title":"do_mq_open","text":""},{"location":"docs/events/builtin/syscalls/mq_open/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/mq_open/#purpose","title":"Purpose","text":"<p>To capture information about when and where the <code>mq_open</code> syscall is invoked.</p>"},{"location":"docs/events/builtin/syscalls/mq_open/#example-use-case","title":"Example Use Case","text":"<p>Using the <code>mq_open</code> event can be used to monitor the creation and access of message queues, logging any relevant information pertaining to the queue and the process that invoked it.</p>"},{"location":"docs/events/builtin/syscalls/mq_open/#issues","title":"Issues","text":"<p>The <code>mq_open</code> event occurs when the message queue is opened and does not indicate that it was successfully opened.</p>"},{"location":"docs/events/builtin/syscalls/mq_open/#related-events","title":"Related Events","text":"<ul> <li>mq_timedsend</li> <li>mq_receive</li> <li>mq_timedreceive</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedreceive/","title":"mq_timedreceive","text":""},{"location":"docs/events/builtin/syscalls/mq_timedreceive/#intro","title":"Intro","text":"<p>mq_timedreceive - receive messages on a message queue with absolute timeout</p>"},{"location":"docs/events/builtin/syscalls/mq_timedreceive/#description","title":"Description","text":"<p>The mq_timedreceive() system call receives the oldest of the highest priority messages on the message queue, <code>mqdes</code>. It does this with using an absolute timeout, <code>abs_timeout</code>. If the operation is successful, the read message is copied in value-result argument <code>msg_ptr</code> and if <code>msg_prio</code> is not <code>NULL</code>, the priority of the message is stored at <code>msg_prio</code>. <code>msg_len</code> should be set to the maximum size of the buffer in <code>msg_ptr</code>. The timeout is given in an <code>struct timespec</code> pointed by <code>abs_timeout</code>, which consists of an absolute time measured in seconds and nanoseconds since the Epoch (00:00:00 UTC, January 1, 1970).</p> <p>This syscall is useful if the order of message reception is important and if the thread needs to wait with a predefined timeout. The negative side of the syscall is that it requires knowledge of the time epoch and the calling application needs to handle timespecs correctly.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedreceive/#arguments","title":"Arguments","text":"<ul> <li><code>mqdes</code>:<code>mqd_t</code>[K] - A message queue descriptor.</li> <li><code>msg_ptr</code>:<code>char*</code>[U] - Pointer to a buffer that will hold the retrieved message.</li> <li><code>msg_len</code>:<code>size_t</code> - Length in bytes of the buffer <code>msg_ptr</code>, which should not be less than the attribute <code>mq_msgsize</code> for the message queue.</li> <li><code>msg_prio</code>:<code>unsigned int*</code>[U] - If not <code>NULL</code>, the priority of the retrieved message will be stored in the integer pointed to by <code>msg_prio</code>.</li> <li><code>abs_timeout</code>:<code>const struct timespec*</code>[U] - Pointer to an absolute timeout in a structure of type <code>struct timespec</code>.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mq_timedreceive/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/mq_timedreceive/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mq_timedreceive/#sys_mq_timedreceive","title":"sys_mq_timedreceive","text":""},{"location":"docs/events/builtin/syscalls/mq_timedreceive/#type","title":"Type","text":"<p>Kprobes + Uprobes</p>"},{"location":"docs/events/builtin/syscalls/mq_timedreceive/#purpose","title":"Purpose","text":"<p>Hooking sys_mq_timedreceive allows us to measure the elapsed time for the syscall and add log information, like process and thread information as well as argument values.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedreceive/#mq_timedreceive_1","title":"mq_timedreceive","text":""},{"location":"docs/events/builtin/syscalls/mq_timedreceive/#type_1","title":"Type","text":"<p>Kretprobes</p>"},{"location":"docs/events/builtin/syscalls/mq_timedreceive/#purpose_1","title":"Purpose","text":"<p>Hooking mq_timedreceive allows us to measure latency, return values, and other performance metrics of the syscall.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedreceive/#example-use-case","title":"Example Use Case","text":"<p>One example use case for mq_timedreceive is for when applications need to get messages from a queue within a defined timeout to ensure responsiveness and reliable throughput.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedreceive/#issues","title":"Issues","text":"<p>If the message queue is empty, mq_timedreceive will timeout and return <code>-ETIMEDOUT</code> which needs to be handled by the calling application.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedreceive/#related-events","title":"Related Events","text":"<ul> <li>mq_timedsend</li> <li>mq_receive</li> <li>mq_send</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedreceive_time32/","title":"mq_timedreceive_time32","text":""},{"location":"docs/events/builtin/syscalls/mq_timedreceive_time32/#intro","title":"Intro","text":"<p><code>mq_timedreceive_time32()</code> - receives the oldest of the highest priority messages stored in the message queue specified by mqdes.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedreceive_time32/#description","title":"Description","text":"<p>The <code>mq_timedreceive_time32()</code> system call atomically removes the oldest of the highest priority messages from the message queue specified by the <code>mqdes</code> argument, places it in the memory pointed to by <code>u_msg_ptr</code>, and returns its priority in the integer pointed to by <code>msg_prio</code>. The <code>msg_len</code> argument specifies the size in bytes of the storage pointed to by <code>u_msg_ptr</code>; this space must be greater than or equal to the mq_msgsize attribute of the message queue. The <code>u_abs_timeout</code> argument points to a structure that specifies the absolute timeout of the call. </p> <p>It can provide synchronization and communication between processes, like avoiding busy waiting and non-sharing of resources between different threads. While there are many advantage to using this system call, one downside of it is that it does not ensure real-time delivery of the message. Also, it is vulnerable to the time of check, time of use (TOCTOU) vulnerability. </p>"},{"location":"docs/events/builtin/syscalls/mq_timedreceive_time32/#arguments","title":"Arguments","text":"<ul> <li><code>mqdes</code>: <code>mqd_t</code>[K] - Descriptor of the message queue.</li> <li><code>u_msg_ptr</code>: <code>char*</code>[K] - Points to the buffer where the oldest/highest priority message will be stored.</li> <li><code>msg_len</code>: <code>unsigned int</code>[K] - Length in bytes of the buffer. </li> <li><code>u_msg_prio</code>: <code>unsigned int*</code>[K] - Pointer to an integer that stores the priority of the received message.</li> <li><code>u_abs_timeout</code>: <code>struct old_timespec32*</code>[K] - Specifies the absolute timeout of the call.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mq_timedreceive_time32/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mq_timedreceive_time32/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mq_timedreceive_time32/#mq_timedreceive_time32_1","title":"mq_timedreceive_time32","text":""},{"location":"docs/events/builtin/syscalls/mq_timedreceive_time32/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/mq_timedreceive_time32/#purpose","title":"Purpose","text":"<p>Hook the <code>mq_timedreceive_time32()</code> system call to measure performance metrics (e.g. latency) and receive messages as expected. </p>"},{"location":"docs/events/builtin/syscalls/mq_timedreceive_time32/#example-use-case","title":"Example Use Case","text":"<p><code>mq_timedreceive_time32()</code> can be used to provide synchronization between different processes and threads. For example, it can be used in a web browser application to receive data from a server that has the same message queue descriptor as the process.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedreceive_time32/#issues","title":"Issues","text":"<ul> <li>It does not ensure real-time delivery of the messages. </li> <li>It is vulnerable to the time of check, time of use (TOCTOU) vulnerability. </li> </ul>"},{"location":"docs/events/builtin/syscalls/mq_timedreceive_time32/#related-events","title":"Related Events","text":"<ul> <li><code>mq_timedsend_time32()</code> - sends a message with absolute timeout to a message queue. </li> <li><code>mq_open()</code> - used to open or create a message queue.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedsend/","title":"mq_timedsend","text":""},{"location":"docs/events/builtin/syscalls/mq_timedsend/#intro","title":"Intro","text":"<p>mq_timedsend - Send a message to a message queue, with a timeout.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedsend/#description","title":"Description","text":"<p>mq_timedsend is a function used to send a message to a message queue, with a timeout specified.  It has the following arguments: a message queue descriptor, a message pointer, the message length, the priority of the message, and a pointer to a timespec struct containing the timeout.  Upon a successful call the message is added to the queue, in the order of priority. </p> <p>The mq_timedsend call is more efficient than mq_send when the timeout is specified as the latter has to check the queue everytime to see if its gotten full, while the former only has to check the timout. However, if no timeout is specified mq_send should be used instead as it's more efficient.</p> <p>Additionally, if the message queue descriptor is invalid, mq_timedsend will return an error.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedsend/#arguments","title":"Arguments","text":"<ul> <li><code>mqdes</code>:<code>mqd_t</code>[K] - File descriptor of the message queue.</li> <li><code>msg_ptr</code>:<code>const char*</code>[K] - Pointer to the message to be sent.</li> <li><code>msg_len</code>:<code>size_t</code>[K] - Length of the message.</li> <li><code>msg_prio</code>:<code>unsigned int</code>[K] - Priority of the message.</li> <li><code>abs_timeout</code>:<code>const struct timespec*</code>[K] - Pointer to a timespec struct containing the timeout information.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mq_timedsend/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mq_timedsend/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mq_timedsend/#mq_timedsend_start","title":"mq_timedsend_start","text":""},{"location":"docs/events/builtin/syscalls/mq_timedsend/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/mq_timedsend/#purpose","title":"Purpose","text":"<p>Hook the start of mq_timedsend to measure time and latency of this syscall.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedsend/#mq_timedsend_return","title":"mq_timedsend_return","text":""},{"location":"docs/events/builtin/syscalls/mq_timedsend/#type_1","title":"Type","text":"<p>Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/mq_timedsend/#purpose_1","title":"Purpose","text":"<p>Hook the return of mq_timedsend to measure time and latency of this syscall.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedsend/#example-use-case","title":"Example Use Case","text":"<p>An example use case of this syscall would be when there is an application that needs to send a message with a certain priority, and there is a time limit on when the message needs to be sent.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedsend/#issues","title":"Issues","text":"<p>mq_timedsend is only available for Linux 2.6.7 or later.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedsend/#related-events","title":"Related Events","text":"<ul> <li>mq_send </li> <li>mq_timedreceive</li> <li>mq_unlink</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedsend_time32/","title":"mq_timedsend_time32","text":""},{"location":"docs/events/builtin/syscalls/mq_timedsend_time32/#intro","title":"Intro","text":"<p>mq_timedsend_time32 - sends message on a message queue with a timeout value</p>"},{"location":"docs/events/builtin/syscalls/mq_timedsend_time32/#description","title":"Description","text":"<p>The mq_timedsend_time32() system call sends the message pointed to by u_msg_ptr, with message length msg_len, and a message priority of msg_prio, to the queue indicated by the message queue descriptor mqdes.</p> <p>The u_abs_timeout parameter points to a structure of type \"old_timespec32\", specifying the absolute timeout (time of day) at which the system call should expire - in other words, the time to wait for a successful return before aborting the operation. If the value of u_abs_timeout-&gt;tv_nsec is greater than or equal to 1 billion, the system call fails and returns an error.</p> <p>When a process sends a message to a queue, the process that is blocked on a message queue due to either mq_timedsend_time32() or mq_timedreceive_time32() will wake up, and either receive the message if the process is blocked on mq_timedreceive_time32(), or find that the send operation succeeded if the process is blocked on mq_timedsend_time32().</p> <p>The tm_timedsend_time32() system call provides an interface for sending a message to an existing message queue with an absolute timeout, preventing an indefinite wait, as it can happen if the message queue is full and the receiver side is absent.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedsend_time32/#arguments","title":"Arguments","text":"<ul> <li><code>mqdes</code>:<code>mqd_t</code>[K] - message queue descriptor.</li> <li><code>u_msg_ptr</code>:<code>char*</code>[KU] - pointer to the message to be sent.</li> <li><code>msg_len</code>:<code>unsigned int</code>[K] - length of the message.</li> <li><code>msg_prio</code>:<code>unsigned int</code>[K] - message priority.</li> <li><code>u_abs_timeout</code>:<code>struct old_timespec32*</code>[K] - pointer to the absolute timeout value.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mq_timedsend_time32/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/mq_timedsend_time32/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mq_timedsend_time32/#do_mq_timedsend_time32","title":"do_mq_timedsend_time32","text":""},{"location":"docs/events/builtin/syscalls/mq_timedsend_time32/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/mq_timedsend_time32/#purpose","title":"Purpose","text":"<p>To trace mq_timedsend_time32 system call.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedsend_time32/#example-use-case","title":"Example Use Case","text":"<p>mq_timedsend_time32 could be used to monitor and trace an application sending messages to a message queue with a timeout value.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedsend_time32/#issues","title":"Issues","text":"<p>The use of absolute timestamps might lead to incorrect time values.</p>"},{"location":"docs/events/builtin/syscalls/mq_timedsend_time32/#related-events","title":"Related Events","text":"<p>mq_timedreceive_time32</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mq_unlink/","title":"mq_unlink","text":""},{"location":"docs/events/builtin/syscalls/mq_unlink/#intro","title":"Intro","text":"<p>mq_unlink - remove a message queue from the system</p>"},{"location":"docs/events/builtin/syscalls/mq_unlink/#description","title":"Description","text":"<p>The mq_unlink() system call removes a message queue named name from the system. This is a permanent operation, and any associated resources are immediately  freed for other use. </p> <p>If the message queue does not exist, the call fails and the system call returns with the errno set to ENOENT.</p>"},{"location":"docs/events/builtin/syscalls/mq_unlink/#arguments","title":"Arguments","text":"<ul> <li><code>name</code>:<code>const char*</code>[K] - the name of the message queue to be unlinked.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mq_unlink/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mq_unlink/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mq_unlink/#sys_mq_unlink","title":"sys_mq_unlink","text":""},{"location":"docs/events/builtin/syscalls/mq_unlink/#type","title":"Type","text":"<p>kprobes</p>"},{"location":"docs/events/builtin/syscalls/mq_unlink/#purpose","title":"Purpose","text":"<p>To be able to track when a message queue is unlinked from the system.</p>"},{"location":"docs/events/builtin/syscalls/mq_unlink/#example-use-case","title":"Example Use Case","text":"<p>This system call can be used to be aware of what message queues are  unlinked from the system in order to debug an application or analyze where resources are being freed in the system.</p>"},{"location":"docs/events/builtin/syscalls/mq_unlink/#issues","title":"Issues","text":"<p>No known issues.</p>"},{"location":"docs/events/builtin/syscalls/mq_unlink/#related-events","title":"Related Events","text":"<ul> <li>mq_open</li> <li>mq_send</li> <li>mq_close</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/mremap/","title":"mremap","text":""},{"location":"docs/events/builtin/syscalls/mremap/#intro","title":"Intro","text":"<p>mremap - move a mapping and resize.</p>"},{"location":"docs/events/builtin/syscalls/mremap/#description","title":"Description","text":"<p>The mremap() system call changes the mapping between virtual addresses and physical pages existing in a process address space. It expands or shrinks the area of existing mapping without moving the page frames. The old address range may have multiple non-contiguous mappings, and new address range can be in a non-contiguous mapping as well.</p> <p>mremap() can also be used to map a non-contiguous area of physical memory as a contiguous mapping. The <code>MREMAP_FIXED</code> flag should be used to request that the new mapping is made at a fixed address, which is specified in the last argument.</p> <p>Aside from enlarging or shrinking a mapping the old range and the new range may overlap or not be adjacent. In those cases, mremap() can also be used to move the mapping from one address space to another.</p> <p>The flags argument enables several options for the mremap() operation. It determines whether the new range of memory should be accessible, what must happen if the desired new address range already contains a mapping, whether the mapping is private or shared, and whether the old address range should be unshareable (prevented from being transparently cloned/shared). </p> <p>mremap() is not required to check access permissions on the old address range before performing the remapping, so care should be taken to ensure that the old address range is correctly protected.</p>"},{"location":"docs/events/builtin/syscalls/mremap/#arguments","title":"Arguments","text":"<ul> <li><code>old_address</code>:<code>void*</code>[KU] - The virtual address of the existing mapping.</li> <li><code>old_size</code>:<code>size_t</code>[K] - The size of the existing mapping.</li> <li><code>new_size</code>:<code>size_t</code>[K] - The size of the new mapping.</li> <li><code>flags</code>:<code>int</code>[K] - The flags controlling the behavior of the mremap() system call.</li> <li><code>new_address</code>:<code>void*</code>[KUOPT] - The virtual address of the new mapping. When the <code>MREMAP_FIXED</code> flag is used, this argument specifies the new address to which the existing mapping is moved, otherwise it is ignored.</li> </ul>"},{"location":"docs/events/builtin/syscalls/mremap/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/mremap/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/mremap/#sys_mremap","title":"sys_mremap","text":""},{"location":"docs/events/builtin/syscalls/mremap/#type","title":"Type","text":"<p>Kprobes + kretprobes</p>"},{"location":"docs/events/builtin/syscalls/mremap/#purpose","title":"Purpose","text":"<p>This function was hooked to monitor memory allocation and deallocation.</p>"},{"location":"docs/events/builtin/syscalls/mremap/#do_mremap","title":"do_mremap","text":""},{"location":"docs/events/builtin/syscalls/mremap/#type_1","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/mremap/#purpose_1","title":"Purpose","text":"<p>This function was hooked to monitor inputs and outputs to the sys_mremap syscall.</p>"},{"location":"docs/events/builtin/syscalls/mremap/#example-use-case","title":"Example Use Case","text":"<p>mremap() can be used to apply a new mapping to an area of physical memory. This might be useful, for example, in an embedded system to remap a shared memory space, allowing different tasks to access the same physical memory in different address spaces.</p>"},{"location":"docs/events/builtin/syscalls/mremap/#issues","title":"Issues","text":"<p>mremap() is vulnerable to TOCTOU (Time Of Check Time Of Use) attacks. If an attacker can create or modify a mapping between the moment a mapping is checked and the moment it is used, it can increase the attack surface area of the application.</p>"},{"location":"docs/events/builtin/syscalls/mremap/#related-events","title":"Related Events","text":"<ul> <li>mmap</li> <li>munmap</li> <li>memcpy</li> <li>memmove</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/msgctl/","title":"msgctl","text":""},{"location":"docs/events/builtin/syscalls/msgctl/#intro","title":"Intro","text":"<p>msgctl - manipulate message queue control operations on System V message queues</p>"},{"location":"docs/events/builtin/syscalls/msgctl/#description","title":"Description","text":"<p>The <code>msgctl</code> system call is used to manipulate message queue control operations on System V message queues. Depending on the command, it can be used to set or get the attributes associated with a message queue, change ownership of the queue, or remove the queue entirely.</p> <p>The command argument specifies the requested control action:  * <code>IPC_STAT</code> to fetch the <code>msqid_ds</code> structure, which contains various status and control information about the queue itself;  * <code>IPC_SET</code> to set some of the members of the <code>msqid_ds</code> structure;  * <code>IPC_RMID</code> to remove the data structure associated with the message queue and destroy the queue.</p> <p>The <code>msgctl</code> system call can suffer from certain time-of-check-to-time-of-use (TOCTOU) vulnerabilitites.</p>"},{"location":"docs/events/builtin/syscalls/msgctl/#arguments","title":"Arguments","text":"<ul> <li><code>msqid</code>:<code>int</code>[K] - the identifier of the message queue to be operated on.</li> <li><code>cmd</code>:<code>int</code>[K] - the operation to be performed on the message queue.  Supported commands are <code>IPC_RMID</code>, <code>IPC_STAT</code>, and <code>IPC_SET</code>, as defined in . <li><code>buf</code>:<code>struct msqid_ds*</code>[KU TOCTOU] - the address of a <code>msqid_ds</code> structure, which is used depending on the command.</li>"},{"location":"docs/events/builtin/syscalls/msgctl/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> </ul>"},{"location":"docs/events/builtin/syscalls/msgctl/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/msgctl/#do_msgctl","title":"do_msgctl","text":""},{"location":"docs/events/builtin/syscalls/msgctl/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/msgctl/#purpose","title":"Purpose","text":"<p>To monitor the arguments and the return value of the <code>msgctl</code> system call.</p>"},{"location":"docs/events/builtin/syscalls/msgctl/#example-use-case","title":"Example Use Case","text":"<p>The <code>msgctl</code> system call can be used to monitor message queues, as well as to detect suspicious activity. For example, it could be used to detect if a queue is constantly being modified or if a malicious process is trying to modify a queue without authorization.</p>"},{"location":"docs/events/builtin/syscalls/msgctl/#issues","title":"Issues","text":"<p>The <code>msgctl</code> system call is vulnerable to TOCTOU vulnerabilities, as the system call may validate one argument when entering the kernel and a different argument when actually executing the command.</p>"},{"location":"docs/events/builtin/syscalls/msgctl/#related-events","title":"Related Events","text":"<ul> <li>msgget</li> <li>msgsnd</li> <li>msgrcv</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/msgget/","title":"msgget","text":""},{"location":"docs/events/builtin/syscalls/msgget/#intro","title":"Intro","text":"<p>msgget - Get a System V message queue identifier  </p>"},{"location":"docs/events/builtin/syscalls/msgget/#description","title":"Description","text":"<p>The msgget() system call returns the message queue identifier associated with the value of the key argument. If key is equal to IPC_PRIVATE, the message queue identifier is created and associated with an internal key value and both are returned. If the System V message queue identifier and key exists and the user does not have the required permissions to access the queue, the system call fails and the return value is -1. If multiple processes attempt to create a message queue with the same key value, each process will get the same message queue identifier and the same internal key value. If a message queue identifier exists for a given key value and msgflg specifies IPC_CREAT and IPC_EXCL, the call will fail.</p> <p>There are a few drawbacks related to msgget() that should be mentioned. Firstly, the IPC_PRIVATE key should not be used as it is shared across all connections. Secondly, the message queue identifier associated with the key not being available when held by the server can result in unintended consequences. Lastly, the System V message queue identifier identifier is limited in size, meaning that only a relatively small number of queues can be created on a particular system.</p>"},{"location":"docs/events/builtin/syscalls/msgget/#arguments","title":"Arguments","text":"<ul> <li><code>key</code>:<code>key_t</code> - Identifier for the System V message queue.</li> <li><code>msgflg</code>:<code>int</code> - A flag that can include any of the following flags: IPC_CREAT, IPC_EXCL, or IPC_NOWAIT.</li> </ul>"},{"location":"docs/events/builtin/syscalls/msgget/#available-tags","title":"Available Tags","text":"<ul> <li>U - Originated from user space</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> </ul>"},{"location":"docs/events/builtin/syscalls/msgget/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/msgget/#sys_msgget","title":"sys_msgget","text":""},{"location":"docs/events/builtin/syscalls/msgget/#type","title":"Type","text":"<p>kprobes </p>"},{"location":"docs/events/builtin/syscalls/msgget/#purpose","title":"Purpose","text":"<p>To identify calls to the sys_msgget function</p>"},{"location":"docs/events/builtin/syscalls/msgget/#example-use-case","title":"Example Use Case","text":"<p>The msgget system call can be used to create a System V message queue identifier which can be used to help in the interprocess communication among different processes running in the system.</p>"},{"location":"docs/events/builtin/syscalls/msgget/#issues","title":"Issues","text":"<p>One issue with the msgget system call is that it has limited numbers of message queues that can be created in a system depending on the size of the System V message queue identifier.</p>"},{"location":"docs/events/builtin/syscalls/msgget/#related-events","title":"Related Events","text":"<ul> <li>msgsnd</li> <li>msgrcv</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/msgrcv/","title":"msgrcv","text":""},{"location":"docs/events/builtin/syscalls/msgrcv/#intro","title":"Intro","text":"<p>msgrcv - Linux system call that reads a message located in a queue</p>"},{"location":"docs/events/builtin/syscalls/msgrcv/#description","title":"Description","text":"<p>msgrcv() is a Linux system call that reads a message located in a  message queue identified by the ID parameter <code>msqid</code>. The parameter  <code>msgp</code> points to the memory containing the read message. The <code>msgp</code>  is overwritten with the actual message in the message queue, which  contains the data in the structure <code>struct msgbuf</code>, and its length is defined by the <code>msgsz</code> parameter. The <code>msgtyp</code> parameter defines the  message type that should be read from the message queue, where zero means the first message of the queue, and negative numbers define the  absolute values of the message types that should be looked for. The  <code>msgflg</code> parameter can be an OR'd combination of flags that specify  the behavior of the system call, and can be set to zero to ignore  them. Note that there may be security issues involved in the use of  this system call, as it ignores the current user id and may allow  attempts to read messages from another user's queue, depending on  the settings of the system.</p>"},{"location":"docs/events/builtin/syscalls/msgrcv/#arguments","title":"Arguments","text":"<ul> <li><code>msqid</code>:<code>int</code>[K] - System-wide unique message queue identifier.</li> <li><code>msgp</code>:<code>struct msgbuf*</code>[KU] - Pointer to the memory that should contain the read message, in a structure that contains the data in the structure <code>struct msgbuf</code>.</li> <li><code>msgsz</code>:<code>size_t</code>[K] - Length of the message pointed by parameter <code>msgp</code>.</li> <li><code>msgtyp</code>:<code>long</code>[K] - Message type that should be read from the message queue, where zero means the first message of the queue, and negative numbers define the absolute values of the message types that should be looked for.</li> <li><code>msgflg</code>:<code>int</code>[K] - OR'd parameter that defines the behavior of the system call, and can be set to zero to ignore them.</li> </ul>"},{"location":"docs/events/builtin/syscalls/msgrcv/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/msgrcv/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/msgrcv/#msgrcv_1","title":"msgrcv","text":""},{"location":"docs/events/builtin/syscalls/msgrcv/#type","title":"Type","text":"<p>KProbes </p>"},{"location":"docs/events/builtin/syscalls/msgrcv/#purpose","title":"Purpose","text":"<p>Hook into the kernel function of msgrcv to monitor any calls made to the system call.</p>"},{"location":"docs/events/builtin/syscalls/msgrcv/#example-use-case","title":"Example Use Case","text":"<p>Using msgrcv allows programs to read and fetch messages from message queues. For example, an application monitoring system can use it to read messages from the message queues of programs it is monitoring.</p>"},{"location":"docs/events/builtin/syscalls/msgrcv/#issues","title":"Issues","text":"<p>The potential security issues of reading messages from message queues of other users might be of concern. It is possible to set the environment of the system to the \"no_root_squash\" value for the NFS, to allow for users to use this system call safely.</p>"},{"location":"docs/events/builtin/syscalls/msgrcv/#related-events","title":"Related Events","text":"<ul> <li>msgsnd - System call that sends a message to a queue.</li> <li>msgget - System call that retrieves a message queue identifier.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/msgsnd/","title":"msgsnd","text":""},{"location":"docs/events/builtin/syscalls/msgsnd/#intro","title":"Intro","text":"<p>msgsnd - submit a message to a message queue</p>"},{"location":"docs/events/builtin/syscalls/msgsnd/#description","title":"Description","text":"<p>The msgsnd() system call appends a message to a message queue. It is a blocking version of msgsnd() and will block until the message can be enqueued. The msqid argument is the identifier of the message queue, and the msgp points to the message structure to be sent. The msgsz argument is the size of the passed message structure in bytes. The msgflag argument is the bitwise OR of flags to indicate the type of message transfer.</p> <p>The msgp argument is a pointer to a structure of the following format:</p> <pre><code>struct msgbuf {\nlong mtype;    /* message type, must be &gt; 0 */\nchar mtext[1]; /* message data */\n};\n</code></pre> <p>The mtype field specifies the type of message being sent, and must be nonzero. On return, the mtext field in the source msgp structure contains no meaningful data.</p>"},{"location":"docs/events/builtin/syscalls/msgsnd/#advantages","title":"Advantages","text":"<p>Using msgsnd() allows for rapid, reliable communication between processes without involving multiple context switches.</p>"},{"location":"docs/events/builtin/syscalls/msgsnd/#drawbacks","title":"Drawbacks","text":"<p>Using msgsnd() requires that the message queue already exists, and that the queues are tested to be valid before attempting to send a message.</p>"},{"location":"docs/events/builtin/syscalls/msgsnd/#arguments","title":"Arguments","text":"<ul> <li><code>msqid</code>:<code>int</code>[K] - Identifier of the message queue.</li> <li><code>msgp</code>:<code>struct msgbuf*</code>[U] - Pointer to the message structure to be sent.</li> <li><code>msgsz</code>:<code>size_t</code> - The size of the passed message structure in bytes.</li> <li><code>msgflg</code>:<code>int</code>[K] - Bitwise OR of flags to indicate the type of message transfer.</li> </ul>"},{"location":"docs/events/builtin/syscalls/msgsnd/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/msgsnd/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/msgsnd/#do_msgsnd","title":"do_msgsnd","text":""},{"location":"docs/events/builtin/syscalls/msgsnd/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/msgsnd/#purpose","title":"Purpose","text":"<p>To monitor the execution of the msgsnd syscall.</p>"},{"location":"docs/events/builtin/syscalls/msgsnd/#example-use-case","title":"Example Use Case","text":"<p>The msgsnd() system call can be used to send a message from one process to another, allowing for interprocess communication.</p>"},{"location":"docs/events/builtin/syscalls/msgsnd/#issues","title":"Issues","text":"<p>None</p>"},{"location":"docs/events/builtin/syscalls/msgsnd/#related-events","title":"Related Events","text":"<ul> <li>msgrcv() - Receive a message from a message queue.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/msync/","title":"msync","text":""},{"location":"docs/events/builtin/syscalls/msync/#intro","title":"Intro","text":"<p>msync - synchronize a file with a memory map</p>"},{"location":"docs/events/builtin/syscalls/msync/#description","title":"Description","text":"<p>The msync() system call causes all changes made to the in-core copy of a file  mapped by a mapping handled by the \"msync\" call to be written to the storage device  on which the file resides or, depending on the flags, to be discarded. </p> <p>Advantages of using msync are that is allows to synchronize a region of a file to  with a copy in a memory mapped region. This can help to avoid data corruption issues when a program exits abruptly.</p> <p>Drawbacks of msync can be related to the performance of synchronizing the data.  Synchronous updates could hurt performance in scenarios where high throughput is  desired.</p>"},{"location":"docs/events/builtin/syscalls/msync/#arguments","title":"Arguments","text":"<ul> <li><code>addr</code>:<code>void*</code>[K] - Pointer to the start of the memory region. Must be aligned to the  system page size.</li> <li><code>length</code>:<code>size_t</code>[K] - Size of the memory region in bytes.</li> <li><code>flags</code>:<code>int</code>[K] - Flags for how to look for changes. </li> </ul>"},{"location":"docs/events/builtin/syscalls/msync/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/msync/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/msync/#sys_msync","title":"sys_msync","text":""},{"location":"docs/events/builtin/syscalls/msync/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/msync/#purpose","title":"Purpose","text":"<p>Track when and with what parameters the sys_msync syscall is called.</p>"},{"location":"docs/events/builtin/syscalls/msync/#example-use-case","title":"Example Use Case","text":"<p>A client-server application where the server keeps track of state using a file and the clients operate on that file by reading and writing to it without calling msync. A msync event could be used to check when the clients write to the file and whether they do it correctly or not.</p>"},{"location":"docs/events/builtin/syscalls/msync/#issues","title":"Issues","text":"<p>msync only works with files that have been directly mapped in to physical memory.  This means it can't be used with files that are mapped in to virtual memory.</p>"},{"location":"docs/events/builtin/syscalls/msync/#related-events","title":"Related Events","text":"<ul> <li>sys_munmap</li> <li>sys_mprotect</li> <li>sys_mlock</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/munlock/","title":"<code>munlock</code>","text":""},{"location":"docs/events/builtin/syscalls/munlock/#intro","title":"Intro","text":"<p><code>munlock</code> - unlock memory from being in the locked state</p>"},{"location":"docs/events/builtin/syscalls/munlock/#description","title":"Description","text":"<p>The <code>munlock</code> syscall unlocks an area of memory previously locked using the <code>mlock</code> syscall. The range of memory that is unlocked must follow the same rules as for <code>mlock</code>, i.e., it must contain the entire range from <code>addr</code> to <code>addr + len</code> inclusively. Note that this syscall does not cause the kernel to allocate the pages that it unlocks, any previously allocated pages in the range are the ones that are unlocked.</p> <p><code>munlock</code> releases or removes the record lock memory range held by the process, allowing it to be swapped out.</p>"},{"location":"docs/events/builtin/syscalls/munlock/#arguments","title":"Arguments","text":"<ul> <li><code>addr</code>:<code>const void*</code>[K] - start address of the memory range to unlock.</li> <li><code>len</code>:<code>size_t</code>[K] - Length of the memory range to unlock.</li> </ul>"},{"location":"docs/events/builtin/syscalls/munlock/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/munlock/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/munlock/#set_memory_x","title":"Set_memory_x","text":""},{"location":"docs/events/builtin/syscalls/munlock/#type","title":"Type","text":"<p>Kprobe + Kretprobe.</p>"},{"location":"docs/events/builtin/syscalls/munlock/#purpose","title":"Purpose","text":"<p>To log when memory is unlocked.</p>"},{"location":"docs/events/builtin/syscalls/munlock/#example-use-case","title":"Example Use Case","text":"<p>The <code>munlock</code> syscall can be used to unlock areas of memory held in a locked state so that it can be swapped out and reclaimed. This could be used to ensure that the system is not continually locking and unlocking pages, thus avoiding unnecessary fragmentation of memory.</p>"},{"location":"docs/events/builtin/syscalls/munlock/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/munlock/#related-events","title":"Related Events","text":"<p><code>mlock</code> - lock memory in memory so that it is not paged out.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/munlockall/","title":"munlockall","text":""},{"location":"docs/events/builtin/syscalls/munlockall/#intro","title":"Intro","text":"<p>munlockall - Unlocks all currently locked-in-memory pages </p>"},{"location":"docs/events/builtin/syscalls/munlockall/#description","title":"Description","text":"<p>The munlockall () system call unlocks all pages in the address space of the current process that were previously locked via mlockall (). After the call, pages are unlocked regardless of the current reference counts. It has no effect on any pages that were not previously locked via mlockall ().</p> <p>The munlockall () system call does not unlock the amount of memory locked for the process.  The amount of locked memory for the process remains the same after a call to munlockall (). However, the call does reset the list of mlocked regions. Any subsequent mlock() and mlock2() system calls are limited by the amount of memory that is currently locked for the process.</p>"},{"location":"docs/events/builtin/syscalls/munlockall/#arguments","title":"Arguments","text":"<ul> <li><code>addr</code>:<code>void *</code>[U] - Pointer to a memory region. </li> </ul>"},{"location":"docs/events/builtin/syscalls/munlockall/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/munlockall/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/munlockall/#munlockall_1","title":"munlockall","text":""},{"location":"docs/events/builtin/syscalls/munlockall/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/munlockall/#purpose","title":"Purpose","text":"<p>To monitor a process's memory utilization, and detect excessive page locking.</p>"},{"location":"docs/events/builtin/syscalls/munlockall/#example-use-case","title":"Example Use Case","text":"<p>An application may need to allocate a large chunk of memory and lock it down for its exclusive use. With munlockall () an application can quickly establish multiple regions of locked memory that it does not need to allocate and initialize each time.</p>"},{"location":"docs/events/builtin/syscalls/munlockall/#issues","title":"Issues","text":"<p>munlockall() may cause performance issues on some systems due to the additional IO operations performed.</p>"},{"location":"docs/events/builtin/syscalls/munlockall/#related-events","title":"Related Events","text":"<ul> <li>mlockall() </li> <li>mlock()</li> <li>munlock()</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/munmap/","title":"munmap","text":""},{"location":"docs/events/builtin/syscalls/munmap/#intro","title":"Intro","text":"<p>munmap - used to unmap/delete a previously mapped region of memory </p>"},{"location":"docs/events/builtin/syscalls/munmap/#description","title":"Description","text":"<p>munmap is a syscall provided by the Linux kernel that is used to unmap/delete a previously mapped region of memory. This can be used to free up memory that was previously allocated for some purpose and is no longer needed. This syscall provides an efficient way for processes to manage their memory usage, as it can free up specific regions of memory that have been mapped, rather than having to free up all the memory and then reallocate the required portions. One of the drawbacks of using this system call is that it can lead to memory fragmentation, as areas of memory are freed individually. This can make it difficult for processes to allocate memory in larger chunks, as there may be a number of small, scattered areas of free memory.</p>"},{"location":"docs/events/builtin/syscalls/munmap/#arguments","title":"Arguments","text":"<ul> <li><code>addr</code>: <code>void*</code>[K] - Address of a previously mapped memory region in the calling process.</li> <li><code>length</code>: <code>size_t</code>[K] - Length of the memory region to be unmapped, in bytes. Must match the length of the region that was provided to mmap() during its creation.</li> </ul>"},{"location":"docs/events/builtin/syscalls/munmap/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/munmap/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/munmap/#do_munmap","title":"do_munmap","text":""},{"location":"docs/events/builtin/syscalls/munmap/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/munmap/#purpose","title":"Purpose","text":"<p>To monitor the unmapping of addressed regions of memory in the kernel.</p>"},{"location":"docs/events/builtin/syscalls/munmap/#vm_munmap","title":"vm_munmap","text":""},{"location":"docs/events/builtin/syscalls/munmap/#type_1","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/munmap/#purpose_1","title":"Purpose","text":"<p>To monitor the unmapping of addressed regions of memory in user space processes.</p>"},{"location":"docs/events/builtin/syscalls/munmap/#example-use-case","title":"Example Use Case","text":"<p>A web server written in C needs to keep track of the addresses of all allocated memory regions as part of its regular clean-up and memory management process. The web server can use the munmap syscall to free-up memory upon the completion of an operation and make the associated address space available for future uses.</p>"},{"location":"docs/events/builtin/syscalls/munmap/#issues","title":"Issues","text":"<p>No issues have been reported with the munmap syscall.</p>"},{"location":"docs/events/builtin/syscalls/munmap/#related-events","title":"Related Events","text":"<ul> <li><code>mmap</code> - The sys call used to map a region of memory.</li> <li><code>mremap</code> - The sys call used to resize a mapped memory region.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/name_to_handle_at/","title":"name_to_handle_at","text":""},{"location":"docs/events/builtin/syscalls/name_to_handle_at/#intro","title":"Intro","text":"<p>name_to_handle_at - Gets a handle for a path</p>"},{"location":"docs/events/builtin/syscalls/name_to_handle_at/#description","title":"Description","text":"<p>The name_to_handle_at system call takes an open file descriptor <code>dirfd</code> of a directory and a path <code>pathname</code> relative to it, and acts in a similar fashion to name_to_handle_at. It returns a handle that can be used in the future to refer to the object specified by the path.</p> <p>The use of this system call allows applications to keep track of objects even if the path to them changes due to mount/unmount operations or directory moves. It is similar to the openat system call, but the returned file handle is valid even if the process moves to another mount namespace.</p> <p>The <code>handle</code> argument is the output that will be filled by the system call. The purpose of passing <code>mount_id</code> is to specify an exported or shared filesystem handle to be used instead of the name. <code>flags</code> is used to add additional information about the name resolution for the file handle.</p>"},{"location":"docs/events/builtin/syscalls/name_to_handle_at/#arguments","title":"Arguments","text":"<ul> <li><code>dirfd</code>:<code>int</code>[K] - File descriptor of a directory used by name_to_handle_at.</li> <li><code>pathname</code>:<code>const char*</code>[K] - Path relative to the directory specified by the <code>dirfd</code> file descriptor.</li> <li><code>handle</code>:<code>struct file_handle*</code>[K] - Memory address used to hold the output result (file handle).</li> <li><code>mount_id</code>:<code>int*</code>[K] - Pointer to an additional information of the exported filesystem.</li> <li><code>flags</code>:<code>int</code>[K] - Flags used to add additional information on the name resolution of the file handle.</li> </ul>"},{"location":"docs/events/builtin/syscalls/name_to_handle_at/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/name_to_handle_at/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/name_to_handle_at/#sys_name_to_handle_at","title":"sys_name_to_handle_at","text":""},{"location":"docs/events/builtin/syscalls/name_to_handle_at/#type","title":"Type","text":"<p>Kprobe + Uprobe</p>"},{"location":"docs/events/builtin/syscalls/name_to_handle_at/#purpose","title":"Purpose","text":"<p>To trace each time a process calls a <code>name_to_handle_at</code> system call.</p>"},{"location":"docs/events/builtin/syscalls/name_to_handle_at/#example-use-case","title":"Example Use Case","text":"<p>When writing a file system monitoring application, it might be interesting to keep track of changes regarding objects in the file system associated with a certain process. The <code>name_to_handle_at</code> system call allows for that, by providing an efficient way to retrieve handles for the objects.</p>"},{"location":"docs/events/builtin/syscalls/name_to_handle_at/#issues","title":"Issues","text":"<p>If mountIDs are used, the returned file handle may be unreliable if the filesystem is moved or unmounted in the meanwhile.</p>"},{"location":"docs/events/builtin/syscalls/name_to_handle_at/#related-events","title":"Related Events","text":"<p>openat</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/nanosleep/","title":"nanosleep","text":""},{"location":"docs/events/builtin/syscalls/nanosleep/#intro","title":"Intro","text":"<p>nanosleep - Suspend execution of the calling thread for whatever is specified by req.</p>"},{"location":"docs/events/builtin/syscalls/nanosleep/#description","title":"Description","text":"<p>nanosleep is used to suspend execution of the calling thread until either the time interval specified in the structure pointed to by req has passed or the delivery of a signal which triggers the invocation of a signal-catching function. This structure value remains in effect until nanosleep finishes, it will not currently adjust the timer in case of interrupted by a signal handler. There are some edge cases and inadequacies related to the timing of nanosleep and how it is affected by clock changes, system load and other processes.</p>"},{"location":"docs/events/builtin/syscalls/nanosleep/#arguments","title":"Arguments","text":"<ul> <li><code>req</code>:<code>const struct timespec*</code>[K] - Pointer to a structure that specifies an interval of time, of type struct timespec, to pause execution of the calling thread.</li> <li><code>rem</code>:<code>struct timespec*</code>[KU] - Pointer to a structure that shall receive the time still remaining of the interval specified in req, of type struct timespec.</li> </ul>"},{"location":"docs/events/builtin/syscalls/nanosleep/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/nanosleep/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/nanosleep/#do_sys_nanosleep","title":"do_sys_nanosleep","text":""},{"location":"docs/events/builtin/syscalls/nanosleep/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/nanosleep/#purpose","title":"Purpose","text":"<p>To find the overhead of nanosleep invocations.</p>"},{"location":"docs/events/builtin/syscalls/nanosleep/#example-use-case","title":"Example Use Case","text":"<p>nanosleep can be used to sleep for a specified length of time to produce a slowdown for the process that is being profiled. It can also be used to yield the CPU running time to other threads and processes.</p>"},{"location":"docs/events/builtin/syscalls/nanosleep/#issues","title":"Issues","text":"<p>Since nanosleep is based on the system\u2019s kernel jiffies counter, its accuracy can be affected by system load, other processes and clock changes. This may cause nanosleep to return earlier or later than requested.</p>"},{"location":"docs/events/builtin/syscalls/nanosleep/#related-events","title":"Related Events","text":"<p>syscall_entry (for nanosleep) - Event that is triggered when a syscall is entered. syscall_exit (for nanosleep) - Event that is triggered when a syscall is exited.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/newfstatat/","title":"newfstatat","text":""},{"location":"docs/events/builtin/syscalls/newfstatat/#intro","title":"Intro","text":"<p>newfstatat - obtains information about a file relative to a directory file descriptor</p>"},{"location":"docs/events/builtin/syscalls/newfstatat/#description","title":"Description","text":"<p>The newfstatat() system call is used to obtain information about a file relative to a directory file descriptor. It is similar the <code>fstat()</code> call, but the file descriptor is related to a directory in which the pathname is relative to. The <code>dirfd</code> parameter of this call is an open file descriptor for a directory, and the <code>pathname</code> parameter is a pathname within that directory; the system call then does the same sort of thing with this file as <code>fstat()</code> does for a given file descriptor. The <code>flags</code> parameter of this call can have different values indicating the behaviour of this call. Returned information about the file will be stored in the <code>statbuf</code> buffer.</p> <p>Are there any edge-cases, drawbacks or advantages of using it?</p> <p>The advantage of using newfstatat() is that it is able to obtain information about a file within a directory without requiring a full pathname, just a filename relative to the directory. The main drawback of using newfstatat() is its lack of support for certain flags that <code>fstat()</code> or <code>stat()</code> might provide.</p>"},{"location":"docs/events/builtin/syscalls/newfstatat/#arguments","title":"Arguments","text":"<ul> <li><code>dirfd</code>: <code>int</code>[K] - an open file descriptor for the directory.</li> <li><code>pathname</code>: <code>const char*</code>[U] - the pathname of the file relative to the directory.</li> <li><code>statbuf</code>: <code>struct stat*</code>[K] - address where information about the file is returned.</li> <li><code>flags</code>: <code>int</code>[K] - flags describing the behaviour of the call.</li> </ul>"},{"location":"docs/events/builtin/syscalls/newfstatat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/newfstatat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/newfstatat/#sys_newfstatat","title":"sys_newfstatat","text":""},{"location":"docs/events/builtin/syscalls/newfstatat/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/newfstatat/#purpose","title":"Purpose","text":"<p>Capturing the file descriptor, flags and pathname arguments and returning the updated file stats.</p>"},{"location":"docs/events/builtin/syscalls/newfstatat/#path_lookupat","title":"path_lookupat","text":""},{"location":"docs/events/builtin/syscalls/newfstatat/#type_1","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/newfstatat/#purpose_1","title":"Purpose","text":"<p>To lookup the pathname passed as an argument and ensure it is valid.</p>"},{"location":"docs/events/builtin/syscalls/newfstatat/#example-use-case","title":"Example Use Case","text":"<p>This event could be used to monitor file access attempts within a directory, such as attempts to access a configuration file or secret file, by logging the pathname of the file and the status of the operation. </p>"},{"location":"docs/events/builtin/syscalls/newfstatat/#issues","title":"Issues","text":"<p>newfstatat() is not able to provide information based on certain flags that would be used with fstat() and stat().</p>"},{"location":"docs/events/builtin/syscalls/newfstatat/#related-events","title":"Related Events","text":"<ul> <li>fstat()</li> <li>stat()</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/nfsservctl/","title":"nfsservctl","text":""},{"location":"docs/events/builtin/syscalls/nfsservctl/#intro","title":"Intro","text":"<p>nfsservctl - Used to query and/or update kernel parameters in the NFS server.</p>"},{"location":"docs/events/builtin/syscalls/nfsservctl/#description","title":"Description","text":"<p>The nfsservctl() system call is used to query or update kernel parameters in the NFS server. When used to query parameters, it returns the current parameters, including potential upgrade messages. When used to modify parameters, flags can be set which will cause the NFS server to automatically restart itself after the parameters take effect.</p> <p>The nfsservctl() system call can also be used to start and stop the NFS server. This ability is useful for system administrators who wish to restart the server for maintenance or configuration changes without requiring a system reboot.</p>"},{"location":"docs/events/builtin/syscalls/nfsservctl/#arguments","title":"Arguments","text":"<ul> <li><code>cmd</code>:<code>int</code>[K] - specifies the type of operation to perform. This is one of the NFSCTL_* constants.</li> <li><code>arg</code>:<code>void *</code>[K] - a pointer to a buffer to be used to store information related to the nfsservctl() command such as parameters that need to be changed or information about the current status of the NFS server.</li> <li><code>len</code>:<code>sizet</code>[K] - used to specify the length of the buffer in bytes.</li> </ul>"},{"location":"docs/events/builtin/syscalls/nfsservctl/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/nfsservctl/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/nfsservctl/#sys_nfsservctl","title":"sys_nfsservctl","text":""},{"location":"docs/events/builtin/syscalls/nfsservctl/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/nfsservctl/#purpose","title":"Purpose","text":"<p>To monitor NFS server activity - It should be able to identify whether the system is issuing NFS server control commands.</p>"},{"location":"docs/events/builtin/syscalls/nfsservctl/#example-use-case","title":"Example Use Case","text":"<p>In certain scenarios, an administrator may need to make frequent changes to NFS server settings in order to optimize performance. In such cases, the nfsservctl() system call allows them to make such changes without requiring a system reboot or manual intervention.</p>"},{"location":"docs/events/builtin/syscalls/nfsservctl/#issues","title":"Issues","text":"<p>null</p>"},{"location":"docs/events/builtin/syscalls/nfsservctl/#related-events","title":"Related Events","text":"<ul> <li>nfsservctl_set_constate</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/nice/","title":"nice","text":""},{"location":"docs/events/builtin/syscalls/nice/#intro","title":"Intro","text":"<p>nice - Change the nice value of the current process, influence scheduling priority</p>"},{"location":"docs/events/builtin/syscalls/nice/#description","title":"Description","text":"<p>The nice() system call can be used to change the nice value of the current process, which influences its scheduling priority. A lower nice value causes more favorable scheduling, and a process with a \"high\" nice value will be scheduled less often than other processes. A process must be privileged to raise its nice value (i.e., to decrease its priority).</p> <p>There are some edge-cases with nice(): if a privileged process calls nice() with a non-zero value, then it might cause the scheduling priority to drop too far or become too favorable; this could put system instability. Additionally, even a process with the correct privileges cannot raise its nice value above its current value.</p>"},{"location":"docs/events/builtin/syscalls/nice/#arguments","title":"Arguments","text":"<ul> <li><code>inc</code>:<code>int</code> - The 'inc' argument specifies an increment to be added to the nice value of the current process. A positive value adds to the nice value and a negative value subtracts from it. For the superuser, the range of valid nice values is from -20 (most favorable) to +19 (least favorable). For a normal process, the range is from 0 to PRIO_MAX (usually 20).</li> </ul>"},{"location":"docs/events/builtin/syscalls/nice/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/nice/#sys_nice","title":"sys_nice","text":""},{"location":"docs/events/builtin/syscalls/nice/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/nice/#purpose","title":"Purpose","text":"<p>To monitor and log when the <code>nice</code> syscall is used.</p>"},{"location":"docs/events/builtin/syscalls/nice/#example-use-case","title":"Example Use Case","text":"<p>Nice() can be used to measure the relative performance of two applications running against each other on a system. By setting one application to a slightly higher nice value, you can prioritize the other application, thus obtaining an accurate performance measurement.</p>"},{"location":"docs/events/builtin/syscalls/nice/#issues","title":"Issues","text":"<p>No known issues.</p>"},{"location":"docs/events/builtin/syscalls/nice/#related-events","title":"Related Events","text":"<p>The sched_setscheduler function can be used to change the scheduling policy and priority of a process. This event is typically a better option than the nice() system call if you want to tailor the scheduling priority of a process.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/old_getrlimit/","title":"old_getrlimit","text":""},{"location":"docs/events/builtin/syscalls/old_getrlimit/#intro","title":"Intro","text":"<p>old_getrlimit - get resource limits knwon to the kernel</p>"},{"location":"docs/events/builtin/syscalls/old_getrlimit/#description","title":"Description","text":"<p>The old_getrlimit syscall is used to retrieve the resource limit values for a particular resource, such as the maximum size of a file that may be written, the maximum number of processes that may be started, etc. It returns the values in the struct rlimit pointed to by the rlim parameter. </p> <p>This syscall is available in Linux kernel versions 2.2 and earlier, although it is no longer supported in newer kernels. As such, it is important to note that, while it may return the correct results, those results may be outdated and the kernel may be changing it's behavior without the process being aware.</p>"},{"location":"docs/events/builtin/syscalls/old_getrlimit/#arguments","title":"Arguments","text":"<ul> <li><code>resource</code>:<code>int</code> - resource identifier.</li> <li><code>rlim</code>:<code>struct rlimit*</code> - pointer to struct rlimit that will store the limit values.</li> </ul>"},{"location":"docs/events/builtin/syscalls/old_getrlimit/#availiable-tags","title":"Availiable Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/old_getrlimit/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/old_getrlimit/#old_getrlimit_1","title":"old_getrlimit","text":""},{"location":"docs/events/builtin/syscalls/old_getrlimit/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/old_getrlimit/#purpose","title":"Purpose","text":"<p>To monitor resource limit values in the kernel.</p>"},{"location":"docs/events/builtin/syscalls/old_getrlimit/#example-use-case","title":"Example Use Case","text":"<p>If a process needs to monitor its resource limit values, it can use old_getrlimit syscall. </p>"},{"location":"docs/events/builtin/syscalls/old_getrlimit/#issues","title":"Issues","text":"<p>The old_getrlimit syscall is no longer supported in newer kernels and as such the results returned may be outdated and the kernel may be changing it's behavior without the process being aware.</p>"},{"location":"docs/events/builtin/syscalls/old_getrlimit/#related-events","title":"Related Events","text":"<ul> <li>setrlimit - set resource limit values.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/old_select/","title":"old_select","text":""},{"location":"docs/events/builtin/syscalls/old_select/#intro","title":"Intro","text":"<p>old_select - Used to monitor multiple file descriptors for a synchronous event.</p>"},{"location":"docs/events/builtin/syscalls/old_select/#description","title":"Description","text":"<p>old_select is used to monitor multiple file descriptors for a synchronous event. This can be useful for waiting for data on a network connection or for handling multiple file descriptors at the same time. old_select will block until one of the file descriptors is ready or a timeout is reached. It has the same function as the newer select() system call, but with a slightly different interface.</p> <p>One of the main drawbacks of the old_select system call is that it is vulnerable to the time-of-check-time-of-use (TOCTOU) race condition. This is because old_select doesn't have the ability to atomically check the file descriptors and set the timeout. This can lead to a process missing out on data if the data has already been read before the timeout is set.</p>"},{"location":"docs/events/builtin/syscalls/old_select/#arguments","title":"Arguments","text":"<ul> <li><code>nfds</code>:<code>int</code> - The number of file descriptors to be monitored.</li> <li><code>readfds</code>:<code>fd_set*</code>[K] - Pointer to a set of file descriptor sets that will be checked for readability.</li> <li><code>writefds</code>:<code>fd_set*</code>[K] - Pointer to a set of file descriptor sets that will be checked for writability.</li> <li><code>exceptfds</code>:<code>fd_set*</code>[K] - Pointer to a set of file descriptor sets that will be checked for out of band data.</li> <li><code>timeout</code>:<code>struct timeval*</code>[K] - Timeout value, as a <code>struct timeval</code>. If <code>nullptr</code> is passed, the call is blocking.</li> </ul>"},{"location":"docs/events/builtin/syscalls/old_select/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/old_select/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/old_select/#old_select_1","title":"old_select","text":""},{"location":"docs/events/builtin/syscalls/old_select/#type","title":"Type","text":"<p>Kprobe.</p>"},{"location":"docs/events/builtin/syscalls/old_select/#purpose","title":"Purpose","text":"<p>To monitor the different conditions of the fd sets that are passed in the selector call.</p>"},{"location":"docs/events/builtin/syscalls/old_select/#example-use-case","title":"Example Use Case","text":"<p>old_select is useful for monitoring multiple file descriptors in a synchronous setting. For example, an application might use it to monitor a network connection for incoming data and multiple local file descriptors for requests from other processes.</p>"},{"location":"docs/events/builtin/syscalls/old_select/#issues","title":"Issues","text":"<p>The main issue with the old_select system call is that it is vulnerable to time-of-check-time-of-use (TOCTOU) race conditions. This means that it is possible for requests to be missed as the condition might already have changed before the timeout is set.</p>"},{"location":"docs/events/builtin/syscalls/old_select/#related-events","title":"Related Events","text":"<ul> <li>new_select - The newer version of the select system call, which is not vulnerable to TOCTOU race conditions. </li> <li>poll - Function to monitor set of file descriptors for activity. </li> <li>epoll - Similar to the poll system call, but with better integration with the I/O event loop.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/oldfstat/","title":"oldfstat","text":""},{"location":"docs/events/builtin/syscalls/oldfstat/#intro","title":"Intro","text":"<p>oldfstat - use this function to get information about an open file</p>"},{"location":"docs/events/builtin/syscalls/oldfstat/#description","title":"Description","text":"<p>The oldfstat function is used to get information about an open file. This function is similar to fstat() which is used to get information about a file that is referred to by a file descriptor. oldfstat() is available on all UNIX-like systems for backwards compatibility and features a similar set of information about the open file. The main difference is that the user does not need to provide the file descriptor, instead of this it takes a file handle. If a process has permission to the file then the information will be used.</p>"},{"location":"docs/events/builtin/syscalls/oldfstat/#arguments","title":"Arguments","text":"<ul> <li><code>fildes</code>:<code>int</code>[K-U] - an open file descriptor of the object to be stat'ed.</li> <li><code>buf</code>:<code>stat*</code>[K] - a pointer to a stat structure in which information is stored.</li> </ul>"},{"location":"docs/events/builtin/syscalls/oldfstat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space. </li> <li>U - Originated from user space (for example, pointer to user space memory used to get it). </li> <li>OPT - Optional argument - might not always be available (passed with null value).</li> </ul>"},{"location":"docs/events/builtin/syscalls/oldfstat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/oldfstat/#sys_oldfstat","title":"<code>sys_oldfstat</code>","text":""},{"location":"docs/events/builtin/syscalls/oldfstat/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/oldfstat/#purpose","title":"Purpose","text":"<p>To track function calls and extract data from arguments to understand the behavior of a program.</p>"},{"location":"docs/events/builtin/syscalls/oldfstat/#example-use-case","title":"Example Use Case","text":"<p>This event can be used to monitor and collect information over time about the files used by a process. It can also be used to audit system programs' behaviors when we are suspicious about their access to the file.</p>"},{"location":"docs/events/builtin/syscalls/oldfstat/#issues","title":"Issues","text":"<p>The oldfstat() does not support file descriptors greater than (USHRT_MAX + 1) and therefore, cannot be reliable for such system calls.</p>"},{"location":"docs/events/builtin/syscalls/oldfstat/#related-events","title":"Related Events","text":"<ul> <li><code>fstat</code> - Similarly used to get information about a file, but takes a file descriptor as an argument. </li> <li><code>lstat</code> - Used to get information about a file from a symbolic link path.</li> <li><code>fstatat</code> - Used to get information about a file and takes a directory file descriptor as an argument.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/oldlstat/","title":"oldlstat","text":""},{"location":"docs/events/builtin/syscalls/oldlstat/#intro","title":"Intro","text":"<p>oldlstat - stat the file pointed to by pathname</p>"},{"location":"docs/events/builtin/syscalls/oldlstat/#description","title":"Description","text":"<p>oldlstat is used to return the status information about the file pointed to by the <code>pathname</code> argument. It return similar information as <code>lstat</code>, except if <code>pathname</code> is a symbolic link, it will return information about the link itself. Additionally, it will update the return value in <code>statbuf</code>, which is a pointer to <code>struct stat</code>.</p> <p>This event is useful to be used in programs that need to retrieve information about a file, but it is vulnerable to Time Of Check, Time of Use (TOCTOU) race condition.</p>"},{"location":"docs/events/builtin/syscalls/oldlstat/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code>[K, U] - pointer to the pathname of the file for which status information will be returned.</li> <li><code>statbuf</code>:<code>struct stat*</code>[K] - pointer to a structure of type <code>struct stat</code> into which information should be stored.</li> </ul>"},{"location":"docs/events/builtin/syscalls/oldlstat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/oldlstat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/oldlstat/#sys_oldlstat","title":"sys_oldlstat","text":""},{"location":"docs/events/builtin/syscalls/oldlstat/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/oldlstat/#purpose","title":"Purpose","text":"<p>The event is hooked with kprobes in order to observe and trace the syscall arguments and return value.</p>"},{"location":"docs/events/builtin/syscalls/oldlstat/#example-use-case","title":"Example Use Case","text":"<p>This event can be used, for example, in an application to monitor file changes in the system.</p>"},{"location":"docs/events/builtin/syscalls/oldlstat/#issues","title":"Issues","text":"<p>Due to the fact that this syscall is vulnerable to TOCTOU race condition, a malicious user could try to bypass the monitoring being done with this event, by changing the file parameters in between the time that it was checked and used.</p>"},{"location":"docs/events/builtin/syscalls/oldlstat/#related-events","title":"Related Events","text":"<ul> <li><code>lstat</code> - similar event used to get information about files. Does not have the TOCTOU vulnerability.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/oldolduname/","title":"oldolduname","text":""},{"location":"docs/events/builtin/syscalls/oldolduname/#intro","title":"Intro","text":"<p>oldolduname - gets the legacy version of the system name</p>"},{"location":"docs/events/builtin/syscalls/oldolduname/#description","title":"Description","text":"<p>The oldolduname syscall obtains the system's legacy version of the name of the operating system running on the system. This name is a string that can contain a maximum of 8 characters and is displayed like <code>GECOS</code> (where the <code>OS/32</code> operating system got its name). This syscall, which is deprecated, should not be used in any production code and its use is discouraged. </p>"},{"location":"docs/events/builtin/syscalls/oldolduname/#arguments","title":"Arguments","text":"<ul> <li><code>name</code>:<code>struct oldold_utsname*</code>[U] - pointer to a buffer of type <code>struct oldold_utsname</code> which will be populated with the system name. </li> </ul>"},{"location":"docs/events/builtin/syscalls/oldolduname/#available-tags","title":"Available Tags","text":"<ul> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/oldolduname/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/oldolduname/#_1","title":"","text":""},{"location":"docs/events/builtin/syscalls/oldolduname/#type","title":"Type","text":"<p>Kprobe.</p>"},{"location":"docs/events/builtin/syscalls/oldolduname/#purpose","title":"Purpose","text":"<p>Hooking this syscall allows users to trace system information, such as getting the specific operating system name, when a process calls it.</p>"},{"location":"docs/events/builtin/syscalls/oldolduname/#example-use-case","title":"Example Use Case","text":"<p>The oldolduname syscall can be used to figure out what legacy operating system the system is running on. It is particularly useful for debuggers and software that needs to identify what system they are running on. </p>"},{"location":"docs/events/builtin/syscalls/oldolduname/#issues","title":"Issues","text":"<p>This syscall is deprecated, so its use is discouraged.</p>"},{"location":"docs/events/builtin/syscalls/oldolduname/#related-events","title":"Related Events","text":"<p>uname - gets the system name and version information.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/oldstat/","title":"oldstat","text":""},{"location":"docs/events/builtin/syscalls/oldstat/#intro","title":"Intro","text":"<p>oldstat - get file status (struct __old_kernel_stat) for the given filename</p>"},{"location":"docs/events/builtin/syscalls/oldstat/#description","title":"Description","text":"<p>The oldstat system call retrieves the file status (the content of the struct __old_kernel_stat) for the given filename. It fills the given structure with information about the file, like permissions, ownership, size, etc. It is typically used to gather data about a file, before attempting to use it in any way. It is important to note that its results might be subject to change due to the condition of the system (e.g. the user running the oldstat call does not have read access to the requested file).</p>"},{"location":"docs/events/builtin/syscalls/oldstat/#arguments","title":"Arguments","text":"<ul> <li><code>filename</code>:<code>char*</code>[U] - Pointer to a buffer containing the name of the file whose status is to be retrieved.</li> <li><code>statbuf</code>:<code>struct __old_kernel_stat*</code>[K] - Pointer to the previously allocated oldstat buffer structure into which the status information should be stored.</li> </ul>"},{"location":"docs/events/builtin/syscalls/oldstat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/oldstat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/oldstat/#old_stat","title":"old_stat","text":""},{"location":"docs/events/builtin/syscalls/oldstat/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/oldstat/#purpose","title":"Purpose","text":"<p>To gather information on what files were requested and their stat information before they were found.</p>"},{"location":"docs/events/builtin/syscalls/oldstat/#example-use-case","title":"Example Use Case","text":"<p>For example, an admin logging tool may want to log the oldstat calls of a process to get information about which files were accessed by it.</p>"},{"location":"docs/events/builtin/syscalls/oldstat/#issues","title":"Issues","text":"<p>The information obtained from this event is only valid at the time of retrieval, meaning that subsequent changes to the file might have been made and yield unexpected results. Furthermore, the user running the oldstat system call must have read access to the requested file.</p>"},{"location":"docs/events/builtin/syscalls/oldstat/#related-events","title":"Related Events","text":"<p>The stat system call is a newer version of the oldstat system call and offers a more robust way of retrieving status about files. The syslog system call also provides information about files being accessed.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/olduname/","title":"olduname","text":""},{"location":"docs/events/builtin/syscalls/olduname/#intro","title":"Intro","text":"<p><code>olduname</code> - Returns sysname, nodename, release, version and machine information of the running system.</p>"},{"location":"docs/events/builtin/syscalls/olduname/#description","title":"Description","text":"<p>The <code>olduname</code> syscall is used to get basic system information about the running Linux system, such as its kernel version and the architecture version of a running machine. This is the original version of the uname system call and its information might be less accurate than the more modern version of the system call. It is commonly used to retrieve a string describing the name and version of the system, which is returned in the kernel parameter <code>buf</code>.</p>"},{"location":"docs/events/builtin/syscalls/olduname/#arguments","title":"Arguments","text":"<ul> <li><code>buf</code>:<code>struct utsname*</code>[K,U] - Pointer to a <code>struct utsname</code> passed by the user to be used to store the system information.</li> </ul>"},{"location":"docs/events/builtin/syscalls/olduname/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/olduname/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/olduname/#sys_olduname","title":"sys_olduname","text":""},{"location":"docs/events/builtin/syscalls/olduname/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/olduname/#purpose","title":"Purpose","text":"<p>Hooked to capture the system information for further investigation.</p>"},{"location":"docs/events/builtin/syscalls/olduname/#example-use-case","title":"Example Use Case","text":"<p>One example use of the <code>olduname</code> system call is to retrieve the Linux kernel version running when a process is spawned. This can be used as an additional source of information to detect malicious activities.</p>"},{"location":"docs/events/builtin/syscalls/olduname/#issues","title":"Issues","text":"<p>Most current Linux distributions use the newer version of the system call, so the information gathered from <code>olduname</code> might be limited.</p>"},{"location":"docs/events/builtin/syscalls/olduname/#related-events","title":"Related Events","text":"<p><code>uname</code> - newer version of the system call used to look for system information.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/open/","title":"open","text":""},{"location":"docs/events/builtin/syscalls/open/#intro","title":"Intro","text":"<p>open - is a system call used to open the file specified by its filename</p>"},{"location":"docs/events/builtin/syscalls/open/#description","title":"Description","text":"<p>The purpose of open is to provide a system call to logicaly open a file in the file system. It might be important to keep in mind that the open call does not actually access the file in the system. Using the flags parameter, one could get different types of access rights to the file. One of the drawbacks of using open is that it is vulnerable to TOCTOU (time of check, time of use).</p>"},{"location":"docs/events/builtin/syscalls/open/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code>[K] - The path to the file we want to open.</li> <li><code>flags</code>:<code>int</code>[K] - Flags for the access. Used to set the access/permissions for the call.</li> <li><code>mode</code>:<code>mode_t</code>[K] - Control access to the opened file.</li> </ul>"},{"location":"docs/events/builtin/syscalls/open/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/open/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/open/#sys_open","title":"sys_open","text":""},{"location":"docs/events/builtin/syscalls/open/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/open/#purpose","title":"Purpose","text":"<p>To record every open system call, including its associated arguments.</p>"},{"location":"docs/events/builtin/syscalls/open/#example-use-case","title":"Example Use Case","text":"<p>This event could be used to monitor reads and writes to a specific file.</p>"},{"location":"docs/events/builtin/syscalls/open/#issues","title":"Issues","text":"<p>open could be very vulnerable to race-condition issues, as it is vulnerable to TOCTOU (Time Of Check, Time Of Use).</p>"},{"location":"docs/events/builtin/syscalls/open/#related-events","title":"Related Events","text":"<p>The related events for the open syscall are close(), read(), and write().</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/open_by_handle_at/","title":"open_by_handle_at","text":""},{"location":"docs/events/builtin/syscalls/open_by_handle_at/#intro","title":"Intro","text":"<p>open_by_handle_at - open a file by a handle, based on a users data</p>"},{"location":"docs/events/builtin/syscalls/open_by_handle_at/#description","title":"Description","text":"<p>The <code>open_by_handle_at()</code> system call is used to open a file given a file handle and mount point. The <code>open_by_handle_at()</code> call is similar to <code>openat()</code>, except that the former takes a file handle obtained from <code>name_to_handle_at()</code> instead of a pathname string.</p> <p>The <code>open_by_handle_at()</code> provides a flexible and fast way of creating new file descriptors for an existing file without the overhead of a file system lookup. It is, however, more fragile than <code>openat()</code> since the target file system may not be available in the same state when it is used for the later operation.</p>"},{"location":"docs/events/builtin/syscalls/open_by_handle_at/#arguments","title":"Arguments","text":"<ul> <li><code>mount_fd</code>:<code>int</code>[K] - file descriptor of the directory at which to open the handle. </li> <li><code>handle</code>: <code>struct file_handle*</code>[U] - pointer to the file handle that was acquired by the <code>name_to_handle_at</code> system call.</li> <li><code>flags</code>: <code>int</code>[K] - file status flags to use when opening the handle. This can be used to control the permissions of the file being opened. </li> </ul>"},{"location":"docs/events/builtin/syscalls/open_by_handle_at/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/open_by_handle_at/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/open_by_handle_at/#do_sys_open","title":"do_sys_open","text":""},{"location":"docs/events/builtin/syscalls/open_by_handle_at/#type","title":"Type","text":"<p>Kprobes + ftrace</p>"},{"location":"docs/events/builtin/syscalls/open_by_handle_at/#purpose","title":"Purpose","text":"<p>Hooks are used to detect when the <code>open_by_handle_at()</code> syscall is called by userspace</p>"},{"location":"docs/events/builtin/syscalls/open_by_handle_at/#get_empty_filp","title":"get_empty_filp","text":""},{"location":"docs/events/builtin/syscalls/open_by_handle_at/#type_1","title":"Type","text":"<p>Kprobes + ftrace</p>"},{"location":"docs/events/builtin/syscalls/open_by_handle_at/#purpose_1","title":"Purpose","text":"<p>Hooks are used to detect when the <code>open_by_handle_at()</code> syscall is setting up the file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/open_by_handle_at/#example-use-case","title":"Example Use Case","text":"<p>The <code>open_by_handle_at()</code> system call can be used to open files from a remote network system without needing to obtain the path of the file.</p>"},{"location":"docs/events/builtin/syscalls/open_by_handle_at/#issues","title":"Issues","text":"<p>This system call is vulnerable to TOCTOU (time of check, time of use) attacks as the file handle may have been acquired from a different file system that may not be in the same state when the file is opened.</p>"},{"location":"docs/events/builtin/syscalls/open_by_handle_at/#related-events","title":"Related Events","text":"<ul> <li><code>openat()</code> - Open a file relative to a directory file descriptor</li> <li><code>name_to_handle_at()</code> - Convert a file name to handle</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/open_tree/","title":"open_tree","text":""},{"location":"docs/events/builtin/syscalls/open_tree/#intro","title":"Intro","text":"<p>open_tree - open a file relative to a directory file descriptor </p>"},{"location":"docs/events/builtin/syscalls/open_tree/#description","title":"Description","text":"<p>open_tree is an Linux system call available since kernel 3.3. It can be used to open a file relative to an open directory file descriptor. It is similar to open but allows the opening of a file relative to an open directory file descriptor which can make the creation of an absolute path easier. </p> <p>Advantages of using this syscall include reducing the number of calls needed to build an absolute path.</p> <p>Drawbacks include lack of compatibility until kernel 3.3.</p>"},{"location":"docs/events/builtin/syscalls/open_tree/#arguments","title":"Arguments","text":"<ul> <li><code>dfd</code>:<code>int</code> - File descriptor of the directory used as base for the relative path of the file to open. </li> <li><code>filename</code>:<code>const char*</code> - The pathname relative to the directory referenced by the file descriptor.</li> <li><code>flags</code>:<code>unsigned int</code> [K] - Flags to be used when opening the file.</li> </ul>"},{"location":"docs/events/builtin/syscalls/open_tree/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/open_tree/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/open_tree/#do_sys_open","title":"do_sys_open","text":""},{"location":"docs/events/builtin/syscalls/open_tree/#type","title":"Type","text":"<p>kprobe </p>"},{"location":"docs/events/builtin/syscalls/open_tree/#purpose","title":"Purpose","text":"<p>To get details about when, and with which arguments, open_tree is called. </p>"},{"location":"docs/events/builtin/syscalls/open_tree/#example-use-case","title":"Example Use Case","text":"<p>open_tree is useful when particularially when the path of the file to open needs to be known before it is open, such as when opening a configuration file.</p>"},{"location":"docs/events/builtin/syscalls/open_tree/#issues","title":"Issues","text":"<p>Since open_tree is a relatively new system call, kernel versions before 3.3 do not support it.</p>"},{"location":"docs/events/builtin/syscalls/open_tree/#related-events","title":"Related Events","text":"<p>open: similar Linux system call for opening files, but does not support relative paths.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/openat/","title":"openat","text":""},{"location":"docs/events/builtin/syscalls/openat/#intro","title":"Intro","text":"<p>openat - The <code>openat(2)</code> system call is used to open a file relative to a directory file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/openat/#description","title":"Description","text":"<p><code>openat(2)</code> performs the same task as <code>open(2)</code>: it opens the file <code>pathname</code> (relative to the directory referred to by the file descriptor <code>dirfd</code>), but it can optionally provide the additional functionality of AT_SYMLINK_NOFOLLOW.</p> <p>The arguments are similar to <code>open(2)</code>: the <code>pathname</code> of the file to be opened, a flags <code>flags</code> and a mode <code>mode</code> to set it if it is created. The only difference is that the <code>dirfd</code> argument is a file descriptor of the directory that will serve as a prefix of the pathname. This allows <code>openat(2)</code> to be used in a thread-safe sequence of operations that all operate relative to the same directory.</p>"},{"location":"docs/events/builtin/syscalls/openat/#arguments","title":"Arguments","text":"<ul> <li><code>dirfd</code>: <code>int</code>[K] - A file descriptor referring to the directory relative to which <code>pathname</code> is to be accessed. If <code>dirfd</code> is the special value <code>AT_FDCWD</code>, then <code>pathname</code> is relative to the current working directory.</li> <li><code>pathname</code>: <code>const char*</code>[K,U] - A pathname of the file to be opened.</li> <li><code>flags</code>: <code>int</code>[K] -File access mode and file status flags. This argument is a bit-mask created by ORing together the <code>O_RDONLY</code>, <code>O_WRONLY</code>, <code>O_RDWR</code>, <code>O_APPEND</code>, <code>O_CREAT</code>, <code>O_EXCL</code>, <code>O_NOCTTY</code>, <code>O_TRUNC</code>, <code>O_DSYNC</code>, <code>O_DIRECTORY</code>, <code>O_NOFOLLOW</code>, <code>O_SYMLINK</code>, <code>O_CLOEXEC</code> and <code>O_NONBLOCK</code> flags.</li> <li><code>mode</code>: <code>mode_t</code>[K] -Mode of the created file. This argument must be supplied when <code>O_CREAT</code> is specified in flags. </li> </ul>"},{"location":"docs/events/builtin/syscalls/openat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/openat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/openat/#do_sys_open","title":"do_sys_open","text":""},{"location":"docs/events/builtin/syscalls/openat/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/openat/#purpose","title":"Purpose","text":"<p>Hooked to analyze the system call parameters.</p>"},{"location":"docs/events/builtin/syscalls/openat/#example-use-case","title":"Example Use Case","text":"<p><code>openat()</code> can be used to open a file in a secure manner, given that two file descriptors are available. The intention of <code>openat()</code> is that it can be used in a thread-safe sequence of operations that all operate relative to the same directory. A simple example of this is ensuring that a file is opened in the same directory as its parent, and not in another directory, even if the working directory has been changed in the meantime.</p>"},{"location":"docs/events/builtin/syscalls/openat/#issues","title":"Issues","text":"<p>Due to the fact that <code>openat()</code> uses an internal buffer to store the pathname, there is a potential vulnerability to TOCTOU (time of check, time of use) attacks.</p>"},{"location":"docs/events/builtin/syscalls/openat/#related-events","title":"Related Events","text":"<p><code>creat(2)</code>, <code>open(2)</code>, <code>stat(2)</code></p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/openat2/","title":"openat2","text":""},{"location":"docs/events/builtin/syscalls/openat2/#intro","title":"Intro","text":"<p>openat2 - create a file with special options</p>"},{"location":"docs/events/builtin/syscalls/openat2/#description","title":"Description","text":"<p>The openat2() system call function creates a file and returns a file descriptor for it. It is similar to openat(), but allows more detailed control over the file's creation. The possible combination of how-&gt;flags and how-&gt;writes can be used to customize the properties of the file, like its permissions, ownership, and timestamps. The openat2() syscall also allows us to specify a size when creating the file, which is useful for creating files with non-zero size or preallocation.</p>"},{"location":"docs/events/builtin/syscalls/openat2/#arguments","title":"Arguments","text":"<ul> <li><code>dirfd</code>:<code>int</code>[K] - a file descriptor for a directory.</li> <li><code>pathname</code>:<code>const char*</code>[U] - a pointer to the pathname of the file to be opened, within the directory referred to by the dirfd argument.</li> <li><code>how</code>:<code>struct open_how*</code>[K] - a pointer to the structure describing how the file should be opened.</li> <li><code>size</code>:<code>size_t</code>[K] - the requested size of the opened file.</li> </ul>"},{"location":"docs/events/builtin/syscalls/openat2/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/openat2/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/openat2/#openat2_1","title":"openat2","text":""},{"location":"docs/events/builtin/syscalls/openat2/#type","title":"Type","text":"<p>TRAP</p>"},{"location":"docs/events/builtin/syscalls/openat2/#purpose","title":"Purpose","text":"<p>The openat2 system call is used to create a file. It is hooked to instrument the creation of files.</p>"},{"location":"docs/events/builtin/syscalls/openat2/#sys_openat2","title":"sys_openat2","text":""},{"location":"docs/events/builtin/syscalls/openat2/#type_1","title":"Type","text":"<p>KRETPROBE </p>"},{"location":"docs/events/builtin/syscalls/openat2/#purpose_1","title":"Purpose","text":"<p>The sys_openat2 system call is the kernel entrypoint for the openat2 system call. It is hooked to intercept and validate the arguments of the call before execution.</p>"},{"location":"docs/events/builtin/syscalls/openat2/#example-use-case","title":"Example Use Case","text":"<p>openat2 can be used to create a hardlink to a file. By providing a pointer to a struct open_how as the \"how\" argument, we can create a link to a file, with specified ownership and permissions.</p>"},{"location":"docs/events/builtin/syscalls/openat2/#issues","title":"Issues","text":"<p>Due to the nature of this system call, there is the risk of TOCTOU vulnerabilities. Care must be taken to make sure that the parameters are valid when they are checked and still valid when they are used.</p>"},{"location":"docs/events/builtin/syscalls/openat2/#related-events","title":"Related Events","text":"<p>openat(), creat(), link(), unlink()</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/pause/","title":"Pause","text":""},{"location":"docs/events/builtin/syscalls/pause/#intro","title":"Intro","text":"<p>Pause - pauses the calling process until a signal is received.</p>"},{"location":"docs/events/builtin/syscalls/pause/#description","title":"Description","text":"<p>The pause() system call suspends the calling process until one of its child process terminates or a signal is received. If any of the currently pending signals have SIGCONT set as its action, pause() returns immediately. Any function that do not have SIGCONT as its action will suspend the process until a signal occurs.</p> <p>The pause() system call is used to synchronize a process with its child processes, so that when a child terminates, the parent can be notified. It is also used to temporarily suspend a process while signals are handled.</p>"},{"location":"docs/events/builtin/syscalls/pause/#arguments","title":"Arguments","text":"<ul> <li>None.</li> </ul>"},{"location":"docs/events/builtin/syscalls/pause/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/pause/#do_sys_pause","title":"do_sys_pause","text":""},{"location":"docs/events/builtin/syscalls/pause/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/pause/#purpose","title":"Purpose","text":"<p>The do_sys_pause() function is the kernel entry point for the pause system call. Kprobes is used to hook this function to record system call parameters.</p>"},{"location":"docs/events/builtin/syscalls/pause/#example-use-case","title":"Example Use Case","text":"<p>The pause() system call could be used for throttling the current process before it runs a task.</p>"},{"location":"docs/events/builtin/syscalls/pause/#issues","title":"Issues","text":"<p>The pause() system call fails if any of the pending signals have SIGCONT as its action.</p>"},{"location":"docs/events/builtin/syscalls/pause/#related-events","title":"Related Events","text":"<ul> <li>signal()  -  send a signal to a process or process group</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/perf_event_open/","title":"perf_event_open","text":""},{"location":"docs/events/builtin/syscalls/perf_event_open/#intro","title":"Intro","text":"<p>perf_event_open - Used to start/stop a specific performance monitoring event on a specific CPU</p>"},{"location":"docs/events/builtin/syscalls/perf_event_open/#description","title":"Description","text":"<p>The <code>perf_event_open system call</code> gives userspace the ability to request very specific performance monitoring events for a specific CPU. This syscall can be used to start and stop monitoring events, depending on the flags set when the syscall is called. It can also be used to group multiple performance monitoring events into a single group and therefore provide a combined report. This syscall has a few drawbacks, such as being susceptible to TOCTOU (time of check, time of use) attacks, as the application may not always be able to guarantee the same data as when the check was performed.</p>"},{"location":"docs/events/builtin/syscalls/perf_event_open/#arguments","title":"Arguments","text":"<ul> <li><code>attr</code>:<code>struct perf_event_attr*</code>[U] - User space memory buffer containing the definition of the performance event. The kernel will use this information to start/stop the performance event.</li> <li><code>pid</code>:<code>pid_t</code>[K] - Process ID of the process where the event needs to be started or stopped. If set to \u2018-1\u2019, the event will be started or stopped on all processes (but not threads).</li> <li><code>cpu</code>:<code>int</code>[K] - CPU number on which the event needs to be started or stopped. If set to \u2018-1\u2019, the event will be started or stopped on all CPUs.</li> <li><code>group_fd</code>:<code>int</code>[U,K] - File descriptor associated with an event group (used to group multiple events into a single report). It is set to \u2018-1\u2019 if not part of an event group.</li> <li><code>flags</code>:<code>unsigned long</code>[K] - Flags that indicate whether to start or stop the event.</li> </ul>"},{"location":"docs/events/builtin/syscalls/perf_event_open/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/perf_event_open/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/perf_event_open/#perf_event_open_1","title":"perf_event_open","text":""},{"location":"docs/events/builtin/syscalls/perf_event_open/#type","title":"Type","text":"<p>kprobe + kretprobe</p>"},{"location":"docs/events/builtin/syscalls/perf_event_open/#purpose","title":"Purpose","text":"<p>To collect performance events for a specific process, CPU or event group.</p>"},{"location":"docs/events/builtin/syscalls/perf_event_open/#example-use-case","title":"Example Use Case","text":"<p>A user space application that needs to get detailed performance stats for one or multiple processes running on a CPU. This application can use the <code>perf_event_open</code> system call, with the appropriate attributes and flags, to get detailed performance stats for each process (or all processes, or a group of processes).</p>"},{"location":"docs/events/builtin/syscalls/perf_event_open/#issues","title":"Issues","text":"<p>The application may be vulnerable to TOCTOU (time of check, time of use) attacks, as the data may change after the check is performed.</p>"},{"location":"docs/events/builtin/syscalls/perf_event_open/#related-events","title":"Related Events","text":"<ul> <li><code>perf_event_open</code></li> <li><code>perf_event_read</code></li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/personality/","title":"personality","text":""},{"location":"docs/events/builtin/syscalls/personality/#intro","title":"Intro","text":"<p>personality - change the personality of the calling process</p>"},{"location":"docs/events/builtin/syscalls/personality/#description","title":"Description","text":"<p>The <code>personality</code> syscall is used to change the personality of the calling process. It can be used to provide the process with different versions of the Linux kernel API, allowing the process to run on different versions of Linux. The personality can also be used to change the behaviour of certain APIs, such as how signals are dispatched or whether threads are schedulable. It also determines which emulation mode the process uses. The personality specified by the argument is a bitmask, consisting of flags from <code>personality.h</code>.</p> <p>There are some drawbacks to changing the personality of a process. It can result in the process being unable to run on certain versions of the kernel, and some features of the kernel may be unavailable in certain personality modes.</p>"},{"location":"docs/events/builtin/syscalls/personality/#arguments","title":"Arguments","text":"<ul> <li><code>persona</code>: <code>unsigned long</code> - specifies the new personality for the calling process.</li> </ul>"},{"location":"docs/events/builtin/syscalls/personality/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/personality/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/personality/#sys_personality","title":"sys_personality","text":""},{"location":"docs/events/builtin/syscalls/personality/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/personality/#purpose","title":"Purpose","text":"<p>To track when processes change their personality.</p>"},{"location":"docs/events/builtin/syscalls/personality/#example-use-case","title":"Example Use Case","text":"<p>This syscall can be used to ensure that processes do not run in an incompatible kernel version by maintaining a list of kernel versions permissible for the process, and setting the process's personality accordingly.</p>"},{"location":"docs/events/builtin/syscalls/personality/#issues","title":"Issues","text":"<p>If the specified personality has not been compiled into the running kernel, the syscall will fail with the <code>ENOSYS</code> error code.</p>"},{"location":"docs/events/builtin/syscalls/personality/#related-events","title":"Related Events","text":"<ul> <li><code>ptrace</code> - used for debugging and modifying processes</li> <li><code>clone</code> - used for creating processes with different personality settings</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/pidfd_getfd/","title":"pidfd_getfd","text":""},{"location":"docs/events/builtin/syscalls/pidfd_getfd/#intro","title":"Intro","text":"<p>pidfd_getfd - opens a file descriptor of the opened process by using pidfd</p>"},{"location":"docs/events/builtin/syscalls/pidfd_getfd/#description","title":"Description","text":"<p>The pidfd_getfd syscall will take a pidfd input as well as a target file descriptor  number, targetfd. It will then open a file descriptor in the opened process  associated with targetfd. If the flags argument is set to be zero, it will open  the original file descriptor without any extra options. If set to O_CLOEXEC,  it will open the target file descriptor with the FD_CLOEXEC flag set.</p>"},{"location":"docs/events/builtin/syscalls/pidfd_getfd/#arguments","title":"Arguments","text":"<ul> <li><code>pidfd</code>:<code>int</code>[K] - File descriptor created by the pidfd_open syscall which references a process that is already opened.</li> <li><code>targetfd</code>:<code>int</code>[K] - File descriptor number to be opened in the already opened process.</li> <li><code>flags</code>:<code>unsigned int</code>[K] - Flags with which the file descriptor should be opened.</li> </ul>"},{"location":"docs/events/builtin/syscalls/pidfd_getfd/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/pidfd_getfd/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/pidfd_getfd/#__x64_sys_pidfd_getfd","title":"__x64_sys_pidfd_getfd","text":""},{"location":"docs/events/builtin/syscalls/pidfd_getfd/#type","title":"Type","text":"<p>KProbes + KRetProbes</p>"},{"location":"docs/events/builtin/syscalls/pidfd_getfd/#purpose","title":"Purpose","text":"<p>To capture and monitor processes via the pidfd_getfd syscall.</p>"},{"location":"docs/events/builtin/syscalls/pidfd_getfd/#example-use-case","title":"Example Use Case","text":"<p>One useful application of pidfd_getfd is to monitor the progress of a process.  By using it in conjunction with the pidfd_open syscall, it is possible to open  a file descriptor that references a process and then use the pidfd_getfd syscall  to open a file descriptor to the original file descriptor of the process.  This can then be used in an auditd system to check the stats of the process and  identify any potentially malicious activities.</p>"},{"location":"docs/events/builtin/syscalls/pidfd_getfd/#issues","title":"Issues","text":"<p>No known issues.</p>"},{"location":"docs/events/builtin/syscalls/pidfd_getfd/#related-events","title":"Related Events","text":"<ul> <li>pidfd_open - Used to open a file descriptor to a process</li> <li>pidfd_send_signal - Used to send a signal to a process opened via pidfd_open</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/pidfd_open/","title":"pidfd_open","text":""},{"location":"docs/events/builtin/syscalls/pidfd_open/#intro","title":"Intro","text":"<p>pidfd_open - open a PID file descriptor for the given process</p>"},{"location":"docs/events/builtin/syscalls/pidfd_open/#description","title":"Description","text":"<p>The pidfd_open syscall allows users to obtain a file descriptor referring to the PID of the specified process. This syscall is useful in situations where one process needs access to the PID of another process in order to send signals, retrieve information about the process, or similar operations. It can also be used to monitor the lifetime of the process, since the file descriptor is closed when the process terminates. </p> <p>One of the use cases for pidfd_open is in containers that wish to move the management of their associated process to the kernel level. By using pidfd_open and then passing the resulting file descriptor to the kernel through pidfd_getfd, the application can ensure that it has proper control over the process and ensure that operations like signals and process management take effect atomically. </p> <p>There are some drawbacks to using pidfd_open. Since the file descriptor is closed when the process terminates, this can lead to race conditions if the process dies quickly. Additionally, pidfd_open can only be used with processes that the caller has permission to access, and if the caller does not have the necessary permissions, a permission denied error will be returned. </p>"},{"location":"docs/events/builtin/syscalls/pidfd_open/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>pid_t</code> - the process ID of the target process.</li> <li><code>flags</code>:<code>unsigned int</code> - a bitmask of flags that modify the functionality of the system call. </li> </ul>"},{"location":"docs/events/builtin/syscalls/pidfd_open/#available-tags","title":"Available Tags","text":"<ul> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/pidfd_open/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/pidfd_open/#pidfd_open_1","title":"pidfd_open","text":""},{"location":"docs/events/builtin/syscalls/pidfd_open/#type","title":"Type","text":"<p>Kprobe </p>"},{"location":"docs/events/builtin/syscalls/pidfd_open/#purpose","title":"Purpose","text":"<p>To monitor the opening of PID file descriptors and track the information associated with them.</p>"},{"location":"docs/events/builtin/syscalls/pidfd_open/#example-use-case","title":"Example Use Case","text":"<p>This syscall could be used in a multi-process application that needs to track the lifetimes of several processes or send signals to them. By obtaining a file descriptor for each process, the application can monitor their lifetimes and send signals in a safe and atomic manner. </p> <p>In addition, this syscall can also be used in a container context. By opening a PID file descriptor and passing it to the kernel through the pidfd_getfd syscall, the container can ensure that process management and signal delivery are handled in an atomic manner. </p>"},{"location":"docs/events/builtin/syscalls/pidfd_open/#issues","title":"Issues","text":"<p>This syscall is vulnerable to a time-of-check/time-of-use race condition. If the target process terminates quickly, it is possible that the file descriptor will be closed before the calling process can act on it. </p> <p>Additionally, since the caller must have permission to access the target process, this syscall may fail if the proper permissions are not set. </p>"},{"location":"docs/events/builtin/syscalls/pidfd_open/#related-events","title":"Related Events","text":"<ul> <li><code>pidfd_getfd</code> - gets the file descriptor of a process using a PID file descriptor</li> <li><code>pidfd_send_signal</code> - sends a signal to a process using a PID file descriptor</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/pidfd_send_signal/","title":"pidfd_send_signal","text":""},{"location":"docs/events/builtin/syscalls/pidfd_send_signal/#intro","title":"Intro","text":"<p>The event <code>pidfd_send_signal</code> allows to send a signal to a specific process specified by a PID file descriptor, rather than its 'traditional' process ID. </p>"},{"location":"docs/events/builtin/syscalls/pidfd_send_signal/#description","title":"Description","text":"<p>The <code>pidfd_send_signal()</code> syscall invokes <code>SIGSYS</code> on the process specified by the <code>pidfd</code> argument, and optionally with additional information from the <code>info</code>. Unlike the <code>kill()</code> syscall, this syscall can express the relative process hierarchy by passing the PID file descriptor instead of the real PID.</p> <p>The extra flags currently supported are <code>PIDFD_SEND_SIGCONT</code> and <code>PIDFD_SEND_SIGNAL_OWNER</code>, as specified in the <code>flags</code> argument. The former is used to inform the process waiting on a pidfd to continue its execution, while the latter is intended to allow a parent process to prevent other users on the same machine to interfere with the process group of the PID file descriptor.</p> <p>This syscall may be useful when there is a need to perform complex operations on a process or process group from a parent process. It also prevents race conditions which could occur between a child process being created and the parent process being notified of it, since the parent process can simply keep the PID trigger in a file descriptor and perform the action when signalled.</p>"},{"location":"docs/events/builtin/syscalls/pidfd_send_signal/#arguments","title":"Arguments","text":"<ul> <li><code>pidfd</code>:<code>int</code> - the file descriptor of a file with a process ID indicating the specific process the signal will be sent to.</li> <li><code>sig</code>:<code>int</code> - the signal that will be sent to the process.</li> <li><code>info</code>:<code>siginfo_t*</code>[U] - Optional additional data, such as the pid of the process that sent the signal and the real uid, which is used to verify the sender's privileges.</li> <li><code>flags</code>:<code>unsigned int</code> - Set of flags which might change the behaviour of the syscall.</li> </ul>"},{"location":"docs/events/builtin/syscalls/pidfd_send_signal/#available-tags","title":"Available Tags","text":"<ul> <li>U - Originated from user space (for example, pointer to user space memory used to get it).</li> </ul>"},{"location":"docs/events/builtin/syscalls/pidfd_send_signal/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/pidfd_send_signal/#send_signal","title":"send_signal","text":""},{"location":"docs/events/builtin/syscalls/pidfd_send_signal/#type","title":"Type","text":"<p>Kprobes + Uprobes</p>"},{"location":"docs/events/builtin/syscalls/pidfd_send_signal/#purpose","title":"Purpose","text":"<p>To handle the sending of signals.</p>"},{"location":"docs/events/builtin/syscalls/pidfd_send_signal/#example-use-case","title":"Example Use Case","text":"<p>The <code>pidfd_send_signal</code> syscall can be used for process synchronization techniques, where a parent process can wait on a PID file descriptor to be signalled before being notified of the completion of a child process.</p> <p>This idea was inspired in part by <code>ptrace(2)</code>, which can be used to place a trace on a process group in order to observe its execution. However, <code>ptrace</code> also provides a means of signalling and process suspension features which are not necessary or desirable in certain types of applications.</p>"},{"location":"docs/events/builtin/syscalls/pidfd_send_signal/#issues","title":"Issues","text":"<p>The implementation of this syscall currently has a bug which can cause some signals to be lost when sent to processes whose parent process is waiting for them.</p>"},{"location":"docs/events/builtin/syscalls/pidfd_send_signal/#related-events","title":"Related Events","text":"<ul> <li><code>kill()</code> - sends the signal specified by <code>sig</code> to the process specified by <code>pid</code></li> <li><code>getpid()</code> - returns the process ID of the calling process.</li> <li><code>waitpid()</code> - suspends execution of the calling process until a child specified by <code>pid</code> terminates. </li> <li><code>ptrace()</code> - trace processes. It can be used to intercept, observe and manipulate the execution of process and its children.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/pipe/","title":"pipe","text":""},{"location":"docs/events/builtin/syscalls/pipe/#intro","title":"Intro","text":"<p>pipe - creates a pipe, a unidirectional data channel that can be used for interprocess communication</p>"},{"location":"docs/events/builtin/syscalls/pipe/#description","title":"Description","text":"<p>Pipe is a system call that creates a unidirectional data channel for communication between two file descriptors.pipefd is an array of two integers, used to return two file descriptors referring to the ends of the pipe. The first file descriptor is for reading; the second file descriptor is for writing.</p> <p>Pipes are used for communication between two related processes, allowing them to exchange data between them. Pipes have the advantage of allowing data to be passed between the processes without having to be stored in memory. The limitation is that the data sent through a pipe can only be read once.</p> <p>As pipe() is a system call, it is vulnerable to TOCTOU attacks. This is because the file descriptor can be obtained on a pipe call and can be used until the pipe is closed.</p>"},{"location":"docs/events/builtin/syscalls/pipe/#arguments","title":"Arguments","text":"<ul> <li><code>pipefd</code>:<code>int[2]</code>[K] - Used to return two file descriptors referring to the ends of the pipe. The first file descriptor is for reading; the second file descriptor is for writing.</li> </ul>"},{"location":"docs/events/builtin/syscalls/pipe/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/pipe/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/pipe/#sys_pipe","title":"sys_pipe","text":""},{"location":"docs/events/builtin/syscalls/pipe/#type","title":"Type","text":"<p>Static analysis / kprobe</p>"},{"location":"docs/events/builtin/syscalls/pipe/#purpose","title":"Purpose","text":"<p>Hooked to monitor communication between processes, detect suspicious activity and detect TOCTOU vulnerability. </p>"},{"location":"docs/events/builtin/syscalls/pipe/#example-use-case","title":"Example Use Case","text":"<p>Pipe is used when two separate processes need to communicate. However, it can also be used as a debugging tool, by monitoring the data that is being passed through a pipe.</p>"},{"location":"docs/events/builtin/syscalls/pipe/#issues","title":"Issues","text":"<p>The main issue with pipe is that the data can only be read once. This can cause issues when the reading process fails to read all of the data and it is discarded.</p>"},{"location":"docs/events/builtin/syscalls/pipe/#related-events","title":"Related Events","text":"<ul> <li>read</li> <li>write</li> <li>select</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/pipe2/","title":"pipe2","text":""},{"location":"docs/events/builtin/syscalls/pipe2/#intro","title":"Intro","text":"<p>pipe2 - create a pipe and set its flags atomically</p>"},{"location":"docs/events/builtin/syscalls/pipe2/#description","title":"Description","text":"<p>The pipe2() system call works similarly to pipe(), but it adds an extra argument flags, which contains the flags for opening the handle to the newly-created pipe. The flags argument is an OR-ed combination of the following ints: <code>O_CLOEXEC</code>, <code>O_NONBLOCK</code>, <code>O_DIRECT</code>. It is useful when the application is in a situation, where it might need to atomically create  a pipe, while setting some of its flags. </p>"},{"location":"docs/events/builtin/syscalls/pipe2/#arguments","title":"Arguments","text":"<ul> <li><code>pipefd</code>:<code>int[2]</code>[K] - Descriptor vector for the created pipe. The first element in the vector will refer to the read end of the pipe, while the second will refer to the write end. </li> <li><code>flags</code>:<code>int</code>[K] - flags to be used when opening the pipe. An OR-ed combination of <code>O_CLOEXEC</code>, <code>O_NONBLOCK</code>, <code>O_DIRECT</code></li> </ul>"},{"location":"docs/events/builtin/syscalls/pipe2/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/pipe2/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/pipe2/#pipe2_1","title":"pipe2","text":""},{"location":"docs/events/builtin/syscalls/pipe2/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/pipe2/#purpose","title":"Purpose","text":"<p>To trace the system call pipe2 and its arguments</p>"},{"location":"docs/events/builtin/syscalls/pipe2/#example-use-case","title":"Example Use Case","text":"<p>pipe2 can be used in a situation in which a process needs to create a pipe atomically, and set some of its flags. For example, named pipes (FIFOs) which are used for Inter Process Communication (IPC), need to be opened with the <code>O_NONBLOCK</code> flag in order to prevent blocking when there is no process connected to the other side. </p>"},{"location":"docs/events/builtin/syscalls/pipe2/#issues","title":"Issues","text":"<p>Zombie processes can appear if the write end of the pipe is not closed by any process.</p>"},{"location":"docs/events/builtin/syscalls/pipe2/#related-events","title":"Related Events","text":"<ul> <li>open</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/pivot_root/","title":"pivot_root","text":""},{"location":"docs/events/builtin/syscalls/pivot_root/#intro","title":"Intro","text":"<p>pivot_root - change the root file system of the current process</p>"},{"location":"docs/events/builtin/syscalls/pivot_root/#description","title":"Description","text":"<p>The pivot_root() system call makes the directory put_old the new root file system.  It moves the current root file system to the directory new_root.  This comparison is done by making the parent of the old PWD as the new PWD. </p> <p>pivot_root() is typically used in the final stages of a shift of a system into a chroot  environment. The old root directory is placed in put_old and can be used later to switch  back or unmount the old root directory (pivot/unpivot).</p> <p>The both directories must be on the same file system. This can also be used to change to  a different root file system if necessary.</p>"},{"location":"docs/events/builtin/syscalls/pivot_root/#arguments","title":"Arguments","text":"<ul> <li><code>new_root</code>:<code>const char*</code>[K] - a pointer to a pathname of the new  directory  which  will  become  the  root  directory  (the  starting  point  for absolute paths).</li> <li><code>put_old</code>:<code>const char*</code>[K] - a pointer to a pathname of the directory which will be the new parent of the old root directory.</li> </ul>"},{"location":"docs/events/builtin/syscalls/pivot_root/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/pivot_root/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/pivot_root/#sys_pivot_root","title":"sys_pivot_root","text":""},{"location":"docs/events/builtin/syscalls/pivot_root/#type","title":"Type","text":"<p>Kprobe </p>"},{"location":"docs/events/builtin/syscalls/pivot_root/#purpose","title":"Purpose","text":"<p>To audit attempts to pivot_root.</p>"},{"location":"docs/events/builtin/syscalls/pivot_root/#example-use-case","title":"Example Use Case","text":"<p>When a process wants to enter a chroot jail for more security, it can use pivot_root() to change its root file system to the one inside the jail. </p>"},{"location":"docs/events/builtin/syscalls/pivot_root/#issues","title":"Issues","text":"<p>pivot_root() cannot be used across file systems.</p>"},{"location":"docs/events/builtin/syscalls/pivot_root/#related-events","title":"Related Events","text":"<p>chdir, chroot</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/pkey_alloc/","title":"pkey_alloc","text":""},{"location":"docs/events/builtin/syscalls/pkey_alloc/#intro","title":"Intro","text":"<p>pkey_alloc - allocate an protection key</p>"},{"location":"docs/events/builtin/syscalls/pkey_alloc/#description","title":"Description","text":"<p>The pkey_alloc system call is used to allocate a protection key; these are used to give a process access to privileges and other capabilities. The flags argument takes an ORed bitmask of options to control access to the key, such as whether or not it can be used with certain instructions like load_exclusive. The access_rights argument specifies the access rights allowed by the key, such as RWX (read-write-execute).</p>"},{"location":"docs/events/builtin/syscalls/pkey_alloc/#arguments","title":"Arguments","text":"<ul> <li><code>flags</code>:<code>unsigned int</code> - the set of flags controlling access of the key.</li> <li><code>access_rights</code>:<code>unsigned long</code> - the set of access rights allowed by the key.</li> </ul>"},{"location":"docs/events/builtin/syscalls/pkey_alloc/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/pkey_alloc/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/pkey_alloc/#pkey_alloc_1","title":"pkey_alloc","text":""},{"location":"docs/events/builtin/syscalls/pkey_alloc/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/pkey_alloc/#purpose","title":"Purpose","text":"<p>To monitor any syscall invocation of the function.</p>"},{"location":"docs/events/builtin/syscalls/pkey_alloc/#example-use-case","title":"Example Use Case","text":"<p>Using pkey_alloc can be used to control which users have access to privileged instructions.</p>"},{"location":"docs/events/builtin/syscalls/pkey_alloc/#issues","title":"Issues","text":"<p>No known issues.</p>"},{"location":"docs/events/builtin/syscalls/pkey_alloc/#related-events","title":"Related Events","text":"<p>The related system call for this event is pkey_free which is used to deallocate a protection key.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/pkey_free/","title":"pkey_free","text":""},{"location":"docs/events/builtin/syscalls/pkey_free/#intro","title":"Intro","text":"<p>pkey_free - frees an arch-specific key assigned to a memory address</p>"},{"location":"docs/events/builtin/syscalls/pkey_free/#description","title":"Description","text":"<p>pkey_free is a syscall which removes the architecture-specific protection key assigned to a memory address. The memory address associated with the protection key is then available to be accessed without any restrictions, and the protection key is freed from the table managed by the kernel.</p> <p>This syscall is necessary when dealing with memory regions where access needs to be restricted for particular users or tasks. This can be done by assigning an array of protection keys to a memory address. Access to this memory will then be restricted to those users and tasks that have been assigned the protection key.</p>"},{"location":"docs/events/builtin/syscalls/pkey_free/#arguments","title":"Arguments","text":"<ul> <li><code>pkey</code>:<code>int</code>[K] - key to be freed.</li> </ul>"},{"location":"docs/events/builtin/syscalls/pkey_free/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/pkey_free/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/pkey_free/#pkey_free_1","title":"pkey_free","text":""},{"location":"docs/events/builtin/syscalls/pkey_free/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/pkey_free/#purpose","title":"Purpose","text":"<p>To monitor the freeing of protection keys by users or processes, as well as to detect any potential misuse.</p>"},{"location":"docs/events/builtin/syscalls/pkey_free/#example-use-case","title":"Example Use Case","text":"<p>pkey_free can be used to enforce memory protection policies. For example, it can be used to restrict access to certain sensitive memory regions to a select group of users or tasks.</p>"},{"location":"docs/events/builtin/syscalls/pkey_free/#issues","title":"Issues","text":"<p>No known issues.</p>"},{"location":"docs/events/builtin/syscalls/pkey_free/#related-events","title":"Related Events","text":"<ul> <li>pkey_alloc</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/pkey_mprotect/","title":"pkey_mprotect","text":""},{"location":"docs/events/builtin/syscalls/pkey_mprotect/#intro","title":"Intro","text":"<p>pkey_mprotect - change memory protections on a memory region protected by a protection key</p>"},{"location":"docs/events/builtin/syscalls/pkey_mprotect/#description","title":"Description","text":"<p>pkey_mprotect is a Linux system call used to change the memory protection of a memory region so that it is bound to a protection key (pkey). As such, it works similarly to mprotect with the added protection that only if the application has the correct protection key it can access the memory region. This added security can be leveraged to protect copy-on-write functions and static data, allowing only authorized applications to access specific areas of process memory.</p>"},{"location":"docs/events/builtin/syscalls/pkey_mprotect/#arguments","title":"Arguments","text":"<ul> <li><code>addr</code>:<code>void*</code>[U] - Pointer to the start of the memory region.</li> <li><code>len</code>:<code>size_t</code>[U] - Size of the memory region to be changed.</li> <li><code>prot</code>:<code>int</code>[U] - A combination of protection flags as described by the mprotect function.</li> <li><code>pkey</code>:<code>int</code>[U] - The protection key associated with the memory region.</li> </ul>"},{"location":"docs/events/builtin/syscalls/pkey_mprotect/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/pkey_mprotect/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/pkey_mprotect/#sys_pkey_mprotect","title":"sys_pkey_mprotect","text":""},{"location":"docs/events/builtin/syscalls/pkey_mprotect/#type","title":"Type","text":"<p>Kprobe.</p>"},{"location":"docs/events/builtin/syscalls/pkey_mprotect/#purpose","title":"Purpose","text":"<p>Track calls to the <code>pkey_mprotect</code> syscall.</p>"},{"location":"docs/events/builtin/syscalls/pkey_mprotect/#example-use-case","title":"Example Use Case","text":"<p>The most common use for the <code>pkey_mprotect</code> syscall is to protect copy-on-write functions from unauthorized use. A process can set a memory region protected by a specific protection key, thus only calls from processes with the correct key can access that region.</p>"},{"location":"docs/events/builtin/syscalls/pkey_mprotect/#issues","title":"Issues","text":"<p>No documented issues. </p>"},{"location":"docs/events/builtin/syscalls/pkey_mprotect/#related-events","title":"Related Events","text":"<p>The <code>pkey_alloc</code> syscall is used to allocate protection keys. The <code>pkey_free</code> syscall is used to programmatically free protection keys which are no longer in use.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/poll/","title":"poll","text":""},{"location":"docs/events/builtin/syscalls/poll/#intro","title":"Intro","text":"<p>poll() - waits for one of a set of file descriptors to become ready to perform I/O operations.</p>"},{"location":"docs/events/builtin/syscalls/poll/#description","title":"Description","text":"<p>The poll() system call is a method of multiplexing a process across several input-output operations. It allows a process to wait for events or data to become available on one or more files or file-descriptors before continuing execution. </p> <p>Certain edge-cases can cause blocking and other issues. Since the process is attempting to read multiple file descriptors, if one of them is blocked, the entire system call may become blocked as a result. Also since the poll() syscall relies on the kernel to inform of changes in the files, there is potential for TOCTOU (Time Of Check, Time Of Use) attacks.</p>"},{"location":"docs/events/builtin/syscalls/poll/#arguments","title":"Arguments","text":"<ul> <li><code>fds</code>:<code>struct pollfd*</code>[U] - Array of pollfd  data structures.</li> <li><code>nfds</code>:<code>unsigned int</code>[U] - Number of file descriptors contained in fds.</li> <li><code>timeout</code>:<code>int</code>[OPT] - The timeout, in milliseconds. A timeout value of 0 causes poll to return immediately, while a value of -1 means an infinite timeout.</li> </ul>"},{"location":"docs/events/builtin/syscalls/poll/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/poll/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/poll/#syscall_entry_poll","title":"syscall_entry_poll","text":""},{"location":"docs/events/builtin/syscalls/poll/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/poll/#purpose","title":"Purpose","text":"<p>Monitor the entry to the poll syscall in order to capture the arguments passed in.</p>"},{"location":"docs/events/builtin/syscalls/poll/#example-use-case","title":"Example Use Case","text":"<p>In a system which needs to monitor multiple file descriptors for events, poll() can be used instead of continually checking each file descriptor to be ready for I/O operations.</p>"},{"location":"docs/events/builtin/syscalls/poll/#issues","title":"Issues","text":"<p>The biggest issue is that of TOCTOU attacks, since the kernel can itself be exploited to modify the information on the file descriptor before the poll syscall ends.</p>"},{"location":"docs/events/builtin/syscalls/poll/#related-events","title":"Related Events","text":"<p>select(), epoll(), muxed poll()</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/ppoll/","title":"ppoll","text":""},{"location":"docs/events/builtin/syscalls/ppoll/#intro","title":"Intro","text":"<p>ppoll - poll file descriptors with a timeout given with nanosecond precision</p>"},{"location":"docs/events/builtin/syscalls/ppoll/#description","title":"Description","text":"<p>ppoll is a Linux syscall that polls a list of file descriptors provided in a struct pollfd array with the expectation of a response within a given timespec timeout. It also serves to allow certain interrupts or signals to be temporarily ignored while ppoll is running. It is very similar to the poll syscall but with the timespec capability for nanosecond level timeouts.</p> <p>The advantages of using ppoll over poll are that it can provide a much finer grained control when setting a timeout, and can block signals from interrupting it while it runs. The main potential drawback is that since it is a newer syscall, it may not be supported by all distributions.</p>"},{"location":"docs/events/builtin/syscalls/ppoll/#arguments","title":"Arguments","text":"<ul> <li><code>fds</code>:<code>struct pollfd*</code>[K] - Pointer to the array of pollfd structures.</li> <li><code>nfds</code>:<code>unsigned int</code>[K] - Number of pollfd structures in the array.</li> <li><code>tmo_p</code>:<code>struct timespec*</code>[K] - Pointer to an object of type timespec that specifies the maximum amount of time (in nanoseconds) that the call will block waiting for a response.</li> <li><code>sigmask</code>:<code>const sigset_t*</code>[K] - Optional pointer to a signal set that is carefully managed while ppoll is running, to prevent system interrupts (such as signals) from interfering with the response time of the call.</li> <li><code>sigsetsize</code>:<code>size_t</code>[K] - Optional value for size of the sigmask. If a sigmask is passed in, then sigsetsize must provide the size of the sigmask including any padding.</li> </ul>"},{"location":"docs/events/builtin/syscalls/ppoll/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/ppoll/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/ppoll/#do_sys_ppoll","title":"do_sys_ppoll","text":""},{"location":"docs/events/builtin/syscalls/ppoll/#type","title":"Type","text":"<p>TRACE_IRQS_OFF</p>"},{"location":"docs/events/builtin/syscalls/ppoll/#purpose","title":"Purpose","text":"<p>Hooks the functions that handles the <code>ppoll</code> syscall, to allow for monitoring its execution.</p>"},{"location":"docs/events/builtin/syscalls/ppoll/#example-use-case","title":"Example Use Case","text":"<p>A process needs to read multiple files concurrently but not take too long to return a result. ppoll could be used with short timeout values to make sure that the call doesn't wait too long on any single file, while still allowing it to monitor multiple files.</p>"},{"location":"docs/events/builtin/syscalls/ppoll/#issues","title":"Issues","text":"<p>Since ppoll is a relatively new syscall, there may be compatibility issues when running on older versions of Linux that don't support it. Additionally, the fine-grained timeout values may not work on certain systems, especially when those systems use slower hard drives.</p>"},{"location":"docs/events/builtin/syscalls/ppoll/#related-events","title":"Related Events","text":"<p>poll - simpler syscall performing similar action without nanosecond-level timeouts</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/ppoll_time32/","title":"ppoll_time32","text":""},{"location":"docs/events/builtin/syscalls/ppoll_time32/#intro","title":"Intro","text":"<p>The <code>ppoll_time32</code> system call is used to poll the given file descriptor sets with the given timeout value in a Linux-based system.</p>"},{"location":"docs/events/builtin/syscalls/ppoll_time32/#description","title":"Description","text":"<p>The <code>ppoll_time32</code> system call is used to poll for activity on a set of file descriptors specified by an array of <code>struct pollfd</code> structures. The call will wait for a specified timeout period, given in an old Linux <code>struct old_timespec32</code> structure, for activity on any of the descriptors to occur and then return. If the <code>sigmask</code> pointer is non-null, the call will block all signals in the given sigset while polling.</p> <p>The call will return the number of file descriptors selected or zero if the timeout expired. It will return <code>-1</code> and set <code>errno</code> in case of errors.</p>"},{"location":"docs/events/builtin/syscalls/ppoll_time32/#arguments","title":"Arguments","text":"<ul> <li><code>ufds</code>:<code>struct pollfd*</code>[KU] - Pointer to an array of <code>struct pollfd</code> structures containing the file descriptors, a list of events and a list of returned events.</li> <li><code>nfds</code>:<code>unsigned int</code>[K] - The number of items in the array of <code>struct pollfd</code> structures.</li> <li><code>tsp</code>:<code>struct old_timespec32*</code>[K] - Pointer to a <code>struct old_timespec32</code> containing the timeout period.</li> <li><code>sigmask</code>:<code>sigset_t*</code>[K] - Pointer to a <code>sigset_t</code> containing the list of signals to block while polling.</li> <li><code>sigsetsize</code>:<code>size_t</code>[K] - Size of the given sigset.</li> </ul>"},{"location":"docs/events/builtin/syscalls/ppoll_time32/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user-space (for example, pointer to user space memory used to get it).</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use).</li> <li>OPT - Optional argument - might not always be available (passed with null value).</li> </ul>"},{"location":"docs/events/builtin/syscalls/ppoll_time32/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/ppoll_time32/#do_ppoll","title":"do_ppoll","text":""},{"location":"docs/events/builtin/syscalls/ppoll_time32/#type","title":"Type","text":"<p>kretprobe.</p>"},{"location":"docs/events/builtin/syscalls/ppoll_time32/#purpose","title":"Purpose","text":"<p>Hooks the <code>do_ppoll</code> function to trace the <code>ppoll_time32</code> system call. </p>"},{"location":"docs/events/builtin/syscalls/ppoll_time32/#example-use-case","title":"Example Use Case","text":"<p>The <code>ppoll_time32</code> system call can be used in a multi-threaded application to safely query the status of a large number of file descriptors.</p>"},{"location":"docs/events/builtin/syscalls/ppoll_time32/#issues","title":"Issues","text":"<p>The <code>ppoll_time32</code> system call is vulnerable to TOCTOU (time of check, time of use) attacks. This means that an attacker may be able to manipulate the content of the <code>struct pollfd</code> structures between the time they are checked by the <code>ppoll_time32</code> system call and the time they are actually used.</p>"},{"location":"docs/events/builtin/syscalls/ppoll_time32/#related-events","title":"Related Events","text":"<ul> <li><code>poll_time32</code> - Similar system call used for polling file descriptors.</li> <li><code>ppoll</code> - Similar modern system call used for polling file descriptors.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/prctl/","title":"prctl","text":""},{"location":"docs/events/builtin/syscalls/prctl/#intro","title":"Intro","text":"<p>prctl - function that allows to set certain process and resource limits.</p>"},{"location":"docs/events/builtin/syscalls/prctl/#description","title":"Description","text":"<p>The prctl() call is a function provided by the Linux kernel that allows a process to set various limits and control flags on itself, as well as retrieve various information about the process or its current resource limits. Additionally it can be used to remove the capability to send signals to the process.</p> <p>The main purpose of the prctl() call is to give the process more control over its environment. This can be especially useful for process tracing tools, as it allows for more reliable tracking of process resources.</p>"},{"location":"docs/events/builtin/syscalls/prctl/#arguments","title":"Arguments","text":"<ul> <li><code>option</code>:<code>int</code>[K] - the operation to perform. </li> <li><code>arg2</code>:<code>unsigned long</code>[K] - depends on the option argument.</li> <li><code>arg3</code>:<code>unsigned long</code>[K] - depends on the option argument.</li> <li><code>arg4</code>:<code>unsigned long</code>[K] - depends on the option argument.</li> <li><code>arg5</code>:<code>unsigned long</code>[K] - depends on the option argument.</li> </ul>"},{"location":"docs/events/builtin/syscalls/prctl/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/prctl/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/prctl/#sys_prctl","title":"sys_prctl","text":""},{"location":"docs/events/builtin/syscalls/prctl/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/prctl/#purpose","title":"Purpose","text":"<p>To trace the prctl system call.</p>"},{"location":"docs/events/builtin/syscalls/prctl/#example-use-case","title":"Example Use Case","text":"<p>For example, a process can use the prctl() call to add/remove memory limits, limit the number of open files, set the process name, or to alter the process's virtual memory size. </p>"},{"location":"docs/events/builtin/syscalls/prctl/#issues","title":"Issues","text":"<p>Since the procedure is relatively complex and lengthy, it can be slow and unsafe when used to execute a task in critical paths. The calling program can be more prone to TOCTOU (time of check, time of use) attacks.</p>"},{"location":"docs/events/builtin/syscalls/prctl/#related-events","title":"Related Events","text":"<p>sys_exit, set_on_exit, duplicate_process</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/pread64/","title":"pread64","text":""},{"location":"docs/events/builtin/syscalls/pread64/#intro","title":"Intro","text":"<p>pread64 - read up to count bytes from file descriptor fd at offset offset</p>"},{"location":"docs/events/builtin/syscalls/pread64/#description","title":"Description","text":"<p>The pread64() system call reads up to <code>count</code> bytes from file descriptor <code>fd</code> at offset <code>offset</code>. It is identical to <code>read</code> except for the checking for a file descriptor that supports <code>pread</code> and the <code>offset</code> parameter.</p> <p>Unlike <code>read</code> the data is not read from the current file offset; instead, <code>offset</code> byteswithe counted from the start of the file.</p> <p>If some bytes were read before and <code>O_APPEND</code> was not set on the file descriptor, subsequent reads are made from the position which was 'current' at the time pread64() has been called. If the file was open with <code>O_APPEND</code> set, the data will be read from the current end of file.</p> <p>The pread64() system call does not change the file offset and it is not affected by whether or not <code>O_APPEND</code> is set on the file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/pread64/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:int - file descriptor of the file to be read</li> <li><code>buf</code>:void*[K] - a pointer to a buffer in which the data should be stored</li> <li><code>count</code>:size_t - the number of bytes to be read</li> <li><code>offset</code>:off_t - offset from the start of the file</li> </ul>"},{"location":"docs/events/builtin/syscalls/pread64/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space</li> </ul>"},{"location":"docs/events/builtin/syscalls/pread64/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/pread64/#sys_pread64","title":"sys_pread64","text":""},{"location":"docs/events/builtin/syscalls/pread64/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/pread64/#purpose","title":"Purpose","text":"<p>To trace reads from the start of a file.</p>"},{"location":"docs/events/builtin/syscalls/pread64/#example-use-case","title":"Example Use Case","text":"<p>A security audit might need to track activity that reads from the beginning of files. </p>"},{"location":"docs/events/builtin/syscalls/pread64/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/pread64/#related-events","title":"Related Events","text":"<ul> <li>read</li> <li>pread2</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/preadv/","title":"preadv","text":""},{"location":"docs/events/builtin/syscalls/preadv/#intro","title":"Intro","text":"<p>preadv - read data from a file descriptor into multiple vectors.</p>"},{"location":"docs/events/builtin/syscalls/preadv/#description","title":"Description","text":"<p>preadv() allows the user to read data from a file descriptor into multiple vectors. It acts like a combination of the read() and lseek() system calls: it reads data from a given position in a file as specified by the pos_h and pos_l arguments and stores it in the buffers which are provided.</p> <p>The size of the data that is read is determined by the sum of the lengths of all the individual iov buffers. If the sum is greater than SSIZE_MAX, then the value stored in errno is set to EINVAL and -1 is returned. Additionally, preadv() can read less than the amount requested if the data is not present in the file.</p> <p>Preadv() respects file positioning flags such as O_APPEND and O_DIRECT. These flags are taken into consideration when determining the position from which data is read.</p> <p>Preadv() is atomic; when multiple threads/processes simultaneously try to read the same file, they will be guaranteed to read the correct data.</p>"},{"location":"docs/events/builtin/syscalls/preadv/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:int[K] - file descriptor referring to a file which is to be read.</li> <li><code>iov</code>:const struct iovec*[K] - pointer to an array of struct iovec. Each element describes the destination buffer in which data will be stored. </li> <li><code>iovcnt</code>:unsigned long[K] - number of elements in iov array.</li> <li><code>pos_l</code>:unsigned long[K] - least significant 32 bits of file offset from which the data will be read. </li> <li><code>pos_h</code>:unsigned long[K] - most significant 32 bits of file offset from which the data will be read.</li> </ul>"},{"location":"docs/events/builtin/syscalls/preadv/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/preadv/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/preadv/#syscall-preadv","title":"Syscall preadv:","text":""},{"location":"docs/events/builtin/syscalls/preadv/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/preadv/#purpose","title":"Purpose","text":"<p>To monitor calls to preadv and collect data about these calls.</p>"},{"location":"docs/events/builtin/syscalls/preadv/#example-use-case","title":"Example Use Case","text":"<p>For example, preadv can be used to securely read metadata from a file on disk.</p>"},{"location":"docs/events/builtin/syscalls/preadv/#issues","title":"Issues","text":"<p>Since preadv does not provide meaningful feedback when the data is not present in the file, it may be difficult to detect errors in the process of reading data.</p>"},{"location":"docs/events/builtin/syscalls/preadv/#related-events","title":"Related Events","text":"<p>pread,pread64,writev,writev64.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/preadv2/","title":"Preadv2","text":""},{"location":"docs/events/builtin/syscalls/preadv2/#intro","title":"Intro","text":"<p>Preadv2 - read data from a file descriptor into multiple memory areas at a given position.</p>"},{"location":"docs/events/builtin/syscalls/preadv2/#description","title":"Description","text":"<p>Preadv2 reads iovcnt buffers from the file associated with the file descriptor fd into the structures pointed to by iov. The pos_l and pos_h arguments are taken together to form a 64-bit value that specifies the location in the file (offset) from which the data is to be read. By using <code>preadv2</code> the position of the file descriptor is left unchanged. The flags argument is a bit mask composed of the bitwise OR of zero or more of the following commands.</p>"},{"location":"docs/events/builtin/syscalls/preadv2/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>: <code>int</code> - File descriptor for the file to read from.</li> <li><code>iov</code>: <code>const struct iovec*</code> - Pointer to an array of <code>iovec</code>  structures pointing to the buffer where the data should be read into.</li> <li><code>iovcnt</code>: <code>unsigned long</code> - Number of elements in the iov buffer.</li> <li><code>pos_l</code>: <code>unsigned long</code> - Lower 32-bits of the 64-bit offset value.</li> <li><code>pos_h</code>: <code>unsigned long</code> - Higher 32-bits of the 64-bit offset value.</li> <li><code>flags</code>: <code>int</code> - Bitmask of options describing whether <code>preadv2</code> or <code>preadv2</code> should be used.</li> </ul>"},{"location":"docs/events/builtin/syscalls/preadv2/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/preadv2/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/preadv2/#sys_preadv2","title":"sys_preadv2","text":""},{"location":"docs/events/builtin/syscalls/preadv2/#type","title":"Type","text":"<p>kprobe + fentry.</p>"},{"location":"docs/events/builtin/syscalls/preadv2/#purpose","title":"Purpose","text":"<p>To monitor the syscalls related to reading data from the file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/preadv2/#example-use-case","title":"Example Use Case","text":"<p>Preadv2 can be used to read from a large file into multiple smaller buffers. It is useful for copying files, as seek and read don't need to be called for each read. It is also useful for applications that want to read a lot of data from a file in parallel.</p>"},{"location":"docs/events/builtin/syscalls/preadv2/#issues","title":"Issues","text":"<p>The flags argument is not yet supported in glibc.</p>"},{"location":"docs/events/builtin/syscalls/preadv2/#related-events","title":"Related Events","text":"<ul> <li>preadv</li> <li>pwritev2</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/prlimit64/","title":"prlimit64","text":""},{"location":"docs/events/builtin/syscalls/prlimit64/#intro","title":"Intro","text":"<p>prlimit64 - manipulate resource limits of a process</p>"},{"location":"docs/events/builtin/syscalls/prlimit64/#description","title":"Description","text":"<p>The prlimit64() system call is used to both set and get the resource limits of a process. It is similar to the setrlimit and getrlimit functions but it can handle larger numerical values when specifying a resource limit. Resource limits can be set per user, and are a mechanism to prevent processes from using toomuch memory, growing too large, creating too many threads or processes, or creating files that are too large. It is important to note that this system call only changes the limits in the current process and not in any other processes that belong to the same user.</p> <p>There are some edge cases to be aware of. It is possible to set a limit that is lower than the current limit. In this case, the limit will remain the same. It is also possible to set a limit that is lower than the current usage. In this case, the process will be terminated. Finally, it is not possible to set a limit for another user using this system call.</p>"},{"location":"docs/events/builtin/syscalls/prlimit64/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>pid_t</code> - the process ID of the process to change the limit for. If set to 0, it will default to the current process.</li> <li><code>resource</code>:<code>int</code> - the resource whose limit is being set/gotten. Examples are RLIMIT_AS (address space size of the process), RLIMIT_CORE (maximum size of core file that process can create), and RLIMIT_NOFILE (maximum number of open files). </li> <li><code>new_limit</code>:<code>const struct rlimit64*</code> - a pointer to a rlimit64 structure which contains the new limit value to set.</li> <li><code>old_limit</code>:<code>struct rlimit64*</code> - optionally, a pointer to a rlimit64 structure which the current limit will be copied into. </li> </ul>"},{"location":"docs/events/builtin/syscalls/prlimit64/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/prlimit64/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/prlimit64/#sys_prlimit64","title":"sys_prlimit64","text":""},{"location":"docs/events/builtin/syscalls/prlimit64/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/prlimit64/#purpose","title":"Purpose","text":"<p>To track when the resource limits of a process are set and getting</p>"},{"location":"docs/events/builtin/syscalls/prlimit64/#example-use-case","title":"Example Use Case","text":"<p>A process monitoring system could use this event to mark when the resource limits of a process are changed in order to be aware of when a process is requesting more resources </p>"},{"location":"docs/events/builtin/syscalls/prlimit64/#issues","title":"Issues","text":"<p>Since the new and old limit are stored in user-space provided pointers, they are vulnerable to TOCTOU attacks.</p>"},{"location":"docs/events/builtin/syscalls/prlimit64/#related-events","title":"Related Events","text":"<p>sys_setrlimit / getrlimit - the 32-bit versions of the same functions.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/process_madvise/","title":"process_madvise","text":""},{"location":"docs/events/builtin/syscalls/process_madvise/#intro","title":"Intro","text":"<p>process_madvise - system call applied to a specific process that provides information about the process' memory layout to the kernel</p>"},{"location":"docs/events/builtin/syscalls/process_madvise/#description","title":"Description","text":"<p>process_madvise is used to provide information about a process's memory layout to the kernel. This call is necessary for some of the more advanced memory management techniques in the kernel, such as transparent huge pages. It can also be used to advise the kernel on what kind of page replacement algorithm may be suitable for a process' memory (e.g. LRU or random). </p> <p>There are some drawbacks and advantages to using process_madvise. The main advantage is that it gives the kernel more insight into the process\u2019s memory layout, and allows for more effective memory management. The main drawback is that the process must call process_madvise for each region of memory it uses, which can slow down its execution.</p>"},{"location":"docs/events/builtin/syscalls/process_madvise/#arguments","title":"Arguments","text":"<ul> <li><code>pidfd</code>: <code>int</code> - a file descriptor for the process being analyzed.</li> <li><code>addr</code>: <code>void*</code> - address of the page within the process that is being analyzed.</li> <li><code>length</code>: <code>size_t</code> - size of the page that is being analyzed.</li> <li><code>advice</code>: <code>int</code> - advice provided to the kernel about the page.</li> <li><code>flags</code>: <code>unsigned long</code> - flags that control the behavior of the call.</li> </ul>"},{"location":"docs/events/builtin/syscalls/process_madvise/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/process_madvise/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/process_madvise/#do_process_madvise","title":"do_process_madvise","text":""},{"location":"docs/events/builtin/syscalls/process_madvise/#type","title":"Type","text":"<p>Kprobes </p>"},{"location":"docs/events/builtin/syscalls/process_madvise/#purpose","title":"Purpose","text":"<p>To monitor the process_madvise syscall and get information about the process being analyzed.</p>"},{"location":"docs/events/builtin/syscalls/process_madvise/#example-use-case","title":"Example Use Case","text":"<p>The process_madvise system call could be used to provide the kernel with information about a process's memory layout when a process is initialized or when it is about to exit. This information can then be used by the kernel to make decisions about memory management, such as which page replacement algorithm to use or when to use transparent huge pages.</p>"},{"location":"docs/events/builtin/syscalls/process_madvise/#issues","title":"Issues","text":"<p>process_madvise has had some minor security issues in the past, such as the potential for kernel memory disclosure and a TOCTOU (time of check, time of use) vulnerability, but these have been addressed in recent kernel versions.</p>"},{"location":"docs/events/builtin/syscalls/process_madvise/#related-events","title":"Related Events","text":"<p>The process_madvise system call is related to other memory management system calls, such as madvise, mincore, and mprotect. It is also related to other process-specific system calls, such as process_setrlimit or process_prctl.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/process_mrelease/","title":"process_mrelease","text":""},{"location":"docs/events/builtin/syscalls/process_mrelease/#intro","title":"Intro","text":"<p>process_mrelease - allows releasing memory from mlock()/mlock2().</p>"},{"location":"docs/events/builtin/syscalls/process_mrelease/#description","title":"Description","text":"<p>process_mrelease is used to release homogeneous memory locked using mlock() or mlock2(). It accepts two parameters: pidfd of type int, which is the PID of the process whose memory is to be released, and flags of type unsigned int, which is used to set flags to determine the behaviour of the syscall. The advantage of using process_mrelease over mlock()/mlock2() is that it offers more fine-grained control; however, a drawback is that it can only be used on homogeneous memory.</p>"},{"location":"docs/events/builtin/syscalls/process_mrelease/#arguments","title":"Arguments","text":"<ul> <li><code>pidfd</code>:<code>int</code>[K] - A file descriptor referring to the process whose memory is to be released. </li> <li><code>flags</code>:<code>unsigned int</code>[K] - Flags that can be used to alter the behaviour of the syscall. The flags must be provided as a bit mask, which can be ORed together.</li> </ul>"},{"location":"docs/events/builtin/syscalls/process_mrelease/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/process_mrelease/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/process_mrelease/#do_mrelease","title":"do_mrelease","text":""},{"location":"docs/events/builtin/syscalls/process_mrelease/#type","title":"Type","text":"<p>Tracepoint probes</p>"},{"location":"docs/events/builtin/syscalls/process_mrelease/#purpose","title":"Purpose","text":"<p>To monitor and trace a successful process mrelease call.</p>"},{"location":"docs/events/builtin/syscalls/process_mrelease/#sys_process_mrelease","title":"sys_process_mrelease","text":""},{"location":"docs/events/builtin/syscalls/process_mrelease/#type_1","title":"Type","text":"<p>Kprobe probes</p>"},{"location":"docs/events/builtin/syscalls/process_mrelease/#purpose_1","title":"Purpose","text":"<p>To monitor and trace the entry and exit of a process mrelease call.</p>"},{"location":"docs/events/builtin/syscalls/process_mrelease/#example-use-case","title":"Example Use Case","text":"<p>A use case for process_mrelease would be for memory locking applications. An application could monitor memory usage changes, and if a certain threshold is met, it could call process_mrelease to release any memory that was locked using mlock()/mlock2().</p>"},{"location":"docs/events/builtin/syscalls/process_mrelease/#issues","title":"Issues","text":"<p>The only issue with process_mrelease is that it can only be used with homogeneous memory. If the memory locked was not homogeneous, the syscall will not succeed.</p>"},{"location":"docs/events/builtin/syscalls/process_mrelease/#related-events","title":"Related Events","text":"<ul> <li>mlock() </li> <li>munlock()</li> <li>mlock2()</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/process_vm_readv/","title":"process_vm_readv","text":""},{"location":"docs/events/builtin/syscalls/process_vm_readv/#intro","title":"Intro","text":"<p>process_vm_readv - a system call that reads data from the memory of another process</p>"},{"location":"docs/events/builtin/syscalls/process_vm_readv/#description","title":"Description","text":"<p>The <code>process_vm_readv</code> system call is used to read data from the address space of another process. It is analogous to <code>readv</code>, with the only difference being that the source of the data is in the memory of another process. This system call is useful for reading data from other processes, without the need for an inter-process communication mechanism or sharing memory between the two processes.  </p> <p>There are some drawbacks and advantages to using this system call. The main drawback is that it does not guarantee atomicity of the transaction, meaning that the data read from another process may become inconsistent, due to changes made in the other process between the time the data was read and the time the request was made. On the other hand, it allows multiple processes to access and share data without having to go through expensive sharing mechanisms such as semaphores or shared memory.</p>"},{"location":"docs/events/builtin/syscalls/process_vm_readv/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>pid_t</code>[K] - The process ID of the remote process from which data will be read.</li> <li><code>local_iov</code>:<code>const struct iovec*</code>[U] - A pointer to a struct <code>iovec</code> object that describes the local memory where the read data will be stored. </li> <li><code>liovcnt</code>:<code>unsigned long</code>[K] - The number of elements in <code>local_iov</code>.</li> <li><code>remote_iov</code>:<code>const struct iovec*</code>[U] - A pointer to a struct <code>iovec</code> object with similar contents to <code>local_iov</code>, but for the remote process.</li> <li><code>riovcnt</code>:<code>unsigned long</code>[K] - The number of elements in <code>remote_iov</code>.</li> <li><code>flags</code>:<code>unsigned long</code>[K] - A set of flags that defines the behavior of the transaction (e.g. <code>0</code>: no flags, <code>PROCESS_VM_READ</code>: reading from remote address space).</li> </ul>"},{"location":"docs/events/builtin/syscalls/process_vm_readv/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use).</li> <li>OPT - Optional argument - might not always be available (passed with null value).</li> </ul>"},{"location":"docs/events/builtin/syscalls/process_vm_readv/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/process_vm_readv/#do_process_vm_readv","title":"do_process_vm_readv","text":""},{"location":"docs/events/builtin/syscalls/process_vm_readv/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/process_vm_readv/#purpose","title":"Purpose","text":"<p>Hooking this function will allow to detect when a process invokes the <code>process_vm_readv</code> system call.</p>"},{"location":"docs/events/builtin/syscalls/process_vm_readv/#example-use-case","title":"Example Use Case","text":"<p>This system call can be used for implementing a safe inter-process communication method. The two processes can use <code>process_vm_readv</code> to exchange data without having to resort to expensive synchronization mechanisms such as semaphores or shared memory. </p>"},{"location":"docs/events/builtin/syscalls/process_vm_readv/#issues","title":"Issues","text":"<p>This system call does not guarantee atomicity, which can lead to reading inconsistent data.</p>"},{"location":"docs/events/builtin/syscalls/process_vm_readv/#related-events","title":"Related Events","text":"<ul> <li><code>process_vm_writev</code> - Writes data to the address space of another process.</li> <li><code>readv</code> - Reads data from a file into the user space.</li> <li><code>writev</code> - Writes data to a file.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/process_vm_writev/","title":"process_vm_writev","text":""},{"location":"docs/events/builtin/syscalls/process_vm_writev/#intro","title":"Intro","text":"<p>process_vm_writev - transfer data between address spaces of different processes</p>"},{"location":"docs/events/builtin/syscalls/process_vm_writev/#description","title":"Description","text":"<p>process_vm_writev() is a system call that allows for transfer of data between the address spaces of two different processes, the caller, and the target. The two processes are referred to as the \"local\" and the \"remote\" process. It does this by writing the contents of one or more iovec data structure entries from the local process to the same entries in a buffer belonging to the remote process. This transfer may either be a completely new set of data, or an update to previously written data. The general approach to using this system call is to use either the <code>vm_writev()</code> or the <code>process_vm_writev()</code>set the iovec data structures of the local process. Then, the contents of those iovec entries can be transfered to the target process by issuing the <code>process_vm_writev()</code> syscall, passing in its parameters the intended target process and the structures containing the data to be written.</p> <p>Are there any edge-cases, drawbacks or advantages of using it?</p> <p>A potential disadvantage is that the local process must have a full copy of the data ready to be written, which may involve a significant amount of time and effort for large amounts of data. Additionally, the remote process may not always have the relevant data to be updated or the memory protection for the target buffer may restrict a successful write.</p>"},{"location":"docs/events/builtin/syscalls/process_vm_writev/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>: <code>pid_t</code>[K] - pid of the target process</li> <li><code>local_iov</code>: <code>const struct iovec*</code>[K] - pointer to the iovec structure for the host process</li> <li><code>liovcnt</code>: <code>unsigned long</code>[K] - number of elements from the local iovec structure to be written</li> <li><code>remote_iov</code>: <code>const struct iovec*</code>[K] - pointer to the iovec structure for the target process</li> <li><code>riovcnt</code>: <code>unsigned long</code>[K] - number of elements from the remote iovec structure to be written</li> <li><code>flags</code>: <code>unsigned long</code>[K] - additional flags to be passed to the syscall</li> </ul>"},{"location":"docs/events/builtin/syscalls/process_vm_writev/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/process_vm_writev/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/process_vm_writev/#process_vm_writev_1","title":"process_vm_writev","text":""},{"location":"docs/events/builtin/syscalls/process_vm_writev/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/process_vm_writev/#purpose","title":"Purpose","text":"<p>To record information about data written from the local process to the target process.</p>"},{"location":"docs/events/builtin/syscalls/process_vm_writev/#example-use-case","title":"Example Use Case","text":"<p>One example use case for this system call is when a search engine needs to quickly update thousands of webpages across many different machines simultaneously. Rather than updating each page one at a time, the process_vm_writev syscall can be used to transfer the same data set to multiple machines, significantly reducing the time needed to update all the pages.</p>"},{"location":"docs/events/builtin/syscalls/process_vm_writev/#issues","title":"Issues","text":"<p>No major issues have been found with this system call.</p>"},{"location":"docs/events/builtin/syscalls/process_vm_writev/#related-events","title":"Related Events","text":"<ul> <li><code>readv</code>: The readv system call is similar to process_vm_writev in that it allows for data transfer between two process, however readv only allows for reading data from the remote process.</li> <li><code>mmap</code>: During a successful <code>process_vm_writev</code> call, the contents of the data structures from the remote process can be mapped into the address space of the local process. This allows for more efficient data transfer between the two processes.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/prof/","title":"prof","text":""},{"location":"docs/events/builtin/syscalls/prof/#intro","title":"Intro","text":"<p>prof - Event triggered when profiler events are enabled or disabled.</p>"},{"location":"docs/events/builtin/syscalls/prof/#description","title":"Description","text":"<p>The <code>prof</code> event is triggered when profiler events are enabled or disabled. It is used to enable and disable per-process event profiling, which is used to measure the performance and execution of a given process. The <code>prof</code> event allows for fine-grained control over the events that are monitored, allowing for granular tracking of process behavior. </p> <p>The <code>prof</code> event has several drawbacks and edge-cases. Since it is specific to the process being monitored, it can be potentially slow to set up and can have unexpected side-effects on the process performance when enabled. Additionally, since the event is being monitored at the process level, it may be dependent on the type of process being monitored. </p>"},{"location":"docs/events/builtin/syscalls/prof/#arguments","title":"Arguments","text":"<ul> <li><code>FLAGS</code>: <code>unsigned long</code>[K] - Flags to configure the event profiling.</li> <li><code>EVENTS</code>: <code>unsigned int</code>[K] - Array of events to monitor while profiling.</li> </ul>"},{"location":"docs/events/builtin/syscalls/prof/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/prof/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/prof/#sched_process_exec","title":"sched_process_exec","text":""},{"location":"docs/events/builtin/syscalls/prof/#type","title":"Type","text":"<p>kprobe + kretprobe</p>"},{"location":"docs/events/builtin/syscalls/prof/#purpose","title":"Purpose","text":"<p>Hook the <code>sched_process_exec</code> function to enable and disable the profiler events when the process executes.</p>"},{"location":"docs/events/builtin/syscalls/prof/#do_exit","title":"do_exit","text":""},{"location":"docs/events/builtin/syscalls/prof/#type_1","title":"Type","text":"<p>kprobe + kretprobe</p>"},{"location":"docs/events/builtin/syscalls/prof/#purpose_1","title":"Purpose","text":"<p>Hook the <code>do_exit</code> function to shutdown the profiler before exiting the process.</p>"},{"location":"docs/events/builtin/syscalls/prof/#example-use-case","title":"Example Use Case","text":"<p>The <code>prof</code> event can be used to measure the performance or track the execution of specific processes on the system. It's commonly used in embedded and real-time applications where precise performance measurements are necessary. </p>"},{"location":"docs/events/builtin/syscalls/prof/#issues","title":"Issues","text":"<p>The <code>prof</code> event is highly process-dependent and can lead to unexpected performance issues or decreased efficiency when enabled. Additionally, because it requires a precise setup across the entire stack, it can be slow to configure and start. </p>"},{"location":"docs/events/builtin/syscalls/prof/#related-events","title":"Related Events","text":"<p>The <code>prof</code> event is related to the <code>perf</code> event, which is used to observation of hardware performance counters.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/profil/","title":"profil","text":""},{"location":"docs/events/builtin/syscalls/profil/#intro","title":"Intro","text":"<p>profil - write execution times of processes/threads to a buffer</p>"},{"location":"docs/events/builtin/syscalls/profil/#description","title":"Description","text":"<p>The profil system call is used to write the execution times of a programs or threads to a user-specified buffer. It can be used to identify code paths which are heavily used or those that are less efficient. It has been largely replaced by existing performance analysis tools like perf and flame graphs.</p> <p>Edge-cases should be taken into account when using the profil system call. The user-specified buffer will eventually fill up and depending on what kernel version is running, this can cause program terminating signals as the end of the buffer is hit. It is therefore important to make sure that the buffer used is large enough to avoid this case.</p>"},{"location":"docs/events/builtin/syscalls/profil/#arguments","title":"Arguments","text":"<ul> <li><code>buf</code>:pointer[U] - the address of the buffer in the user memory.</li> <li><code>buflen</code>:unsigned int[U] - the size of the buffer in bytes.</li> <li><code>offset</code>:unsigned int[U] - the offset from the beginning of the buffer to start writing from. This should be no bigger than <code>buflen</code>.</li> <li><code>scale</code>:unsigned int[U] - the size of the scale to store the information. A scale of five, for example, would store the value in five-microsecond intervals.</li> <li><code>pc</code>:unsigned long[K] - the base address of the program counter used by the kernel for the profiling.</li> </ul>"},{"location":"docs/events/builtin/syscalls/profil/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/profil/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/profil/#sys_profil","title":"sys_profil","text":""},{"location":"docs/events/builtin/syscalls/profil/#type","title":"Type","text":"<p>Kprobe+kretprobe</p>"},{"location":"docs/events/builtin/syscalls/profil/#purpose","title":"Purpose","text":"<p>Assessing the performance of a user-space program or thread.</p>"},{"location":"docs/events/builtin/syscalls/profil/#example-use-case","title":"Example Use Case","text":"<p>Profiling and examining the performance of a given application or thread. </p>"},{"location":"docs/events/builtin/syscalls/profil/#issues","title":"Issues","text":"<p>The <code>buflen</code> and <code>offset</code> parameters are user-specified and there is no limit checking on the kernel side, so care must be taken when using them, and the size of the buffer should be sutable large enough to avoid running out of space during use.</p>"},{"location":"docs/events/builtin/syscalls/profil/#related-events","title":"Related Events","text":"<ul> <li>fork </li> <li>execve </li> <li>setitimer</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/pselect6/","title":"pselect6","text":""},{"location":"docs/events/builtin/syscalls/pselect6/#intro","title":"Intro","text":"<p>pselect6 - the Linux system call that syntactically combines select() and pselect() system calls.</p>"},{"location":"docs/events/builtin/syscalls/pselect6/#description","title":"Description","text":"<p>pselect6 is the Linux system call that syntactically combines select() and pselect() system calls. This system call can be used to select or monitor many files or sockets for readability, writability, prior-to-termination conditions etc. It can also optionally monitor a set of signal numbers for presence in the caller's signal mask without temporarily replacing the signal mask.</p> <p>The pselect6 system call takes 6 parameters. The first parameter is an integer, which specifies the maximum of the number of file descriptors in any of the three sets (readfds, writefds, exceptfds). The second, third and fourth parameters are pointers to sets of file descriptors (readfds, writefds, exceptfds). The fifth argument is a pointer to a timeval structure which specifies the absolute or relative timeout time. The sixth argument is a pointer to a signal set, or a null pointer, which specify the set of signals to be monitored for any pending signal during the monitor time.</p> <p>Once pselect6 is called, it will monitor all the file descriptors which are in the three sets until a file descriptor becomes \u2018ready\u2019 or a timeout occurs or a signal becomes \u2018pending.\u2019 When one of these events happens, the pselect6 returns to the caller with the ready filed descriptors and updated signal masks.</p>"},{"location":"docs/events/builtin/syscalls/pselect6/#arguments","title":"Arguments","text":"<ul> <li><code>nfds</code>:<code>int</code>[K] - an integer specifying the maximum number of file descriptors in the set of files to monitor.</li> <li><code>readfds</code>:<code>fd_set*</code>[K] - The file descriptor set to monitor for readability.</li> <li><code>writefds</code>:<code>fd_set*</code>[K] - The file descriptor set to monitor for writability.</li> <li><code>exceptfds</code>:<code>fd_set*</code>[K] - The file descriptor set to monitor for exceptional conditions.</li> <li><code>timeout</code>:<code>struct timespec*</code>[U] - Pointer to a time structure which specifies the absolute or relative timeout time.</li> <li><code>sigmask</code>:<code>void*</code>[K] - Pointer to a signal set or NULL. If not NULL, specifies the set of signals to be monitored for any pending signal during the monitor wait. If a signal is pending, pselect6 will return with an EINTR error code and will fill the sigmask parameter with the set of pending signals.</li> </ul>"},{"location":"docs/events/builtin/syscalls/pselect6/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value).</li> </ul>"},{"location":"docs/events/builtin/syscalls/pselect6/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/pselect6/#do_syscall_64","title":"do_syscall_64","text":""},{"location":"docs/events/builtin/syscalls/pselect6/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/pselect6/#purpose","title":"Purpose","text":"<p>To monitor for calls to the system call related to pselect6.</p>"},{"location":"docs/events/builtin/syscalls/pselect6/#example-use-case","title":"Example Use Case","text":"<p>pselect6() system call can be used to monitor multiple sockets for readability, writeability, exceptions, or other conditions simultaneously. For example, a web server could use pselect6 to wait for incoming connections on a set of sockets, and have one single process to handle all of the sockets.</p>"},{"location":"docs/events/builtin/syscalls/pselect6/#issues","title":"Issues","text":"<p>The pselect6 system call is vulnerable to time of check/ time of use (TOCTOU) race condition because the process might have blocked on the selector before the I/O that it is waiting for will complete.</p>"},{"location":"docs/events/builtin/syscalls/pselect6/#related-events","title":"Related Events","text":"<ul> <li>select</li> <li>sigprocmask</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/pselect6_time32/","title":"pselect6_time32","text":""},{"location":"docs/events/builtin/syscalls/pselect6_time32/#intro","title":"Intro","text":"<p>pselect6_time32 - select a subset of file descriptors based on given time frame</p>"},{"location":"docs/events/builtin/syscalls/pselect6_time32/#description","title":"Description","text":"<p>This event is a Linux version of <code>select</code> system call. It allows user to select subset of file descriptors, or sockets, withing a given time frame. The time frame is defined by the last argument, a timeout structure.</p> <p>The <code>pselect6_time32</code> system call is used to wait for a given set of file descriptors to become ready to perform read, write orupdate operations, or to get a notification when one of the specified set of signals arrives within given time frame.</p>"},{"location":"docs/events/builtin/syscalls/pselect6_time32/#arguments","title":"Arguments","text":"<ul> <li><code>n</code>:<code>int</code> - maximum number of file descriptors to select from.</li> <li><code>inp</code>:<code>fd_set*</code> - pointer to set of file descriptors that are being tested for readiness.</li> <li><code>outp</code>:<code>fd_set*</code> - pointer to a set of file descriptors that are set if they become ready.</li> <li><code>exp</code>:<code>fd_set*</code> - pointer to a set of file descriptors that will be set if an error occurs.</li> <li><code>tsp</code>:<code>struct old_timespec32*</code>[KU] - pointer to a timeout structure.</li> <li><code>sig</code>:<code>void*</code>[K] - pointer to set of signals to be watched.</li> </ul>"},{"location":"docs/events/builtin/syscalls/pselect6_time32/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/pselect6_time32/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/pselect6_time32/#do_select_vec","title":"do_select_vec","text":""},{"location":"docs/events/builtin/syscalls/pselect6_time32/#type","title":"Type","text":"<p>Probes </p>"},{"location":"docs/events/builtin/syscalls/pselect6_time32/#purpose","title":"Purpose","text":"<p>Log the arguments given to pselect6_time32 for troubleshooting.</p>"},{"location":"docs/events/builtin/syscalls/pselect6_time32/#compat_sys_pselect6_time32","title":"compat_sys_pselect6_time32","text":""},{"location":"docs/events/builtin/syscalls/pselect6_time32/#type_1","title":"Type","text":"<p>In-kernel hooking </p>"},{"location":"docs/events/builtin/syscalls/pselect6_time32/#purpose_1","title":"Purpose","text":"<p>To hook calls to the pselect6_time32 system call in kernel and log the arguments for further analysis.</p>"},{"location":"docs/events/builtin/syscalls/pselect6_time32/#example-use-case","title":"Example Use Case","text":"<p>Let's say we have a whole set of file descriptors that have to be open in order to execute our program. However, the conditions under which they can be opened are limited, and we would like to know if all the file descriptors are ready to use within the given time frame. To do this, we can use <code>pselect6_time32</code> to wait for all the file descriptors to be ready, and provides us a subset of the file descriptors that are actually ready. On failure, the <code>exp</code> set contains file descriptors that couldn't be ready within the timeout.</p>"},{"location":"docs/events/builtin/syscalls/pselect6_time32/#issues","title":"Issues","text":"<p>The last argument, <code>sig</code>, is designed to work as a synchronous equivalent of <code>sigevent</code>, which can be used to execute asynchronous operations on signals. As of version 5.4 of the Linux kernel, this argument is not implemented and have to be passed as null or ignored.</p>"},{"location":"docs/events/builtin/syscalls/pselect6_time32/#related-events","title":"Related Events","text":"<ul> <li><code>select</code> - related event with wider compatiblity, but no support for timeout.</li> <li><code>pselect6</code> - similar to <code>pselect6_time32</code> except the timeout structure takes <code>old_timespec</code> instead of <code>old_timespec32</code> format.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/ptrace/","title":"ptrace","text":""},{"location":"docs/events/builtin/syscalls/ptrace/#intro","title":"Intro","text":"<p>ptrace - A system call that allows inspection and manipulation of another process.</p>"},{"location":"docs/events/builtin/syscalls/ptrace/#description","title":"Description","text":"<p>The <code>ptrace</code> system call allows monitoring of and control of other processes. It is possible to read and modify the registers and memory of another running process, let the process execute a single instruction, or attach and detach other process to a tracer. Its use is found in debuggers, analytics and tracing tools, system call interception and emulation, and binary instrumentation.</p> <p>By itself not a dangerous system call, but its functionality can be misused in certain scenarios, such as manipulating other processes running in the same system.</p>"},{"location":"docs/events/builtin/syscalls/ptrace/#arguments","title":"Arguments","text":"<ul> <li><code>request</code>:<code>long</code> - Request type, see below for options</li> <li><code>pid</code>:<code>pid_t</code> - PID of the process to operate on</li> <li><code>addr</code>:<code>void*</code>[U] - Address in the user space of the process to begin or end operations</li> <li><code>data</code>:<code>void*</code>[U,TOCTOU] - Extra data to be passed to the request, if necessary.</li> </ul>"},{"location":"docs/events/builtin/syscalls/ptrace/#available-tags","title":"Available Tags","text":"<ul> <li>U - Originated from user space (for example, pointer to user space memory)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> </ul>"},{"location":"docs/events/builtin/syscalls/ptrace/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/ptrace/#do_syscall_64","title":"do_syscall_64","text":""},{"location":"docs/events/builtin/syscalls/ptrace/#type","title":"Type","text":"<p>System call trampoline</p>"},{"location":"docs/events/builtin/syscalls/ptrace/#purpose","title":"Purpose","text":"<p>Provides the system call entry point</p>"},{"location":"docs/events/builtin/syscalls/ptrace/#sys_ptrace","title":"sys_ptrace","text":""},{"location":"docs/events/builtin/syscalls/ptrace/#type_1","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/ptrace/#purpose_1","title":"Purpose","text":"<p>To provide an entry point for kernel tracing</p>"},{"location":"docs/events/builtin/syscalls/ptrace/#example-use-case","title":"Example Use Case","text":"<p>A debugging tool that allows the user to monitor and control another running process in the same system.</p>"},{"location":"docs/events/builtin/syscalls/ptrace/#issues","title":"Issues","text":"<p>In certain setups, <code>ptrace</code> can be used to manipulate another process' running state, making it potentially dangerous.</p>"},{"location":"docs/events/builtin/syscalls/ptrace/#related-events","title":"Related Events","text":"<p>Syscall <code>clone</code>, for forking and tracing a child process.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/putpmsg/","title":"putpmsg","text":""},{"location":"docs/events/builtin/syscalls/putpmsg/#intro","title":"Intro","text":"<p>putpmsg - send a message on a STREAMS pipe.</p>"},{"location":"docs/events/builtin/syscalls/putpmsg/#description","title":"Description","text":"<p>The putpmsg() system call is used to write a message on a STREAMS pipe. It enables a process to place zero to two messages on the pipe in an atomic manner, the combination of two messages making a single queued message.</p>"},{"location":"docs/events/builtin/syscalls/putpmsg/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code> - the file descriptor associated with a STREAMS pipe.</li> <li><code>ctlptr</code>:<code>struct strbuf</code>[K] - The argument points to a strbuf structure which is used to point to the control part of a message.  If a control part is not desired then a null pointer may be used.</li> <li><code>dataptr</code>:<code>struct strbuf</code>[K] - The argument points to a strbuf structure which is used to point to the data part of a message, or may be a null pointer if no message data is requested.</li> <li> <p><code>flag</code>:<code>int</code> - The flag argument can take one of the values 0, MSG_BAND, MSG_HIPRI or MSG_ANY as defined below:</p> <ul> <li>MSG_BAND \u2014 if the pipe grants priority bands, the specified priority band is requested.</li> <li>MSG_HIPRI \u2014 the highest priority band is requested.</li> <li>MSG_ANY \u2014 any priority band is acceptable.</li> </ul> </li> </ul>"},{"location":"docs/events/builtin/syscalls/putpmsg/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/putpmsg/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/putpmsg/#do_putpmsg","title":"do_putpmsg","text":""},{"location":"docs/events/builtin/syscalls/putpmsg/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/putpmsg/#purpose","title":"Purpose","text":"<p>To trace calls to putpmsg() system call.</p>"},{"location":"docs/events/builtin/syscalls/putpmsg/#example-use-case","title":"Example Use Case","text":"<p>One use case for putpmsg() is executing daemon services. By hooking the putpmsg() kprobe, one can check if and in what order daemon services are receiving messages each time. </p>"},{"location":"docs/events/builtin/syscalls/putpmsg/#issues","title":"Issues","text":"<p>As putpmsg() is specific to a STREAMS pipe, it will only be useful for applications that use it.</p>"},{"location":"docs/events/builtin/syscalls/putpmsg/#related-events","title":"Related Events","text":"<ul> <li>link()</li> <li>open()</li> <li>read()</li> <li>write()</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/pwrite64/","title":"pwrite64","text":""},{"location":"docs/events/builtin/syscalls/pwrite64/#intro","title":"Intro","text":"<p>pwrite64 - A system call that writes data from a buffer described by <code>buf</code> of a given size <code>count</code> to a given file descriptor <code>fd</code> at a certain offset <code>offset</code> in the open file.</p>"},{"location":"docs/events/builtin/syscalls/pwrite64/#description","title":"Description","text":"<p>The <code>pwrite64</code> system call, like the <code>write</code> system call, writes data from a buffer described by <code>buf</code> of a given size <code>count</code> to a specified file descriptor <code>fd</code>. The <code>pwrite64</code> system call differs from the <code>write</code> system call in that it writes a specified number of bytes to an open file descriptor at an offset instead of the current position. This offset can be specified with <code>offset</code>, a parameter of type <code>off_t</code>, which is a signed integer integer type frequently used to specify an offset or distance.This behavior is useful if, for example, an application needs to write data to a file at specific locations.</p> <p>The <code>pwrite64</code> system call is not vulnerable to Time-of-Check Time-of-Use (TOCTOU) because the parameters are evaluated before any action is taken.</p>"},{"location":"docs/events/builtin/syscalls/pwrite64/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - The file descriptor.</li> <li><code>buf</code>:<code>const void*</code>[KU] - Pointer to the buffer containing data for write operation. </li> <li><code>count</code>:<code>size_t</code>[K] - Quantity of data, in bytes, to be written to the file descriptor.</li> <li><code>offset</code>:<code>off_t</code>[K] - Specifies the position in the file where the data issued from <code>buf</code> should be written. </li> </ul>"},{"location":"docs/events/builtin/syscalls/pwrite64/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/pwrite64/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/pwrite64/#sys_pwrite64","title":"sys_pwrite64","text":""},{"location":"docs/events/builtin/syscalls/pwrite64/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/pwrite64/#purpose","title":"Purpose","text":"<p>Used to keep track of all calls to <code>pwrite64</code> system call.</p>"},{"location":"docs/events/builtin/syscalls/pwrite64/#do_syscall_64","title":"do_syscall_64","text":""},{"location":"docs/events/builtin/syscalls/pwrite64/#type_1","title":"Type","text":"<p>Kprobe </p>"},{"location":"docs/events/builtin/syscalls/pwrite64/#purpose_1","title":"Purpose","text":"<p>Used to observe the start of all the execution of group 2 system calls.</p>"},{"location":"docs/events/builtin/syscalls/pwrite64/#example-use-case","title":"Example Use Case","text":"<p>The <code>pwrite64</code> system call can be used by programs that need to modify an existing file in a very precise way. A good example would be a text editor that uses pwrite64 to modify the file at a particular byte offset, ensuring that it keeps the original file structure intact.</p>"},{"location":"docs/events/builtin/syscalls/pwrite64/#issues","title":"Issues","text":"<p>Due to its parameters, the <code>pwrite64</code> system call can be rather slow when dealing with large files since its read/write operations occur at an offset specified in the parameter <code>offset</code>; hence, it performs one operation at a time (as opposed to <code>write</code> system call).</p>"},{"location":"docs/events/builtin/syscalls/pwrite64/#related-events","title":"Related Events","text":"<ul> <li><code>write</code></li> <li><code>pwritev64</code></li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/pwritev/","title":"pwritev","text":""},{"location":"docs/events/builtin/syscalls/pwritev/#intro","title":"Intro","text":"<p>pwritev - write data from multiple buffers to a file descriptor at a given offset.</p>"},{"location":"docs/events/builtin/syscalls/pwritev/#description","title":"Description","text":"<p>The <code>pwritev</code> system call is used to write data from multiple buffers to a file descriptor at a given offset. It is similar to <code>readv</code> in the way that it can write data from multiple non-contiguous memory blocks, however, the data is written to a specific location instead of just to a file descriptor. This can be useful for writing data at a specific location, regardless of the current file offset.</p> <p>The <code>pwritev</code> system call is useful when writing data to a specific location in a file, but due to its reliance on a single file descriptor (FD) it can be vulnerable to race conditions when writing to multiple files, since the FD value might change between different calls.</p>"},{"location":"docs/events/builtin/syscalls/pwritev/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>: <code>int</code> - a valid file descriptor, for a file previously opened for writing.</li> <li><code>iov</code>: <code>const struct iovec*</code> - a pointer to a struct iovec* array of read buffers. The size of the array is specified in iovcnt.</li> <li><code>iovcnt</code>: <code>unsigned long</code> - the size of the read buffer array passed in iov.</li> <li><code>pos_l</code>: <code>unsigned long</code> - the low bits of the position in the file to start writing to.</li> <li><code>pos_h</code>: <code>unsigned long</code> - the high bits of the position in the file to start writing to.</li> </ul>"},{"location":"docs/events/builtin/syscalls/pwritev/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/pwritev/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/pwritev/#sys_pwritev","title":"sys_pwritev","text":""},{"location":"docs/events/builtin/syscalls/pwritev/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/pwritev/#purpose","title":"Purpose","text":"<p>To instrument the pwritev syscall in order to get more insight into data being written.</p>"},{"location":"docs/events/builtin/syscalls/pwritev/#example-use-case","title":"Example Use Case","text":"<p>In a system where data needs to be written from buffers scattered throughout a wide memory range, <code>pwritev</code> can be used to write data directly to a specific file offset. This can eliminate the need to read the entire file in order to write data at a certain location.</p>"},{"location":"docs/events/builtin/syscalls/pwritev/#issues","title":"Issues","text":"<p><code>pwritev</code> is vulnerable to race conditions when the same file descriptor is used to write data to multiple files. If the FD value changes between multiple calls, data can be written in the wrong file.</p>"},{"location":"docs/events/builtin/syscalls/pwritev/#related-events","title":"Related Events","text":"<ul> <li>preadv</li> <li>readv</li> <li>writev</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/pwritev2/","title":"pwritev2","text":""},{"location":"docs/events/builtin/syscalls/pwritev2/#intro","title":"Intro","text":"<p>pwritev2 - attempts to write data to a file descriptor at a given position</p>"},{"location":"docs/events/builtin/syscalls/pwritev2/#description","title":"Description","text":"<p>pwritev2() is used to write data to a file descriptor at a given position. The data is written to the file descriptor in the form of an array of iovec structures, which allow for the writing of multiple buffers in a single call. </p> <p>pwritev2() differs from the pwritev() system call in that it has optional <code>flags</code> argument which controls the behavior of the syscall in more detail. The flag <code>PWRITEV_UPDATE_POSITION</code> causes the file pointer to be adjusted to reflect the amount of data written to the file descriptor.</p> <p>pwritev2() is useful for maximizing the performance of writing large amounts of data to a file descriptor, as it can allow for the writing of multiple buffers in a single call.</p>"},{"location":"docs/events/builtin/syscalls/pwritev2/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code> - file descriptor of the opened file.</li> <li><code>iov</code>:<code>const struct iovec*</code> - pointer to an array of iovec structures that specify the source buffers from which data is written to the file descriptor.</li> <li><code>iovcnt</code>:<code>unsigned long</code> - the number of elements in the iovec array.</li> <li><code>pos_l</code>:<code>unsigned long</code> - lower 32 bits of 64-bit position data.</li> <li><code>pos_h</code>:<code>unsigned long</code> - higher 32 bits of 64-bit position data.</li> <li><code>flags</code>:<code>int</code>[OPT] - optional flags which control the behavior of the call.</li> </ul>"},{"location":"docs/events/builtin/syscalls/pwritev2/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/pwritev2/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/pwritev2/#sys_pwritev2","title":"sys_pwritev2","text":""},{"location":"docs/events/builtin/syscalls/pwritev2/#type","title":"Type","text":"<p>KPROBE</p>"},{"location":"docs/events/builtin/syscalls/pwritev2/#purpose","title":"Purpose","text":"<p>To capture the data passed to the pwritev2() syscall.</p>"},{"location":"docs/events/builtin/syscalls/pwritev2/#example-use-case","title":"Example Use Case","text":"<p>pwritev2() can be used to write data to a file descriptor at a specific position in an optimized way. For example, it could be used in an application that needs to write large amounts of data to a file in an efficient way.</p>"},{"location":"docs/events/builtin/syscalls/pwritev2/#issues","title":"Issues","text":"<p>Due to the fact that pwritev2() writes data from multiple buffers, it can be vulnerable to race conditions. It is important to be aware of the possibility of race conditions when using the pwritev2() system call.</p>"},{"location":"docs/events/builtin/syscalls/pwritev2/#related-events","title":"Related Events","text":"<p>pwritev() - similar system call but with fewer optional flags parameter. preadv2(), writev(), preadv(), writev2() - other system calls related to writing data to or from file descriptors.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/query_module/","title":"query_module","text":""},{"location":"docs/events/builtin/syscalls/query_module/#intro","title":"Intro","text":"<p>query_module - query the kernel for information about a loaded Linux Kernel Module</p>"},{"location":"docs/events/builtin/syscalls/query_module/#description","title":"Description","text":"<p>The query_module system call provides information about loaded Kernel Modules and information about those modules. It can be used to query for the module's size, symbol table, and other related information. The call is typically used by kernel debuggers and kernel developers, as well as system administrators who need to check the module's state. </p>"},{"location":"docs/events/builtin/syscalls/query_module/#arguments","title":"Arguments","text":"<ul> <li><code>name</code>:<code>char*</code>[K] - name of the module to query.</li> <li><code>which</code>:<code>int</code>[K] - Parameter specifying the module information to return.</li> <li><code>buf</code>:<code>void*</code>[K, U] - data buffer to store the queried information in.</li> <li><code>bufsize</code>:<code>size_t</code>[K] - size of the data buffer.</li> <li><code>ret_size</code>:<code>size_t*</code>[K, U] - pointer to size_t store the size of the returned information.</li> </ul>"},{"location":"docs/events/builtin/syscalls/query_module/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/query_module/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/query_module/#query_module_1","title":"query_module","text":""},{"location":"docs/events/builtin/syscalls/query_module/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/query_module/#purpose","title":"Purpose","text":"<p>This system call is often used by kernel debuggers and developers for obtaining information about Linux modules. As this call is highly involved in kernel development and debugging, it is important to be aware of when and how it is being used. Kprobes can be used to intercept the call in order to observe its parameters and behaviour.</p>"},{"location":"docs/events/builtin/syscalls/query_module/#example-use-case","title":"Example Use Case","text":"<p>One scenario where query_module can be useful is for trouble-shooting issues with Linux modules. System administrators may use this system call to manually query the kernel for information on a module, in the event that module is not behaving correctly.</p>"},{"location":"docs/events/builtin/syscalls/query_module/#issues","title":"Issues","text":"<p>There is a potential TOCTOU (Time of Check, Time of Use) vulnerability with query_module. As this system call has the potential to access user-space memory, it is possible for malicious code to overwrite the contents of the queried module before it is used. It is therefore recommended to use this system call with caution and only in well-controlled situations.</p>"},{"location":"docs/events/builtin/syscalls/query_module/#related-events","title":"Related Events","text":"<ul> <li>init_module - initialize a Linux Kernel Module</li> <li>delete_module - delete a Linux Kernel Module</li> <li>get_kernel_syms - query the kernel for exported symbols.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/quotactl/","title":"quotactl","text":""},{"location":"docs/events/builtin/syscalls/quotactl/#intro","title":"Intro","text":"<p>quotactl - manipulate disk quotas from user space.</p>"},{"location":"docs/events/builtin/syscalls/quotactl/#description","title":"Description","text":"<p>The quotactl system call is used to set disk quotas and retrieve disk quota information from user space. It is a way to limit disk usage on a system-wide basis and provides the ability to do things like set disk quota limits, enforce the disk quota limits and record disk usage for users. There are several different parameters that can be set with quotactl, such as the maximum size of a user's files and the grace period for when the quota limit is exceeded.</p> <p>The quotactl system call can be used to manipulate the disk quota information stored in the quota setup files. It can also be used to enforce the quota limit and to revoke access to the files exceeding the quota limit until the usage is brought back within the limit.</p>"},{"location":"docs/events/builtin/syscalls/quotactl/#arguments","title":"Arguments","text":"<ul> <li><code>cmd</code>:<code>int</code>[K] - The command to be performed, which can be one of the following:</li> <li><code>Q_QUOTAON</code> - Turn quotas on</li> <li><code>Q_QUOTAOFF</code> - Turn quotas off</li> <li><code>Q_SETQUOTA</code> - Set the quota limits</li> <li><code>Q_GETQUOTA</code> - Get the quota limits</li> <li><code>Q_GETNEXTQUOTA</code> - Get information about the next user in the system </li> <li><code>special</code>:<code>const char*</code>[K] - A pointer to a pathname indicating the block device for whose quotas the command is to be applied.</li> <li><code>id</code>:<code>int</code>[K] - The user or group id for whom the quotas are set or retrieved.</li> <li><code>addr</code>:<code>void*</code>[K] - A pointer to a buffer which contains the requested quota information to set, or which will store the quota information retrieved.</li> </ul>"},{"location":"docs/events/builtin/syscalls/quotactl/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/quotactl/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/quotactl/#quotactl_1","title":"quotactl","text":""},{"location":"docs/events/builtin/syscalls/quotactl/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/quotactl/#purpose","title":"Purpose","text":"<p>To monitor the system calls and track disk quotas.</p>"},{"location":"docs/events/builtin/syscalls/quotactl/#example-use-case","title":"Example Use Case","text":"<p>quotactl can be used as an effective disk quota enforcement mechanism to keep a user from exceeding disk usage limits. It can be used to track and monitor disk usage in order to better control resource allocation.</p>"},{"location":"docs/events/builtin/syscalls/quotactl/#issues","title":"Issues","text":"<p>It is vulnerable to TOCTOU (time of check, time of use) race conditions.</p>"},{"location":"docs/events/builtin/syscalls/quotactl/#related-events","title":"Related Events","text":"<ul> <li>getdents - manipulate directory entries.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/quotactl_fd/","title":"quotactl_fd","text":""},{"location":"docs/events/builtin/syscalls/quotactl_fd/#intro","title":"Intro","text":"<p>quotactl_fd - set/get filesystem quotas and limits</p>"},{"location":"docs/events/builtin/syscalls/quotactl_fd/#description","title":"Description","text":"<p>The quotactl_fd syscalls allows the retrieval and modification of disk quotas and limits, as well as get and set disk usage information, when given a valid file descriptor. It is used to invoke one of the available commands on the specified filesystem, with specific additional parameters. It is particularly useful for setting and retrieving hard and soft limits for quotas and limits for multiple users simultaneously.</p>"},{"location":"docs/events/builtin/syscalls/quotactl_fd/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>unsigned int</code> - an open file descriptor of a filesystem from which to get or set the information, or to which the command will be sent.</li> <li><code>cmd</code>:<code>unsigned int</code> - one of the available commands that can be used in the syscall, as listed in the manual page.</li> <li><code>id</code>:<code>qid_t</code> - represents the user/group/project ID to be associated with the specified filesystem.</li> <li><code>addr</code>:<code>void *</code>[K] - an address pointing to a memory area from which data can be read or to which data can be written, depending on the type of command sent.</li> </ul>"},{"location":"docs/events/builtin/syscalls/quotactl_fd/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/quotactl_fd/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/quotactl_fd/#do_quotactl_fd","title":"<code>do_quotactl_fd</code>","text":""},{"location":"docs/events/builtin/syscalls/quotactl_fd/#type","title":"Type","text":"<p>KProbe + KRetProbe.</p>"},{"location":"docs/events/builtin/syscalls/quotactl_fd/#purpose","title":"Purpose","text":"<p>Hooked to gain visibility into how this system call is used, when it is used, where it is used and what arguments are associated with its usage.</p>"},{"location":"docs/events/builtin/syscalls/quotactl_fd/#example-use-case","title":"Example Use Case","text":"<p>This system call can be used for applications that need to set usage quotas and limits for disk usage on a certain file system. </p>"},{"location":"docs/events/builtin/syscalls/quotactl_fd/#issues","title":"Issues","text":"<p>None so far.</p>"},{"location":"docs/events/builtin/syscalls/quotactl_fd/#related-events","title":"Related Events","text":"<ul> <li><code>quotactl</code> - related system call.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/read/","title":"Read","text":""},{"location":"docs/events/builtin/syscalls/read/#intro","title":"Intro","text":"<p>read - Read from a file descriptor</p>"},{"location":"docs/events/builtin/syscalls/read/#description","title":"Description","text":"<p>The <code>read</code> syscall is used to read from an open file descriptor. It takes as input three arguments: <code>fd</code>, <code>buf</code>, and <code>count</code>, and returns a result in the form of the number of bytes read. </p> <p>The <code>fd</code> argument is an integer that represents a file descriptor, which can be retrieved using the <code>open</code> syscall. The <code>buf</code> argument is a pointer to the buffer used to store the read bytes, which should have size at least <code>count</code>. The <code>count</code> argument represents the maximum number of bytes to be read. </p> <p>The <code>read</code> syscall usually blocks the calling process until the requested data has been read. This can cause issues if the process was expected to remain responsive while waiting for the data. If this is an issue, one possible solution would be to use the <code>poll</code> syscall to check when data is available.</p>"},{"location":"docs/events/builtin/syscalls/read/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - The file descriptor representing the file or device to read from.</li> <li><code>buf</code>:<code>void*</code>[KU] - Pointer to the buffer to which the data should be written.</li> <li><code>count</code>:<code>size_t</code>[K] - The maximum number of bytes to be read.</li> </ul>"},{"location":"docs/events/builtin/syscalls/read/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/read/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/read/#sys_read","title":"sys_read","text":""},{"location":"docs/events/builtin/syscalls/read/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/read/#purpose","title":"Purpose","text":"<p>To trace syscall execution in order to record useful data like time, arguments, and return codes.</p>"},{"location":"docs/events/builtin/syscalls/read/#example-use-case","title":"Example Use Case","text":"<p>The <code>read</code> syscall can be used to read data from a file in the system, such as the contents of log files or configuration files. It may be useful for profiling the system by monitoring which files are read and when.</p>"},{"location":"docs/events/builtin/syscalls/read/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/read/#related-events","title":"Related Events","text":"<p>write, poll, open</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/readahead/","title":"Readahead","text":""},{"location":"docs/events/builtin/syscalls/readahead/#intro","title":"Intro","text":"<p>Readahead - readahead preloads a file or block device into the page cache.</p>"},{"location":"docs/events/builtin/syscalls/readahead/#description","title":"Description","text":"<p>The readahead() system call initiates a read from a file or block device into the page cache of the kernel. It begins at an offset in the file and reads up to count bytes. If readahead has already been performed on this file, the kernel will extend the previous read by the additional count bytes. This call allows the kernel to prefetch more data than is needed before the data is requested. Thus, the act of calling readahead allows the kernel to speed up subsequent read operations by preloading the data before it is requested by the user.</p> <p>The readahead system call can be used to improve the slow-start performance of applications that read full files sequentially. By pre-loading data with readahead, the user has less wait time while the disk is being read.</p> <p>Readahead does not guarantee that the data will remain in the page cache. The kernel discards quickly-referenced pages from the page cache in order to make room for other page-cache requests.</p>"},{"location":"docs/events/builtin/syscalls/readahead/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - The file descriptor for the file. </li> <li><code>offset</code>:<code>off_t</code>[K] - The location in the file to begin reading from. </li> <li><code>count</code>:<code>size_t</code>[K] - The amount of bytes to read.</li> </ul>"},{"location":"docs/events/builtin/syscalls/readahead/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/readahead/#hooks","title":"Hooks","text":"<p>No functions are hooked when readahead is called.</p>"},{"location":"docs/events/builtin/syscalls/readahead/#example-use-case","title":"Example Use Case","text":"<p>One example use case of the readahead system call is the readahead_all() function in the Linux kernel. It is used to prefetch files in parallel to speed-up the start of an application that requires multiple files. This can significantly reduce I/O latency by allowing more data to be read in one go since the kernel can readahead to fill-up the page cache.</p>"},{"location":"docs/events/builtin/syscalls/readahead/#issues","title":"Issues","text":"<p>No known issues exist with the readahead system call.</p>"},{"location":"docs/events/builtin/syscalls/readahead/#related-events","title":"Related Events","text":"<ul> <li>madvise() - The madvise() system call can allow applications to inform the kernel about the expected usage patterns of data so that the optimal page management strategies can be implemented. It is typically used in conjunction with readahead() to optimize the performance of file reads.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/readdir/","title":"readdir","text":""},{"location":"docs/events/builtin/syscalls/readdir/#intro","title":"Intro","text":"<p>readdir - Reads a directory structure from the given opened file descriptor</p>"},{"location":"docs/events/builtin/syscalls/readdir/#description","title":"Description","text":"<p>The readdir() system call reads a single directory entry from a directory opened with the open() system call. It returns the next directory entry in a directory stream pointed to by the file descriptor fd. Upon successful return, the content of the directory entry is copied to the old_linux_dirent structure pointed to by dirp.</p> <p>The readdir() system call is used to get information about each subdirectory in a filesystem, one entry at a time. It is possible to call this system call on any open file descriptor , regardless of the type of file is associated with it.</p> <p>The count argument specifies the length of the old_linux_dirent buffer. If the buffer size is not large enough to hold the entire directory entry, an error will be returned.</p> <p>readdir() does not guarantee that successive calls to this system call with the same file descriptor will always return the entries in the same order.</p>"},{"location":"docs/events/builtin/syscalls/readdir/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>unsigned int</code>[K] - A file descriptor returned from open system call.</li> <li><code>dirp</code>:<code>struct old_linux_dirent*</code>[K] - A pointer to the structure.</li> <li><code>count</code>:<code>unsigned int</code>[K] - Total number of bytes for the structure.</li> </ul>"},{"location":"docs/events/builtin/syscalls/readdir/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/readdir/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/readdir/#readdir_1","title":"readdir()","text":""},{"location":"docs/events/builtin/syscalls/readdir/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/readdir/#purpose","title":"Purpose","text":"<p>Monitoring calls to readdir.</p>"},{"location":"docs/events/builtin/syscalls/readdir/#example-use-case","title":"Example Use Case","text":"<p>readdir() can be used to monitor a specific directory in the filesystem. It can be used to monitor or detect any changes or operations, such as the creation of files or the deletion of directories, in the monitored directory.</p>"},{"location":"docs/events/builtin/syscalls/readdir/#issues","title":"Issues","text":"<p>readdir() is vulnerable to a Time of Check, Time of Use (TOCTOU) race condition, which can result in security vulnerabilities if not carefully handled.</p>"},{"location":"docs/events/builtin/syscalls/readdir/#related-events","title":"Related Events","text":"<p>open(), seekdir(), getdents(), rewinddir()</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/readlink/","title":"readlink","text":""},{"location":"docs/events/builtin/syscalls/readlink/#intro","title":"Intro","text":"<p>readlink - read the contents of a symbolic link</p>"},{"location":"docs/events/builtin/syscalls/readlink/#description","title":"Description","text":"<p>The <code>readlink()</code> system call reads the contents of a symbolic link and stores the  result in the buffer pointed to by <code>buf</code>, which has a length of <code>bufsiz</code> bytes.  This call does not follow symbolic links; it reads the contents of the link itself.  The <code>readlink()</code> system call does not append a null byte to the buffer. </p>"},{"location":"docs/events/builtin/syscalls/readlink/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code>[K] - Pointer to the symbolic link pathname.</li> <li><code>buf</code>:<code>char*</code>[K+U] - A character array to store the contents of the link in.</li> <li><code>bufsiz</code>:<code>size_t</code>[K] - Size of the character array.</li> </ul>"},{"location":"docs/events/builtin/syscalls/readlink/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/readlink/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/readlink/#__x64_sys_readlink","title":"__x64_sys_readlink","text":""},{"location":"docs/events/builtin/syscalls/readlink/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/readlink/#purpose","title":"Purpose","text":"<p>To capture information regarding the use of the readlink system call.</p>"},{"location":"docs/events/builtin/syscalls/readlink/#example-use-case","title":"Example Use Case","text":"<p>A malicious user is attempting to use <code>readlink</code> for nefarious purposes. By  hooking the <code>__x64_sys_readlink</code> function, an analyst can track and collect  information regarding the use of the <code>readlink</code> syscall.</p>"},{"location":"docs/events/builtin/syscalls/readlink/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/readlink/#related-events","title":"Related Events","text":"<ul> <li>open - The <code>open()</code> system call is used to open a file given its pathname. Used  in conjunction with <code>readlink()</code>, as one cannot use <code>readlink()</code> with a relative  path. </li> <li>access - The <code>access()</code> system call is used to determine whether a process has  permission to access a certain file or directory. Used in conjunction with  <code>readlink()</code>, as an analyst may want to see if a user has access to certain file  paths.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/readlinkat/","title":"readlinkat","text":""},{"location":"docs/events/builtin/syscalls/readlinkat/#intro","title":"Intro","text":"<p>readlinkat - read the contents of a symbolic link</p>"},{"location":"docs/events/builtin/syscalls/readlinkat/#description","title":"Description","text":"<p>The readlinkat() system call is used to read the contents of a symbolic link. The call requires a file descriptor for the directory that contains the symbolic link, the name of the link itself, a buffer for the link contents, and the size of the buffer. The call returns the contents of the link in the given buffer, or an error code if the buffer is too small for the link.</p> <p>The readlinkat() system call is similar to the readlink() system call, except it allows for more control of the environment in which the link is read. While readlink() always takes the path of the link as relative to the current working directory, readlinkat() allows the path to be relative to a directory that is different than the current working directory. </p> <p>The readlinkat() system call has some drawbacks. It is vulnerable to \"time of check, time of use\" (TOCTOU) race conditions, as the link could be changed between the time it is checked and when it is used. It also requires the user to provide a valid file descriptor for the target directory. This can be difficult when the target directory is a remote filesystem, or a virtual filesystem.</p>"},{"location":"docs/events/builtin/syscalls/readlinkat/#arguments","title":"Arguments","text":"<ul> <li><code>dirfd</code>:<code>int</code>[K] - file descriptor for directory containing the link.</li> <li><code>pathname</code>:<code>const char*</code>[KU] - the pathname of the link.</li> <li><code>buf</code>:<code>char*</code>[KU] - buffer for the link contents. </li> <li><code>bufsiz</code>:<code>int</code>[K] - size of the buffer.</li> </ul>"},{"location":"docs/events/builtin/syscalls/readlinkat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/readlinkat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/readlinkat/#vfs_readlink","title":"vfs_readlink()","text":""},{"location":"docs/events/builtin/syscalls/readlinkat/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/readlinkat/#purpose","title":"Purpose","text":"<p>To add additional tracing capabilities to the readlinkat() system call.</p>"},{"location":"docs/events/builtin/syscalls/readlinkat/#generic_permission","title":"generic_permission()","text":""},{"location":"docs/events/builtin/syscalls/readlinkat/#type_1","title":"Type","text":"<p>Kretprobes</p>"},{"location":"docs/events/builtin/syscalls/readlinkat/#purpose_1","title":"Purpose","text":"<p>To record the return value of the readlinkat() system call.</p>"},{"location":"docs/events/builtin/syscalls/readlinkat/#example-use-case","title":"Example Use Case","text":"<p>The readlinkat() system call can be used to read the contents of a symbolic link and ensure that the link points to the expected target. This can be useful for validation of the directory structure, or for creating a log of file and directory changes.</p>"},{"location":"docs/events/builtin/syscalls/readlinkat/#issues","title":"Issues","text":"<p>The readlinkat() system call is vulnerable to \"time of check, time of use\" (TOCTOU) race conditions, as the link could be changed between the time it is checked and when it is used. </p>"},{"location":"docs/events/builtin/syscalls/readlinkat/#related-events","title":"Related Events","text":"<p>The readlink() system call is the simplified version of readlinkat() and is used to read the contents of a link. The lstat() system call can be used to check the properties of the link and ensure it is a valid link. The openat() system call is used to open the target directory and get a file descriptor for use with readlinkat().</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/readv/","title":"readv","text":""},{"location":"docs/events/builtin/syscalls/readv/#intro","title":"Intro","text":"<p>readv - read data from a file descriptor into multiple buffers</p>"},{"location":"docs/events/builtin/syscalls/readv/#description","title":"Description","text":"<p>The readv() system call reads data from a file descriptor into multiple buffers, specified with the array iov. Each element in the array contains the location and number of bytes to read. Up to iovcnt elements can be read from an array.</p> <p>The readv() call operates similarly to a call of read() except for the arrays of vectors, rather than a single user buffer. The readv() call is then useful for reading from a file or socket into multiple buffers, allowing for greater efficiency when working with large datasets.</p> <p>Edge cases: Depending on the value used for the iovcnt argument, fewer than the requested number of bytes may be written to the output buffers.</p>"},{"location":"docs/events/builtin/syscalls/readv/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code> - the file descriptor from which the data should be read.</li> <li><code>iov</code>:<code>const struct iovec*</code>[KU] - an array containing the location and number of bytes to read.</li> <li><code>iovcnt</code>:<code>int</code> - the number of elements in the iov array that should be used.</li> </ul>"},{"location":"docs/events/builtin/syscalls/readv/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/readv/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/readv/#readv_1","title":"readv","text":""},{"location":"docs/events/builtin/syscalls/readv/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/readv/#purpose","title":"Purpose","text":"<p>To be able to trace when the system call readv gets triggered, in order to determine when data is being read from a file descriptor into multiple buffers.</p>"},{"location":"docs/events/builtin/syscalls/readv/#example-use-case","title":"Example Use Case","text":"<p>readv() can be used to read a large amount of data from a file descriptor into multiple buffers, for example for writing to a log file or sending large datasets over a network.</p>"},{"location":"docs/events/builtin/syscalls/readv/#issues","title":"Issues","text":"<p>No issues known for this event.</p>"},{"location":"docs/events/builtin/syscalls/readv/#related-events","title":"Related Events","text":"<ul> <li>writev</li> <li>preadv</li> <li>preadv2</li> <li>pwritev</li> <li>pwritev2</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/reboot/","title":"reboot","text":""},{"location":"docs/events/builtin/syscalls/reboot/#intro","title":"Intro","text":"<p>reboot - reboot a computer</p>"},{"location":"docs/events/builtin/syscalls/reboot/#description","title":"Description","text":"<p>The reboot() system call causes the system to be rebooted. The magic parameter and magic2 parameter, if non-zero, are passed to the kernel and the behavior of the call can depend on their values. The cmd parameter may be one of the following:</p> <ul> <li>RB_AUTOBOOT - Forces the system to restart, no questions asked.</li> <li>RB_HALT_SYSTEM - Halts the system after the system has been shut down.</li> <li>RB_POWER_OFF - Powers the system off and is the equivalent of using the power   button on a PC.</li> </ul> <p>The arg parameter can be set to a pointer to a character array, which is used to provide additional information such as a shutdown message, but it is generally ignored.</p>"},{"location":"docs/events/builtin/syscalls/reboot/#arguments","title":"Arguments","text":"<ul> <li><code>magic</code>:<code>int</code> - Magic argument. Used to tell the kernel certain privileges   for the reboot procedure.</li> <li><code>magic2</code>:<code>int</code>-[K] - Magic argument number two. Used to tell the kernel   certain privileges for the reboot procedure.</li> <li><code>cmd</code>:<code>int</code> - Command to execute. Can be one of the following: RB_AUTOBOOT,   RB_HALT_SYSTEM and RB_POWER_OFF.</li> <li><code>arg</code>:<code>void*</code>-[U] - A pointer to a character array that can be used to   provide additional information but is generally ignored.</li> </ul>"},{"location":"docs/events/builtin/syscalls/reboot/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/reboot/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/reboot/#do_sys_reboot","title":"do_sys_reboot","text":""},{"location":"docs/events/builtin/syscalls/reboot/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/reboot/#purpose","title":"Purpose","text":"<p>To intercept attempts to reboot the system.</p>"},{"location":"docs/events/builtin/syscalls/reboot/#example-use-case","title":"Example Use Case","text":"<p>Reboot the system to apply a kernel patch or a system configuration change.</p>"},{"location":"docs/events/builtin/syscalls/reboot/#issues","title":"Issues","text":"<p>The reboot system call does not return, so it needs to be used with caution to avoid inadvertently affecting system stability.</p>"},{"location":"docs/events/builtin/syscalls/reboot/#related-events","title":"Related Events","text":"<ul> <li>sys_reboot - Generates a system reboot.</li> <li>sys_restart_syscall - Restarts a system call after it was interrupted by a   signal.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/recvfrom/","title":"recvfrom","text":""},{"location":"docs/events/builtin/syscalls/recvfrom/#intro","title":"Intro","text":"<p>recvfrom - receive a message from a network socket</p>"},{"location":"docs/events/builtin/syscalls/recvfrom/#description","title":"Description","text":"<p>The recvfrom() system call reads a message from a socket, and stores it in a buffer. The flags argument can be used to alter the behavior of the call. If src_addr is not NULL, then the source address of the message is filled in. For connection-oriented sockets (e.g., type SOCK_STREAM), this is attempted only on the first message on the socket. If addrlen is not NULL, then it is filled in with the size of the address actually returned.</p> <p>The recvfrom() call is usually used with connectionless sockets (type SOCK_DGRAM). With a connectionless socket, the source address of the message is returned in src_addr and addrlen holds the size of the address. If src_addr is NULL, nothing is filled in; in this case, addrlen is not used, and should also be NULL.</p>"},{"location":"docs/events/builtin/syscalls/recvfrom/#arguments","title":"Arguments","text":"<ul> <li><code>sockfd</code>:<code>int</code>[K] - File descriptor referring to a socket.</li> <li><code>buf</code>:<code>void*</code>[KU] - Pointer to the buffer in which the message should be stored.</li> <li><code>len</code>:<code>size_t</code>[KU] - Length of the buffer.</li> <li><code>flags</code>:<code>int</code>[K] - Flags for the call.</li> <li><code>src_addr</code>:<code>struct sockaddr*</code>[KU] - Pointer to a buffer which will contain the source address of the message. Can be NULL.</li> <li><code>addrlen</code>:<code>int*</code>[KU] - Pointer to a buffer which will contain the length of the source address. Can be NULL.</li> </ul>"},{"location":"docs/events/builtin/syscalls/recvfrom/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/recvfrom/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/recvfrom/#sys_recvfrom","title":"sys_recvfrom","text":""},{"location":"docs/events/builtin/syscalls/recvfrom/#type","title":"Type","text":"<p>Kprobes and Uprobe</p>"},{"location":"docs/events/builtin/syscalls/recvfrom/#purpose","title":"Purpose","text":"<p>To observe the use of recvfrom syscall, the entry point of the syscall can be intercepted with a kprobe. This allows the function to be handled in a safe environment and the arguments to be intercepted and passed to the tracer.</p>"},{"location":"docs/events/builtin/syscalls/recvfrom/#mm_access","title":"mm_access","text":""},{"location":"docs/events/builtin/syscalls/recvfrom/#type_1","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/recvfrom/#purpose_1","title":"Purpose","text":"<p>This kprobe is used to handle the buffer passed to the syscall to ensure that it can be read by the kernel safely.</p>"},{"location":"docs/events/builtin/syscalls/recvfrom/#example-use-case","title":"Example Use Case","text":"<p>An example of a use case for recvfrom is for a server logging program, which needs to read the data contained in incoming messages. The program can use recvfrom to receive the messages from the appropriate socket, and it can then process the data contained in the message.</p>"},{"location":"docs/events/builtin/syscalls/recvfrom/#issues","title":"Issues","text":"<p>The recvfrom() system call is vulnerable to Time-of-Check-Time-of-Use (TOCTOU) attacks. This means that an attacker could modify the data between the time it is checked and the time it is used. To mitigate this, checks should be performed on the data at both the time of check and time of use.</p>"},{"location":"docs/events/builtin/syscalls/recvfrom/#related-events","title":"Related Events","text":"<ul> <li>sendto</li> <li>getsockname</li> <li>recv</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/recvmmsg/","title":"recvmmsg","text":""},{"location":"docs/events/builtin/syscalls/recvmmsg/#intro","title":"Intro","text":"<p>recvmmsg - Receive multiple messages on a socket</p>"},{"location":"docs/events/builtin/syscalls/recvmmsg/#description","title":"Description","text":"<p>The recvmmsg() system call is used to receive multiple messages from a socket, similar to recvmsg(), but allows passing a user-space array to retrieve multiple messages into different buffers with a single call, instead of having to call the function multiple times.</p> <p>There are several advantages to using recvmmsg(): - It is much faster, because it can receive multiple messages at once, thus   avoiding the need for multiple system calls. - It can be used for better network performance, since it does fewer system   calls, meaning less context switches from user-space to kernel-space. - It can be used to receive multiple messages from different sockets (as   opposed to recvmsg(), which receives from only one)</p> <p>There are also a few drawbacks to using recvmmsg(): - It is not suitable for small messages, since the overhead for using it is   higher than that of using the single message system call (recvmsg()) - If the socket is set to non-blocking, recvmmsg() will return an error if   there are not enough messages in the queue, whereas recvmsg() would return   immediately with the messages it has (if any).</p>"},{"location":"docs/events/builtin/syscalls/recvmmsg/#arguments","title":"Arguments","text":"<ul> <li><code>sockfd</code>:<code>int</code>[K] - The file descriptor of the socket.</li> <li><code>msgvec</code>:<code>struct mmsghdr*</code>[U] - An array of mmsghdr structures, each one   containing a message that recvmmsg() receives into. The caller should ensure   that this array is large enough for up to vlen messages.</li> <li><code>vlen</code>:<code>unsigned int</code>[K] - The maximum size of the msgvec array.</li> <li><code>flags</code>:<code>int</code>[K] - Socket flags, such as MSG_DONTWAIT.</li> <li><code>timeout</code>:<code>struct timespec*</code>[K] - If not null, a pointer to a timespec   structure to be used for timeouts.</li> </ul>"},{"location":"docs/events/builtin/syscalls/recvmmsg/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/recvmmsg/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/recvmmsg/#sys_recvmmsg","title":"sys_recvmmsg","text":""},{"location":"docs/events/builtin/syscalls/recvmmsg/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/recvmmsg/#purpose","title":"Purpose","text":"<p>To monitor the receipt of multiple messages on a socket.</p>"},{"location":"docs/events/builtin/syscalls/recvmmsg/#example-use-case","title":"Example Use Case","text":"<p>By using recvmmsg(), multiple file descriptors can be monitored in a single system call, thus avoiding the need for making multiple system calls. This can be useful when working with high-performance applications, such as distributed systems, where a single system call needs to receive many messages at once.</p>"},{"location":"docs/events/builtin/syscalls/recvmmsg/#issues","title":"Issues","text":"<p>No known issues.</p>"},{"location":"docs/events/builtin/syscalls/recvmmsg/#related-events","title":"Related Events","text":"<ul> <li>recvmsg() - Receive a message from a socket.</li> <li>sendmmsg() - Send multiple messages on a socket.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/recvmmsg_time32/","title":"recvmmsg_time32","text":""},{"location":"docs/events/builtin/syscalls/recvmmsg_time32/#intro","title":"Intro","text":"<p>recvmmsg_time32 system call - an implementation for recvmmsg for 32-bit timeval structures.</p>"},{"location":"docs/events/builtin/syscalls/recvmmsg_time32/#description","title":"Description","text":"<p>The recvmmsg_time32() system call is an implementation of the recvmmsg() system call that uses the old_timespec32 data type instead of timespec. This allows the receiving of multiple messages with a single system call, instead of multiple calls. The old_timespec32 structure allows a 32-bit seconds and microseconds fields, as opposed to the timespec structure, which uses a 64-bit nanoseconds field.</p> <p>This function is using pointers to user space memory, to fetch multiple messages, which could be potentialy vulnerable to TOCTOU (Time Of Check, Time Of Use) attacks.</p>"},{"location":"docs/events/builtin/syscalls/recvmmsg_time32/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[KU] - The file descriptor from which to receive the message.</li> <li><code>mmsg</code>:<code>struct mmsghdr*</code>[KU] - A pointer to an array of mmsghdr structures containing information about the messages that are to be received by recvmsg().</li> <li><code>vlen</code>:<code>unsigned int</code>[K] - The length of the array of mmsghdr structures.</li> <li><code>flags</code>:<code>unsigned int</code>[K] - The flags to be used for the recvmsg() syscalls used in the process.</li> <li><code>timeout</code>:<code>struct old_timespec32*</code>[K] - A pointer to a struct old_timespec32 containing the timeout for the recvmmsg call to wait for incoming messages.</li> </ul>"},{"location":"docs/events/builtin/syscalls/recvmmsg_time32/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/recvmmsg_time32/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/recvmmsg_time32/#tracepoint_sys_enter_recvmmsg_time32","title":"tracepoint_sys_enter_recvmmsg_time32","text":""},{"location":"docs/events/builtin/syscalls/recvmmsg_time32/#type","title":"Type","text":"<p>Tracepoint</p>"},{"location":"docs/events/builtin/syscalls/recvmmsg_time32/#purpose","title":"Purpose","text":"<p>To trace calls to the recvmmsg_time32 syscall.</p>"},{"location":"docs/events/builtin/syscalls/recvmmsg_time32/#ptrace_recv_syscall","title":"ptrace_recv_syscall","text":""},{"location":"docs/events/builtin/syscalls/recvmmsg_time32/#type_1","title":"Type","text":"<p>Ptrace hook</p>"},{"location":"docs/events/builtin/syscalls/recvmmsg_time32/#purpose_1","title":"Purpose","text":"<p>To be able to hook the recvmmsg_time32 syscall, and modify its arguments before syscall enter.</p>"},{"location":"docs/events/builtin/syscalls/recvmmsg_time32/#example-use-case","title":"Example Use Case","text":"<p>This system call can be used to receive multiple messages in one system call, for example for an event-based server application. It can be used to wait in a select()-like loop on multiple sockets, but instead of having to perform multiple recvmsg() calls, a single recvmmsg_time32() system call can be used to receive messages from all the sockets.</p>"},{"location":"docs/events/builtin/syscalls/recvmmsg_time32/#issues","title":"Issues","text":"<p>TBD</p>"},{"location":"docs/events/builtin/syscalls/recvmmsg_time32/#related-events","title":"Related Events","text":"<ul> <li>recvmsg,</li> <li>sendmsg,</li> <li>select,</li> <li>poll,</li> <li>epoll_wait</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/recvmsg/","title":"recvmsg","text":""},{"location":"docs/events/builtin/syscalls/recvmsg/#intro","title":"Intro","text":"<p>recvmsg - read a message from a socket</p>"},{"location":"docs/events/builtin/syscalls/recvmsg/#description","title":"Description","text":"<p>recvmsg() is used to receive messages from a  socket,  and  may  be  used  to  receive  both  connection-based  and  connectionless messages. recvmsg() may also be used to receive file descriptors sent by means of the sendmsg() system call.</p> <p>The flags argument provides further options and is constructed by giving the bitwise OR of one or more of the following: * MSG_CMSG_CLOEXEC - Indicates that associated to each control message an close-on-exec flag must be set. * MSG_DONTWAIT - Non-blocking operation - make the call fail if the socket is not available for receive. * MSG_ERRQUEUE - Receive messages from the kernel error queue. * MSG_OOB - Receive out-of-band data.</p> <p>Advantage of using recvmsg is the possibility of merging several different types of input into one system call. Drawback is that it does not provide any data ordering assurance.</p>"},{"location":"docs/events/builtin/syscalls/recvmsg/#arguments","title":"Arguments","text":"<ul> <li><code>sockfd</code>:<code>int</code>[K] - File descriptor of the socket from which to receive messages. </li> <li><code>msg</code>:<code>struct msghdr*</code>[K] - Pointer to a msghdr structure which will contain the message of up to size 65535 bytes.</li> <li><code>flags</code>:<code>int</code>[K] - OR-ed bit flags of the possible flags: MSG_CMSG_CLOEXEC, MSG_DONTWAIT, MSG_ERRQUEUE and MSG_OOB.</li> </ul>"},{"location":"docs/events/builtin/syscalls/recvmsg/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/recvmsg/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/recvmsg/#syscall_recvmsg","title":"syscall_recvmsg","text":""},{"location":"docs/events/builtin/syscalls/recvmsg/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/recvmsg/#purpose","title":"Purpose","text":"<p>To analyze and control the messages received from the given socket.</p>"},{"location":"docs/events/builtin/syscalls/recvmsg/#example-use-case","title":"Example Use Case","text":"<p>An example use of recvmsg is when using socket-level security for validating messages. By using recvmsg, messages delivery can be allowed or denied according to some criteria.</p>"},{"location":"docs/events/builtin/syscalls/recvmsg/#issues","title":"Issues","text":"<p>No known issues with this event.</p>"},{"location":"docs/events/builtin/syscalls/recvmsg/#related-events","title":"Related Events","text":"<ul> <li>sendmsg - opposite of recvmsg, used to send messages.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/remap_file_pages/","title":"remap_file_pages","text":""},{"location":"docs/events/builtin/syscalls/remap_file_pages/#intro","title":"Intro","text":"<p>remap_file_pages - Map or remap part of a file into the process's address space</p>"},{"location":"docs/events/builtin/syscalls/remap_file_pages/#description","title":"Description","text":"<p>The <code>remap_file_pages</code> system call changes the protection and mapping of memory pages in the virtual address space of the calling process. It can remap an existing file mapping, create a new one, or unmap a range of pages previously mapped. It can also be used to change the permissions of the mapped pages. </p> <p>This call provides support for memory mapped files that can be used as shared memory or for other kinds of memory sharing among processes. </p> <p>An edge-case that can be encountered when using <code>remap_file_pages</code> is when the requested range of file pages is not available. This can be caused by the underlying file having been truncated, or if the requested mapping overlaps with another existing mapping.</p>"},{"location":"docs/events/builtin/syscalls/remap_file_pages/#arguments","title":"Arguments","text":"<ul> <li><code>addr</code>:<code>void*</code>[U] - Starting address of the mapping.</li> <li><code>size</code>:<code>size_t</code>[U] - Size of the mapping.</li> <li><code>prot</code>:<code>int</code>[U] - Memory protection flags to set for the mapping.</li> <li><code>pgoff</code>:<code>size_t</code>[U] - File offset in bytes corresponding to the start of the mapping.</li> <li><code>flags</code>:<code>int</code>[U] - Flags for the mapping. Can be set to 0 for default behavior. </li> </ul>"},{"location":"docs/events/builtin/syscalls/remap_file_pages/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/remap_file_pages/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/remap_file_pages/#do_mmap_pgoff","title":"do_mmap_pgoff","text":""},{"location":"docs/events/builtin/syscalls/remap_file_pages/#type","title":"Type","text":"<p>KProbes</p>"},{"location":"docs/events/builtin/syscalls/remap_file_pages/#purpose","title":"Purpose","text":"<p>To monitor the <code>do_mmap_pgoff</code> syscall which is used by the kernel to handle <code>remap_file_pages</code> calls. </p>"},{"location":"docs/events/builtin/syscalls/remap_file_pages/#update_mmap_zero_pfn","title":"update_mmap_zero_pfn","text":""},{"location":"docs/events/builtin/syscalls/remap_file_pages/#type_1","title":"Type","text":"<p>KProbes</p>"},{"location":"docs/events/builtin/syscalls/remap_file_pages/#purpose_1","title":"Purpose","text":"<p>To monitor the <code>update_mmap_zero_pfn</code> syscall which is used by the kernel to handle <code>remap_file_pages</code> calls.</p>"},{"location":"docs/events/builtin/syscalls/remap_file_pages/#example-use-case","title":"Example Use Case","text":"<p><code>remap_file_pages</code> can be used when a process needs to share parts of its address space with other processes. This can be done through the use of memory mapped files or shared memory.</p>"},{"location":"docs/events/builtin/syscalls/remap_file_pages/#issues","title":"Issues","text":"<p>Due to its underlying implementation, <code>remap_file_pages</code> can be vulnerable to TOCTOU races. This means that between the time when the data is read and the data is used, other operations can take place which make the read data obsolete.</p>"},{"location":"docs/events/builtin/syscalls/remap_file_pages/#related-events","title":"Related Events","text":"<ul> <li><code>mmap</code>: used to create mappings in the virtual address space</li> <li><code>mprotect</code>: used to change page permissions</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/removexattr/","title":"removexattr","text":""},{"location":"docs/events/builtin/syscalls/removexattr/#intro","title":"Intro","text":"<p>removexattr() - removes the extended attribute to the file system object</p>"},{"location":"docs/events/builtin/syscalls/removexattr/#description","title":"Description","text":"<p>The removexattr() system call removes an extended attribute associated with the given file system object path. It is used to control access to file system objects. It removes only one attribute per invocation, which is specified by the given name argument.</p> <p>Are there any edge-cases, drawbacks or advantages of using it?</p> <p>The main drawback of using removexattr() is that it does not provide any mechanism for setting a default value for an attribute.  Additionally, it does not support any type of transactional behavior.</p>"},{"location":"docs/events/builtin/syscalls/removexattr/#arguments","title":"Arguments","text":"<ul> <li><code>path</code>:<code>const char*</code>[K] - The path name of the file system object.</li> <li><code>name</code>:<code>const char*</code>[K] - The name of the extended attribute to remove.</li> </ul>"},{"location":"docs/events/builtin/syscalls/removexattr/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/removexattr/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/removexattr/#__x64_sys_removexattr","title":"__x64_sys_removexattr","text":""},{"location":"docs/events/builtin/syscalls/removexattr/#type","title":"Type","text":"<p>Kprobes + Kretprobes</p>"},{"location":"docs/events/builtin/syscalls/removexattr/#purpose","title":"Purpose","text":"<p>To capture information related to the invocation of the removexattr() system  call, including the arguments and return value, for tracing and performance  analysis.</p>"},{"location":"docs/events/builtin/syscalls/removexattr/#example-use-case","title":"Example Use Case","text":"<p>An example use case for this event is for security-related purposes. It can be used to monitor for suspicious activity, such as the removal of extended attributes from a file system object.</p>"},{"location":"docs/events/builtin/syscalls/removexattr/#issues","title":"Issues","text":"<p>No known issues.</p>"},{"location":"docs/events/builtin/syscalls/removexattr/#related-events","title":"Related Events","text":"<ul> <li>setxattr</li> <li>getxattr</li> <li>listxattr</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/rename/","title":"rename","text":""},{"location":"docs/events/builtin/syscalls/rename/#intro","title":"Intro","text":"<p>rename - change the name or location of a file</p>"},{"location":"docs/events/builtin/syscalls/rename/#description","title":"Description","text":"<p>The <code>rename()</code> syscall is used to change the name or location of a file. It can also be used to move a file from one directory to another, or to rename a file. This can be important for system processes, for example making changes to files during updates or installation processes, or for application processes like renaming a file with a new version number.  Edge cases can arise from differing permissions levels between the two paths. It can also be vulnerable to TOCTOU (time of check, time of use) attacks if not properly handled, as the operation of the rename can be interrupted between the check that the file exists and when the rename happens.</p>"},{"location":"docs/events/builtin/syscalls/rename/#arguments","title":"Arguments","text":"<ul> <li><code>oldpath</code>: <code>const char*</code>[K] - Path to existing file</li> <li><code>newpath</code>: <code>const char*</code>[K] - New path of file</li> </ul>"},{"location":"docs/events/builtin/syscalls/rename/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/rename/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/rename/#sys_rename","title":"sys_rename","text":""},{"location":"docs/events/builtin/syscalls/rename/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/rename/#purpose","title":"Purpose","text":"<p>Monitoring the rename syscall</p>"},{"location":"docs/events/builtin/syscalls/rename/#example-use-case","title":"Example Use Case","text":"<p>An example use-case of the <code>rename()</code> syscall could be updating a program. A program would call <code>rename()</code> to move an existing version of the file to a new directory and/or with a different name, and then place a new version of the program into the proper directory.</p>"},{"location":"docs/events/builtin/syscalls/rename/#issues","title":"Issues","text":"<p>TOCTOU (Time of Check, Time of Use) attacks are possible when using the <code>rename()</code> syscall. If a file is checked to exist and then renamed, an attacker can theoretically create the file in the meantime and cause an attack vector through the rename.</p>"},{"location":"docs/events/builtin/syscalls/rename/#related-events","title":"Related Events","text":"<p>The <code>rename()</code> syscall is often used in conjunction with other syscalls, such as <code>open()</code>, <code>stat()</code>, <code>unlink()</code> or <code>mkDIR()</code>. Additionally, other related syscalls like <code>link()</code> and <code>symlink()</code> can achieve similar effects.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/renameat/","title":"renameat","text":""},{"location":"docs/events/builtin/syscalls/renameat/#intro","title":"Intro","text":"<p>renameat - rename a file or directory, relative to an existing file descriptor</p>"},{"location":"docs/events/builtin/syscalls/renameat/#description","title":"Description","text":"<p>The <code>renameat</code> syscall is used to rename a file or directory, relative to an existing file descriptor. It takes four arguments: two file descriptors, <code>olddirfd</code> and <code>newdirfd</code>, and two file paths, <code>oldpath</code> and <code>newpath</code>. <code>olddirfd</code> and <code>newdirfd</code> must refer to valid file descriptors associated with directories, while <code>oldpath</code> and <code>newpath</code> must refer to valid file paths. If these arguments are not provided, the <code>renameat</code> syscall will fail with an error.</p> <p>This syscall is used for managing files and directories. It is useful for providing an extra level of protection when renaming files and directories, because it allows the user to specify a file descriptor rather than a full path. It also allows for easier, more portable file and directory management.</p> <p>Note that the <code>renameat</code> syscall is vulnerable to TOCTOU (time of check, time of use) issues, because the file path and file descriptor can become invalid between the check and the use.</p>"},{"location":"docs/events/builtin/syscalls/renameat/#arguments","title":"Arguments","text":"<ul> <li><code>olddirfd</code>:<code>int</code>[K] - the file descriptor of the directory containing the file to be renamed. Must be a valid file descriptor associated with a directory.</li> <li><code>oldpath</code>:<code>const char*</code>[K] - the path of the file to be renamed, relative to the directory referenced by <code>olddirfd</code>. Must be a valid file path.</li> <li><code>newdirfd</code>:<code>int</code>[K] - the file descriptor of the directory in which to rename the file. Must be a valid file descriptor associated with a directory.</li> <li><code>newpath</code>:<code>const char*</code>[K] - the path of the new file, relative to the directory referenced by <code>newdirfd</code>. Must be a valid file path.</li> </ul>"},{"location":"docs/events/builtin/syscalls/renameat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/renameat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/renameat/#__x32_sys_renameat","title":"__x32_sys_renameat","text":""},{"location":"docs/events/builtin/syscalls/renameat/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/renameat/#purpose","title":"Purpose","text":"<p>To trace the <code>renameat</code> syscall.</p>"},{"location":"docs/events/builtin/syscalls/renameat/#example-use-case","title":"Example Use Case","text":"<p>A user wants to move a file from one directory to another, without knowing the full file paths. The user can use the <code>renameat</code> syscall to move the file, using the two file descriptors to refer to the respective directories.</p>"},{"location":"docs/events/builtin/syscalls/renameat/#issues","title":"Issues","text":"<p>The <code>renameat</code> syscall is vulnerable to TOCTOU issues. This can cause unexpected behavior if the file path or file descriptor becomes invalid between the check and the use.</p>"},{"location":"docs/events/builtin/syscalls/renameat/#related-events","title":"Related Events","text":"<ul> <li>openat - open a file relative to an existing file descriptor.</li> <li>unlinkat - delete a file or directory, relative to an existing file descriptor.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/renameat2/","title":"renameat2","text":""},{"location":"docs/events/builtin/syscalls/renameat2/#intro","title":"Intro","text":"<p>renameat2 - Atomically change the name and/or location of a file relative to two directories.</p>"},{"location":"docs/events/builtin/syscalls/renameat2/#description","title":"Description","text":"<p>renameat2 is used to rename or move a file from one directory to another. It is similar to renameat, but allows for additional flags to be specified for more fine grained control. The flags can be used to set the behavior when the target of the rename operation is a non-directory file, when a rename operation is attempted across file system boundaries, and when the target of the rename operation already exists. </p>"},{"location":"docs/events/builtin/syscalls/renameat2/#arguments","title":"Arguments","text":"<ul> <li><code>olddirfd</code>:<code>int</code>[K] - A file descriptor referring to the old directory, or AT_FDCWD (use the current working directory). </li> <li><code>oldpath</code>:<code>const char*</code>[U] - The relative pathname of the file to be renamed.</li> <li><code>newdirfd</code>:<code>int</code>[K] - A file descriptor referring to the new directory, or AT_FDCWD (use the current working directory).</li> <li><code>newpath</code>:<code>const char*</code>[U] - The relative pathname of the file to be created. </li> <li><code>flags</code>:<code>unsigned int</code>[K] - Flags which can be used to change the behavior of the call. These flags are specified as bitwise OR of the values, RENAME_EXCHANGE, RENAME_NOREPLACE, and RENAME_WHITEOUT.</li> </ul>"},{"location":"docs/events/builtin/syscalls/renameat2/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/renameat2/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/renameat2/#do_rename","title":"do_rename","text":""},{"location":"docs/events/builtin/syscalls/renameat2/#type","title":"Type","text":"<p>Ftrace</p>"},{"location":"docs/events/builtin/syscalls/renameat2/#purpose","title":"Purpose","text":"<p>To track all rename operations across multiple subsystems for debugging and to detect malicious files.</p>"},{"location":"docs/events/builtin/syscalls/renameat2/#example-use-cases","title":"Example Use Cases","text":"<p>One example of a use case for this event would be a security audit of a system. By analyzing the flow of files and processes, an auditor could identify any suspicious events such as potential malware or privilege escalation attempts.</p>"},{"location":"docs/events/builtin/syscalls/renameat2/#issues","title":"Issues","text":"<p>This syscall is vulnerable to race conditions, as the former and new paths of the file are evaluated at different times. The RENAME_EXCHANGE flag can be used to atomically trade two files, which solves the race condition issue.</p>"},{"location":"docs/events/builtin/syscalls/renameat2/#related-events","title":"Related Events","text":"<p>The renameat syscall can be used in a similar fashion as renameat2, though it does not have the flags parameter and cannot set the behavior in edge cases. Additionally, the process_exec syscall can be used to detect when a user is attempting to execute a malicious file.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/request_key/","title":"request_key","text":""},{"location":"docs/events/builtin/syscalls/request_key/#intro","title":"Intro","text":"<p>request_key - create or update an object based on a given type, description and callout information.</p>"},{"location":"docs/events/builtin/syscalls/request_key/#description","title":"Description","text":"<p>request_key is a system call used to create an object of a given type, with a specified description, and callout information that could be used by a userspace program to process that object. The call will return a key serial, which is the id associated with the created object. The request key call can also be used to update an existing object; this is done by providing the same type and description, and an updated callout info, and the key serial of the object needing to be updated.</p>"},{"location":"docs/events/builtin/syscalls/request_key/#arguments","title":"Arguments","text":"<ul> <li><code>type</code>:<code>const char*</code>[K] - the type of the object.</li> <li><code>description</code>:<code>const char*</code>[K] - description of the object.</li> <li><code>callout_info</code>:<code>const char*</code>[K] - callout information that can be processed by an userspace program.</li> <li><code>dest_keyring</code>:<code>key_serial_t</code>[K] - the key serial of the keyring that will receive the new/updated object (defaults to the current thread keyring).</li> </ul>"},{"location":"docs/events/builtin/syscalls/request_key/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/request_key/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/request_key/#request_key_1","title":"request_key","text":""},{"location":"docs/events/builtin/syscalls/request_key/#type","title":"Type","text":"<p>KProbe</p>"},{"location":"docs/events/builtin/syscalls/request_key/#purpose","title":"Purpose","text":"<p>To trace and log the creation/update of an object passed to the request_key system call.</p>"},{"location":"docs/events/builtin/syscalls/request_key/#example-use-case","title":"Example Use Case","text":"<p>A use case example for request_key is an authentication system or encryption program. request_key can be called with the callout_info set to the user information and encrypted with the users public key, allowing the userspace application to verify the caller is the same user that encrypted the object.</p>"},{"location":"docs/events/builtin/syscalls/request_key/#issues","title":"Issues","text":"<p>request_key could be vulnerable to TOCTOU attack, where the value of the object being updated is checked before the update and then changed before the update finishes its operations.</p>"},{"location":"docs/events/builtin/syscalls/request_key/#related-events","title":"Related Events","text":"<ul> <li>keyctl_describe_key - get information about a given key.</li> <li>keyctl_delete_key - delete a key.</li> <li>keyctl_read - read the contents of a key.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/restart_syscall/","title":"restart_syscall","text":""},{"location":"docs/events/builtin/syscalls/restart_syscall/#intro","title":"Intro","text":"<p>restart_syscall - Restarts a stopped system call that was previously interrupted by a signal</p>"},{"location":"docs/events/builtin/syscalls/restart_syscall/#description","title":"Description","text":"<p>The <code>restart_syscall</code> system call restarts a previously suspended system call using the <code>SA_RESTART</code> flag supplied when setting a signal handler with <code>sigaction</code>. This system call restarts the call which was previously interrupted using <code>sigprocmask</code> and allows execution to continue where it left off. This system call is useful in situations where a signal was handled by a signal handler, such as when a child process is killed, but without restarting the system call, execution could be left in an inconsistent state.</p>"},{"location":"docs/events/builtin/syscalls/restart_syscall/#arguments","title":"Arguments","text":"<ul> <li><code>None</code></li> </ul>"},{"location":"docs/events/builtin/syscalls/restart_syscall/#available-tags","title":"Available Tags","text":"<ul> <li>None</li> </ul>"},{"location":"docs/events/builtin/syscalls/restart_syscall/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/restart_syscall/#sys_restart_syscall","title":"sys_restart_syscall","text":""},{"location":"docs/events/builtin/syscalls/restart_syscall/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/restart_syscall/#purpose","title":"Purpose","text":"<p>Tracing restarted system calls to monitor the impact of signals in the system.</p>"},{"location":"docs/events/builtin/syscalls/restart_syscall/#example-use-case","title":"Example Use Case","text":"<p>Tracing restarted system calls to detect a system call that is taking too long to complete, or to determine how long it takes to restart a system call.</p>"},{"location":"docs/events/builtin/syscalls/restart_syscall/#issues","title":"Issues","text":"<p>There may be some system calls which cannot be restarted, and in those cases the <code>restart_syscall</code> system call may fail.</p>"},{"location":"docs/events/builtin/syscalls/restart_syscall/#related-events","title":"Related Events","text":"<ul> <li>sigaction</li> <li>sigprocmask</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/rmdir/","title":"rmdir","text":""},{"location":"docs/events/builtin/syscalls/rmdir/#intro","title":"Intro","text":"<p>rmdir - delete an empty directory</p>"},{"location":"docs/events/builtin/syscalls/rmdir/#description","title":"Description","text":"<p>The rmdir() system call deletes an empty directory. The directory must be empty, and the calling process must have the necessary permissions to delete it. It is possible to use relative pathnames to remove directories that are not in the current working directory.</p> <p>The rmdir() system call is often used to remove a parent directory that contains a now-unneeded subdirectory. For example, if an application creates a subdirectory \"foo\" under \"/tmp\", it should call rmdir() on \"/tmp/foo\" as soon as the subdirectory is no longer needed.</p>"},{"location":"docs/events/builtin/syscalls/rmdir/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char</code>* - The pathname of the directory to delete.</li> </ul>"},{"location":"docs/events/builtin/syscalls/rmdir/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/rmdir/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/rmdir/#do_rmdir","title":"do_rmdir","text":""},{"location":"docs/events/builtin/syscalls/rmdir/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/rmdir/#purpose","title":"Purpose","text":"<p>To inspect when an empty directory is deleted.</p>"},{"location":"docs/events/builtin/syscalls/rmdir/#example-use-case","title":"Example Use Case","text":"<p>Using rmdir in order to remove a directory created by an application after it is no longer needed.</p>"},{"location":"docs/events/builtin/syscalls/rmdir/#issues","title":"Issues","text":"<p>The rmdir system call will fail if the directory is not empty. Furthermore, it will not delete directories that contain files that have been unlinked, but are still open.</p>"},{"location":"docs/events/builtin/syscalls/rmdir/#related-events","title":"Related Events","text":"<ul> <li>unlink: to delete a file from a directory.</li> <li>rename: to rename or move a directory.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/rseq/","title":"rseq","text":""},{"location":"docs/events/builtin/syscalls/rseq/#intro","title":"Intro","text":"<p>rseq - registers a specified region in a given address space before user-level code execution.</p>"},{"location":"docs/events/builtin/syscalls/rseq/#description","title":"Description","text":"<p>rseq is a Linux syscall that enables user-level code to register and reserve a specific memory region for exclusive execution without outside interruption. It does this by reserving a specific address space for exclusive execution and using the kernel to enforce atomicity of this exclusive code region. The main purpose of rseq is to provide a lightweight concurrency mechanism for multithreaded applications. This syscall is useful when implementing certain performance optimizations, such as loop-level parallelism, where it is critical that only one thread is allowed to execute a specific region of code.</p> <p>The syscall takes a pointer to a region event structure (struct rseq), the length of that structure, an optional flags argument, and an optional signal argument. The flags are used to indicate what kind of operations the application wishes to perform, such as reading or writing memory. The signal argument allows the application to optionally specify a signal to be sent to the calling process if the operation fails.</p> <p>By using rseq, user-level code can register and reserve a specific memory region for exclusive execution that is guaranteed to return success or failure atomically.  It is important to note, however, that rseq is currently only supported on 64-bit x86 systems and Linux kernel versions 4.13 and later.</p>"},{"location":"docs/events/builtin/syscalls/rseq/#arguments","title":"Arguments","text":"<ul> <li><code>rseq</code>: <code>struct rseq*</code>[KU] - Pointer to the data structure used to specify a region for exclusive execution. </li> <li><code>rseq_len</code>: <code>u32</code>[KU] - Length of the data structure in bytes. Must be given as an argument for safety reasons.</li> <li><code>flags</code>: <code>int</code>[K] - Optional argument to indicate what kind of operations the application wishes to perform.</li> <li><code>sig</code>: <code>u32</code>[K] - Optional argument to specify a signal to be sent to the calling process if rseq fails.</li> </ul>"},{"location":"docs/events/builtin/syscalls/rseq/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/rseq/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/rseq/#do_rseq","title":"do_rseq","text":""},{"location":"docs/events/builtin/syscalls/rseq/#type","title":"Type","text":"<p>Kprobe.</p>"},{"location":"docs/events/builtin/syscalls/rseq/#purpose","title":"Purpose","text":"<p>retrieve the arguments for the syscall, then store them as part of the context related to the calling process</p>"},{"location":"docs/events/builtin/syscalls/rseq/#sys_rseq","title":"sys_rseq","text":""},{"location":"docs/events/builtin/syscalls/rseq/#type_1","title":"Type","text":"<p>Kprobe.</p>"},{"location":"docs/events/builtin/syscalls/rseq/#purpose_1","title":"Purpose","text":"<p>Verifiy that the parameters retrieved by the previous probe are valid before attempting to execute the actual system call.</p>"},{"location":"docs/events/builtin/syscalls/rseq/#example-use-case","title":"Example Use Case","text":"<p>rseq is useful when implementing certain performance optimizations, where it is critical that only one thread is allowed to execute a specific region of code. An example would be loop-level parallelism, where a programmer can take advantage of multiple CPU cores to increase the performance of loops. </p>"},{"location":"docs/events/builtin/syscalls/rseq/#issues","title":"Issues","text":"<p>rseq is currently only supported on 64-bit x86 systems and Linux kernel versions 4.13 and later. It is also not yet supported on memory model architectures, like ARM.</p>"},{"location":"docs/events/builtin/syscalls/rseq/#related-events","title":"Related Events","text":"<p>The <code>rseq</code> system call can be used in conjunction with the <code>set_tid_address</code> system call to create a reliable thread-local region event.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigaction/","title":"rt_sigaction","text":""},{"location":"docs/events/builtin/syscalls/rt_sigaction/#intro","title":"Intro","text":"<p>rt_sigaction - install or confirm action for specified signal.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigaction/#description","title":"Description","text":"<p><code>rt_sigaction</code> is a system call that changes the action taken by a process on receipt of a specific signal. Signal actions are explained in signal(7).</p> <p>Using <code>rt_sigaction</code>, a process can specify the action to be taken when a specific signal is delivered. This can include ignoring the signal, catching it with a signal handler, or setting a flag in the process's signal mask. </p> <p><code>rt_sigaction</code> is available on Linux systems and is a more recent, improved way of setting signal handlers compared to <code>signal</code> syscall. It can be used to install signal handlers that take an extra parameter, an <code>ucontext_t *</code>, which will be used by the handler to store the context of the signal where it was caught.</p> <p>The main advantage of using this system call over the <code>signal</code> syscall is that it allows for the setting of a real-time signal, in addition to the usual POSIX signals. A critical limitation of the <code>signal</code> syscall is that it does not provide a way to set real-time signals, which are useful for applications needing to respond quickly to events.</p> <p><code>rt_sigaction</code> is also useful for working with signals that have been registered using <code>sigaction</code>. For example, <code>sigaction</code> can be used to register a signal handler, but <code>rt_sigaction</code> is the only way to retrieve the currently installed signal handler. </p>"},{"location":"docs/events/builtin/syscalls/rt_sigaction/#arguments","title":"Arguments","text":"<ul> <li><code>signum</code>:int[K] - Signal to be handled, which can either be a POSIX signal or real-time signal.</li> <li><code>act</code>:const struct sigaction*[K] - New signal action, or NULL to restore default action.</li> <li><code>oldact</code>:struct sigaction*[K] - Output parameter which will return the previous signal action, or NULL if not required.</li> <li><code>sigsetsize</code>:size_t[K] - Size of the sigset specified by <code>act</code> in bytes.</li> </ul>"},{"location":"docs/events/builtin/syscalls/rt_sigaction/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/rt_sigaction/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/rt_sigaction/#do_signal","title":"do_signal","text":""},{"location":"docs/events/builtin/syscalls/rt_sigaction/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/rt_sigaction/#purpose","title":"Purpose","text":"<p>Hook function to capture signal handler changes made using <code>rt_sigaction</code> syscall. </p>"},{"location":"docs/events/builtin/syscalls/rt_sigaction/#signal_deliver_stop","title":"signal_deliver_stop","text":""},{"location":"docs/events/builtin/syscalls/rt_sigaction/#type_1","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/rt_sigaction/#purpose_1","title":"Purpose","text":"<p>Hook function to capture signals as they are delivered to the process. </p>"},{"location":"docs/events/builtin/syscalls/rt_sigaction/#example-use-case","title":"Example Use Case","text":"<p><code>rt_sigaction</code> can be used to enable a process to react quickly to a signal sent from another process, or another thread in the same process. For example, a signal handler can be registered with <code>rt_sigaction</code> that sets a flag when the signal is received. The flag can then be checked in an application loop, and its presence will trigger an action. </p>"},{"location":"docs/events/builtin/syscalls/rt_sigaction/#issues","title":"Issues","text":"<p>It is possible to register a signal handler using <code>rt_sigaction</code> that does not take an additional parameter for the <code>ucontext_t *</code>, even though this parameter is required for real-time signals. While this will work for most OS versions without failing, this may cause unexpected results or failures on some systems. </p>"},{"location":"docs/events/builtin/syscalls/rt_sigaction/#related-events","title":"Related Events","text":"<p><code>signal</code>, <code>rt_sigprocmask</code></p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigpending/","title":"rt_sigpending","text":""},{"location":"docs/events/builtin/syscalls/rt_sigpending/#intro","title":"Intro","text":"<p>rt_sigpending - examine a pending signal mask</p>"},{"location":"docs/events/builtin/syscalls/rt_sigpending/#description","title":"Description","text":"<p>The rt_sigpending() system call asks the kernel to store the currently pending signal set for the calling process in the location pointed to by <code>set</code>. The <code>sigsetsize</code> argument specifies the size (in bytes) of the memory pointed to by <code>set</code>.</p> <p>The purpose of this system call is to allow applications to examine the set of signals which are currently blocked for the caller's execution. This could be useful for synchronizing processes waiting on signals, or to simply query their signal state.</p> <p>There are some edge cases or drawbacks to using rt_sigpending, particularly with regard to thread-safe signal handling. If the signal set in <code>set</code> is not protected by a mutex or other thread-safe mechanisms, multiple threads may race to modify the signal set and cause unexpected results. Furthermore, the kernel may not be able to accurately detect any pending signals if an application handles them with a signal handler, as the pending signals may be consumed before the kernel can list them.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigpending/#arguments","title":"Arguments","text":"<ul> <li><code>set</code>:<code>sigset_t*</code>[U] - pointer to a sigset_t type in user space.</li> <li><code>sigsetsize</code>:<code>size_t</code>[K] - The size of the <code>set</code> argument in bytes.</li> </ul>"},{"location":"docs/events/builtin/syscalls/rt_sigpending/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/rt_sigpending/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/rt_sigpending/#do_rt_sigpending","title":"do_rt_sigpending","text":""},{"location":"docs/events/builtin/syscalls/rt_sigpending/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/rt_sigpending/#purpose","title":"Purpose","text":"<p>The do_rt_sigpending() function is the kernel entry point for the rt_sigpending system call. It is responsible for copying the set of pending signals for the calling process into the location pointed to by <code>set</code>. It is hooked with a Kprobe to provide userspace visibility into the details of pending signal sets.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigpending/#example-use-case","title":"Example Use Case","text":"<p>An example use case for rt_sigpending() is to query the current blocked signal set of the calling process. This is useful to synchronize processes waiting on signals, or to simply query the process's blocked signal state.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigpending/#issues","title":"Issues","text":"<p>No issues have been identified with the rt_sigpending system call.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigpending/#related-events","title":"Related Events","text":"<ul> <li>sighandler - Set a signal handler for a given signal. May be useful to set a handler for the signal which is blocked.</li> <li>sigprocmask - Examine or change the blocked signal set of the calling process.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigprocmask/","title":"rt_sigprocmask","text":""},{"location":"docs/events/builtin/syscalls/rt_sigprocmask/#intro","title":"Intro","text":"<p>rt_sigprocmask - examine and change a signal mask</p>"},{"location":"docs/events/builtin/syscalls/rt_sigprocmask/#description","title":"Description","text":"<p>rt_sigprocmask is a system call used to examine and change a signal mask for a process. The signal mask is a set of signals used to control what signals are blocked and thus not delivered to a process. It also allows for the manipulation of the process' signal mask atomically (in one instruction). The rt_sigprocmask system call is a realtime version of the sigprocmask system call, and will preserve the realtime signals.</p> <p>There are some edge cases to be aware of when using rt_sigprocmask. For example, if the sigsetsize parameter is greater than the size of a sigset_t (128 bytes on 64-bit architectures), then the call will fail with EINVAL.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigprocmask/#arguments","title":"Arguments","text":"<ul> <li><code>how</code>:<code>int</code> - Specifies how the signal mask is to be changed. It is one of the following constants:</li> <li>SIG_BLOCK: The resulting set is the union of the current set and the set argument.</li> <li>SIG_UNBLOCK: The resulting set is the intersection of the current set and the complement of the set argument.</li> <li>SIG_SETMASK: The resulting set is the set argument.</li> <li><code>set</code>:<code>sigset_t*</code>[K] - Pointer to a signal set whose elements will be added (SIG_BLOCK) or deleted (SIG_UNBLOCK) from the current set.</li> <li><code>oldset</code>:<code>sigset_t*</code> - Pointer to a signal set which will be filled with the old signal mask.</li> <li><code>sigsetsize</code>:<code>size_t</code> - The size of the signal set oldset in bytes.</li> </ul>"},{"location":"docs/events/builtin/syscalls/rt_sigprocmask/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/rt_sigprocmask/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/rt_sigprocmask/#do_rt_sigprocmask","title":"do_rt_sigprocmask","text":""},{"location":"docs/events/builtin/syscalls/rt_sigprocmask/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/rt_sigprocmask/#purpose","title":"Purpose","text":"<p>This function is hooked to enable monitoring of the behavior of the rt_sigprocmask system call. With this hook, you can monitor when the system call is called and how long the call takes.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigprocmask/#example-use-case","title":"Example Use Case","text":"<p>One example of where this event could be useful is in monitoring system calls for benchmarking applications. By monitoring the rt_sigprocmask system call you can measure how long this system call takes to execute, which can give an indication of how fast the overall application is.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigprocmask/#issues","title":"Issues","text":"<p>One issue to be aware of when using this system call is that it is vulnerable to a time-of-check-to-time-of-use (TOCTOU) race condition due to the fact that the signal mask can be changed between the time of the check and the time of the use.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigprocmask/#related-events","title":"Related Events","text":"<ul> <li>rt_sigaction()</li> <li>sigprocmask()</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigqueueinfo/","title":"rt_sigqueueinfo","text":""},{"location":"docs/events/builtin/syscalls/rt_sigqueueinfo/#intro","title":"Intro","text":"<p>rt_sigqueueinfo - send a signal with associated data to a thread</p>"},{"location":"docs/events/builtin/syscalls/rt_sigqueueinfo/#description","title":"Description","text":"<p>The <code>rt_sigqueueinfo()</code> system call sends a signal, <code>sig</code>, and associated data, <code>info</code>, to the thread identified by <code>tgid</code>. This call is like <code>kill()</code>, but allows to pass the extra data.</p> <p>Compared to <code>sigqueue()</code>, the <code>info</code> is passed as a pointer rather than an argument.</p> <p>The <code>siginfo_t</code>data type typically includes signal information such as signal number and sender information. </p> <p>In  kernels prior to 2.6.9, the <code>info</code> argument is limited to a <code>si_value</code> value, which indicate the signal value.</p> <p>Using <code>rt_sigqueueinfo</code> has some advantages: * It can pass the additional data, such as <code>si_value</code>, for signal information. * Its use is thread-safe.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigqueueinfo/#arguments","title":"Arguments","text":"<ul> <li><code>tgid</code>:<code>pid_t</code>[K] - thread group identifier for which signal is to be sent.</li> <li><code>sig</code>:<code>int</code>[U] - signal to be sent.</li> <li><code>info</code>:<code>siginfo_t*</code>[U] - signal info.</li> </ul>"},{"location":"docs/events/builtin/syscalls/rt_sigqueueinfo/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/rt_sigqueueinfo/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/rt_sigqueueinfo/#do_sigaction","title":"do_sigaction","text":""},{"location":"docs/events/builtin/syscalls/rt_sigqueueinfo/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/rt_sigqueueinfo/#purpose","title":"Purpose","text":"<p>To get the signal information before being sent.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigqueueinfo/#example-use-case","title":"Example Use Case","text":"<p>An example use case of rt_sigqueueinfo is when an application needs to send a signal with data from kernel-space to a thread in user-space.  It can be used to report information about a critical event or abort a process.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigqueueinfo/#issues","title":"Issues","text":"<ul> <li>The signal info (<code>siginfo_t</code>) is limited to a <code>si_value</code> value for kernels   prior to 2.6.9.</li> <li>The third argument, <code>info</code>, is a pointer to user space. Therefore, information   from user space might not be reliable, as it might be subject to TOCTOU   attacks.</li> </ul>"},{"location":"docs/events/builtin/syscalls/rt_sigqueueinfo/#related-events","title":"Related Events","text":"<ul> <li><code>kill()</code> - send a signal to a process.</li> <li><code>sigqueue()</code> - send a signal with data to a process or thread.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigreturn/","title":"rt_sigreturn","text":""},{"location":"docs/events/builtin/syscalls/rt_sigreturn/#intro","title":"Intro","text":"<p>rt_sigreturn - System call to return from user-owned signal handlers</p>"},{"location":"docs/events/builtin/syscalls/rt_sigreturn/#description","title":"Description","text":"<p>The <code>rt_sigreturn</code> system call restores the caller's user-space context previously saved by the kernel at the occurrence of a signal. It is used on architectures that don't store the user-space registers (in particular context) when a signal handler is invoked by the kernel, so the user-space has to do it instead. After restoring the context, the <code>rt_sigreturn</code> call will return to the address the execution was at before the signal happened. </p> <p>It's important to note that returning from a signal handler or restarting a system call instead of executing a <code>sigreturn</code> call may be a source of bugs which could lead to privilege escalation or other vulnerabilites. In addition, due to the race conditions which are present due to the nature of the signal handling in Linux, it is vulnerable to TOCTOU attacks as noted below.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigreturn/#arguments","title":"Arguments","text":"<ul> <li><code>ustack</code>:<code>pointer</code>[KU] - Pointer to the user-space signal stack context. The signal stack context is defined by each architecture.</li> </ul>"},{"location":"docs/events/builtin/syscalls/rt_sigreturn/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> </ul>"},{"location":"docs/events/builtin/syscalls/rt_sigreturn/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/rt_sigreturn/#sys_rt_sigreturn","title":"sys_rt_sigreturn","text":""},{"location":"docs/events/builtin/syscalls/rt_sigreturn/#type","title":"Type","text":"<p>Trampoline</p>"},{"location":"docs/events/builtin/syscalls/rt_sigreturn/#purpose","title":"Purpose","text":"<p>To capture the context when a signal handler exits.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigreturn/#example-use-case","title":"Example Use Case","text":"<p>An example use-case for <code>rt_sigreturn</code> is for tracing signal handler return paths, for example for debugging purposes or for catching vulnerabilities. All the user-space registers and the stack content used when the signal handler was called can be obtained from the <code>ustack</code> argument. This data could be used in order to detect if a bug or an exploit has been triggered. </p>"},{"location":"docs/events/builtin/syscalls/rt_sigreturn/#issues","title":"Issues","text":"<p><code>rt_sigreturn</code> can be used in an attempt of privilege escalation if an attacker can find a way to modify the <code>ustack</code> argument which is only present in kernel-space. In addition, <code>rt_sigreturn</code> is vulnerable to TOCTOU (time of check, time of use) attacks, since it can be interrupted before the operation is completely finished.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigreturn/#related-events","title":"Related Events","text":"<ul> <li>signal - system call used to send signals to processes.</li> <li>signal handler - signal handlers are functions called by the kernel when a signal is delivered.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigsuspend/","title":"rt_sigsuspend","text":""},{"location":"docs/events/builtin/syscalls/rt_sigsuspend/#intro","title":"Intro","text":"<p>rt_sigsuspend - temporarily replace the signal mask and wait for a signal</p>"},{"location":"docs/events/builtin/syscalls/rt_sigsuspend/#description","title":"Description","text":"<p>The rt_sigsuspend() system call is used to temporarily replace the signal mask of the calling process and wait for a signal to be delivered. It is a layer on top of the sigprocmask() system call which atomically performs the operations of replacing the signal mask and suspending execution of the calling thread. It is mostly used in signal handlers when temporarily blocking the signal the handler is responding to.</p> <p>The main advantage of this system call is that it does not require the user to pass the current blockmask when temporarily replacing it.</p> <p>However, there are some drawbacks when using rt_sigsuspend(). Firstly, the process resumes execution from the same address it was interrupted in (as opposed to other system calls such as sigsuspend() which resumes execution from the start of the signal handler). This can lead to the atomicity issues when signals are delivered while the process is trying to do several operations, leading to inconsistent states. Secondly, it can only be used in signal handlers and is not appropriate for other synchronisation tasks.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigsuspend/#arguments","title":"Arguments","text":"<ul> <li><code>mask</code>:<code>sigset_t*</code>[K, U] - pointer to user space memory which holds the signal mask to be replaced.</li> <li><code>sigsetsize</code>:<code>size_t</code>[K] - size of the mask in bytes.</li> </ul>"},{"location":"docs/events/builtin/syscalls/rt_sigsuspend/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/rt_sigsuspend/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/rt_sigsuspend/#do_rt_sigsuspend","title":"do_rt_sigsuspend","text":""},{"location":"docs/events/builtin/syscalls/rt_sigsuspend/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/rt_sigsuspend/#purpose","title":"Purpose","text":"<p>Tracing when the rt_sigsuspend system call is executed. </p>"},{"location":"docs/events/builtin/syscalls/rt_sigsuspend/#example-use-case","title":"Example Use Case","text":"<p>Tracing when a process invokes the rt_sigsuspend system call.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigsuspend/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigsuspend/#related-events","title":"Related Events","text":"<ul> <li>sigprocmask - get blocked signals or set blocked signals</li> <li>sigsuspend - suspend process until signal</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait/","title":"rt_sigtimedwait","text":""},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait/#intro","title":"Intro","text":"<p>rt_sigtimedwait - a system call that waits for a signal to arrive</p>"},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait/#description","title":"Description","text":"<p>rt_sigtimedwait is a system call that atomically waits for a signal to arrive and removes the signal from the queue. It operates similarly to the pselect() system call, except it waits for a signal instead of a file descriptor to become readable and writable. The set parameter specifies the set of signals to wait for, info points to a structure where information about the signal caught is stored, timeout specifies an upper limit on the amount of time that the call should block, and sigsetsize specifies the size of the signal set in bytes. </p> <p>This system call should not be used if the signal being waited for is handled by a signal handler registered by sigaction(). In such cases, the signal is delivered directly to the signal handler instead of the process's signal queue.</p> <p>The event can cause the calling process to sleep until the signal is received or the timeout has reached. Additionally, real-time signals that are not caught or ignored by the process may cause it to terminate.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait/#arguments","title":"Arguments","text":"<ul> <li><code>set</code>:<code>const sigset_t*</code>[K] - a pointer to a structure to examine a set of signals that the process may be waiting for.</li> <li><code>info</code>:<code>siginfo_t*</code>[U] - a pointer to a structure where information about the signal caught is stored.</li> <li><code>timeout</code>:<code>const struct timespec*</code>[K] - a pointer to a structure that specifies an upper limit on the amount of time that the call should block.</li> <li><code>sigsetsize</code>:<code>size_t</code>[K] - the size of the signal set in bytes.</li> </ul>"},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait/#rt_sigtimedwait_1","title":"rt_sigtimedwait","text":""},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait/#type","title":"Type","text":"<p>Kernel function</p>"},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait/#purpose","title":"Purpose","text":"<p>Hooked to monitor the use and arguments of the system call.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait/#example-use-case","title":"Example Use Case","text":"<p>rt_sigtimedwait can be used to create a timeout mechanism by waiting for a signal in a loop. </p>"},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait/#issues","title":"Issues","text":"<p>One of the key drawbacks of using rt_sigtimedwait is that the process may sleep until the signal arrives or the timeout has been reached, which may be undesirable in cases where having a responsive application is important.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait/#related-events","title":"Related Events","text":"<ul> <li>sigaction() - the system call to register a signal handler</li> <li>sigprocmask() - the system call to examine and change the currently blocked signals</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait_time32/","title":"rt_sigtimedwait_time32","text":""},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait_time32/#intro","title":"Intro","text":"<p>rt_sigtimedwait_time32 - wait synchronously for queued signals arising within a given time</p>"},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait_time32/#description","title":"Description","text":"<p>rt_sigtimedwait_time32 is a system call that allows waiting for one of the pending signals occurring in the signal set <code>uthese</code> with a timeout of <code>uts</code>, which is rounded up to the system clock granularity (specified by <code>uts</code>). The signal's number and its associated <code>uinfo</code> are returned in the <code>uinfo</code> argument if available. <code>sigsetsize</code> is used to indicate size in bytes of the signal set pointed by <code>uthese</code>. Status of the signal for which the call was unblocked is returned. The time is limited by the <code>uts-&gt;tv_sec</code> and <code>uts-&gt;tv_nsec</code> arguments. If timeout is set to 0 and no signals are present on the queue, then this will cause an error. </p> <p>This system call provides an easy to use way to wait for signals that arrive over a short period of time with the benefit of minimizing the chances of missing them.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait_time32/#arguments","title":"Arguments","text":"<ul> <li><code>uthese</code>:<code>sigset_t*</code> - pointer to a signal set containing the signals which are to be waited for. <li><code>uinfo</code>:<code>siginfo_t*</code>[K] - pointer to a <code>siginfo_t</code> structure to store the information about the signal, may be <code>NULL</code>.</li> <li><code>uts</code>:<code>struct old_timespec32*</code>[K] - a structure that specifies the end time for the timeout, may be <code>NULL</code>.</li> <li><code>sigsetsize</code>:<code>size_t</code>[K] - number of bytes in the signal set pointed to by <code>uthese</code>.</li>"},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait_time32/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value) </li> </ul>"},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait_time32/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait_time32/#do_sigtimedwait","title":"do_sigtimedwait","text":""},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait_time32/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait_time32/#purpose","title":"Purpose","text":"<p>This function is hooked to measure the time it takes for each time <code>rt_sigtimedwait_time32</code> system call is executed.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait_time32/#old_sigaction","title":"old_sigaction","text":""},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait_time32/#type_1","title":"Type","text":"<p>Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait_time32/#purpose_1","title":"Purpose","text":"<p>This function is hooked to record some information related to the signals and their structure when it is used in conjunctiob with the <code>rt_sigtimedwait_time32</code> system call.</p>"},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait_time32/#example-use-case","title":"Example Use Case","text":"<p>The rt_sigtimedwait_time32 system call can be used to wait on synchronous signals arrivals with a given timeout, which is useful in workflows and systems which depend on real-time performance. </p>"},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait_time32/#issues","title":"Issues","text":"<p>rt_sigtimedwait_time32 is susceptible to TOCTOU (time of check, time of use), because between the check and the actual use of the signal, the signal might change. </p>"},{"location":"docs/events/builtin/syscalls/rt_sigtimedwait_time32/#related-events","title":"Related Events","text":"<ul> <li>rt_sigtimedwait</li> <li>rt_sigprocmask</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/rt_tgsigqueueinfo/","title":"rt_tgsigqueueinfo","text":""},{"location":"docs/events/builtin/syscalls/rt_tgsigqueueinfo/#intro","title":"Intro","text":"<p>rt_tgsigqueueinfo - send signal information to a specific thread in a specific process.</p>"},{"location":"docs/events/builtin/syscalls/rt_tgsigqueueinfo/#description","title":"Description","text":"<p>The rt_tgsigqueueinfo() system call sends the signal sig with the additional information provided in info to any thread with the thread ID tid, who is part of the process with process ID tgid.</p> <p>This syscall was developed to create a non-intrusive way to work with threads, not to risk them being suddenly paused or interrupted, as those events could cause lost progress.</p>"},{"location":"docs/events/builtin/syscalls/rt_tgsigqueueinfo/#arguments","title":"Arguments","text":"<ul> <li><code>tgid</code>:<code>pid_t</code> - the process ID (tgid) of the targeted process.</li> <li><code>tid</code>:<code>pid_t</code> - the thread ID (tid) of the targeted thread within the process identified by tgid.</li> <li><code>sig</code>:<code>int</code> - the signal to send.</li> <li><code>info</code>:<code>siginfo_t*</code>[K U] - Data to be sent to the thread, defined in a _siginfo_t struct.</li> </ul>"},{"location":"docs/events/builtin/syscalls/rt_tgsigqueueinfo/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/rt_tgsigqueueinfo/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/rt_tgsigqueueinfo/#do_rt_tgsigqueueinfo","title":"do_rt_tgsigqueueinfo","text":""},{"location":"docs/events/builtin/syscalls/rt_tgsigqueueinfo/#type","title":"Type","text":"<p>Kprobe.</p>"},{"location":"docs/events/builtin/syscalls/rt_tgsigqueueinfo/#purpose","title":"Purpose","text":"<p>To trace the system calls and arguments of this event.</p>"},{"location":"docs/events/builtin/syscalls/rt_tgsigqueueinfo/#example-use-case","title":"Example Use Case","text":"<p>The rt_tgsigqueueinfo() system call can be used to send a signal to a specific thread within a specific process. This is often used for communication within multithreaded programs, or for debugging purposes.</p>"},{"location":"docs/events/builtin/syscalls/rt_tgsigqueueinfo/#issues","title":"Issues","text":"<p>Due to the non-intrusive nature of this system call, there may be issues with latency as it does not force a thread to accept the signal if not ready for it.</p>"},{"location":"docs/events/builtin/syscalls/rt_tgsigqueueinfo/#related-events","title":"Related Events","text":"<ul> <li>sigaction() - Used to set up a signal handler.</li> <li>waitid() - Used to wait for a thread to stop or signal to be delivered.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sched_get_priority_max/","title":"<code>sched_get_priority_max</code>","text":""},{"location":"docs/events/builtin/syscalls/sched_get_priority_max/#intro","title":"Intro","text":"<p><code>sched_get_priority_max</code> - get the maximum priority value for a given scheduling policy</p>"},{"location":"docs/events/builtin/syscalls/sched_get_priority_max/#description","title":"Description","text":"<p>The <code>sched_get_prority_max</code> function returns the maximum priority value allowed by a given scheduling policy. It is used to obtain the highest allowed scheduling priority for the specified policy of a particular process.</p> <p><code>sched_get_priority_max</code> is most commonly used in combination with the <code>sched_get_priority_min</code> syscall, which returns the minimum priority value allowed by a given policy. Together, the two syscalls allow the range of valid scheduling priorities to be determined. It returns the maximum value allowed according to the operating systems configuration, but this value may be limited by the user or system.</p>"},{"location":"docs/events/builtin/syscalls/sched_get_priority_max/#arguments","title":"Arguments","text":"<ul> <li><code>policy</code>: <code>int</code>[K] - Specifies the scheduling policy for which the maximum priority value is to be returned. </li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_get_priority_max/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_get_priority_max/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sched_get_priority_max/#sched_get_priority_max_1","title":"<code>sched_get_priority_max</code>","text":""},{"location":"docs/events/builtin/syscalls/sched_get_priority_max/#type","title":"Type","text":"<p>kprobes </p>"},{"location":"docs/events/builtin/syscalls/sched_get_priority_max/#purpose","title":"Purpose","text":"<p>To obtain the maximum priority value for a given scheduling policy.</p>"},{"location":"docs/events/builtin/syscalls/sched_get_priority_max/#example-use-case","title":"Example Use Case","text":"<p>This syscall can be used to get task or thread priority values in order to properly manage the scheduling of threads in a system.</p>"},{"location":"docs/events/builtin/syscalls/sched_get_priority_max/#issues","title":"Issues","text":"<p>N/A</p>"},{"location":"docs/events/builtin/syscalls/sched_get_priority_max/#related-events","title":"Related Events","text":"<ul> <li><code>sched_get_priority_min</code> - get the minimum priority value for a given scheduling policy.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sched_get_priority_min/","title":"sched_get_priority_min","text":""},{"location":"docs/events/builtin/syscalls/sched_get_priority_min/#intro","title":"Intro","text":"<p>sched_get_priority_min - returns the minimum priority value that can be used with the scheduling policy</p>"},{"location":"docs/events/builtin/syscalls/sched_get_priority_min/#description","title":"Description","text":"<p>This system call is used to get the minimum priority value that can be used when using the scheduling policy mentioned as the parameter. This call will usually return -1 if the policy is invalid, and will return the minimum priority value that can be used with the scheduling policy upon successful completion. </p> <p>There are a few drawbacks when using this system call. Firstly, it may be too restrictive in that it is limited to only one scheduling policy, meaning if multiple scheduling policies are used, multiple separate calls are needed. Additionally, the accuracy of the minimum priority value depends on the implementation of the OS, and may not be as precise as desired. </p>"},{"location":"docs/events/builtin/syscalls/sched_get_priority_min/#arguments","title":"Arguments","text":"<ul> <li><code>policy</code>:<code>int</code>[K] - a scheduling policy identified by an integer.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_get_priority_min/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_get_priority_min/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sched_get_priority_min/#sched_get_priority_min_1","title":"sched_get_priority_min","text":""},{"location":"docs/events/builtin/syscalls/sched_get_priority_min/#type","title":"Type","text":"<p>Kprobe.</p>"},{"location":"docs/events/builtin/syscalls/sched_get_priority_min/#purpose","title":"Purpose","text":"<p>To inform the user of the minimum priority value that can be used in the given scheduling policy.</p>"},{"location":"docs/events/builtin/syscalls/sched_get_priority_min/#example-use-case","title":"Example Use Case","text":"<p>This system call can be utilized to define the limits on the chosen priorities for various threads in a multithreading application.</p>"},{"location":"docs/events/builtin/syscalls/sched_get_priority_min/#issues","title":"Issues","text":"<p>There can be a margin of error present when considering the minimum priority values, depending on the implementation of the OS. </p>"},{"location":"docs/events/builtin/syscalls/sched_get_priority_min/#related-events","title":"Related Events","text":"<p>sched_get_priority_max, sched_setscheduler, sched_setparam</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sched_getaffinity/","title":"sched_getaffinity","text":""},{"location":"docs/events/builtin/syscalls/sched_getaffinity/#intro","title":"Intro","text":"<p>sched_getaffinity - retrieve the CPU affinity of a process</p>"},{"location":"docs/events/builtin/syscalls/sched_getaffinity/#description","title":"Description","text":"<p>The sched_getaffinity() system call retrieves the CPU affinity mask of the process whose ID is specified in pid, and places it in the cpusetsize bytes of memory pointed to by mask. </p> <p>The CPU affinity mask is a bit mask where each bit represents a CPU that the process is able to execute on. A set bit signifies that a CPU is able to be used while an unset bit signifies that the CPU is unavailable.  The argument cpusetsize is the size of the mask pointed to by mask and must not be smaller than the size of the kernel's internal CPU mask, returned by sysconf(_SC_NPROCESSORS_ONLN).</p> <p>This system call is useful for optimizing the process's compatibility when switching between systems with different numbers of processors.</p>"},{"location":"docs/events/builtin/syscalls/sched_getaffinity/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>pid_t</code>[U] - process ID of the thread whose affinity is to be retrieved.</li> <li><code>cpusetsize</code>:<code>size_t</code>[U] - number of bytes in the bitmask pointed to by mask.</li> <li><code>mask</code>:<code>unsigned long*</code>[U] - pointer to a bit mask for the CPUs on which the thread may run.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_getaffinity/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_getaffinity/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sched_getaffinity/#sys_sched_getaffinity","title":"sys_sched_getaffinity()","text":""},{"location":"docs/events/builtin/syscalls/sched_getaffinity/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/sched_getaffinity/#purpose","title":"Purpose","text":"<p>To monitor the state of CPU affinity for different threads. </p>"},{"location":"docs/events/builtin/syscalls/sched_getaffinity/#example-use-case","title":"Example Use Case","text":"<p>An example of a use case for this system call would be to ensure that a user's thread or process is only running on one CPU or multiple CPUs across different physical processors. </p>"},{"location":"docs/events/builtin/syscalls/sched_getaffinity/#issues","title":"Issues","text":"<p>The most common issue with this system call is when the size of the mask pointed to by mask is not sufficient to contain the kernel's internal CPU mask, leading to truncation of the actual CPU mask.</p>"},{"location":"docs/events/builtin/syscalls/sched_getaffinity/#related-events","title":"Related Events","text":"<ul> <li>sched_setaffinity(): Set the CPU affinity mask of a process</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sched_getattr/","title":"sched_getattr","text":""},{"location":"docs/events/builtin/syscalls/sched_getattr/#intro","title":"Intro","text":"<p>sched_getattr - Retrieve scheduling policy and attributes from a given process.</p>"},{"location":"docs/events/builtin/syscalls/sched_getattr/#description","title":"Description","text":"<p>The <code>sched_getattr()</code> system call retrieves the scheduling policy and attributes of a given process. It allows for retrieving of scheduling policy and attributes of other processes, if given the appropriate privileges. It supports the following flags: <code>SCHED_FLAG_KEEP_POLICY</code>, <code>SCHED_FLAG_KEEP_PARAMS</code>, and <code>SCHED_FLAG_ALLOW_NULL</code>. The <code>attr</code> argument is a pointer to a <code>struct sched_attr</code>, which stores the scheduling parameters.</p> <p>The <code>sched_getattr()</code> system call retrieves the scheduling attributes of the given process. When used with the <code>SCHED_FLAG_KEEP_POLICY</code> and <code>SCHED_FLAG_KEEP_PARAMS</code> flags, this allows for retrieving of scheduling policy and attributes of other processes, if given the appropriate privileges.</p>"},{"location":"docs/events/builtin/syscalls/sched_getattr/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>pid_t</code>[K] - The pid of the process to query.</li> <li><code>attr</code>:<code>struct sched_attr*</code>[K] - A pointer to a <code>struct sched_attr</code> where the retrieved attributes will be stored.</li> <li><code>size</code>:<code>unsigned int</code>[K] - The size of the <code>struct sched_attr</code> in bytes.</li> <li><code>flags</code>:<code>unsigned int</code>[K] - Flags specifying how the scheduling attributes should be retrieved, allowed values are <code>SCHED_FLAG_KEEP_POLICY</code>, <code>SCHED_FLAG_KEEP_PARAMS</code>, and <code>SCHED_FLAG_ALLOW_NULL</code>.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_getattr/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_getattr/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sched_getattr/#sys_sched_getattr","title":"<code>sys_sched_getattr</code>","text":""},{"location":"docs/events/builtin/syscalls/sched_getattr/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/sched_getattr/#purpose","title":"Purpose","text":"<p>To monitor retrieval of scheduling attributes of a given process.</p>"},{"location":"docs/events/builtin/syscalls/sched_getattr/#example-use-case","title":"Example Use Case","text":"<p>An administrator who needs to monitor scheduling policies of other processes.</p>"},{"location":"docs/events/builtin/syscalls/sched_getattr/#issues","title":"Issues","text":"<p>This system call requires appropriate privileges in order to monitor processes of other users.</p>"},{"location":"docs/events/builtin/syscalls/sched_getattr/#related-events","title":"Related Events","text":"<ul> <li><code>sched_setattr</code> - Set scheduling policy and attributes for a given process. </li> <li><code>sched_setscheduler</code> - Set the scheduling policy for a given process.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sched_getparam/","title":"sched_getparam","text":""},{"location":"docs/events/builtin/syscalls/sched_getparam/#intro","title":"Intro","text":"<p>sched_getparam - fetch scheduling parameters of the target process</p>"},{"location":"docs/events/builtin/syscalls/sched_getparam/#description","title":"Description","text":"<p>sched_getparam is a function used to modify the scheduling parameters of the target process with the given pid according to the changes specified in the second argument, the parameters of the used scheduling policy. It is often used by system administrators to make sure that a certain process is always given the same priority relative to other processes on the system.</p> <p>One of the advantages of using this function over other methods of setting policy parameters is that it works with any policy, regardless of the number of parameters. This can save time when configuring policies that have a large number of parameters, as the system administrator does not have to manually set each parameter individually.</p> <p>One of the drawbacks is that it is not an atomic operation. If the pid argument provided is the same as the pid of the calling process, then the operation may take a relatively long time, as the operation must first be carried out on the caller's process, then on the target process. This operation can also lead to race conditions if the pid of the calling process and the pid of the target process are both the same.</p>"},{"location":"docs/events/builtin/syscalls/sched_getparam/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:pid_t[K] - pid of the process to query the parameters of.</li> <li><code>param</code>:struct sched_param*[K+U] - pointer to a struct sched_param to store the policy information in.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_getparam/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_getparam/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sched_getparam/#do_sys_sched_getparam","title":"do_sys_sched_getparam","text":""},{"location":"docs/events/builtin/syscalls/sched_getparam/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/sched_getparam/#purpose","title":"Purpose","text":"<p>Collecting information about the scheduling parameters of a particular process.</p>"},{"location":"docs/events/builtin/syscalls/sched_getparam/#example-use-case","title":"Example Use Case","text":"<p>sched_getparam can be used in a monitoring process which keeps track of the scheduling parameters of processes, in order to ensure that they do not \"starve\" in terms of resources and can run to completion.</p>"},{"location":"docs/events/builtin/syscalls/sched_getparam/#issues","title":"Issues","text":"<p>The operation is not atomic, which may lead to race conditions with multiple threads trying to access the same process.</p>"},{"location":"docs/events/builtin/syscalls/sched_getparam/#related-events","title":"Related Events","text":"<ul> <li>sched_setscheduler - set scheduling policy and parameters of the target process </li> <li>sched_get_priority_min - get the minimum priority value for the given scheduling policy</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sched_getscheduler/","title":"sched_getscheduler","text":""},{"location":"docs/events/builtin/syscalls/sched_getscheduler/#intro","title":"Intro","text":"<p>sched_getscheduler - Retrieve the scheduling policy of a process.</p>"},{"location":"docs/events/builtin/syscalls/sched_getscheduler/#description","title":"Description","text":"<p>The sched_getscheduler() system call retrieves the scheduling policy currently applied to the process identified by pid. If pid is zero, the policy of the calling process is retrieved. </p> <p>The available scheduling policies are: * SCHED_OTHER - the traditional time-sharing policy. * SCHED_FIFO   - a first-in, first-out policy * SCHED_RR     - a round-robin policy</p> <p>sched_getscheduler() can be used to retrieve the currently used scheduling policy for any process, allowing for the comparison of different policies for a process or for multiple processes.</p>"},{"location":"docs/events/builtin/syscalls/sched_getscheduler/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>pid_t</code>[K] - The tid of the process whose policy will be retrieved.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_getscheduler/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_getscheduler/#hooks","title":"Hooks","text":"<p>No functions are hooked in order to allow execution of the system call.</p>"},{"location":"docs/events/builtin/syscalls/sched_getscheduler/#example-use-case","title":"Example Use Case","text":"<p>This system call can be used in the context of a monitoring application to compare scheduling policies between different processes.</p>"},{"location":"docs/events/builtin/syscalls/sched_getscheduler/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/sched_getscheduler/#related-events","title":"Related Events","text":"<p>The system call <code>sched_setscheduler</code> is related to this system call, as it allows for the setting of the scheduling policy for a process.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval/","title":"sched_rr_get_interval","text":""},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval/#intro","title":"Intro","text":"<p>sched_rr_get_interval - get the time quantum for a given pid.</p>"},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval/#description","title":"Description","text":"<p>This syscall is used to get the current time quantum for the real-time scheduler for a given process. This allows for useful information about the scheduling policy for a particular process to be retrieved. Additionally, this syscall can be used in debugging applications to help identify exactly which process is consuming resources in an unexpected way.</p> <p>There are, however, some caveats to using this syscall. On some operating systems, the time quantum may not be reset when a real-time process is stopped or suspended. This can lead to unexpected behavior if a process is stopped or suspended in the middle of its time quantum. There are also some caveats with regard to pre-emption on some operating systems with regard to real-time processes, so care should be taken to ensure that any processes using this syscall will not suffer any ill effects due to pre-emption.</p>"},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>pid_t</code> - the pid of the process for which the time quantum should be retrieved.</li> <li><code>tp</code>:<code>struct timespec*</code>[U] - a pointer to a timespec structure which will be filled in with the time quantum for the process.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval/#sched_rr_get_interval_1","title":"sched_rr_get_interval","text":""},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval/#purpose","title":"Purpose","text":"<p>Debugging and monitoring purposes.</p>"},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval/#example-use-case","title":"Example Use Case","text":"<p>sched_rr_get_interval can be used to retrieve the time quantum of a real-time process that is consuming more resources than expected.</p>"},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval/#issues","title":"Issues","text":"<p>On some operating systems, the time quantum may not be reset when a real-time process is stopped or suspended. This can lead to unexpected behavior if a process is stopped or suspended in the middle of its time quantum.</p>"},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval/#related-events","title":"Related Events","text":"<ul> <li>sched_setscheduler()</li> <li>sched_getparam()</li> <li>sched_getaffinity()</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval_time32/","title":"sched_rr_get_interval_time32","text":""},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval_time32/#intro","title":"Intro","text":"<p>sched_rr_get_interval_time32 - Retrieve the Round Robin scheduling interval of the thread with the corresponding pid.</p>"},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval_time32/#description","title":"Description","text":"<p>The sched_rr_get_interval_time32 system call is used to determine the current Round Robin scheduling interval of the thread with the corresponding pid. It retrieves the interval on which the thread will be executed in Round Robin scheduling. </p> <p>There are several drawbacks to this syscall such as the fact that it only works with threads, not processes. In addition, the time precision of the interval is limited to second granularity. It also has some advantages such as the ability to determine the scheduling order of tasks.</p>"},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval_time32/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>pid_t</code>[K] - Thread ID of the thread of whom the scheduling interval will be retrieved.</li> <li><code>interval</code>:<code>struct old_timespec32*</code>[K] - Pointer to a structure of type old_timespec32 that will store the interval of the thread.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval_time32/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval_time32/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval_time32/#kernel_sched_rr_get_interval_time32","title":"kernel_sched_rr_get_interval_time32","text":""},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval_time32/#type","title":"Type","text":"<p>Tracepoint</p>"},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval_time32/#purpose","title":"Purpose","text":"<p>To understand the structure of Round Robin scheduling and the duration of tasks in this scheduling policy.</p>"},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval_time32/#example-use-case","title":"Example Use Case","text":"<p>Monitoring and understanding the utilization of a CPU by a certain thread.</p>"},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval_time32/#issues","title":"Issues","text":"<p>This system call can only be used for threads, not processes.</p>"},{"location":"docs/events/builtin/syscalls/sched_rr_get_interval_time32/#related-events","title":"Related Events","text":"<ul> <li>sched_setscheduler - To adjust scheduling policy and priority of processes</li> <li>sched_get_priority_min &amp; sched_get_priority_max - To check the priority range of the current scheduling policy in the system.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sched_setaffinity/","title":"sched_setaffinity","text":""},{"location":"docs/events/builtin/syscalls/sched_setaffinity/#intro","title":"Intro","text":"<p>sched_setaffinity - sets the CPU affinity mask of the process or thread with given pid.</p>"},{"location":"docs/events/builtin/syscalls/sched_setaffinity/#description","title":"Description","text":"<p>The <code>sched_setaffinity()</code> system call is used to set the CPU affinity mask of the process or thread with the specified <code>pid</code>.  The <code>cpusetsize</code> argument is the size in bytes of the data pointed to by <code>mask</code>.  This allows applications to set the processor affinity of threads to selected processors in a processor group.  This eliminates the need to rely on system scheduler to selecting a processor for a thread to execute on, and provides for more control for the user about the processor a particular thread will run on.</p> <p>The call will fail if the process does not have the appropriate privileges, or if the process does not exist.  In addition, it can fail if there are more bits in the <code>mask</code> than the system allows, or if the <code>mask</code> is invalid in some other way. </p> <p>Due to the amount of detail that goes into implementing an optimized thread scheduling strategy, there may be edge-cases or other considerations to take into account when using this system call.</p>"},{"location":"docs/events/builtin/syscalls/sched_setaffinity/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>: <code>pid_t</code>[K] - The pid of the process or thread whose affinity mask should be set.</li> <li><code>cpusetsize</code>: <code>size_t</code>[K] - The size in bytes of the data pointed to by <code>mask</code>.</li> <li><code>mask</code>: <code>unsigned long*</code>[K] - A pointer to an array of unsigned longs that comprises the CPU affinity mask.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_setaffinity/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_setaffinity/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sched_setaffinity/#do_sched_setaffinity","title":"do_sched_setaffinity","text":""},{"location":"docs/events/builtin/syscalls/sched_setaffinity/#type","title":"Type","text":"<p>kprobe + uprobe</p>"},{"location":"docs/events/builtin/syscalls/sched_setaffinity/#purpose","title":"Purpose","text":"<p>To monitor when processes are setting the CPU affinity mask of their threads or child processes.</p>"},{"location":"docs/events/builtin/syscalls/sched_setaffinity/#example-use-case","title":"Example Use Case","text":"<p>For applications that need to be distributed across CPU cores, scheduling affinity allows programs to manually dictate the cores a process should use, rather than relying on the operating system's scheduler. For example, if a group of threads need to prioritize one process over another, scheduling affinity can be used to ensure threads are allocated to the appropriate cores.</p>"},{"location":"docs/events/builtin/syscalls/sched_setaffinity/#issues","title":"Issues","text":"<p>The scheduling affinity is not always respected if the load is heavy on the system. This means that processes may land on cores that were not originally assigned to them due to the demand. In addition, it may not be possible to set the affinity to cores that do not exist on the system, and so the appropriate checks must be made before calling the system call.</p>"},{"location":"docs/events/builtin/syscalls/sched_setaffinity/#related-events","title":"Related Events","text":"<p>sched_getaffinity - gets the CPU affinity mask of the process or thread with given pid.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sched_setattr/","title":"sched_setattr","text":""},{"location":"docs/events/builtin/syscalls/sched_setattr/#intro","title":"Intro","text":"<p>sched_setattr - sets the scheduling policy and attributes of a process </p>"},{"location":"docs/events/builtin/syscalls/sched_setattr/#description","title":"Description","text":"<p>sched_setattr takes a pid, attr and flags and performs the setting of a process's scheduling policy and attributes. The only allowable scheduling policy is the SCHED_DEADLINE policy. The function returns the scheduling policy that has been set for the process. This function is useful to set up specific parameters for a process that require real-time scheduling.</p> <p>Edge cases that can occur when using this function include out of memory errors, when the system does not have enough memory to set the attributes specified, as well as policy errors, when attempting to set a policy that is not supported.</p> <p>Another issue that could possibly occur is related to the scheduling priority set by the scheduling policy, namely when attempting to set up a higher priority than what is allowed based on the system permissions. </p>"},{"location":"docs/events/builtin/syscalls/sched_setattr/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>pid_t</code>[K] - the process id of the process whose scheduling policy and attributes are to be set.</li> <li><code>attr</code>:<code>struct sched_attr*</code>[K] - the struct containing the scheduling policy, period and runtime and other scheduling details.</li> <li><code>flags</code>:<code>unsigned int</code>[K] - flags that can be used to override the default behavior of sched_setattr.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_setattr/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_setattr/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sched_setattr/#syscall_trace_enter","title":"syscall_trace_enter","text":""},{"location":"docs/events/builtin/syscalls/sched_setattr/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/sched_setattr/#purpose","title":"Purpose","text":"<p>Tracing system calls for debugging, performance analysis, and other various use cases.</p>"},{"location":"docs/events/builtin/syscalls/sched_setattr/#sched_setattr_1","title":"sched_setattr","text":""},{"location":"docs/events/builtin/syscalls/sched_setattr/#type_1","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/sched_setattr/#purpose_1","title":"Purpose","text":"<p>To trace calls to sched_setattr, in order to debug the scheduling of processes.</p>"},{"location":"docs/events/builtin/syscalls/sched_setattr/#example-use-case","title":"Example Use Case","text":"<p>To verify the operation of application processes with real-time requirements.</p>"},{"location":"docs/events/builtin/syscalls/sched_setattr/#issues","title":"Issues","text":"<p>The flags argument of sched_setattr is currently not used.</p>"},{"location":"docs/events/builtin/syscalls/sched_setattr/#related-events","title":"Related Events","text":"<p>sched_getattr, sched_setscheduler, sched_getscheduler</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sched_setparam/","title":"sched_setparam","text":""},{"location":"docs/events/builtin/syscalls/sched_setparam/#intro","title":"Intro","text":"<p>sched_setparam - sets parameters for a process in the scheduling process table</p>"},{"location":"docs/events/builtin/syscalls/sched_setparam/#description","title":"Description","text":"<p>Sched_setparam is a Linux system call that sets parameters for a given process  in the scheduling process table. It changes the scheduling policy and parameters  associated with a given process. The scheduling policy is not changed, however the  parameters used for the selected policy are set for the process in question. This  helpful for defining more fine-grained scheduling controls.</p> <p>When a process has its scheduling parameters modified it can affect how the CPU  performs. It can also affect the way that a process interacts with users, which  can have an effect on user experience.</p> <p>There can be drawbacks to using sched_setparam, as setting the right schedules  parameters are quite complex and depend on a variety of factors, such as other  running processes, the architecture, and so on.</p>"},{"location":"docs/events/builtin/syscalls/sched_setparam/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>pid_t</code>[K] - This argument specifies the process ID of the process that  the scheduling parameters will be set to.</li> <li><code>param</code>:<code>struct sched_param*</code>[U] - This argument specifies a pointer to a  struct sched_param, which contains the scheduling parameters to be set.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_setparam/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_setparam/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sched_setparam/#do_sched_setparam","title":"do_sched_setparam","text":""},{"location":"docs/events/builtin/syscalls/sched_setparam/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/sched_setparam/#purpose","title":"Purpose","text":"<p>To log information about processes that are executing the do_sched_setparam  system call.</p>"},{"location":"docs/events/builtin/syscalls/sched_setparam/#sched_setscheduler","title":"sched_setscheduler","text":""},{"location":"docs/events/builtin/syscalls/sched_setparam/#type_1","title":"Type","text":"<p>Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/sched_setparam/#purpose_1","title":"Purpose","text":"<p>To capture the return value of the sched_setparam call in order to determine if the  scheduling parameters have been set successfully.</p>"},{"location":"docs/events/builtin/syscalls/sched_setparam/#example-use-case","title":"Example Use Case","text":"<p>One use case for this system call is using sched_setparam to set a certain CPU  scheduling priority for a certain process. This could be done if a process is  causing issues with other processes or user experience and needs to be given a  lower priority in order to allow other processes to run.</p>"},{"location":"docs/events/builtin/syscalls/sched_setparam/#issues","title":"Issues","text":"<p>There can be a number of issues when using sched_setparam. The parameters set in  the struct sched_param can be specific to a certain architecture, so the values  need to be set correctly for the current architecture. Also, the parameters can be  complex to set correctly, as they can depend on other running processes or the  architecture.</p>"},{"location":"docs/events/builtin/syscalls/sched_setparam/#related-events","title":"Related Events","text":"<ul> <li>sched_getscheduler - retrieves the scheduling policy of the process with given pid</li> <li>sched_getparam - retrieves the scheduling parameters associated with a given process.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sched_setscheduler/","title":"sched_setscheduler","text":""},{"location":"docs/events/builtin/syscalls/sched_setscheduler/#intro","title":"Intro","text":"<p>sched_setscheduler - Set scheduling policy and parameters of a process</p>"},{"location":"docs/events/builtin/syscalls/sched_setscheduler/#description","title":"Description","text":"<p>sched_setscheduler can be used to set the scheduling policy and scheduling parameter of an existing process with specified process ID (pid) and specified scheduling parameters (param). It can be used to set and toggle between different scheduling policies, e.g. SCHED_FIFO, SCHED_RR, SCHED_NORMAL, etc., depending on the requirements of the process. It can also be used to set the process' priority within the specified scheduling policy, using the struct sched_param.</p> <p>This call is subject to the CAP_SYS_NICE capability.</p>"},{"location":"docs/events/builtin/syscalls/sched_setscheduler/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>pid_t</code>[K] - Process ID of the process whose scheduling policy should be set.</li> <li><code>policy</code>:<code>int</code>[K] - Scheduling policy. Must be one of SCHED_OTHER (normal time-sharing), SCHED_FIFO (run until blocked or killed), SCHED_RR (same as FIFO but timesliced), or SCHED_BATCH (batch job).</li> <li><code>param</code>:<code>struct sched_param*</code>[K] - Scheduling parameters, to set the process priority within the specified scheduling policy.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_setscheduler/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sched_setscheduler/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sched_setscheduler/#sched_setscheduler_1","title":"sched_setscheduler","text":""},{"location":"docs/events/builtin/syscalls/sched_setscheduler/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/sched_setscheduler/#purpose","title":"Purpose","text":"<p>To track the scheduling policy and parameters being set for a process.</p>"},{"location":"docs/events/builtin/syscalls/sched_setscheduler/#example-use-case","title":"Example Use Case","text":"<p>sched_setscheduler can be used when one needs fine-grained control over how a process is scheduled on a system. It can be used to prioritize processes, for example, when one process demands more resources than other processes.</p>"},{"location":"docs/events/builtin/syscalls/sched_setscheduler/#issues","title":"Issues","text":"<p>Before 4.15, scheduling parameters did not work with SCHED_IDLE or SCHED_BATCH.</p>"},{"location":"docs/events/builtin/syscalls/sched_setscheduler/#related-events","title":"Related Events","text":"<ul> <li>sched_getparam - Get scheduling parameters of a process.</li> <li>sched_getaffinity - Get/set the CPU affinity of a process.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sched_yield/","title":"sched_yield","text":""},{"location":"docs/events/builtin/syscalls/sched_yield/#intro","title":"Intro","text":"<p>sched_yield - temporarily pause the current thread in favor of other threads</p>"},{"location":"docs/events/builtin/syscalls/sched_yield/#description","title":"Description","text":"<p>The task sched_yield() cause the calling thread to relinquish the CPU. The thread is put to the end of the queue for its static priority and another thread will be scheduled to run. If there are no other threads running in the system, the yield will cause the thread to continue to run.</p> <p>sched_yield() is useful for an application to allow other threads to run (i.e. to prevent starvation of other threads) or for a thread to be scheduled in to reduce the latency for an scheduling event.</p>"},{"location":"docs/events/builtin/syscalls/sched_yield/#arguments","title":"Arguments","text":"<p>No arguments for this syscall.</p>"},{"location":"docs/events/builtin/syscalls/sched_yield/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sched_yield/#do_sys_sched_yield","title":"do_sys_sched_yield","text":""},{"location":"docs/events/builtin/syscalls/sched_yield/#type","title":"Type","text":"<p>Tracepoint</p>"},{"location":"docs/events/builtin/syscalls/sched_yield/#purpose","title":"Purpose","text":"<p>To monitor context switches.</p>"},{"location":"docs/events/builtin/syscalls/sched_yield/#example-use-case","title":"Example Use Case","text":"<p>sched_yield() should be used when a process needs to pause its execution and give a chance to the other threads, waiting in the same priority queue.</p>"},{"location":"docs/events/builtin/syscalls/sched_yield/#issues","title":"Issues","text":"<p>If there are no runnable threads with the same priority level, then the current thread will not be context switched and all other threads will be stuck behind it.</p>"},{"location":"docs/events/builtin/syscalls/sched_yield/#related-events","title":"Related Events","text":"<ul> <li>sched_setscheduler: to change the scheduling policy and priority of selected thread.</li> <li>sched_get_priority_max/min: to get the highest/lowest priority limit of a scheduling policy.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/seccomp/","title":"seccomp","text":""},{"location":"docs/events/builtin/syscalls/seccomp/#intro","title":"Intro","text":"<p>seccomp - Used to filter allowed syscalls</p>"},{"location":"docs/events/builtin/syscalls/seccomp/#description","title":"Description","text":"<p>seccomp is a Linux-specific syscall used to restrict system calls available to a process and as such, can be used to harden system security. It utilizes a secure computing mode (hence the acronym) to place limitations on what a process can do. This limitation is applied to any system call made within the secure computing environment.</p> <p>There are a number of drawbacks to using seccomp, such as the difficulty in configuring it due to its restrictive nature, as well as the black box nature of the call, which can hamper debugging. Additionally, runtime errors can be difficult to diagnose and handle as the underlying cause may be hidden from the developer.</p> <p>Overall, seccomp is a powerful tool that can help strengthen security in cases where it is necessary. The best use case is one where there are specific system calls a process must avoid.</p>"},{"location":"docs/events/builtin/syscalls/seccomp/#arguments","title":"Arguments","text":"<ul> <li><code>operation</code>:<code>unsigned int</code>[K] - Sets the operation of seccomp.</li> <li><code>flags</code>:<code>unsigned int</code>[K] - Sets the flags that control the behavior of seccomp.</li> <li><code>args</code>:<code>const void*</code>[K] - Source of additional information used in setting up seccomp.</li> </ul>"},{"location":"docs/events/builtin/syscalls/seccomp/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/seccomp/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/seccomp/#sys_seccomp","title":"sys_seccomp","text":""},{"location":"docs/events/builtin/syscalls/seccomp/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/seccomp/#purpose","title":"Purpose","text":"<p>Hook the system call to filter allowed syscalls</p>"},{"location":"docs/events/builtin/syscalls/seccomp/#example-use-case","title":"Example Use Case","text":"<p>seccomp could be used as an addition to existing firewall configurations to restrict the kinds of system calls that can be made by different processes. </p>"},{"location":"docs/events/builtin/syscalls/seccomp/#issues","title":"Issues","text":"<p>Due to seccomp's restrictive nature, it can be difficult to configure and maintain. Additionally, runtime errors can be particularly perplexing to debug due to the opaque nature of the syscall. </p>"},{"location":"docs/events/builtin/syscalls/seccomp/#related-events","title":"Related Events","text":"<ul> <li>prctl() - Used to set seccomp rules on a process.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/security/","title":"security","text":""},{"location":"docs/events/builtin/syscalls/security/#intro","title":"Intro","text":"<p>security - checks if the current security context is valid</p>"},{"location":"docs/events/builtin/syscalls/security/#description","title":"Description","text":"<p>The security syscall call is used to check if the current security context is valid. It is used to check whether a security context is able to access a given resource. If the current security context does not have access to the resource, it can be updated to match the security context of the resource. It is important to note that the security context of a resource is determined by the security measure, or policy, of the particular resource.</p> <p>The security syscall is a key part of any security-minded application. It can help to ensure that only certain users are allowed to access certain resources, and that any access is done in a secure way. In addition, the security syscall can help to ensure that the security measures of a system are not circumvented or broken. </p> <p>There are a few key points to keep in mind when using the security syscall. The security context of the user needs to be checked for validity at all times, and the user\u2019s security context should be updated whenever necessary. In addition, the security syscall should never be used to perform authentication or authorization checks, as these should be done using a separate system.</p>"},{"location":"docs/events/builtin/syscalls/security/#arguments","title":"Arguments","text":"<ul> <li><code>context</code>:<code>char const *</code>[U, TOCTOU] - a pointer to a security context string.</li> <li><code>resource</code>:<code>char const *</code>[U, TOCTOU] - a pointer to a resource string.</li> <li><code>access</code>:<code>int</code>[U] - a bit mask representing the access rights.</li> <li><code>timeout</code>:<code>long</code>[U, OPT] - maximum time in milliseconds to wait for a security change before returning an error (if not provided, will wait indefinitely).</li> </ul>"},{"location":"docs/events/builtin/syscalls/security/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/security/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/security/#__x86_sys_security","title":"__x86_sys_security","text":""},{"location":"docs/events/builtin/syscalls/security/#type","title":"Type","text":"<p>bpf + kprobe</p>"},{"location":"docs/events/builtin/syscalls/security/#purpose","title":"Purpose","text":"<p>The purpose of hooking this function is to detect when the security syscall is called, and to obtain information about the context, resource, access and timeout arguments used.</p>"},{"location":"docs/events/builtin/syscalls/security/#security_update","title":"security_update","text":""},{"location":"docs/events/builtin/syscalls/security/#type_1","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/security/#purpose_1","title":"Purpose","text":"<p>The purpose of hooking this function is to detect when the security context of a resource is updated and to obtain information about the context, resource, and access arguments used.</p>"},{"location":"docs/events/builtin/syscalls/security/#example-use-case","title":"Example Use Case","text":"<p>A security-minded application may use the security syscall to check a user\u2019s access rights to a particular resource. If the user is not authorized to access the resource, the security syscall can be used to update the user\u2019s security context to match the resource\u2019s security settings. This allows the user to access the resource in a secure fashion.</p>"},{"location":"docs/events/builtin/syscalls/security/#issues","title":"Issues","text":"<p>The security syscall can be vulnerable to TOCTOU attacks. If a malicious user is able to manipulate the security context of a resource, they can bypass the security checks done by the security syscall.</p>"},{"location":"docs/events/builtin/syscalls/security/#related-events","title":"Related Events","text":"<ul> <li>execve - spawns a new process</li> <li>getgid - returns the group identifier (GID) of the current effective user</li> <li>chroot - changes the root directory of the calling process</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/select/","title":"select","text":""},{"location":"docs/events/builtin/syscalls/select/#intro","title":"Intro","text":"<p>select - Wait for some event on a group of files or sockets</p>"},{"location":"docs/events/builtin/syscalls/select/#description","title":"Description","text":"<p>The select event is used to monitor changes on a set of sockets or files. It  allows for the asynchronous detection of changes on these objects in a  time-efficient manner. After calling select, the application will be notified  when any of the objects in the set changes and is able to take action  accordingly. Select also supports waiting for a timeout.</p>"},{"location":"docs/events/builtin/syscalls/select/#arguments","title":"Arguments","text":"<ul> <li><code>nfds</code>:int - The highest numbered file descriptor in any of the sets and should be one more than the descriptor of the last file or socket that the select() statement is being asked to watch.</li> <li><code>readfds</code>:fd_set* - Optional argument. A pointer to an fd_set data structure passed by reference. The set of file descriptors whose status the caller wishes to query.</li> <li><code>writefds</code>:fd_set* - Optional argument. A pointer to an fd_set data structure passed by reference. The set of file descriptors on which the caller is asking to be notified when it is possible to write data.</li> <li><code>exceptfds</code>:fd_set* - Optional argument. A pointer to an fd_set data structure passed by reference. The set of file descriptors which the system will report when there is an exceptional condition pending.</li> <li><code>timeout</code>:struct timeval* - Optional argument. A pointer to a timeval structure containing the maximum time for which the caller wishes to wait for the select() call to complete before returning. </li> </ul>"},{"location":"docs/events/builtin/syscalls/select/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/select/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/select/#do_select","title":"do_select","text":""},{"location":"docs/events/builtin/syscalls/select/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/select/#purpose","title":"Purpose","text":"<p>Hooked in order to detect when the kernel is awaiting on a select call.</p>"},{"location":"docs/events/builtin/syscalls/select/#example-use-case","title":"Example Use Case","text":"<p>The select event can be used for an application to keep track of multiple users concurrently without having to wait for each action by every user. This can be done by calling select on multiple sockets to maintain a listen client and detect when one of the clients has sent data.   </p>"},{"location":"docs/events/builtin/syscalls/select/#issues","title":"Issues","text":"<p>When calling select with more than one objects, if the data in one object changes, the application will have to wait additional time to serve the other objects in the set. This can lead to longer wait times if one of the objects in the set has data which changes rapidly or is frequently use accessed. </p>"},{"location":"docs/events/builtin/syscalls/select/#related-events","title":"Related Events","text":"<ul> <li>epoll - event-driven I/O model which uses events instead of the select/poll APIs </li> <li>poll - provides much of the same functionality as select.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/semctl/","title":"semctl","text":""},{"location":"docs/events/builtin/syscalls/semctl/#intro","title":"Intro","text":"<p>semctl - a command used to perform operations on System V semaphore sets. </p>"},{"location":"docs/events/builtin/syscalls/semctl/#description","title":"Description","text":"<p>The semctl command is used to perform operations on System V semaphore sets. It has four arguments, a semaphore set identifier, a semaphore number, a command and an optional additional argument. The purpose of this command is to set and retrieve the control information associated with a semaphore set and to set the operational parameters associated with a semaphore. The semctl command can be used to stat, set, mark and get information related to a semaphore set. Some of the drawbacks of using this command is that it can potentially set a semaphore set to a state which can be used in a deadlock situation, or cause race conditions if not handled correctly.</p>"},{"location":"docs/events/builtin/syscalls/semctl/#arguments","title":"Arguments","text":"<ul> <li><code>semid</code>:<code>int</code>[K] - A semaphore set identifier returned by semget().</li> <li><code>semnum</code>:<code>int</code>[K] - The number of the semaphore in the set to be affected by cmd.</li> <li><code>cmd</code>:<code>int</code>[K] - Semaphore control command.</li> <li><code>arg</code>:<code>unsigned long</code>[K+U+OPT] - Optional structure pointer or value returned from or passed to the kernel.</li> </ul>"},{"location":"docs/events/builtin/syscalls/semctl/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/semctl/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/semctl/#sys_semctl","title":"sys_semctl","text":"<p>Type: kprobe + kretprobe. Purpose: To trace the execution of the sys_semctl system call. </p>"},{"location":"docs/events/builtin/syscalls/semctl/#example-use-case","title":"Example Use Case","text":"<p>An example use case for this event is a system administrator using the semctl command to monitor the semaphore set for errors or for debugging purposes.</p>"},{"location":"docs/events/builtin/syscalls/semctl/#issues","title":"Issues","text":"<p>No issues are currently known for this event.</p>"},{"location":"docs/events/builtin/syscalls/semctl/#related-events","title":"Related Events","text":"<ul> <li>semget - get a semaphore set identifier</li> <li>semop - perform semaphore operations</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/semget/","title":"semget","text":""},{"location":"docs/events/builtin/syscalls/semget/#intro","title":"Intro","text":"<p>semget - allows processes to obtain access to semaphore sets</p>"},{"location":"docs/events/builtin/syscalls/semget/#description","title":"Description","text":"<p><code>semget</code> is used to identify and access an existing semaphore set, or to create a new semaphore set.  It is typically used to control access to a shared resource. When using <code>semget</code> to create a new semaphore set, an application must specify the size of the set, along with the read and write permissions.  The new semaphore set will remain until removed with <code>semctl</code> or the system is rebooted.</p> <p>If a process attempts to semget a semaphore set with a key that already exists, the process will be granted access to the semaphore set that already exists provided the permissions matches.</p> <p>There is an upper limit for the number of semaphore sets that may be created with semget. This limit is determined by the hardware platform and kernel configuration.</p>"},{"location":"docs/events/builtin/syscalls/semget/#arguments","title":"Arguments","text":"<ul> <li><code>key</code>:<code>key_t</code> - Key of the semaphore set. Used to identify a unique semaphore set and can be created using the <code>ftok</code> function. </li> <li><code>nsems</code>:<code>int</code> - The number of semaphores contained in the semaphore set specified by <code>key</code>.</li> <li><code>semflg</code>:<code>int</code>[U,K,TOCTOU] - Permissions to access the semaphore set, to perform read and write operations.</li> </ul>"},{"location":"docs/events/builtin/syscalls/semget/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> </ul>"},{"location":"docs/events/builtin/syscalls/semget/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/semget/#sys_semget","title":"sys_semget","text":""},{"location":"docs/events/builtin/syscalls/semget/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/semget/#purpose","title":"Purpose","text":"<p>To track the use of <code>semget</code> syscalls, to identify any potential race conditions, deadlocks or failed resource allocation.</p>"},{"location":"docs/events/builtin/syscalls/semget/#example-use-case","title":"Example Use Case","text":"<p><code>semget</code> is a useful tool for controlling access to a shared resource amongst multiple processes. For example, a server application may want to control access to a file by having one process obtain the file and then use <code>semget</code> to set up a semaphore set that can be used to coordinate between multiple clients that need to access it.</p>"},{"location":"docs/events/builtin/syscalls/semget/#issues","title":"Issues","text":"<p>When using <code>semget</code> to create a new semaphore set, care must be taken to ensure that it has been configured properly and the permissions have been set correctly. Race conditions may occur if the semaphore set is not properly configured. Additionally, Once created, the <code>semget</code> call will return a semaphore set identifier and it is the responsibility of the calling process to manage the semaphore set. If the process exits without freeing up the semaphore set it was responsible for, the semaphore set will remain in the system until the system is rebooted.</p>"},{"location":"docs/events/builtin/syscalls/semget/#related-events","title":"Related Events","text":"<ul> <li>semop - to specify the operations to be carried out on the semaphore set </li> <li>semctl - to control the state of the semaphore set</li> <li>semtimedop - similar to <code>semop</code> but with an option of timing out</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/semop/","title":"semop","text":""},{"location":"docs/events/builtin/syscalls/semop/#intro","title":"Intro","text":"<p>semop - atomically perform operations on a set of semaphores</p>"},{"location":"docs/events/builtin/syscalls/semop/#description","title":"Description","text":"<p>Semop is a Linux system call used to perform operations on a set of semaphores. It ensures that all operations specified in the argument <code>sops</code> will either be completed or none of them will be performed at all. This call can be used for synchronization between threads or processes. The only drawback is that if the maximum number of semaphores allowed is reached, the call will fail.</p>"},{"location":"docs/events/builtin/syscalls/semop/#arguments","title":"Arguments","text":"<ul> <li><code>semid</code>:<code>int</code> - ID of the set of semaphores.</li> <li><code>sops</code>:<code>struct sembuf*</code> - pointer to an array of semaphore operations.</li> <li><code>nsops</code>:<code>size_t</code> - number of semaphores in the array.</li> </ul>"},{"location":"docs/events/builtin/syscalls/semop/#available-tags","title":"Available Tags","text":"<ul> <li>KU - Originated from kernel-space or user space.</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/semop/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/semop/#sys_semop","title":"sys_semop","text":""},{"location":"docs/events/builtin/syscalls/semop/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/semop/#purpose","title":"Purpose","text":"<p>To gain insight to the arguments passed to semop, as well as to log any broken semaphore constraints.</p>"},{"location":"docs/events/builtin/syscalls/semop/#example-use-case","title":"Example Use Case","text":"<p>If you need to synchronize between threads or processes, semop can be used to guarantee that a set of operations on a set of semaphores will either all succeed or none of them will.</p>"},{"location":"docs/events/builtin/syscalls/semop/#issues","title":"Issues","text":"<p>If the maximum number of semaphores allowed is reached, the call will fail.</p>"},{"location":"docs/events/builtin/syscalls/semop/#related-events","title":"Related Events","text":"<ul> <li>semget - Gets an existing semaphore set or allocate a new one.</li> <li>semctl - Examine or change an existing semaphore set.</li> <li>semtimedop - Like <code>semop</code>, but with an additional timeout parameter.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/semtimedop/","title":"semtimedop","text":""},{"location":"docs/events/builtin/syscalls/semtimedop/#intro","title":"Intro","text":"<p>semtimedop - acquire a semaphore in a timed manner</p>"},{"location":"docs/events/builtin/syscalls/semtimedop/#description","title":"Description","text":"<p>The <code>semtimedop()</code> system call is used to acquire a semaphore in an asynchronous manner with a timeout. It is designed to acquire one or multiple semaphores atomically. If the specified <code>timeout</code> is reached, the call will fail with an <code>EAGAIN</code> error. The return value of the call will contain information about the number of semaphores actually acquired.</p>"},{"location":"docs/events/builtin/syscalls/semtimedop/#arguments","title":"Arguments","text":"<ul> <li><code>semid</code>:<code>int</code> - ID of the semaphore set.</li> <li><code>sops</code>:<code>struct sembuf*</code> - Pointer to an array of <code>sembuf</code> structs. Each struct contains the index of the semaphore inside the semaphore array and condition of the operation (unlock/lock).</li> <li><code>nsops</code>:<code>size_t</code> - Size of the array of <code>sembuf</code> structs.</li> <li><code>timeout</code>:<code>const struct timespec*</code>[K, OPT] - Pointer to a timespec struct describing the time duration of the wait.</li> </ul>"},{"location":"docs/events/builtin/syscalls/semtimedop/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/semtimedop/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/semtimedop/#sys_semtimedop","title":"sys_semtimedop","text":""},{"location":"docs/events/builtin/syscalls/semtimedop/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/semtimedop/#purpose","title":"Purpose","text":"<p>To monitor the execution of <code>semtimedop()</code> and modify behavior when needed.</p>"},{"location":"docs/events/builtin/syscalls/semtimedop/#example-use-case","title":"Example Use Case","text":"<p><code>semtimedop()</code> is especially useful when implementing synchronization mechanisms into a system. These synchronization mechanisms could be related to multi-threaded application, and the <code>semtimedop()</code> could be used to allow access  to shared resources in a controlled manner.</p>"},{"location":"docs/events/builtin/syscalls/semtimedop/#issues","title":"Issues","text":"<p>At the time of writing, the <code>timeout</code> argument does not work as expected on all  supported architectures.</p>"},{"location":"docs/events/builtin/syscalls/semtimedop/#related-events","title":"Related Events","text":"<ul> <li>semop()</li> <li>semtimedop_time64()</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sendfile/","title":"sendfile","text":""},{"location":"docs/events/builtin/syscalls/sendfile/#intro","title":"Intro","text":"<p>sendfile() - copies data between two file descriptors</p>"},{"location":"docs/events/builtin/syscalls/sendfile/#description","title":"Description","text":"<p>The sendfile() syscall copies data between two file descriptors. It copies data from the file descriptor in_fd and sends it to the file descriptor out_fd. The offset argument is an offset pointer, and it is used to define the position within the file from which the data will be read. The count argument defines how much data from the in_fd should be transferred.</p> <p>When using sendfile() it is important to note that the data is read from the in_fd file descriptor and written directly to the out_fd descriptor without passing through user-space. This can be faster than the traditional file-read-to-user-space-buffer-and-write-to-file approach.</p>"},{"location":"docs/events/builtin/syscalls/sendfile/#arguments","title":"Arguments","text":"<ul> <li><code>out_fd</code>:<code>int</code> - File descriptor from which the data will be written</li> <li><code>in_fd</code>:<code>int</code> - File descriptor from which the data will be read</li> <li><code>offset</code>:<code>off_t*</code>[K] - Pointer to an offset value </li> <li><code>count</code>:<code>size_t</code> - Length of data in bytes which will be transferred </li> </ul>"},{"location":"docs/events/builtin/syscalls/sendfile/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space</li> </ul>"},{"location":"docs/events/builtin/syscalls/sendfile/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sendfile/#sys_sendfile","title":"sys_sendfile","text":""},{"location":"docs/events/builtin/syscalls/sendfile/#type","title":"Type","text":"<p>KProbe + KRetProbe </p>"},{"location":"docs/events/builtin/syscalls/sendfile/#purpose","title":"Purpose","text":"<p>Track the arguments passed to the kernel sendfile() syscall, as well as its return values.</p>"},{"location":"docs/events/builtin/syscalls/sendfile/#example-use-case","title":"Example Use Case","text":"<p>sendfile() can be used to efficiently transfer large amounts of data between two file descriptors. It can be used to provide a way to efficiently transfer a stream of data between two network sockets.</p>"},{"location":"docs/events/builtin/syscalls/sendfile/#issues","title":"Issues","text":"<p>The count argument for sendfile() is limited to 32-bits of size. If more data must be transferred, it is necessary to iterate over multiple calls to sendfile().</p> <p>Additionally, passing a null pointer for the offset argument is not supported on all architectures.</p>"},{"location":"docs/events/builtin/syscalls/sendfile/#related-events","title":"Related Events","text":"<ul> <li>writev() - performs scatter-gather I/O</li> <li>send() - sends data on a socket </li> <li>splice() - constructs a pipe out of two files/file descriptors</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sendfile32/","title":"sendfile32","text":""},{"location":"docs/events/builtin/syscalls/sendfile32/#intro","title":"Intro","text":"<p>sendfile32 - used to copy data between two file descriptors</p>"},{"location":"docs/events/builtin/syscalls/sendfile32/#description","title":"Description","text":"<p>sendfile32 is a system call used to copy data between two file descriptors. It is used to copy data using zero copy system calls, which can potentially improve the performance when dealing with large IO sizes. The operation may fail or complete with a partial result, depending on the size of the data being sent.</p> <p>Advantages of using sendfile32 include its ability to do zero-copy IO and to handle large IO requests. Drawbacks include the fact that it can only be used to send data from one file descriptor to another, and that it is not atomic and therefore vulnerable to time-of-check/time-of-use (TOCTOU) race conditions.</p>"},{"location":"docs/events/builtin/syscalls/sendfile32/#arguments","title":"Arguments","text":"<ul> <li><code>out_fd</code>:<code>int</code> - file descriptor from which data is to be read.</li> <li><code>in_fd</code>:<code>int</code> - file descriptor to which data is to be written.</li> <li><code>offset</code>:<code>off_t*</code>[U,TOCTOU] - pointer to an offset to start reading from the <code>in_fd</code> descriptor.</li> <li><code>count</code>:<code>size_t</code>[OPT] - the number of byte to copy. If not passed, the value is assumed to be the size of the file.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sendfile32/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/sendfile32/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sendfile32/#_1","title":"","text":""},{"location":"docs/events/builtin/syscalls/sendfile32/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/sendfile32/#purpose","title":"Purpose","text":"<p>Used to trace each time the system call is executed.</p>"},{"location":"docs/events/builtin/syscalls/sendfile32/#example-use-case","title":"Example Use Case","text":"<p>A monitoring system might use this event to track the rate at which each user is copying data from one file descriptor to another.</p>"},{"location":"docs/events/builtin/syscalls/sendfile32/#issues","title":"Issues","text":"<p>sendfile32 is not atomic and therefore vulnerable to time of check/time of use (TOCTOU) race conditions.</p>"},{"location":"docs/events/builtin/syscalls/sendfile32/#related-events","title":"Related Events","text":"<ul> <li>execve: used to call the sendfile32 system call.</li> <li>pread: used to read data from a file descriptor.</li> <li>write: used to write data to a file descriptor.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sendmmsg/","title":"sendmmsg","text":""},{"location":"docs/events/builtin/syscalls/sendmmsg/#intro","title":"Intro","text":"<p>sendmmsg - send multiple messages at once</p>"},{"location":"docs/events/builtin/syscalls/sendmmsg/#description","title":"Description","text":"<p>The sendmmsg() system call is used to send multiple messages on a socket. It takes the parameters: <code>sockfd</code> (an integer file descriptor referring to a socket), <code>msgvec</code> (an array of struct mmsghdr structures, which contain the message payload and flags of each message, as well as an ancillary data buffer and an ancillary data buffer length), <code>vlen</code> (an unsigned integer specifying the size of the array of structures and thus the number of messages sent in one call), and <code>flags</code> (an integer specifying flags applied to each message sent in the call). Sending multiple messages at once allows the user to send multiple messages at once with the same system call instead of having to issue multiple calls for different messages; this reduces the number of system calls issued, increases the efficiency of the program, and does not harm any of the messages' delivery if any fail.</p> <p>This call may fail if the socket is not connected.</p>"},{"location":"docs/events/builtin/syscalls/sendmmsg/#arguments","title":"Arguments","text":"<ul> <li><code>sockfd</code>:<code>int</code> - The file descriptor of the socket to send the messages on</li> <li><code>msgvec</code>:<code>struct mmsghdr*</code>[KU] - An array of struct mmsghdr structures which contain the message payload and flags, as well as an ancillary data buffer and an ancillary data buffer length</li> <li><code>vlen</code>:<code>unsigned int</code> - The size of the array of structures and thus the number of messages sent in one call</li> <li><code>flags</code>:<code>int</code> - Flags applied to each message sent in the call</li> </ul>"},{"location":"docs/events/builtin/syscalls/sendmmsg/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/sendmmsg/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sendmmsg/#sys_sendmmsg","title":"sys_sendmmsg","text":""},{"location":"docs/events/builtin/syscalls/sendmmsg/#type","title":"Type","text":"<p>kprobes</p>"},{"location":"docs/events/builtin/syscalls/sendmmsg/#purpose","title":"Purpose","text":"<p>The purpose of this hook is to track calls to this syscall and log the arguments passed to it. This is useful for monitoring the behavior of applications, or determining the source of an error when something goes wrong.</p>"},{"location":"docs/events/builtin/syscalls/sendmmsg/#sock_sendmsg","title":"sock_sendmsg","text":""},{"location":"docs/events/builtin/syscalls/sendmmsg/#type_1","title":"Type","text":"<p>kretprobes</p>"},{"location":"docs/events/builtin/syscalls/sendmmsg/#purpose_1","title":"Purpose","text":"<p>The purpose of this hook is to track returns from this syscall and log any errors that occurred. This is useful for debugging applications or analysis of security issues.</p>"},{"location":"docs/events/builtin/syscalls/sendmmsg/#example-use-case","title":"Example Use Case","text":"<p>This event could be used to monitor applications for suspicious behavior, by logging calls to this syscall and tracking the arguments passed to it. This could be used, for example, to detect applications that are using excessive amounts of data, or using data in an unlikely way.</p>"},{"location":"docs/events/builtin/syscalls/sendmmsg/#issues","title":"Issues","text":"<p>This system call may fail if the socket is not connected.</p>"},{"location":"docs/events/builtin/syscalls/sendmmsg/#related-events","title":"Related Events","text":"<ul> <li>recvmsg - receive messages from a socket</li> <li>recvmmsg - receive multiple messages from a socket</li> <li>recvfrom - receive data from a socket</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sendmsg/","title":"sendmsg","text":""},{"location":"docs/events/builtin/syscalls/sendmsg/#intro","title":"Intro","text":"<p>sendmsg - send a message to another socket</p>"},{"location":"docs/events/builtin/syscalls/sendmsg/#description","title":"Description","text":"<p>The <code>sendmsg()</code> system call is used to send a message to another socket on the system. It is used when the message needs to be sent with a socket address, or if you need to specify control information headers. There are a few different control information headers that can be used, such as the SCM_RIGHTS and SCM_CREDENTIALS which are used to supply permissions and credentials. One of the benefits of using <code>sendmsg()</code> is that it can be used to send data between processes without relying on shared memory. Some of the drawbacks are that it requires additional overhead when encoding the control information and it can be quite difficult to debug.</p>"},{"location":"docs/events/builtin/syscalls/sendmsg/#arguments","title":"Arguments","text":"<ul> <li><code>sockfd</code>:<code>int</code> - file descriptor of the target socket</li> <li><code>msg</code>:<code>struct msghdr*</code> - pointer to a <code>struct msghdr</code> containing information on the message buffer, destination address and optional control headers</li> <li><code>flags</code>:<code>int</code>[OPT] - a bitmask of flags to control the interpretation of the data</li> </ul>"},{"location":"docs/events/builtin/syscalls/sendmsg/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value) </li> </ul>"},{"location":"docs/events/builtin/syscalls/sendmsg/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sendmsg/#sys_sendmsg","title":"sys_sendmsg","text":""},{"location":"docs/events/builtin/syscalls/sendmsg/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/sendmsg/#purpose","title":"Purpose","text":"<p>Measure time taken to perform the <code>sendmsg()</code> system call</p>"},{"location":"docs/events/builtin/syscalls/sendmsg/#example-use-case","title":"Example Use Case","text":"<p>One example of the use of the <code>sendmsg()</code> event is in applications that need to send data to multiple sockets simultaneously. By sending messages via <code>sendmsg()</code> instead of individual writes to each socket, the overhead of setting up and tearing down connected sockets can be greatly reduced.</p>"},{"location":"docs/events/builtin/syscalls/sendmsg/#issues","title":"Issues","text":"<p>One of the common issues with <code>sendmsg()</code> is related to copying buffers to/from userspace. If these operations are done quickly enough, an attacker could exploit time-of-check-time-of-use (TOCTOU) vulnerabilities on the source machine.</p>"},{"location":"docs/events/builtin/syscalls/sendmsg/#related-events","title":"Related Events","text":"<ul> <li>sendto</li> <li>recvmsg</li> <li>sendfile</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sendto/","title":"sendto","text":""},{"location":"docs/events/builtin/syscalls/sendto/#intro","title":"Intro","text":"<p>sendto - send a message on a socket</p>"},{"location":"docs/events/builtin/syscalls/sendto/#description","title":"Description","text":"<p>The sendto() system call is used to send a message to a socket. The message is specified by a pointer to a buffer buf, and is specified to be of a length len. The flags argument specifies the type of message transmission. The dest_addr argument is a pointer to a socket address structure, which contains the address of the receiving socket. The addrlen argument specifies the size of this structure. If the socket is connection-oriented, the address of the target socket is already specified, and dest_addr should be NULL. If the socket is not connection-oriented, the address of the target socket must be specified and addrlen must be set to its size.</p>"},{"location":"docs/events/builtin/syscalls/sendto/#arguments","title":"Arguments","text":"<ul> <li><code>sockfd</code>:<code>int</code>[U] - file descriptor for the socket (returned from socket call).</li> <li><code>buf</code>:<code>void*</code>[U] - pointer to the message buffer to be sent.</li> <li><code>len</code>:<code>size_t</code>[U] - length of the message to be sent.</li> <li><code>flags</code>:<code>int</code>[U] - message transmission flags.</li> <li><code>dest_addr</code>:<code>struct sockaddr*</code>[U] - pointer to a socket address structure containing the target socket address.</li> <li><code>addrlen</code>:<code>int</code>[U] - size of the socket address structure.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sendto/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/sendto/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sendto/#sys_sendto","title":"sys_sendto","text":""},{"location":"docs/events/builtin/syscalls/sendto/#type","title":"Type","text":"<p>KProbe</p>"},{"location":"docs/events/builtin/syscalls/sendto/#purpose","title":"Purpose","text":"<p>Tracking the flow of messages sent via sockets.</p>"},{"location":"docs/events/builtin/syscalls/sendto/#example-use-case","title":"Example Use Case","text":"<p>When debugging an application, one could hook sendto system call to monitor the flow of messages being sent from the application.</p>"},{"location":"docs/events/builtin/syscalls/sendto/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/sendto/#related-events","title":"Related Events","text":"<ul> <li>recvfrom</li> <li>sendmsg</li> <li>recvmsg</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/set_mempolicy/","title":"set_mempolicy","text":""},{"location":"docs/events/builtin/syscalls/set_mempolicy/#intro","title":"Intro","text":"<p>set_mempolicy - one sentence description of the event</p>"},{"location":"docs/events/builtin/syscalls/set_mempolicy/#description","title":"Description","text":"<p>set_mempolicy() is a system call that sets the policy of allocation of memory on NUMA machines. It sets the default memory policy for how threads in the current process interact with memory across different NUMA nodes. It is used mainly by two types of processes: runtime linker or dynamic loader to directly specify which memory policy should be used when loading the newly loaded shared objects, or NUMA-aware applications that create huge pages or allocate big objects and tune how their threads interact with different NUMA nodes.</p> <p>There are two main drawbacks of using this system call. First, it does not check whether certain memory is located on a certain NUMA node, so there can be unnecessary cross-node migrations that might happen if set_mempolicy is used incorrectly. Second, it might have bad performance due to the different policies available being conflicting.</p>"},{"location":"docs/events/builtin/syscalls/set_mempolicy/#arguments","title":"Arguments","text":"<ul> <li><code>mode</code>:<code>int</code>[K] - sets the mode of the policy. Can be either MPOL_DEFAULT, MPOL_PREFERRED, MPOL_BIND, MPOL_INTERLEAVE, which sets the policy depending on the specified argument.</li> <li><code>nodemask</code>:<code>const unsigned long*</code>[U,TOCTOU] - pointer to an array of unsigned long that contains the nodes to be used by the policy. The array will include up to maxnode unsigned longs.</li> <li><code>maxnode</code>:<code>unsigned long</code>[K] - the maximum number of the nodes that can be used by the policy.</li> </ul>"},{"location":"docs/events/builtin/syscalls/set_mempolicy/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> </ul>"},{"location":"docs/events/builtin/syscalls/set_mempolicy/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/set_mempolicy/#__do_sys_set_mempolicy","title":"__do_sys_set_mempolicy","text":""},{"location":"docs/events/builtin/syscalls/set_mempolicy/#type","title":"Type","text":"<p>kretprobe </p>"},{"location":"docs/events/builtin/syscalls/set_mempolicy/#purpose","title":"Purpose","text":"<p>Hooking __do_sys_set_mempolicy allows us to capture all invocations of the set_mempolicy syscall.</p>"},{"location":"docs/events/builtin/syscalls/set_mempolicy/#example-use-case","title":"Example Use Case","text":"<p>set_mempolicy is used in applications that allocate huge memory objects and need to be aware of the NUMA node the memory originates from. It is also used in runtime linkers and dynamic loaders in order to allocate shared objects on specific NUMA nodes.</p>"},{"location":"docs/events/builtin/syscalls/set_mempolicy/#issues","title":"Issues","text":"<p>set_mempolicy does not check whether certain memory is located on a certain NUMA node, so there can be unnecessary cross-node migrations that might happen if set_mempolicy is used incorrectly.</p>"},{"location":"docs/events/builtin/syscalls/set_mempolicy/#related-events","title":"Related Events","text":"<ul> <li>set_numa_affinity - Used to set which NUMA nodes should be used for subsequent memory allocations.</li> <li>get_mempolicy - Used to get information about the memory policy of a process.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/set_robust_list/","title":"set_robust_list","text":""},{"location":"docs/events/builtin/syscalls/set_robust_list/#intro","title":"Intro","text":"<p>set_robust_list - Sets head for the list of robust futexes for the current thread</p>"},{"location":"docs/events/builtin/syscalls/set_robust_list/#description","title":"Description","text":"<p>The <code>set_robust_list</code> syscall sets the head for the list of robust futexes for the current thread. This list is created when a robust futex is allocated. The <code>set_robust_list</code> syscall can be used to create, modify and/or remove the list. It takes two arguments, head and len. The head is a pointer to the list of robust futexes and the len is the size of the list in bytes. </p> <p>The <code>set_robust_list</code> syscall is used to guard against data races in user-space software. If the robust futex is detected to be in use by another thread, it means that a data race is occurring and the current thread can take steps to avoid the race condition.</p>"},{"location":"docs/events/builtin/syscalls/set_robust_list/#arguments","title":"Arguments","text":"<ul> <li><code>head</code>: <code>struct robust_list_head*</code>[U] - Pointer to the head of the list of robust futexes.</li> <li><code>len</code>: <code>size_t</code>[U] - Size of the list in bytes.</li> </ul>"},{"location":"docs/events/builtin/syscalls/set_robust_list/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/set_robust_list/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/set_robust_list/#sys_set_robust_list","title":"sys_set_robust_list","text":""},{"location":"docs/events/builtin/syscalls/set_robust_list/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/set_robust_list/#purpose","title":"Purpose","text":"<p>Hooking on sys_set_robust_list is useful for tracking when the list of robust futexes is modified or created.</p>"},{"location":"docs/events/builtin/syscalls/set_robust_list/#example-use-case","title":"Example Use Case","text":"<p>One example of <code>set_robust_list</code> being used is in thread synchronization mechanisms. In this case, a thread can call the <code>set_robust_list</code> syscall in order to create or modify a list of robust futexes in order to guard against data races.</p>"},{"location":"docs/events/builtin/syscalls/set_robust_list/#issues","title":"Issues","text":"<p>The <code>set_robust_list</code> syscall is vulnerable to TOCTOU (time of check, time of use) attacks and in some cases it may be necessary to take extra precautions to secure this system call.</p>"},{"location":"docs/events/builtin/syscalls/set_robust_list/#related-events","title":"Related Events","text":"<p>The <code>get_robust_list</code> syscall can be used to get the current list of robust futexes from a thread and is related to the <code>set_robust_list</code> syscall.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/set_thread_area/","title":"set_thread_area","text":""},{"location":"docs/events/builtin/syscalls/set_thread_area/#intro","title":"Intro","text":"<p>set_thread_area - Sets the area in which a thread's registers are saved</p>"},{"location":"docs/events/builtin/syscalls/set_thread_area/#description","title":"Description","text":"<p>The set_thread_area() system call sets the thread-local storage (TLS) area for  the calling thread via the ldt_entry structure passed in the u_info argument.  The TLS area stores the segment registers (fs and gs). This area is found on  the user stack of the thread and is initialized after a thread is created.  The size of the area is implementation-defined, but at least 28 bytes of  space must be provided.</p> <p>Using this system call, the user can specify which segment descriptor should  be used for fs/gs. This is mostly useful for thread libraries. </p>"},{"location":"docs/events/builtin/syscalls/set_thread_area/#arguments","title":"Arguments","text":"<ul> <li><code>u_info</code>:struct user_desc*[KU] - Pointer to a user_desc structure which contains the information about the TLS area that the system call should set.</li> </ul>"},{"location":"docs/events/builtin/syscalls/set_thread_area/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/set_thread_area/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/set_thread_area/#do_set_thread_area","title":"do_set_thread_area","text":""},{"location":"docs/events/builtin/syscalls/set_thread_area/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/set_thread_area/#purpose","title":"Purpose","text":"<p>To track when the set_thread_area syscall is called and to inspect the arguments.</p>"},{"location":"docs/events/builtin/syscalls/set_thread_area/#example-use-case","title":"Example Use Case","text":"<p>The set_thread_area syscall can be used when implementing thread-local storage (TLS) for a thread library and setting the memory area for storing the segment registers.</p>"},{"location":"docs/events/builtin/syscalls/set_thread_area/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/set_thread_area/#related-events","title":"Related Events","text":"<p>set_tid_address, get_thread_area, clone, rt_sigaction</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/set_tid_address/","title":"set_tid_address","text":""},{"location":"docs/events/builtin/syscalls/set_tid_address/#intro","title":"Intro","text":"<p>set_tid_address - sets the thread ID used by the kernel for this thread</p>"},{"location":"docs/events/builtin/syscalls/set_tid_address/#description","title":"Description","text":"<p>The set_tid_address system call sets the thread ID used by the kernel for this thread. This system call is used when creating new threads with the clone system call. It is usually used in conjunction with the CLONE_CHILD_SETTID flag. It allows the thread to receive the child thread's ID through the pointer provided.</p> <p>The set_tid_address system call takes a single argument, a pointer to an integer, <code>tidptr</code> that points to an integer that can be used to store the thread ID from the kernel.</p> <p>Edge cases, drawbacks or advantages of using it: * It ensures that the thread ID returned in the clone system call is valid and will not be reused by another thread. This makes it easier to detect thread creation errors. * If the thread is created without the CLONE_CHILD_SETTID flag, the pointer passed in this system call will not be used by the kernel.</p>"},{"location":"docs/events/builtin/syscalls/set_tid_address/#arguments","title":"Arguments","text":"<ul> <li><code>tidptr</code>:<code>int*</code>[K] - pointer to an integer that can be used to store the thread ID from the kernel.</li> </ul>"},{"location":"docs/events/builtin/syscalls/set_tid_address/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/set_tid_address/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/set_tid_address/#sys_set_tid_address","title":"SyS_set_tid_address","text":""},{"location":"docs/events/builtin/syscalls/set_tid_address/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/set_tid_address/#purpose","title":"Purpose","text":"<p>Hook the entry point to set_tid_address system call in order to trace threads created using the clone system call.</p>"},{"location":"docs/events/builtin/syscalls/set_tid_address/#example-use-case","title":"Example Use Case","text":"<p>set_tid_address is commonly used when creating new threads with the clone system call. It allows the thread to receive the child thread's ID through the pointer provided.</p> <p>One example of using set_tid_address is in the Linux kernel source code. The _do_fork syscall uses set_tid_address in order to set the thread ID for the new thread.</p>"},{"location":"docs/events/builtin/syscalls/set_tid_address/#issues","title":"Issues","text":"<p>The set_tid_address system call is not supported on some architectures.</p>"},{"location":"docs/events/builtin/syscalls/set_tid_address/#related-events","title":"Related Events","text":"<ul> <li>clone - used together with set_tid_address to create new threads.</li> <li>gettid - can be used to obtain the thread ID after set_tid_address is called.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setdomainname/","title":"setdomainname","text":""},{"location":"docs/events/builtin/syscalls/setdomainname/#intro","title":"Intro","text":"<p>setdomainname - sets the system's hostname to the given name </p>"},{"location":"docs/events/builtin/syscalls/setdomainname/#description","title":"Description","text":"<p>The setdomainname() system call is used to set the domain name of the system. The name is set to the value pointed to by the argument name, which is subject to the size restrictions on the hostname parameter as specified by length.</p> <p>The setdomainname() syscall is generally used in conjunction with the sethostname() syscall, which sets the hostname parameter. </p> <p>This system call is useful for setting the full domain name of a system as part of a larger system or network. It is also useful for setting up servers and switches on a local network.</p>"},{"location":"docs/events/builtin/syscalls/setdomainname/#arguments","title":"Arguments","text":"<ul> <li><code>name</code>: <code>const char*</code>[K] - a pointer to a character string specifying the domain name of the system. </li> <li><code>len</code>: <code>size_t</code>[K] - length of the supplied name, in bytes.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setdomainname/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setdomainname/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setdomainname/#sys_setdomainname","title":"sys_setdomainname","text":""},{"location":"docs/events/builtin/syscalls/setdomainname/#type","title":"Type","text":"<p>KProbes</p>"},{"location":"docs/events/builtin/syscalls/setdomainname/#purpose","title":"Purpose","text":"<p>To log every setdomainname call and its arguments.</p>"},{"location":"docs/events/builtin/syscalls/setdomainname/#example-use-case","title":"Example Use Case","text":"<p>You are setting up a local network with several servers and computers in order to host an application. You can use the sethostname and setdomainname calls to quickly configure the system to have the unique domain name and host name that is required for this application.</p>"},{"location":"docs/events/builtin/syscalls/setdomainname/#issues","title":"Issues","text":"<p>None known.</p>"},{"location":"docs/events/builtin/syscalls/setdomainname/#related-events","title":"Related Events","text":"<ul> <li>sethostname - sets the system's hostname. </li> <li>uname - gets system information, including domainname and hostname.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setfsgid/","title":"setfsgid","text":""},{"location":"docs/events/builtin/syscalls/setfsgid/#intro","title":"Intro","text":"<p>setfsgid - This system call changes the Effective Group ID of the calling process to the group ID passed in.  </p>"},{"location":"docs/events/builtin/syscalls/setfsgid/#description","title":"Description","text":"<p>The setfsgid() system call sets the Effective Group ID of the calling process to the group ID passed in. no permission checks are performed. This means that setfsgid() is allowed to set the Effective Group ID to values which are not permitted for the real user ID or for the saved set-user-ID.</p> <p>setfsgid() is allowed in environments where the user is not privileged (Does not have the CAP_SETGID capability). It is typically used by programs that change their group ID in order to access group-restricted files, but do not want to permanently drop all group privileges.</p> <p>The setfsgid() system call is the non-privileged version of the setegid() system call (which sets the Effective Group ID of a process). The setfsgid() system call also changes the File System Group ID (FSGID) of the calling process. The FSGID is used as the group for new files created by the calling process; it is also used for determining file access for non-numeric user ID or group ID permissions.</p>"},{"location":"docs/events/builtin/syscalls/setfsgid/#arguments","title":"Arguments","text":"<ul> <li><code>fsgid</code>: <code>gid_t</code> - The group ID to set the Effective Group ID and the File System Group ID to.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setfsgid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setfsgid/#sys_setfsgid","title":"SYS_setfsgid","text":""},{"location":"docs/events/builtin/syscalls/setfsgid/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/setfsgid/#purpose","title":"Purpose","text":"<p>This function is hooked to capture when the setfsgid syscall is called and log the arguments passed in.</p>"},{"location":"docs/events/builtin/syscalls/setfsgid/#example-use-case","title":"Example Use Case","text":"<p>The setfsgid() system call can be used by applications that want to change their group ID temporarily in order to access group-restricted files, but do not want to permanently drop all group privileges.</p>"},{"location":"docs/events/builtin/syscalls/setfsgid/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/setfsgid/#related-events","title":"Related Events","text":"<ul> <li>setgid</li> <li>getgid</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setfsgid16/","title":"setfsgid16","text":""},{"location":"docs/events/builtin/syscalls/setfsgid16/#intro","title":"Intro","text":"<p>setfsgid16 - set the effective group id for the current thread</p>"},{"location":"docs/events/builtin/syscalls/setfsgid16/#description","title":"Description","text":"<p>The setfsgid16() call sets the effective group ID for the current thread to fsgid. It is analogous to setegid(), but can only be used to set the effective group ID of the calling process to one of the real, effective, or saved GIDs.</p> <p>setfsgid16() is intended for use only in systems with an 16-bit GID type. On Linux and other systems with a 32-bit GID type, the setfsgid() wrapper function is provided using the new setfsgid32() system call.</p>"},{"location":"docs/events/builtin/syscalls/setfsgid16/#arguments","title":"Arguments","text":"<ul> <li><code>fsgid</code>:<code>old_gid_t</code>[U, OPT] - the new group id for the current thread.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setfsgid16/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/setfsgid16/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setfsgid16/#sys_setfsgid16","title":"sys_setfsgid16","text":""},{"location":"docs/events/builtin/syscalls/setfsgid16/#type","title":"Type","text":"<p>Tracepoints</p>"},{"location":"docs/events/builtin/syscalls/setfsgid16/#purpose","title":"Purpose","text":"<p>To monitor attempts to change the effective group ID of the current thread.</p>"},{"location":"docs/events/builtin/syscalls/setfsgid16/#example-use-case","title":"Example Use Case","text":"<p>A user space application could use setfsgid16() to change its effective GID after verifying its permission to do so.</p>"},{"location":"docs/events/builtin/syscalls/setfsgid16/#issues","title":"Issues","text":"<p>None known.</p>"},{"location":"docs/events/builtin/syscalls/setfsgid16/#related-events","title":"Related Events","text":"<p>setegid(), setfsgid32()</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setfsuid/","title":"setfsuid","text":""},{"location":"docs/events/builtin/syscalls/setfsuid/#intro","title":"Intro","text":"<p>setfsuid - change the effective user id of the current process</p>"},{"location":"docs/events/builtin/syscalls/setfsuid/#description","title":"Description","text":"<p>setfsuid() changes the effective user ID of the calling process. If the effective ID of the caller is root, the real UID and saved set-user-ID are also set.</p> <p>In case the fsuid is set to a value not equal to the current real and effective UIDs, the permission check for system calls and certain library functions is done against the effective user ID. This can be used to implement (amongst other things) effective privilege separation in set-user-ID programs without requiring the set-user-ID bit to be set on the executable file.</p>"},{"location":"docs/events/builtin/syscalls/setfsuid/#arguments","title":"Arguments","text":"<ul> <li><code>fsuid</code>:<code>uid_t</code> - The effective user id(UID) to set.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setfsuid/#available-tags","title":"Available Tags","text":"<p>N/A</p>"},{"location":"docs/events/builtin/syscalls/setfsuid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setfsuid/#sys_setfsuid","title":"sys_setfsuid","text":""},{"location":"docs/events/builtin/syscalls/setfsuid/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/setfsuid/#purpose","title":"Purpose","text":"<p>To trace user calls to setfsuid() system call.</p>"},{"location":"docs/events/builtin/syscalls/setfsuid/#example-use-case","title":"Example Use Case","text":"<p>The setfsuid system call can be used in a set-user-ID program for privilege separation. By calling setfsuid() and setting it to a specific user, it can restrict the privileges available to the program and prevent unwanted privilege escalation.</p>"},{"location":"docs/events/builtin/syscalls/setfsuid/#issues","title":"Issues","text":"<p>If a process' effective user id (UID) is not equal to that of the calling process, then the permission check for system calls and certain library functions will be done against the setfsuid value, which could create a security vulnerability.</p>"},{"location":"docs/events/builtin/syscalls/setfsuid/#related-events","title":"Related Events","text":"<p>setfsuid32, setresuid, setresuid32</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setfsuid16/","title":"setfsuid16","text":""},{"location":"docs/events/builtin/syscalls/setfsuid16/#intro","title":"Intro","text":"<p>setfsuid16 - sets the effective user ID of the calling process</p>"},{"location":"docs/events/builtin/syscalls/setfsuid16/#description","title":"Description","text":"<p>The setfsuid16 syscall sets the effective user ID of the calling process to fsuid. This syscall will only be successful if the user process has the appropriate privileges to set their own effective user ID to the given value. This syscall can be used to change the effective user ID of the calling process, and it may also set the saved set-user-ID if the user has appropriate privileges. It is important to note that this does not change the real user ID or group ID, or the process credentials. </p> <p>In order for a process to make use of this syscall, the user needs to have the capability CAP_SETUID set.</p>"},{"location":"docs/events/builtin/syscalls/setfsuid16/#arguments","title":"Arguments","text":"<ul> <li><code>fsuid</code>:<code>old_uid_t</code>[K] - The effective user ID of the calling process will be set to this value.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setfsuid16/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setfsuid16/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setfsuid16/#sys_setfsuid16","title":"sys_setfsuid16","text":""},{"location":"docs/events/builtin/syscalls/setfsuid16/#type","title":"Type","text":"<p>KProbe</p>"},{"location":"docs/events/builtin/syscalls/setfsuid16/#purpose","title":"Purpose","text":"<p>To monitor processes changing their effective user ID.</p>"},{"location":"docs/events/builtin/syscalls/setfsuid16/#example-use-case","title":"Example Use Case","text":"<p>This syscall can be used to set the effective user ID of the calling process to a different value, which might be necessary in the case of switching users in a process.</p>"},{"location":"docs/events/builtin/syscalls/setfsuid16/#issues","title":"Issues","text":"<p>This syscall can lead to a privilege escalation vulnerability if used incorrectly. Care should be taken to ensure that the user has the appropriate privileges to set their own effective user ID.</p>"},{"location":"docs/events/builtin/syscalls/setfsuid16/#related-events","title":"Related Events","text":"<p>setresuid16</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setgid/","title":"setgid","text":""},{"location":"docs/events/builtin/syscalls/setgid/#intro","title":"Intro","text":"<p>setgid - set group identity of the current process</p>"},{"location":"docs/events/builtin/syscalls/setgid/#description","title":"Description","text":"<p>The <code>setgid</code> syscall is used to set the group identity of the current process. This syscall does not affect the supplemental group list (see <code>getgroups</code>/<code>setgroups</code>). On most implementations, only root is allowed to call this syscall.</p> <p>The primary advantage of using <code>setgid</code> is that it is a very simple, lightweight way to switch the group ID of the current process. However, there are some edge-cases to be aware of. Not all implementations will set the effective GID on all threads, which can lead to inconsistent behavior. Additionally, this syscall does not affect the supplemental groups list, so any groups set through <code>setgid</code> will not be applied to any child processes which are created.</p>"},{"location":"docs/events/builtin/syscalls/setgid/#arguments","title":"Arguments","text":"<ul> <li><code>gid</code>:<code>gid_t</code> - The GID to use as the effective GID of the calling process.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setgid/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setgid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setgid/#sys_setgid","title":"sys_setgid","text":""},{"location":"docs/events/builtin/syscalls/setgid/#type","title":"Type","text":"<p>kprobes + kretprobes</p>"},{"location":"docs/events/builtin/syscalls/setgid/#purpose","title":"Purpose","text":"<p>To monitor the entry and return from setgid calls.</p>"},{"location":"docs/events/builtin/syscalls/setgid/#example-use-case","title":"Example Use Case","text":"<p>This could be used to monitor processes attempting to change their group ID, which may indicate an attack being launched or escalation of privileges.</p>"},{"location":"docs/events/builtin/syscalls/setgid/#issues","title":"Issues","text":"<p>This syscall does not affect the supplemental group list, so any groups set through <code>setgid</code> will not be applied to any child processes which are created.</p>"},{"location":"docs/events/builtin/syscalls/setgid/#related-events","title":"Related Events","text":"<ul> <li><code>getgid</code> - get the group identity of the current process</li> <li><code>setgroups</code> - call to set the supplemental group list</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setgid16/","title":"setgid16","text":""},{"location":"docs/events/builtin/syscalls/setgid16/#intro","title":"Intro","text":"<p>setgid16 - change the effective of the calling process and the saved set-group-ID</p>"},{"location":"docs/events/builtin/syscalls/setgid16/#description","title":"Description","text":"<p>The setgid16() system call is used to set the user's real group ID, effective group ID, and the saved set-group-ID of the calling process. This can be used to change the privileges of a process to that of a new group. The setgid16() call is one of the set-ID system calls, meaning that the real user ID and effective user ID of the calling process will also be set. This call is made obsolete by the setgid() call.</p>"},{"location":"docs/events/builtin/syscalls/setgid16/#arguments","title":"Arguments","text":"<ul> <li><code>gid</code>:<code>old_gid_t</code>[KU] - represents a group ID.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setgid16/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it).</li> </ul>"},{"location":"docs/events/builtin/syscalls/setgid16/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setgid16/#sys_setgid16","title":"sys_setgid16","text":""},{"location":"docs/events/builtin/syscalls/setgid16/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/setgid16/#purpose","title":"Purpose","text":"<p>To capture calls to the setgid16 system call.</p>"},{"location":"docs/events/builtin/syscalls/setgid16/#example-use-case","title":"Example Use Case","text":"<p>The setgid16 system call could be used to temporarily switch the effective group ID of a process from a privileged group to that of an unprivileged single-user group in order to perform a task that requires elevated privileges. After the task is complete, the process can be switched back to its original group ID.</p>"},{"location":"docs/events/builtin/syscalls/setgid16/#issues","title":"Issues","text":"<p>The setgid16 system call is obsolete and should not be used in modern Linux systems. It should be replaced with setgid.</p>"},{"location":"docs/events/builtin/syscalls/setgid16/#related-events","title":"Related Events","text":"<ul> <li>setgid</li> <li>getgid</li> <li>setegid</li> <li>getegid</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setgroups/","title":"setgroups","text":""},{"location":"docs/events/builtin/syscalls/setgroups/#intro","title":"Intro","text":"<p>setgroups - sets the list of supplementary groups of the calling process</p>"},{"location":"docs/events/builtin/syscalls/setgroups/#description","title":"Description","text":"<p>The setgroups() system call allows the calling process to set its supplementary group IDs directly, without manipulating the supplementary group IDs with  the  initgroups() system call.  The setgroups() system call is limited to  processes  with  the  CAP_SETGID  capability  and with an effective user ID of 0. </p> <p>This system call is the complementary system call to the getgroups() system call, which gets the supplementary group IDs of the calling process.</p>"},{"location":"docs/events/builtin/syscalls/setgroups/#arguments","title":"Arguments","text":"<ul> <li><code>size</code>:<code>int</code> - The  number of supplementary group IDs in the list. </li> <li><code>list</code>:<code>gid_t*</code>[K] - A pointer to the list of group IDs.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setgroups/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setgroups/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setgroups/#sys_setgroups","title":"sys_setgroups","text":""},{"location":"docs/events/builtin/syscalls/setgroups/#type","title":"Type","text":"<p>kprobe+kretprobe</p>"},{"location":"docs/events/builtin/syscalls/setgroups/#purpose","title":"Purpose","text":"<p>Observe setgroups() calls and the return values.</p>"},{"location":"docs/events/builtin/syscalls/setgroups/#example-use-case","title":"Example Use Case","text":"<p>For example, an administrator could use the setgroups() system call to change the supplementary group IDs associated with a process in order to temporarily assign it additional privileges.</p>"},{"location":"docs/events/builtin/syscalls/setgroups/#issues","title":"Issues","text":"<p>One possible issue with setgroups is that it may be vulnerable to time of check, time of use (TOCTOU) race conditions.</p>"},{"location":"docs/events/builtin/syscalls/setgroups/#related-events","title":"Related Events","text":"<p>getgroups - gets the list of supplementary groups of the calling process</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setgroups16/","title":"setgroups16","text":""},{"location":"docs/events/builtin/syscalls/setgroups16/#intro","title":"Intro","text":"<p>setgroups16 - assign process's supplementary group IDs</p>"},{"location":"docs/events/builtin/syscalls/setgroups16/#description","title":"Description","text":"<p>The <code>setgroups16()</code> system call sets the supplementary group IDs for the process. The argument <code>size</code> specifies the number of group IDs passed in <code>list</code>. The group IDs in <code>list</code> are set for the range <code>0 &lt;= i &lt; size</code>. If the process is privileged, all request IDs can be set; otherwise, an error may be returned if any of the IDs specified by <code>list</code> are invalid or are not valid and permissible for the real user ID of the calling process.</p> <p>Unlike <code>setgroups()</code> which sets the object's Supplementary Group IDs to exactly those supplied in <code>list</code>, <code>setgroups16()</code> sets filling the Supplementary Group IDs with values taken from <code>list</code> and leaves empty entries after the last one specified in <code>list</code>, following the BSD 4.3 behaviour.</p>"},{"location":"docs/events/builtin/syscalls/setgroups16/#arguments","title":"Arguments","text":"<ul> <li><code>size</code>:<code>size_t</code>[K] - specifies the number of group Ids passed in list.</li> <li><code>list</code>:<code>const gid_t*</code>[U] - contains the group IDs to be set for the calling process.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setgroups16/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/setgroups16/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setgroups16/#do_setgroups16","title":"do_setgroups16","text":""},{"location":"docs/events/builtin/syscalls/setgroups16/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/setgroups16/#purpose","title":"Purpose","text":"<p>This hook is used to monitor the system call do_setgroups16 which is responsible for setting the supplementary group IDs of a process.</p>"},{"location":"docs/events/builtin/syscalls/setgroups16/#example-use-case","title":"Example Use Case","text":"<p>This function can be used to detect changes in the supplementary group IDs of a process. For example, this can be used to detect if a malicious process is setting itself as the root user.</p>"},{"location":"docs/events/builtin/syscalls/setgroups16/#issues","title":"Issues","text":"<p>No known issues.</p>"},{"location":"docs/events/builtin/syscalls/setgroups16/#related-events","title":"Related Events","text":"<p>This system call is related to the <code>setgroups()</code> system call since it set the supplementary group IDs of a process in a similar way. Also related is the <code>getgroups16()</code> system call which can be used to retrieve the current supplementary group IDs assigned to a process.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sethostname/","title":"sethostname","text":""},{"location":"docs/events/builtin/syscalls/sethostname/#intro","title":"Intro","text":"<p>sethostname - a syscall to set the system's hostname </p>"},{"location":"docs/events/builtin/syscalls/sethostname/#description","title":"Description","text":"<p>The sethostname() system call is used to set the system's hostname. The hostname is a single component of the fully qualified domain name (FQDN) of a system. The sethostname() call takes two arguments; the first argument is a pointer to a character string specifying the host name, and the second argument is the size of the character string pointed to by the first argument. The system hostname is limited to a maximum length of __HOST_NAME_MAX bytes (defined in limits.h) not including the NUL terminator.</p> <p>The sethostname() call does not make any consistency checks for the given hostname. The only requirement for setting the hostname is that it should be a valid NUL terminated character string. It is up to the caller to ensure that the hostname is valid and properly formatted.</p> <p>The sethostname() call is provided for compatibility with BSD systems. It is recommended that applications use sethostname() with caution and verify that the hostname is properly formed.</p>"},{"location":"docs/events/builtin/syscalls/sethostname/#arguments","title":"Arguments","text":"<ul> <li><code>name</code>:<code>const char*</code>[KU] - Pointer to a character string specifying the system's hostname.  </li> <li><code>len</code>:<code>size_t</code>[K] - Length of the character string specified by name.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sethostname/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/sethostname/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sethostname/#sys_sethostname","title":"sys_sethostname","text":""},{"location":"docs/events/builtin/syscalls/sethostname/#type","title":"Type","text":"<p>Kprobe + Kretprobe </p>"},{"location":"docs/events/builtin/syscalls/sethostname/#purpose","title":"Purpose","text":"<p>To record system calls and argument passing information.</p>"},{"location":"docs/events/builtin/syscalls/sethostname/#example-use-case","title":"Example Use Case","text":"<p>The sethostname() system call can be used to set the hostname of a system. This can be useful in cloud environments, where automated scripts can set hostnames based on the environment they're running in.</p>"},{"location":"docs/events/builtin/syscalls/sethostname/#issues","title":"Issues","text":"<p>The sethostname() call does not verify the hostname given to it. This can be a security issue if an attacker is able to manipulate the parameters being passed. </p> <p>To mitigate this, it is important to always verify the hostname being passed to the sethostname() call.</p>"},{"location":"docs/events/builtin/syscalls/sethostname/#related-events","title":"Related Events","text":"<ul> <li>gethostname() - retrieve the system's hostname.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setitimer/","title":"setitimer","text":""},{"location":"docs/events/builtin/syscalls/setitimer/#intro","title":"Intro","text":"<p>setitimer - set value of an interval timer</p>"},{"location":"docs/events/builtin/syscalls/setitimer/#description","title":"Description","text":"<p>The <code>setitimer</code> system call sets the value of an interval timer. It sets the clock associated with the timer <code>which</code> according to the <code>new_value</code> argument. If <code>old_value</code> is non-NULL, the previous value of the timer is stored there. The time is measured in seconds, microseconds and nanoseconds (if possible on the platform); if required, the time is rounded up to the system clock granularity, and kernel-internal quantities are measured in jiffies (1/100ths of a second).</p> <p>This system call is useful for applications that need to be periodically notified, for example to update statistics or audit data.</p>"},{"location":"docs/events/builtin/syscalls/setitimer/#arguments","title":"Arguments","text":"<ul> <li><code>which</code>:<code>int</code>[K] - Specifies which of the four interval timers to set. It can take one of the following values: ITIMER_REAL, ITIMER_VIRTUAL, ITIMER_PROF or ITIMER_MONOTONIC.</li> <li><code>new_value</code>:<code>struct itimerval*</code>[KU] - A pointer to a <code>struct itimerval</code> data structure which sets the new values of the interval timer.</li> <li><code>old_value</code>:<code>struct itimerval*</code>[U] - A pointer to a <code>struct itimerval</code> data structure that will be filled with the reset value(s) of the interval timer.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setitimer/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/setitimer/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setitimer/#do_setitimer","title":"do_setitimer","text":""},{"location":"docs/events/builtin/syscalls/setitimer/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/setitimer/#purpose","title":"Purpose","text":"<p>To monitor when an interval timer is set.</p>"},{"location":"docs/events/builtin/syscalls/setitimer/#example-use-case","title":"Example Use Case","text":"<p>An application which needs to perform multiple periodic tasks, each on a different interval, can use <code>setitimer</code> system call to set up different interval timers. </p>"},{"location":"docs/events/builtin/syscalls/setitimer/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/setitimer/#related-events","title":"Related Events","text":"<ul> <li><code>getitimer</code>, <code>timer_create</code>, <code>timer_delete</code>, <code>timer_settime</code>, <code>timer_gettime</code>, <code>timer_getoverrun</code>.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setns/","title":"setns","text":""},{"location":"docs/events/builtin/syscalls/setns/#intro","title":"Intro","text":"<p>setns - allows processes to join a namespace or modify an existing namespace</p>"},{"location":"docs/events/builtin/syscalls/setns/#description","title":"Description","text":"<p>The setns system call is used to join a namespace or modify an existing namespace of a process. The call takes two parameters, a file descriptor to a namespace and the requested label ('nstype') of the namespace. The call fails if the provided namespace isn't supported by the kernel, if the calling process (or thread) had different user and group IDs when it created the namespace, or if the user doesn't have access to joining the namespace. Generally, the user must own the file descriptor and be privileged to change their namespace. </p> <p>The joined, or modified, namespace can alter the process's view of resources, such as mount points, network devices, and process identifiers. Joining a namespace requires the process to disassociate from the previous namespace. The process's view of its resources is not immediately updated, so the process may experience inconsistent behavior until the update completes.</p>"},{"location":"docs/events/builtin/syscalls/setns/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[U] - A file descriptor that refers to an existing namespace.   </li> <li><code>nstype</code>:<code>int</code>[K] - The requested label of the namespace.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setns/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/setns/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setns/#sys_setns","title":"sys_setns","text":""},{"location":"docs/events/builtin/syscalls/setns/#type","title":"Type","text":"<p>Kprobes + SystemTap</p>"},{"location":"docs/events/builtin/syscalls/setns/#purpose","title":"Purpose","text":"<p>Logging/Monitoring of setns syscall - to detect namespace related vulnerabilities or analyze namespace resource usage.</p>"},{"location":"docs/events/builtin/syscalls/setns/#example-use-case","title":"Example Use Case","text":"<p>A system administrator would use setns to join a process to an existing namespace in order to monitor its resource usage.</p>"},{"location":"docs/events/builtin/syscalls/setns/#issues","title":"Issues","text":"<p>setns could be used to bypass kernel resource protection mechanisms. The kernel should prevent unprivileged users from joining namespaces that are owned by privileged users.</p>"},{"location":"docs/events/builtin/syscalls/setns/#related-events","title":"Related Events","text":"<ul> <li>clone() - to create new namespaces</li> <li>unshare() - to Split away parts of the thread's current execution context into a new unshared execution environment.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setpgid/","title":"setpgid","text":""},{"location":"docs/events/builtin/syscalls/setpgid/#intro","title":"Intro","text":"<p>setpgid - Set the process group ID of a process</p>"},{"location":"docs/events/builtin/syscalls/setpgid/#description","title":"Description","text":"<p>The setpgid() function sets the process group ID of the process specified by pid to pgid.  If pid is zero, the process ID of the current process is used.  If pgid is zero, the process ID of the process specified by pid is used.  The setpgid() system call is allowed only for a process with a single thread.</p> <p>Setpgid can be used to implement job control in a shell.  In a single-threaded program, setpgid() can be used to create a new process group within the same session.</p>"},{"location":"docs/events/builtin/syscalls/setpgid/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>pid_t</code> - The process ID of the process.</li> <li><code>pgid</code>:<code>pid_t</code> - The ID of the process group to which the process should be moved.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setpgid/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setpgid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setpgid/#setpgid_1","title":"setpgid","text":""},{"location":"docs/events/builtin/syscalls/setpgid/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/setpgid/#purpose","title":"Purpose","text":"<p>To instrument the process control system call to detect changes in the process group ID.</p>"},{"location":"docs/events/builtin/syscalls/setpgid/#example-use-case","title":"Example Use Case","text":"<p>Monitoring changes in process group IDs, particularly when using Job Control (e.g. with a shell).</p>"},{"location":"docs/events/builtin/syscalls/setpgid/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/setpgid/#related-events","title":"Related Events","text":"<ul> <li>execve() - Used to create a new process session and set the process group ID.</li> <li>setpgrp() - Used to set the process group ID of the current process and create a new process group.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setpriority/","title":"setpriority","text":""},{"location":"docs/events/builtin/syscalls/setpriority/#intro","title":"Intro","text":"<p>setpriority - modifies the scheduling priority of specified process</p>"},{"location":"docs/events/builtin/syscalls/setpriority/#description","title":"Description","text":"<p>The setpriority() system call is used to modify the scheduling priority of specified process or process group.</p> <p>The which argument allows the priority of one of the following selections to be changed: * PRIO_PROCESS -  change the priority of specified process * PRIO_PGRP -  change the priority of all processes in the specified process group * PRIO_USER -  change the priority of all processes for the specified user</p> <p>The who argument specifies the process, process group, or user the priority of which is to be changed. The who argment should be different from 0 to specify a process instead of a process group or user.</p> <p>The prio argument allows the priority to be specified as a value in the range -20 to 19. A lower numerical value causes a process to be scheduled with higher priority.</p>"},{"location":"docs/events/builtin/syscalls/setpriority/#arguments","title":"Arguments","text":"<ul> <li><code>which</code>:<code>int</code>[K] - specifies which selection is to be modified</li> <li><code>who</code>:<code>int</code>[K] - user ID of the process or process group to be modified </li> <li><code>prio</code>:<code>int</code>[K] - the new priority value in the range -20 to 19</li> </ul>"},{"location":"docs/events/builtin/syscalls/setpriority/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setpriority/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setpriority/#sys_setpriority","title":"sys_setpriority","text":""},{"location":"docs/events/builtin/syscalls/setpriority/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/setpriority/#purpose","title":"Purpose","text":"<p>Capture information about process scheduling priority changes</p>"},{"location":"docs/events/builtin/syscalls/setpriority/#example-use-case","title":"Example Use Case","text":"<p>The setpriority() system call can be used to customize the scheduling priorities for certain processes on the system. For example, setting the scheduling priority of a process containing a real-time task to a higher priority than that of other processes.</p>"},{"location":"docs/events/builtin/syscalls/setpriority/#issues","title":"Issues","text":"<p>This system call only gives priority to processes with non-real-time priority scheduling. Real-time priority schedulers should be done with other syscalls.</p>"},{"location":"docs/events/builtin/syscalls/setpriority/#related-events","title":"Related Events","text":"<ul> <li>sched_setattr() - sets attributes for process scheduling</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setregid/","title":"setregid","text":""},{"location":"docs/events/builtin/syscalls/setregid/#intro","title":"Intro","text":"<p>setregid - set the real/effective group id of the calling process</p>"},{"location":"docs/events/builtin/syscalls/setregid/#description","title":"Description","text":"<p>The setregid() system call conveniently sets both the real and effective group ids of the calling process. It requires two arguments \u2013 rgid and egid \u2013 that are both of type gid_t. This syscall provides an easy way for changing group id for processes thereby enabling effective group management.</p> <p>Additionally, setregid() can be used to grant privilege. This can be done by temporarily setting the effective group ID to a privileged group, executing the required operations and then setting it back.</p>"},{"location":"docs/events/builtin/syscalls/setregid/#arguments","title":"Arguments","text":"<ul> <li><code>rgid</code>:<code>gid_t</code> - The real group ID of the calling process.</li> <li><code>egid</code>:<code>gid_t</code> - The effective group ID of the calling process.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setregid/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/setregid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setregid/#sys_setegid","title":"sys_setegid","text":""},{"location":"docs/events/builtin/syscalls/setregid/#type","title":"Type","text":"<p>Tracepoint</p>"},{"location":"docs/events/builtin/syscalls/setregid/#purpose","title":"Purpose","text":"<p>In order to monitor any changes to the effective group ID of a process.</p>"},{"location":"docs/events/builtin/syscalls/setregid/#sys_setregid","title":"sys_setregid","text":""},{"location":"docs/events/builtin/syscalls/setregid/#type_1","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/setregid/#purpose_1","title":"Purpose","text":"<p>In order to monitor processes setting their real or effective group ID.</p>"},{"location":"docs/events/builtin/syscalls/setregid/#example-use-case","title":"Example Use Case","text":"<p>A service might need to be able to switch user/group contexts in order to access restricted sections. Using this event, the system administrator can monitor the service behaviour and check for suspicious real/group ID changes.</p>"},{"location":"docs/events/builtin/syscalls/setregid/#issues","title":"Issues","text":"<p>None</p>"},{"location":"docs/events/builtin/syscalls/setregid/#related-events","title":"Related Events","text":"<p>Other events related to setregid() are getuid(), setreuid(), setgid(), and getgid().</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setregid16/","title":"setregid16","text":""},{"location":"docs/events/builtin/syscalls/setregid16/#intro","title":"Intro","text":"<p>setregid16 - Set real and effective group IDs in a 16-bit environment</p>"},{"location":"docs/events/builtin/syscalls/setregid16/#description","title":"Description","text":"<p>The setregid16() system call changes the real and effective group IDs of the calling process to rgid and egid, respectively.  The argument rgid is taken as the new real group ID, and the argument egid is taken as the new effective group ID. If the effective UID of the process is 0 (root), then both arguments are taken as the real group ID and the saved group ID is set to egid. If the effective UID of the process is nonzero, then only rgid needs to be equal to the real group ID, and setregid16() sets the effective group ID to egid provided that it is equal to either the real group ID or the saved group ID.</p>"},{"location":"docs/events/builtin/syscalls/setregid16/#arguments","title":"Arguments","text":"<ul> <li><code>rgid</code>:<code>old_gid_t</code>[K] - Real group ID to be set.</li> <li><code>egid</code>:<code>old_gid_t</code>[K] - Effective group ID to be set.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setregid16/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setregid16/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setregid16/#sys_setregid16","title":"sys_setregid16","text":""},{"location":"docs/events/builtin/syscalls/setregid16/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/setregid16/#purpose","title":"Purpose","text":"<p>Trace when the setregid16 system call is called. </p>"},{"location":"docs/events/builtin/syscalls/setregid16/#example-use-case","title":"Example Use Case","text":"<p>Setregid16 can be useful in security contexts as it allows to change the real GID of the current process to a specific number or values which is important for granting or revoking access to certain resources which could be guarded by specific modern capabilities. </p>"},{"location":"docs/events/builtin/syscalls/setregid16/#issues","title":"Issues","text":"<p>It is important to note that setregid16 system call has been deprecated in newer versions of Linux in favor of setregid system call. </p>"},{"location":"docs/events/builtin/syscalls/setregid16/#related-events","title":"Related Events","text":"<ul> <li><code>setregid</code> system call</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setresgid/","title":"setresgid","text":""},{"location":"docs/events/builtin/syscalls/setresgid/#intro","title":"Intro","text":"<p>setresgid - Changes the calling process's real, effective, and saved set-group-ID privileges</p>"},{"location":"docs/events/builtin/syscalls/setresgid/#description","title":"Description","text":"<p>The setresgid() system call is used to change the real, effective, and saved set-group-ID privileges. It is analogous to setresuid() for user IDs. The new IDs are provided in the rgid, egid and sgid arguments, respectively. Only a privileged process (Linux: one with the CAP_SETUID capability) can set the real UID, effective UID, or saved UID to an arbitrary value. An unprivileged process may set any or all of the effective, real, or saved user IDs to the current value of the corresponding real, effective, or saved user ID, or to the value of some other user ID in the same user group as the corresponding real, effective, or saved user ID.</p> <p>It should be noted that the setresgid() call does not clear up any supplementary group IDs. These remain unchanged in all cases. To change the group membership, the setgroups() system call must be used.</p>"},{"location":"docs/events/builtin/syscalls/setresgid/#arguments","title":"Arguments","text":"<ul> <li><code>rgid</code>:<code>gid_t</code>[K] - The  rgid argument specifies the new real group ID for the calling process.</li> <li><code>egid</code>:<code>gid_t</code>[K] - The  egid argument specifies the new effective group ID for the calling process.</li> <li><code>sgid</code>:<code>gid_t</code>[K] - The  sgid argument specifies the new saved set-group-ID for the calling process.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setresgid/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/setresgid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setresgid/#sys_setresgid","title":"sys_setresgid","text":""},{"location":"docs/events/builtin/syscalls/setresgid/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/setresgid/#purpose","title":"Purpose","text":"<p>The purpose of hooks for the setresgid call is to analyze process privilege escalation and the effectiveness of security mechanisms.  </p>"},{"location":"docs/events/builtin/syscalls/setresgid/#example-use-case","title":"Example Use Case","text":"<p>A system task was designed to invoke the setresgid system call to increase the privileges of another security process on the system. This could be used to monitor whether the task is effective and what parameters are used in the call.</p>"},{"location":"docs/events/builtin/syscalls/setresgid/#issues","title":"Issues","text":"<p>In order to call setresgid() successfully, the user must have the CAP_SETUID capability.</p>"},{"location":"docs/events/builtin/syscalls/setresgid/#related-events","title":"Related Events","text":"<p>setresuid() - used to change the real, effective, and saved user IDs of the calling process.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setresgid16/","title":"setresgid16","text":""},{"location":"docs/events/builtin/syscalls/setresgid16/#intro","title":"Intro","text":"<p>setresgid16 - set real, effective and saved user or group ID</p>"},{"location":"docs/events/builtin/syscalls/setresgid16/#description","title":"Description","text":"<p>The setresgid16() system call sets the real GID, effective GID, and saved set-user-ID of the calling process. This call sets the three GIDs with a single syscall, instead of the sets the individual GID values with setregid(2). </p> <p>The three GIDs are set according to the following rules:</p> <ul> <li> <p>If rgid is not (uid_t)-1, it is set as the real GID of the process;</p> </li> <li> <p>If egid is not (uid_t)-1, it is set as the effective GID of the process;</p> </li> <li> <p>If suid is not (uid_t)-1, it is set as the saved set-GID of the process.</p> </li> </ul> <p>It is permitted that the real GID, effective GID, and saved set-GID are all set to the same value. </p> <p>By convention, a set-user-ID or set-GID program should clear the saved set-user-ID or set-GID when it starts, and should do so early in its initialization before other things that might open files or create child processes. In an environment where file names are relied on to be predictable and unchanging, using setresgid16() to clear the saved set-GID avoids certain security problems (but also see getresgid16(2), below).</p>"},{"location":"docs/events/builtin/syscalls/setresgid16/#arguments","title":"Arguments","text":"<ul> <li><code>rgid</code>:<code>old_uid_t</code>[K] - real group ID of the calling process. </li> <li><code>euid</code>:<code>old_uid_t</code>[K] - effective group ID of the calling process. </li> <li><code>suid</code>:<code>old_uid_t</code>[K] - saved set-group-ID of the calling process.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setresgid16/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setresgid16/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setresgid16/#sys_setresgid16","title":"sys_setresgid16","text":""},{"location":"docs/events/builtin/syscalls/setresgid16/#type","title":"Type","text":"<p>Kprobe.</p>"},{"location":"docs/events/builtin/syscalls/setresgid16/#purpose","title":"Purpose","text":"<p>To monitor execution of the setresgid16() system call and get the values of the given arguments.</p>"},{"location":"docs/events/builtin/syscalls/setresgid16/#example-use-case","title":"Example Use Case","text":"<p>This event can be used to monitor changes in the real GID, effective GID and saved set-GID of the running process. It can be used to identify abnormal behavior or unexpected modifications in these GIDs.</p>"},{"location":"docs/events/builtin/syscalls/setresgid16/#issues","title":"Issues","text":"<p>N/A</p>"},{"location":"docs/events/builtin/syscalls/setresgid16/#related-events","title":"Related Events","text":"<ul> <li>sys_setregid16() - sets the real GID and effective GID of the calling process.</li> <li>sys_setresuid16() - sets the real UID, effective UID, and saved set-user-ID of the calling process.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setresuid/","title":"setresuid","text":""},{"location":"docs/events/builtin/syscalls/setresuid/#intro","title":"Intro","text":"<p>setresuid - set real, effective, and saved user IDs of the calling process</p>"},{"location":"docs/events/builtin/syscalls/setresuid/#description","title":"Description","text":"<p>The setresuid system call is used to set the real, effective, and saved user IDs of the calling process. The parameters ruid, euid, and suid define the user IDs that the calling process should assume. The parameters can either be passed directly as integers or can be set to the constant value -1, which indicates that the calling process should retain its current user ID.</p> <p>The use of setresuid is primarily to enable privilege elevation - that is, to allow a process to assume an effective user ID greater than its real user ID. In particular, this can be done to temporarily assume the root user ID while executing a particular task.</p> <p>At user-level, the setresuid system call is equivalent to the setreuid function call.</p>"},{"location":"docs/events/builtin/syscalls/setresuid/#arguments","title":"Arguments","text":"<ul> <li><code>ruid</code>:<code>uid_t</code> - Real user ID associated with the calling process. </li> <li><code>euid</code>:<code>uid_t</code> - Effective user ID associated with the calling process. Will take on a value less than or equal to the real user ID.</li> <li><code>suid</code>:<code>uid_t</code> - Saved user ID associated with the calling process. Can take on any value, regardless of the real or effective user IDs.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setresuid/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/setresuid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setresuid/#do_setresuid","title":"do_setresuid","text":""},{"location":"docs/events/builtin/syscalls/setresuid/#type","title":"Type","text":"<p>Kprobes.</p>"},{"location":"docs/events/builtin/syscalls/setresuid/#purpose","title":"Purpose","text":"<p>To track any changes in user ID made with the setresuid system call.</p>"},{"location":"docs/events/builtin/syscalls/setresuid/#example-use-case","title":"Example Use Case","text":"<p>One example use case for the setresuid system call would be to temporarily assume the root user ID for a particular task. For example, in a banking program, the process might need to temporarily assume the root user ID in order to read a file containing the bank's account information.</p>"},{"location":"docs/events/builtin/syscalls/setresuid/#issues","title":"Issues","text":"<p>Using setresuid can be a security risk, as it can be used to gain elevated privileges. It is important to ensure that any user IDs that are set with setresuid are set back to the original value when no longer needed. </p>"},{"location":"docs/events/builtin/syscalls/setresuid/#related-events","title":"Related Events","text":"<p>The setreuid system call is very closely related, and is functionally equivalent at user-level.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setresuid16/","title":"setresuid16","text":""},{"location":"docs/events/builtin/syscalls/setresuid16/#intro","title":"Intro","text":"<p>setresuid16 - set real, effective and saved user identity</p>"},{"location":"docs/events/builtin/syscalls/setresuid16/#description","title":"Description","text":"<p>The setresuid16 syscall sets the effective, real, and saved user identities depending on the value of the argument flags. A process with the CAP_SETUID capability can set its own user ID's. A process without the CAP_SETUID capability can set the real and effective user ID's to the effective user ID of the process. All the ID's are changed regardless of the value of the flags argument, so group and supplemental group changes can not be suppressed.</p>"},{"location":"docs/events/builtin/syscalls/setresuid16/#arguments","title":"Arguments","text":"<ul> <li><code>ruid</code>:<code>old_uid_t</code>[K] - real user ID</li> <li><code>euid</code>:<code>old_uid_t</code>[K] - effective user ID</li> <li><code>suid</code>:<code>old_uid_t</code>[K] - saved set-user-ID</li> </ul>"},{"location":"docs/events/builtin/syscalls/setresuid16/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setresuid16/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setresuid16/#sys_setresuid16","title":"sys_setresuid16","text":""},{"location":"docs/events/builtin/syscalls/setresuid16/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/setresuid16/#purpose","title":"Purpose","text":"<p>To monitor changes in user ID's.</p>"},{"location":"docs/events/builtin/syscalls/setresuid16/#example-use-case","title":"Example Use Case","text":"<p>An example of a use case for this event is if a system administrator wanted to monitor user ID changes as they occur. This event can be used to detect any attempts to change a user's identity in order to access resources they are not authorized to access.</p>"},{"location":"docs/events/builtin/syscalls/setresuid16/#issues","title":"Issues","text":"<p>There are no known issues with this event.</p>"},{"location":"docs/events/builtin/syscalls/setresuid16/#related-events","title":"Related Events","text":"<ul> <li>getresuid16 - get real, effective, and saved user identity</li> <li>setreuid16 - set real and effective user identity </li> <li>setfsuid16 - set filesystem user identity</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setreuid/","title":"setreuid","text":""},{"location":"docs/events/builtin/syscalls/setreuid/#intro","title":"Intro","text":"<p>setreuid - is a system call used to set the real and effective user identities. </p>"},{"location":"docs/events/builtin/syscalls/setreuid/#description","title":"Description","text":"<p>The setreuid() system call allows a process to set its real user ID, effective user ID and sub-process user ID. This call can be used by a process to set the user identity to its current user identity, that of its effective user identity, or to a specified user ID. </p> <p>By setting the effective user identity to a given user ID, a process is able to act as that user. This can be used by a process to gain additional privileges. However, elevating a process's privileges carries the risk of introducing security vulnerabilities. Therefore, due diligence and caution should be used when using this system call.</p>"},{"location":"docs/events/builtin/syscalls/setreuid/#arguments","title":"Arguments","text":"<ul> <li><code>ruid</code>: <code>uid_t</code> - specifies the real user identity of the process and is written to the ruid field in the uarea.</li> <li><code>euid</code>: <code>uid_t</code> - specifies the effective user identity of the process and is written to the euid field in the uarea.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setreuid/#available-tags","title":"Available tags","text":"<p>K - Originated from kernel-space. U - Originated from user space (for example, pointer to user space memory used to get it)</p>"},{"location":"docs/events/builtin/syscalls/setreuid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setreuid/#setreuid_1","title":"setreuid","text":""},{"location":"docs/events/builtin/syscalls/setreuid/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/setreuid/#purpose","title":"Purpose","text":"<p>To capture the system call arguments and trigger certain actions when the given parameters are used.</p>"},{"location":"docs/events/builtin/syscalls/setreuid/#example-use-case","title":"Example Use Case","text":"<p>A process can use setreuid() to temporarily configure its user identity in order to execute a privileged operation.</p>"},{"location":"docs/events/builtin/syscalls/setreuid/#issues","title":"Issues","text":"<p>Security vulnerabilities can be introduced if elevating the process's privileges without proper care.</p>"},{"location":"docs/events/builtin/syscalls/setreuid/#related-events","title":"Related Events","text":"<ul> <li>getuid: allows a process to query its user identites</li> <li>seteuid: allows a process to set its effective user identity</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setreuid16/","title":"setreuid16","text":""},{"location":"docs/events/builtin/syscalls/setreuid16/#intro","title":"Intro","text":"<p>setreuid16() - sets real and effective user ids of the current process to given values</p>"},{"location":"docs/events/builtin/syscalls/setreuid16/#description","title":"Description","text":"<p>setreuid16() sets the real and effective user ids of the current process to the given values. It is the equivalent of setreuid(2) that uses 16 bit user identifiers, which is the same as the setuid(2) system call on 16 bit ids. This allows programs which use the 16 bit user identifiers to switch the user id of the current process. To change the user ids of another process use setreuid(2). </p> <p>Edge cases: * If the effective user id is equal to the process's real user id and the effective user id is changed, then the saved set-user-ID of the executable will be set to the new effective user id. * If either of the new IDs matches the saved set-user-ID, then the saved set-user-ID will be cleared and the set-user-ID bit in the process's set of file mode creation flags will be cleared.</p>"},{"location":"docs/events/builtin/syscalls/setreuid16/#arguments","title":"Arguments","text":"<ul> <li><code>ruid</code>:<code>old_uid_t</code> - real user ID.</li> <li><code>euid</code>:<code>old_uid_t</code> - effective user ID.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setreuid16/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/setreuid16/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setreuid16/#setreuid16_1","title":"setreuid16","text":""},{"location":"docs/events/builtin/syscalls/setreuid16/#type","title":"Type","text":"<p>Kprobe.</p>"},{"location":"docs/events/builtin/syscalls/setreuid16/#purpose","title":"Purpose","text":"<p>In order to trace the setreuid16 system call execution for debugging purpose.</p>"},{"location":"docs/events/builtin/syscalls/setreuid16/#example-use-case","title":"Example Use Case","text":"<p>setreuid16() can be used to switch the user id of the current process with the given real and effective user ids. This may be useful in situations where a process needs to gain extra privileges while still running under a different user.</p>"},{"location":"docs/events/builtin/syscalls/setreuid16/#issues","title":"Issues","text":"<p>Changing the user id of the process is a powerful action, and care needs to be taken to make sure that the effective user id is the same as the real user id. This is because if the effective user id is different from the real user id, then the saved set-user-ID of the executable will also be set to the effective user id.</p>"},{"location":"docs/events/builtin/syscalls/setreuid16/#related-events","title":"Related Events","text":"<p>setuid16(), seteuid16(), setfsuid16(), setreuid(), setuid(), seteuid(), setfsuid(), setresuid(), setresuid16(), chroot()</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setrlimit/","title":"setrlimit","text":""},{"location":"docs/events/builtin/syscalls/setrlimit/#intro","title":"Intro","text":"<p>setrlimit - setting resource limits for processes</p>"},{"location":"docs/events/builtin/syscalls/setrlimit/#description","title":"Description","text":"<p>The <code>setrlimit()</code> system call is used to set limits on the resources that can be consumed by a process. These limits can be used to limit the amount of memory, number of open files and processes, and other resources that a process can utilize. There are two types of limits which can be set with <code>setrlimit()</code>: soft limits and hard limits. The soft limit can be exceeded temporarily, while the hard limit can not be exceeded at all. The hard limit is typically much lower than the soft limit.</p> <p>One advantage of using <code>setrlimit()</code> is that it can help protect a process from consuming too many resources, which could lead to crashing. It also can help prevent situations where other processes suffer because one process is taking up too many resources.</p>"},{"location":"docs/events/builtin/syscalls/setrlimit/#arguments","title":"Arguments","text":"<ul> <li><code>resource</code>:<code>int</code>[K] - the type of resource limit to be set. The value of this parameter must be one of the constants specified in <code>&lt;sys/resource.h&gt;</code>.</li> <li><code>rlim</code>:<code>const struct rlimit*</code>[K] - a pointer to a <code>struct rlimit</code> that contains the new limits to be set.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setrlimit/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/setrlimit/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setrlimit/#sys_setrlimit","title":"sys_setrlimit","text":""},{"location":"docs/events/builtin/syscalls/setrlimit/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/setrlimit/#purpose","title":"Purpose","text":"<p>To track resource limits being set by processes.</p>"},{"location":"docs/events/builtin/syscalls/setrlimit/#example-use-case","title":"Example Use Case","text":"<p>The <code>setrlimit()</code> system call can be used to limit the amount of memory used by a given process. This is useful for ensuring that processes do not consume too much memory, which can lead to instability.</p>"},{"location":"docs/events/builtin/syscalls/setrlimit/#issues","title":"Issues","text":"<p>The <code>setrlimit()</code> system call is not well understood by many developers. Misuses can lead to instability and crashes.</p>"},{"location":"docs/events/builtin/syscalls/setrlimit/#related-events","title":"Related Events","text":"<ul> <li>getrlimit - provides information about the resources used by the process</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setsid/","title":"setsid","text":""},{"location":"docs/events/builtin/syscalls/setsid/#intro","title":"Intro","text":"<p>setsid - create a session and set the process group ID</p>"},{"location":"docs/events/builtin/syscalls/setsid/#description","title":"Description","text":"<p>setsid() creates a new session if the calling process is not a process group leader.  The calling process is the leader of the new session (session leader) and the process group leader of the new process group (PGID).</p> <p>The process will become the only process in its session and the only process in its process group.</p> <p>The process will also be disassociated from its controlling terminal, if any.</p> <p>If the calling process is already a process group leader, setsid() will fail with EPERM.</p>"},{"location":"docs/events/builtin/syscalls/setsid/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>pid_t</code>[U] - PID of the session/process group leader to be replaced if positive,  or to be created if 0 or negative.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setsid/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/setsid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setsid/#do_setsid","title":"do_setsid","text":""},{"location":"docs/events/builtin/syscalls/setsid/#type","title":"Type","text":"<p>KProbes </p>"},{"location":"docs/events/builtin/syscalls/setsid/#purpose","title":"Purpose","text":"<p>To monitor the creation of new sessions/process groups.</p>"},{"location":"docs/events/builtin/syscalls/setsid/#example-use-case","title":"Example Use Case","text":"<p>For example, setsid() could be used when a process is executed through a child  process, so that it also creates its own session.</p>"},{"location":"docs/events/builtin/syscalls/setsid/#issues","title":"Issues","text":"<p>Setsid() is not allowed if the calling process is already a process group leader, so other methods of creating independent process group should be used in that case.</p>"},{"location":"docs/events/builtin/syscalls/setsid/#related-events","title":"Related Events","text":"<ul> <li>fork - to create a new process </li> <li>setpgid - to set the process group ID of a process</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setsockopt/","title":"setsockopt","text":""},{"location":"docs/events/builtin/syscalls/setsockopt/#intro","title":"Intro","text":"<p>setsockopt - call that sets options on sockets </p>"},{"location":"docs/events/builtin/syscalls/setsockopt/#description","title":"Description","text":"<p>The setsockopt() function sets options associated with a socket. Options may exist at multiple protocol levels; they are always present at the uppermost socket level. When manipulating socket options, the level at which the option resides and the name of the option must be specified. </p> <p>The setsockopt() function sets the option specified by the option_name argument. Optval argument is a value that depends on the option being set. The optlen argument specifies the length of the option value, in bytes. </p> <p>Edge cases of this system call are when the optval argument points to an invalid pointer or the optlen argument contains an invalid length. In these cases, it will return an error. An advantage of this system call is that it allows users to manipulate socket options, enabling them to customize their socket for a variety of applications. </p>"},{"location":"docs/events/builtin/syscalls/setsockopt/#arguments","title":"Arguments","text":"<ul> <li><code>sockfd</code>:<code>int</code>[K] - Socket file descriptor.</li> <li><code>level</code>:<code>int</code>[K] - The protocol level which will be affected.</li> <li><code>optname</code>:<code>int</code>[K] - Socket option name. </li> <li><code>optval</code>:<code>const void *</code>[K] - Socket option value. </li> <li><code>optlen</code>:<code>int</code>[K] - Size of the option value, in bytes. </li> </ul>"},{"location":"docs/events/builtin/syscalls/setsockopt/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setsockopt/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setsockopt/#sys_setsockopt","title":"sys_setsockopt","text":""},{"location":"docs/events/builtin/syscalls/setsockopt/#type","title":"Type","text":"<p>Kprobes </p>"},{"location":"docs/events/builtin/syscalls/setsockopt/#purpose","title":"Purpose","text":"<p>Monitoring of socket operations.</p>"},{"location":"docs/events/builtin/syscalls/setsockopt/#example-use-case","title":"Example Use Case","text":"<p>The setsockopt() can be used to set options on a socket such as the SO_RCVTIMEO flags. This will allow a read operation on a socket to timeout after the specified period of time. This can be utilized in situations where network streaming must be cut off a certain point in time. </p>"},{"location":"docs/events/builtin/syscalls/setsockopt/#issues","title":"Issues","text":"<p>Since setsockopt() is a privileged call, careless application developers could write code which grants more capabilities to processes than necessary, in some cases leading to privilege escalation.</p>"},{"location":"docs/events/builtin/syscalls/setsockopt/#related-events","title":"Related Events","text":"<ul> <li>socket()</li> <li>connect()</li> <li>bind()</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/settimeofday/","title":"settimeofday","text":""},{"location":"docs/events/builtin/syscalls/settimeofday/#intro","title":"Intro","text":"<p>settimeofday - sets the system's time and date, and optional timezone</p>"},{"location":"docs/events/builtin/syscalls/settimeofday/#description","title":"Description","text":"<p>The settimeofday() system call is used to set the system's time, and optionally also the timezone if the tz parameter is not NULL. This is usually used when synchronizing the system's time with an external time source. In order to set the timezone, there must also be an associated time value. When setting the time only, the tz parameter should be NULL.</p> <p>There are some caveats when it comes to setting the time or the timezone. The kernel will not accept values which are out of valid ranges, or are otherwise invalid. Additionally, there can be side effects depending on the system where settimeofday() is called. For example, on some systems setting the time may cause certain user tasks to be interrupted.</p>"},{"location":"docs/events/builtin/syscalls/settimeofday/#arguments","title":"Arguments","text":"<ul> <li><code>tv</code>:<code>const struct timeval*</code>[K] - Pointer to const struct timeval. Should contain the desired time to be set.</li> <li><code>tz</code>:<code>const struct timezone*</code>[K] - Pointer to const struct timezone. Should contain the desired timezone to be set.</li> </ul>"},{"location":"docs/events/builtin/syscalls/settimeofday/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/settimeofday/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/settimeofday/#settimeofday_1","title":"settimeofday","text":""},{"location":"docs/events/builtin/syscalls/settimeofday/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/settimeofday/#purpose","title":"Purpose","text":"<p>Monitoring timezone changes and time changes</p>"},{"location":"docs/events/builtin/syscalls/settimeofday/#example-use-case","title":"Example Use Case","text":"<p>One can use settimeofday() to monitor changes in system time or timezone.</p>"},{"location":"docs/events/builtin/syscalls/settimeofday/#issues","title":"Issues","text":"<p>settimeofday() is vulnerable to TOCTOU (time of check, time of use) attacks.</p>"},{"location":"docs/events/builtin/syscalls/settimeofday/#related-events","title":"Related Events","text":"<p>setitimer() - set interval timer</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setuid/","title":"setuid","text":""},{"location":"docs/events/builtin/syscalls/setuid/#intro","title":"Intro","text":"<p>Setuid - Allows a process to acquire the privileges of a different user.</p>"},{"location":"docs/events/builtin/syscalls/setuid/#description","title":"Description","text":"<p>The setuid() call will set the effective user ID of the calling process to the specified uid. If the executable file contains <code>setuid</code> in its mode mask, the setuid() system call will set the effective user ID of the calling process to the user ID specified in the executable file. This call can be used to provide privileges to a process that it ordinarily would not have. However, it is important to understand the drawbacks and potential security risks associated with setuid calls, such as potential TOCTOU (time-of-check-time-of-use) vulnerabilities and privilege escalation.</p>"},{"location":"docs/events/builtin/syscalls/setuid/#arguments","title":"Arguments","text":"<ul> <li><code>uid</code>:<code>uid_t</code> - The uid to assign to the process.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setuid/#available-tags","title":"Available Tags","text":"<ul> <li>U - Originated from user space</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/setuid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setuid/#sys_setuid","title":"sys_setuid","text":""},{"location":"docs/events/builtin/syscalls/setuid/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/setuid/#purpose","title":"Purpose","text":"<p>To monitor calls of the setuid() system call, for the purpose of debugging.</p>"},{"location":"docs/events/builtin/syscalls/setuid/#example-use-case","title":"Example Use Case","text":"<p>For example, a system administrator might use the setuid() call to temporarily elevated privileges so that a privileged user can execute a particular command on a system.</p>"},{"location":"docs/events/builtin/syscalls/setuid/#issues","title":"Issues","text":"<p>Due to the TOCTOU vulnerability associated with the setuid() call, special attention should be paid to ensure that the value passed to setuid() is trustworthy.</p>"},{"location":"docs/events/builtin/syscalls/setuid/#related-events","title":"Related Events","text":"<ul> <li><code>setgid()</code> - A system call used to set the group ID of a process. </li> <li><code>seteuid()</code> - A system call used to set the effective user ID of the current process to the supplied user ID.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setuid16/","title":"setuid16","text":""},{"location":"docs/events/builtin/syscalls/setuid16/#intro","title":"Intro","text":"<p>setuid16 - sets the effective user ID of the calling process</p>"},{"location":"docs/events/builtin/syscalls/setuid16/#description","title":"Description","text":"<p>setuid16() sets the effective user ID of the calling process. The argument uid is used to set the  effective user ID of the caller.</p> <p>If the calling process is privileged (i.e., owns the superuser id), the effective user ID can be set to any value.</p> <p>Under normal conditions, an unprivileged process may change the real and saved user IDs to the value of uid only if they match its own real (or effective, if uid is not privileged) user ID. A privileged process (under Linux: one having the CAP_SETUID capability) may set the effective user ID to any value.</p> <p>The related seteuid16(), setreuid16() and setresuid16() provide more fine-grain control over processes' privilege.</p>"},{"location":"docs/events/builtin/syscalls/setuid16/#arguments","title":"Arguments","text":"<ul> <li><code>uid</code>:old_old_uid_t[KU] - user ID of the new set of the IDs.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setuid16/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/setuid16/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setuid16/#setuid16_1","title":"setuid16","text":""},{"location":"docs/events/builtin/syscalls/setuid16/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/setuid16/#purpose","title":"Purpose","text":"<p>Monitoring of user identity changes.</p>"},{"location":"docs/events/builtin/syscalls/setuid16/#example-use-case","title":"Example Use Case","text":"<p>One example of use case of setuid16 is to trace a malicious thread changing its user identity and running malicious code.</p>"},{"location":"docs/events/builtin/syscalls/setuid16/#issues","title":"Issues","text":"<p>There are no known issues with setuid16.</p>"},{"location":"docs/events/builtin/syscalls/setuid16/#related-events","title":"Related Events","text":"<p>setreuid16, setresuid16, seteuid16.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/setxattr/","title":"setxattr","text":""},{"location":"docs/events/builtin/syscalls/setxattr/#intro","title":"Intro","text":"<p>setxattr - Set extended attributes on regular, special, and symbolic link files</p>"},{"location":"docs/events/builtin/syscalls/setxattr/#description","title":"Description","text":"<p>The setxattr() system call sets the extended attributes associated with the file path to the name, value and size pointed to by the arguments name, value and size, respectively. The flags argument is a bitwise-or of flags that let the application control how the extended attribute is created. </p> <p>If the name is except for existing attributes and the size of the attribute is larger than the existing attribute, the existing value is overwritten. If the attribute does not exist on the file and the size of the attribute is 0, a new attribute is created.</p> <p>The flags argument can be used to control how the extended attribute is created, or if it should fail if the extended attribute already exists. The flags value should be set to 0 to create a new attribute, or the value XATTR_CREATE to ensure that the attribute is newly created and will fail with an EEXIST error if it already exists.</p>"},{"location":"docs/events/builtin/syscalls/setxattr/#arguments","title":"Arguments","text":"<ul> <li><code>path</code>:<code>const char*</code>[K] - The full path to the file to set the extended attribute.</li> <li><code>name</code>:<code>const char*</code>[U] - The name of the extended attribute to set.</li> <li><code>value</code>:<code>const void*</code>[U] - The value to set the extended attribute to. </li> <li><code>size</code>:<code>size_t</code>[U] - The size in bytes of the value.</li> <li><code>flags</code>:<code>int</code>[U] - Bitwise-or of flags that let the application control how the extended attribute is created.</li> </ul>"},{"location":"docs/events/builtin/syscalls/setxattr/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/setxattr/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/setxattr/#do_setxattr","title":"do_setxattr","text":""},{"location":"docs/events/builtin/syscalls/setxattr/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/setxattr/#purpose","title":"Purpose","text":"<p>Inspect execution of the setxattr system call.</p>"},{"location":"docs/events/builtin/syscalls/setxattr/#example-use-case","title":"Example Use Case","text":"<p>setxattr can be used to set extended attributes on a regular file, special file, or symbolic link. These attributes can be used to store arbitrary information associated with the file, such as data needed to validate a cryptographic signature or provide access control information. </p>"},{"location":"docs/events/builtin/syscalls/setxattr/#issues","title":"Issues","text":"<p>setxattr is vulnerable to TOCTOU (time of check, time of use) attack.</p>"},{"location":"docs/events/builtin/syscalls/setxattr/#related-events","title":"Related Events","text":"<ul> <li>getxattr - Get extended attributes associated with a file </li> <li>listxattr - Return lists of extended attributes for a file</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sgetmask/","title":"sgetmask","text":""},{"location":"docs/events/builtin/syscalls/sgetmask/#intro","title":"Intro","text":"<p>sgetmask - Get the current signal mask of the calling thread</p>"},{"location":"docs/events/builtin/syscalls/sgetmask/#description","title":"Description","text":"<p>The sgetmask() syscall retrieves the current signal mask for the calling thread in the form of an integer. The signal mask consists of a set of bits, one for each signal, that specifies which signals are blocked from delivery to the thread. By default, signals will always be blocked when they are generated. This syscall allows processes to customize this behavior by blocking or unblocking specific signals. It is not possible to unblock signals that were not blocked in the first place.</p>"},{"location":"docs/events/builtin/syscalls/sgetmask/#arguments","title":"Arguments","text":"<p>No arguments.</p>"},{"location":"docs/events/builtin/syscalls/sgetmask/#available-tags","title":"Available Tags","text":"<p>N/A</p>"},{"location":"docs/events/builtin/syscalls/sgetmask/#hooks","title":"Hooks","text":"<p>No hooks configured.</p>"},{"location":"docs/events/builtin/syscalls/sgetmask/#example-use-case","title":"Example Use Case","text":"<p>This syscall could be used in multi-threaded applications to discover which signals are blocked in each thread. This could be used to implement custom signal handling strategies on a per-thread basis.</p>"},{"location":"docs/events/builtin/syscalls/sgetmask/#issues","title":"Issues","text":"<p>This syscall may be vulnerable to TOCTOU (time of check, time of use) race conditions. It is possible that a signal mask could be changed between the time the syscall is invoked and the time the updated signal mask value is returned.</p>"},{"location":"docs/events/builtin/syscalls/sgetmask/#related-events","title":"Related Events","text":"<ul> <li>sigprocmask() - Used to set or retrieve the signal mask of a specified process.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/shmat/","title":"shmat","text":""},{"location":"docs/events/builtin/syscalls/shmat/#intro","title":"Intro","text":"<p>shmat - Attach a shared memory segment.</p>"},{"location":"docs/events/builtin/syscalls/shmat/#description","title":"Description","text":"<p>The <code>shmat</code> system call attaches the shared memory segment identified by <code>shmid</code> to the address space of the calling process. <code>shmaddr</code> specifies the address at which the shared memory segment is attached. If shmaddr is NULL, the system will choose an address at which to attach the segment. The <code>shmflg</code> parameter specifies characteristics of the attachment, including read/write permissions.</p> <p>A successful call to <code>shmat</code> returns the address of the attached shared memory segment. The segment is detached from the address space of the calling process with <code>shmdt</code>.</p>"},{"location":"docs/events/builtin/syscalls/shmat/#arguments","title":"Arguments","text":"<ul> <li><code>shmid</code>:<code>int</code>[K] - Identifier of the shared memory segment to be attached.</li> <li><code>shmaddr</code>:<code>const void*</code>[U] - If not NULL, address the segment should                     be attached at.</li> <li><code>shmflg</code>:<code>int</code>[K] - Specifies various flags for the attachment:                     <pre><code>SHM_RDONLY = 0x001  - Segment attached read-only\nSHM_RND    = 0x002  - Round addr to SHMLBA boundary\nSHM_REMAP  = 0x004  - Map into current address space\nSHM_RXAREA = 0x008  - Force/allow read/execute\nSHM_EXEC   = 0x010  - Segment attached execute-only\n</code></pre></li> </ul>"},{"location":"docs/events/builtin/syscalls/shmat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/shmat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/shmat/#shmat_common","title":"shmat_common","text":""},{"location":"docs/events/builtin/syscalls/shmat/#type","title":"Type","text":"<p>kprobes + ftrace</p>"},{"location":"docs/events/builtin/syscalls/shmat/#purpose","title":"Purpose","text":"<p>To measure the execution time of the syscall.</p>"},{"location":"docs/events/builtin/syscalls/shmat/#example-use-case","title":"Example Use Case","text":"<p>Event <code>shmat</code> could be used when an application needs to access a shared memory segment that is not mapped in the address space.</p>"},{"location":"docs/events/builtin/syscalls/shmat/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/shmat/#related-events","title":"Related Events","text":"<ul> <li><code>mmap</code> - Create or map a memory segment.</li> <li><code>shmdt</code> - Detach a shared memory segment.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/shmctl/","title":"shmctl","text":""},{"location":"docs/events/builtin/syscalls/shmctl/#intro","title":"Intro","text":"<p>shmctl - System V shared memory operations</p>"},{"location":"docs/events/builtin/syscalls/shmctl/#description","title":"Description","text":"<p>The <code>shmctl</code> system call is used to control System V (SVIPC) shared memory segments. It operates on the shared memory segment identified by the given <code>shmid</code> value. The <code>cmd</code> argument is used to specify the specific operation that needs to be performed. The <code>buf</code> argument is used to tell the kernel additional information about the operation, such as the data structure of <code>struct shmid_ds</code> defining the permission and size of the shared memory segment.</p> <p>The <code>shmctl</code> system call is generally used to control the state of shared memory segments, like attach, detach, get the size of a segment, change permissions and so on.</p> <p>The main advantages of using <code>shmctl</code> are that it provides an interface which is generic, easy to use and allows a range of different operations on shared memory segments.</p>"},{"location":"docs/events/builtin/syscalls/shmctl/#arguments","title":"Arguments","text":"<ul> <li><code>shmid</code>:<code>int</code>[K] - The id of the shared memory segment as returned by   <code>shmget</code>.</li> <li><code>cmd</code>:<code>int</code>[K] - The command to be performed on the shared memory segment,   can range from <code>IPC_STAT</code> to <code>IPC_RMID</code>.</li> <li><code>buf</code>:<code>struct shmid_ds*</code>[K] - Pointer to the buffer containing the   information about the command to be performed on the shared memory segment.</li> </ul>"},{"location":"docs/events/builtin/syscalls/shmctl/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/shmctl/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/shmctl/#sys_shmctl","title":"<code>sys_shmctl</code>","text":""},{"location":"docs/events/builtin/syscalls/shmctl/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/shmctl/#purpose","title":"Purpose","text":"<p>Hooked to get invoked whenever a <code>shmctl</code> system call is executed.</p>"},{"location":"docs/events/builtin/syscalls/shmctl/#example-use-case","title":"Example Use Case","text":"<p>The <code>shmctl</code> system call can be useful for development in data structures, message passing and process scheduling for distributed computing systems. It can be used to create shared memory segments, update information about existing memory segments, remove shared memory segments and more.</p>"},{"location":"docs/events/builtin/syscalls/shmctl/#issues","title":"Issues","text":"<p>Since the <code>shmctl</code> system call is vulnerable to TOCTOU (time-of-check/time-of-use) attack, as some of its arguments can change between the time they are checked and used,  it is very important to be aware of the security implications.</p>"},{"location":"docs/events/builtin/syscalls/shmctl/#related-events","title":"Related Events","text":"<ul> <li><code>shmget</code></li> <li><code>shmat</code></li> <li><code>msgget</code></li> <li><code>msgsnd</code></li> <li><code>msgrcv</code></li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/shmdt/","title":"shmdt","text":""},{"location":"docs/events/builtin/syscalls/shmdt/#intro","title":"Intro","text":"<p>shmdt - detach a shared memory segment from the caller's data segment</p>"},{"location":"docs/events/builtin/syscalls/shmdt/#description","title":"Description","text":"<p>The <code>shmdt()</code> syscall detached a shared memory segment from the caller's data segment. It shall be used after a shared memory segment is no longer needed. When a shared memory segment is attached, it becomes part of the address space of the calling process, and the calling process must explicitly detach it. An <code>shmdt()</code> call destroys the association between the process and the shared memory segment. If a process has multiple shared memory attachments, each must be detached individually.</p> <p>When the last process detaches a segment, the segment is deleted and its resources are returned to the system. If a segment is detached while processes still have the segment attached, the state of the segment persists until all processes have detached it.</p>"},{"location":"docs/events/builtin/syscalls/shmdt/#arguments","title":"Arguments","text":"<ul> <li><code>shmaddr</code>:<code>const void*</code>[K] - pointer to the shared memory segment.</li> </ul>"},{"location":"docs/events/builtin/syscalls/shmdt/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/shmdt/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/shmdt/#shmdt_1","title":"shmdt","text":""},{"location":"docs/events/builtin/syscalls/shmdt/#type","title":"Type","text":"<p>Kprobe </p>"},{"location":"docs/events/builtin/syscalls/shmdt/#purpose","title":"Purpose","text":"<p>The <code>shmdt()</code> syscall is used to detach a shared memory segment from the caller's data segment, so it is important to understand when this event is called.</p>"},{"location":"docs/events/builtin/syscalls/shmdt/#example-use-case","title":"Example Use Case","text":"<p>For example, you can monitor when shared memory is being detached and gather information such as the process PID and the address of the segment being detached.</p>"},{"location":"docs/events/builtin/syscalls/shmdt/#issues","title":"Issues","text":"<p>Currently, the shmdt() syscall is not able to detach more than one shared memory segment at a time.</p>"},{"location":"docs/events/builtin/syscalls/shmdt/#related-events","title":"Related Events","text":"<ul> <li>shmget - get a shared memory segment</li> <li>shmat - attach a shared memory segment</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/shmget/","title":"shmget","text":""},{"location":"docs/events/builtin/syscalls/shmget/#intro","title":"Intro","text":"<p>shmget - used to get a shared memory segment</p>"},{"location":"docs/events/builtin/syscalls/shmget/#description","title":"Description","text":"<p>shmget is a SystemV IPC system call that is used to get a shared memory segment. It requires the caller to provide a key, size and flag argument. If the key identified by the key argument exists, the call returns the identifier of the shared memory region associated with it. If the key does not exist, a new region is created and its identifier is returned, or the call fails according to the argument flags. Some of the possible flags include: IPC_CREAT, IPC_EXCL and SHM_HUGETLB.</p> <p>Caution should be used when using IPC_EXCL and IPC_CREAT flags together, as it is vulnerable to time of check/time of use (TOCTOU) race condition.</p>"},{"location":"docs/events/builtin/syscalls/shmget/#arguments","title":"Arguments","text":"<ul> <li><code>key</code>:<code>key_t</code>[U] - key for the shared memory segment. This should be generated using ftok and must be unique;</li> <li><code>size</code>:<code>size_t</code>[U] - size of the shared memory segment in bytes;</li> <li><code>shmflg</code>:<code>int</code>[U] - this argument's value mitght consists of various flags, like IPC_CREAT, IPC_EXCL, etc.</li> </ul>"},{"location":"docs/events/builtin/syscalls/shmget/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/shmget/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/shmget/#sys_ipc","title":"<code>sys_ipc</code>","text":""},{"location":"docs/events/builtin/syscalls/shmget/#type","title":"Type","text":"<p>bpf kprobe</p>"},{"location":"docs/events/builtin/syscalls/shmget/#purpose","title":"Purpose","text":"<p>This function is hooked to trace when the shmget syscall is called.</p>"},{"location":"docs/events/builtin/syscalls/shmget/#example-use-case","title":"Example Use Case","text":"<p>shmget can be used to create a shared memory segment, for example, between two applications that need to communicate.</p>"},{"location":"docs/events/builtin/syscalls/shmget/#issues","title":"Issues","text":"<p>Due to the TOCTOU sensitivity of using IPC_EXCL and IPC_CREAT flags together, caution is recommended when using those flags.</p>"},{"location":"docs/events/builtin/syscalls/shmget/#related-events","title":"Related Events","text":"<p>shmat - used to attach the shared memory segment to the process address space  shmdt - used to detach the shared memory segment from the process address space</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/shutdown/","title":"shutdown","text":""},{"location":"docs/events/builtin/syscalls/shutdown/#intro","title":"Intro","text":"<p>shutdown - Request that a connection be shut down </p>"},{"location":"docs/events/builtin/syscalls/shutdown/#description","title":"Description","text":"<p>The <code>shutdown</code> call requests that a given connection be severed. The <code>how</code> argument specifies the way in which the connection should be shut down: * 0 - No more receives. * 1 - No more sends. Adding 2 to the above values (2 and 3) requests that the connection also be terminated and that the resources associated with the connection be released.</p> <p>This call can be used to perform a half-closed shutdown, in which one side of the connection is open for sending data and the other side is closed for receiving data.</p>"},{"location":"docs/events/builtin/syscalls/shutdown/#arguments","title":"Arguments","text":"<ul> <li><code>sockfd</code>:<code>int</code> - The file descriptor associated with the socket.</li> <li><code>how</code>:<code>int</code> - Defines how to shutdown connection.</li> </ul>"},{"location":"docs/events/builtin/syscalls/shutdown/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/shutdown/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/shutdown/#shutdown_1","title":"shutdown","text":""},{"location":"docs/events/builtin/syscalls/shutdown/#type","title":"Type","text":"<p>Kprobes + Kretprobes</p>"},{"location":"docs/events/builtin/syscalls/shutdown/#purpose","title":"Purpose","text":"<p>Monitor the connection resources associated with a socket and detect anomalies.</p>"},{"location":"docs/events/builtin/syscalls/shutdown/#example-use-case","title":"Example Use Case","text":"<p>The shutdown event can be used to monitor socket connections and detect resource leaks at the same time. This is especially useful when debugging applications that create multiple network connections in order to verify that the required resources are released when the connection is severed.</p>"},{"location":"docs/events/builtin/syscalls/shutdown/#issues","title":"Issues","text":"<p>There are some issues with using the <code>shutdown</code> syscall due to the fact that it requires the application to have access to the socket associated with the connection. This means that any applications that do not have permission to access this socket will be unable to shut down the connection.</p>"},{"location":"docs/events/builtin/syscalls/shutdown/#related-events","title":"Related Events","text":"<ul> <li>connect</li> <li>close</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sigaction/","title":"sigaction","text":""},{"location":"docs/events/builtin/syscalls/sigaction/#intro","title":"Intro","text":"<p>sigaction - manipulate signal actions</p>"},{"location":"docs/events/builtin/syscalls/sigaction/#description","title":"Description","text":"<p>This event manipulates the action taken by a process on receipt of particular signal. These signals can be generated internally by the kernel, by user programs, or sourced externally from the hardware. The action parameter describes what is to be done when the signal arrives.</p> <p>The program specifies an action and a signal number, along with an optional set of flags which modify the behavior of the signal. The act argument points to a structure which specifies a signal handler and also includes a set of flags that modify the behavior of the sigaction call. The oact argument points to a location where a copy of the old signal action is stored.</p> <p>This syscall is used when user has to register multiple signal handlers and modify existing registered actions efficiently. Since different signals can be received, sigaction helps in implementing context-dependent behavior in the application, allowing it to react differently to different signals.</p>"},{"location":"docs/events/builtin/syscalls/sigaction/#arguments","title":"Arguments","text":"<ul> <li><code>sig</code>:<code>int</code> - the signal number</li> <li><code>act</code>:<code>const struct sigaction*</code>[K] - a pointer to a signal-handling function or a set of flags</li> <li><code>oact</code>:<code>struct sigaction*</code>[K-TOCTOU] - an optional pointer to a signal-handling function or a set of flags</li> </ul>"},{"location":"docs/events/builtin/syscalls/sigaction/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> </ul>"},{"location":"docs/events/builtin/syscalls/sigaction/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sigaction/#do_sigaction","title":"do_sigaction","text":""},{"location":"docs/events/builtin/syscalls/sigaction/#type","title":"Type","text":"<p>Kprobe </p>"},{"location":"docs/events/builtin/syscalls/sigaction/#purpose","title":"Purpose","text":"<p>To trace the signal action taken when signal deliveres</p>"},{"location":"docs/events/builtin/syscalls/sigaction/#do_signal","title":"do_signal","text":""},{"location":"docs/events/builtin/syscalls/sigaction/#type_1","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/sigaction/#purpose_1","title":"Purpose","text":"<p>To trace the signal action taken when signal occurs</p>"},{"location":"docs/events/builtin/syscalls/sigaction/#example-use-case","title":"Example Use Case","text":"<p>This event is useful for system administrators monitoring applications. When an application fails, signals can be sent to the application to notify the administrator and/or take action. This event can be used to trace these signal actions and create an audit trail.</p>"},{"location":"docs/events/builtin/syscalls/sigaction/#issues","title":"Issues","text":"<p>The signal may arrive between the time when <code>sigaction</code> is called and when the signal handler is installed. This means that a signal the user didn't anticipate can still arrive, causing parts of the application to misbehave.</p>"},{"location":"docs/events/builtin/syscalls/sigaction/#related-events","title":"Related Events","text":"<ul> <li><code>sigprocmask</code> - Get and/or change the signal mask of a process (which signals are blocked)</li> <li><code>sigpending</code> - Get list of signals that are blocked and pending for delivery to the process</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sigaltstack/","title":"sigaltstack","text":""},{"location":"docs/events/builtin/syscalls/sigaltstack/#intro","title":"Intro","text":"<p>sigaltstack - Sets or gets the signal stack context</p>"},{"location":"docs/events/builtin/syscalls/sigaltstack/#description","title":"Description","text":"<p>The <code>sigaltstack</code> syscall can be used to set or get the signal stack context of a process. It sets a new signal stack for the process (or retrieves the previously set one) and specifies a <code>sigaction</code> structure that determines what should be done when signals are delivered to that stack. This is useful for separating execution stacks for signal handlers and other asynchronous events, for example for dealing with asynchronous interrupts. The <code>sigaltstack</code> syscall can also be used to enable or disable the alternate stack which can improve the performance of the process in receiving signals.</p> <p>There are two main advantages of using <code>sigaltstack</code>. Firstly, it allows users to control the stack used during signals to limit the amount of data that must be copied around. Secondly, it allows users to create a dedicated signal stack, enabling them to have a separate memory space for signal handlers that is independent of the current stack frame.</p> <p>However, there are some drawbacks to consider when using sigaltstack:</p> <ul> <li>There is a limit on the size of the alternate stack. This means that some signals might not fit onto the stack and thus fail without their handler being executed.</li> <li>The <code>sigaltstack</code> syscall is potentially vulnerable to a TOCTOU attack. Furthermore, due to the alternate stack, access to certain parts of the program may be restricted while the signal is being processed.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sigaltstack/#arguments","title":"Arguments","text":"<ul> <li><code>ss</code>:<code>const stack_t*</code>[K,U] - Pointer to a stack_t structure containing the alternate stack data.</li> <li><code>old_ss</code>:<code>stack_t*</code>[U] - Pointer to a stack_t structure where the currently active stack will be stored.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sigaltstack/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/sigaltstack/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sigaltstack/#sys_sigaltstack","title":"sys_sigaltstack","text":""},{"location":"docs/events/builtin/syscalls/sigaltstack/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/sigaltstack/#purpose","title":"Purpose","text":"<p>To disable the alternate stack before the sigaltstack syscall is executed and to enable it afterwards. This allows us to ensure that any signal handler is only using the alternate stack and not a user space stack.</p>"},{"location":"docs/events/builtin/syscalls/sigaltstack/#user_sigaltstack","title":"user_sigaltstack","text":""},{"location":"docs/events/builtin/syscalls/sigaltstack/#type_1","title":"Type","text":"<p>Uprobe</p>"},{"location":"docs/events/builtin/syscalls/sigaltstack/#purpose_1","title":"Purpose","text":"<p>To trace any sigaltstack syscalls happening in a user space context. This allows us to track any attempted signals that might be generated as a result of the sigaltstack syscall.</p>"},{"location":"docs/events/builtin/syscalls/sigaltstack/#example-use-case","title":"Example Use Case","text":"<p>sigaltstack can be used to handle certain signals that cause program execution flow interruption, such as SIGSEGV and SIGINT. By setting an alternate stack and catching the interrupt-based signals, the program can be protected from crashing due to a segmentation fault.</p>"},{"location":"docs/events/builtin/syscalls/sigaltstack/#issues","title":"Issues","text":"<p>The <code>sigaltstack</code> syscall is vulnerable to TOCTOU (Time Of Check, Time Of Use) attacks, meaning that a malicious actor could potentially corrupt the signal stack pointer between the time when it is checked and the time it is used to stage the signal handler.</p>"},{"location":"docs/events/builtin/syscalls/sigaltstack/#related-events","title":"Related Events","text":"<ul> <li>signal: Used to register signal handlers.</li> <li>sigaction: Used to define how a signal should be handled. </li> <li>sigsuspend: Used to pause the process until a signal is received.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/signal/","title":"signal","text":""},{"location":"docs/events/builtin/syscalls/signal/#intro","title":"Intro","text":"<p>Signal - sends a signal specifying its number (<code>signum</code>), plus an optional <code>handler</code>, to the calling process or process group.</p>"},{"location":"docs/events/builtin/syscalls/signal/#description","title":"Description","text":"<p>The <code>signal</code> syscall is used to send a signal to one or more process, specify by its <code>signum</code> and with optional <code>handler</code> (the function being executed when the signal is delivered). It can be used to send signals like <code>SIGTERM</code> and <code>SIGKILL</code> to terminate processes, as well as custom signals to communicate information or initiate actions from other processes. </p> <p>Signals can be blocked depending on their type, so it is important to take that into account when sending a signal.</p>"},{"location":"docs/events/builtin/syscalls/signal/#arguments","title":"Arguments","text":"<ul> <li><code>signum</code>: <code>int</code> - the signal number to send. The list of available signals is described in the <code>signal(7)</code> manual page.</li> <li><code>handler</code>: <code>sighandler_t</code>[K] - optional pointer to the function to be executed upon arrival of the signal.</li> </ul>"},{"location":"docs/events/builtin/syscalls/signal/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/signal/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/signal/#do_signal","title":"do_signal","text":""},{"location":"docs/events/builtin/syscalls/signal/#type","title":"Type","text":"<p>Tracepoint + Kprobe</p>"},{"location":"docs/events/builtin/syscalls/signal/#purpose","title":"Purpose","text":"<p>Gather data and figure out what function is executed when the signal is received.</p>"},{"location":"docs/events/builtin/syscalls/signal/#example-use-case","title":"Example Use Case","text":"<p>One example of use of the <code>signal</code> event is to count how many signals of a particular kind (in this case, SIGTERM) were sent and received during a given period of time.</p>"},{"location":"docs/events/builtin/syscalls/signal/#issues","title":"Issues","text":"<p>Due to the asynchronous and unreliable nature of signals, in some cases signals may be lost or delivered late.</p>"},{"location":"docs/events/builtin/syscalls/signal/#related-events","title":"Related Events","text":"<ul> <li><code>kill</code> - similar to signal but with a more precise target.</li> <li><code>waitid</code> - used to wait for processes and identify the signal sent.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/signalfd/","title":"signalfd","text":""},{"location":"docs/events/builtin/syscalls/signalfd/#intro","title":"Intro","text":"<p>signalfd - creates a file descriptor that can be used to accept signals</p>"},{"location":"docs/events/builtin/syscalls/signalfd/#description","title":"Description","text":"<p>signalfd() creates an object of type \u201csignalfd\u201d that can be used to accept signals. The signalfd file descriptor is returned. Once it is created, the signals specified in the set argument will be accepted by the file descriptor and handled according to the flags argument. If multiple threads are waiting for the same signal, their calls to signalfd() will all be queued; each call will receive the same signalfd. If the same signal is received though, the previous one will be packed into the structure until it is read by the user.</p> <p>The events signalled by a signalfd() call can be edge-triggered or level-triggered depending on the flags argument. The signalfd() call also allows for implementation of a signal queue. </p> <p>Advantages of using signalfd() instead of signal() include increased file descriptor limits, asynchronous notification and synchronization of signal delivery. Signalfd() calls are also generally more reliable than their signal() counterparts and more efficient in terms of CPU usage. </p>"},{"location":"docs/events/builtin/syscalls/signalfd/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - file descriptor returned.</li> <li><code>mask</code>:<code>sigset_t*</code>[U, TOCTOU] - pointer to the signals that will be handled by the file descriptor.</li> <li><code>flags</code>:<code>int</code>[K] - flags that determine if the handled signals will be edge- or level-triggered.</li> </ul>"},{"location":"docs/events/builtin/syscalls/signalfd/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/signalfd/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/signalfd/#do_signalfd","title":"do_signalfd","text":""},{"location":"docs/events/builtin/syscalls/signalfd/#type","title":"Type","text":"<p>kretprobe</p>"},{"location":"docs/events/builtin/syscalls/signalfd/#purpose","title":"Purpose","text":"<p>Hook the return point from signalfd.</p>"},{"location":"docs/events/builtin/syscalls/signalfd/#do_signalfd4","title":"do_signalfd4","text":""},{"location":"docs/events/builtin/syscalls/signalfd/#type_1","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/signalfd/#purpose_1","title":"Purpose","text":"<p>Hook the sycall signalfd entry point.</p>"},{"location":"docs/events/builtin/syscalls/signalfd/#example-use-case","title":"Example Use Case","text":"<p>Signalfd can be used to provide asynchronous notification of pending signals. For instance, a multitasking daemons or services could be designed to respond quickly to events and signals received by certain file descriptors.</p>"},{"location":"docs/events/builtin/syscalls/signalfd/#issues","title":"Issues","text":"<p>Signalfd is subject to the Time of check-time of use race condition, where the operation between a check on the validity of a resource and an operation on the same resource is visible or exploitable.</p>"},{"location":"docs/events/builtin/syscalls/signalfd/#related-events","title":"Related Events","text":"<ul> <li>select - Can be used to multiplexing I/O operations on multiple file descriptors in a single thread.</li> <li>pselect - Same as select but also sets a timeout argument to prevent blocking.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/signalfd4/","title":"signalfd4","text":""},{"location":"docs/events/builtin/syscalls/signalfd4/#intro","title":"Intro","text":"<p>signalfd4 - create a file descriptor to receive signals</p>"},{"location":"docs/events/builtin/syscalls/signalfd4/#description","title":"Description","text":"<p>The signalfd4() system call is used to create an \"eventfd\" object which can be used to receive notifications of signals. It is similar to the signalfd() system call, but in addition it allows the user to specify an additional 'mask' parameter which can be used to limit which signals are monitored. The 'mask' parameter is a bitmask of the signals to monitor. The 'sizemask' parameter is the size of the 'mask' parameter in bytes. The 'flags' parameter can be used to fine-tune the behavior of the call.</p> <p>Signalfd4() allows for very precise signal handling and can be used to reduce the amount of signal handling work a process needs to do. It can also be used to throttle signal delivery or prevent signal flooding.</p>"},{"location":"docs/events/builtin/syscalls/signalfd4/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code> - file descriptor.</li> <li><code>mask</code>:<code>const sigset_t*</code>[K] - a bitmask of signals to monitoring, 0 to only monitor SIGIO.</li> <li><code>sizemask</code>:<code>size_t</code> - size of the 'mask' parameter, in bytes.</li> <li><code>flags</code>:<code>int</code> - flags to fine-tune the behavior of the call.</li> </ul>"},{"location":"docs/events/builtin/syscalls/signalfd4/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/signalfd4/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/signalfd4/#signalfd4_1","title":"signalfd4","text":""},{"location":"docs/events/builtin/syscalls/signalfd4/#type","title":"Type","text":"<p>Kprobe/Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/signalfd4/#purpose","title":"Purpose","text":"<p>To add instrumentation to the signalfd4() syscall to retrieve arguments and return value from the syscall </p>"},{"location":"docs/events/builtin/syscalls/signalfd4/#example-use-case","title":"Example Use Case","text":"<p>For example, an application may need to wait for a signal to arrive and then process the signal. Rather than having to check for the signal periodically and receive it synchronously, the application can use signalfd4() to create a file descriptor that will be notified whenever the signal arrives. </p>"},{"location":"docs/events/builtin/syscalls/signalfd4/#issues","title":"Issues","text":"<p>This system call is not available in all systems, check for availability in the Linux manual page.</p>"},{"location":"docs/events/builtin/syscalls/signalfd4/#related-events","title":"Related Events","text":"<p>The related event to this syscall are read(), write(), poll(), signalfd() and exit().</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sigpending/","title":"sigpending","text":""},{"location":"docs/events/builtin/syscalls/sigpending/#intro","title":"Intro","text":"<p>sigpending - Check the signals that are pending for the process.</p>"},{"location":"docs/events/builtin/syscalls/sigpending/#description","title":"Description","text":"<p>The sigpending() system call queries the pending signals for the calling  process  (check  which signals have been raised while blocked). It fills in the signal set pointed to by set, which  is  of type sigset_t, with the set of signals currently pending for the process.</p> <p>Are there any edge-cases, drawbacks or advantages of using it?</p> <p>The most useful edge-case is that it allows a process to find out signals that have been sent to it, but blocked by the process with <code>sigprocmask()</code>.</p>"},{"location":"docs/events/builtin/syscalls/sigpending/#arguments","title":"Arguments","text":"<ul> <li><code>set</code>:<code>sigset_t*</code>[U] - Pointer to a signal set which will be set to the set of pending signals for the process.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sigpending/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/sigpending/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sigpending/#do_sigpending","title":"do_sigpending","text":""},{"location":"docs/events/builtin/syscalls/sigpending/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/sigpending/#purpose","title":"Purpose","text":"<p>Triggers every time the system call is made, allowing to analyze what was the source of the call.</p>"},{"location":"docs/events/builtin/syscalls/sigpending/#example-use-case","title":"Example Use Case","text":"<p>For example, this system call can be used to create a signal handler to check whether or not a particular signal is blocked.</p>"},{"location":"docs/events/builtin/syscalls/sigpending/#issues","title":"Issues","text":"<p>No known issues.</p>"},{"location":"docs/events/builtin/syscalls/sigpending/#related-events","title":"Related Events","text":"<p>signal, sigprocmask, sigaction</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sigprocmask/","title":"sigprocmask","text":""},{"location":"docs/events/builtin/syscalls/sigprocmask/#intro","title":"Intro","text":"<p>sigprocmask - using signal sets, this function is used to examine and change the signal mask of the calling thread.</p>"},{"location":"docs/events/builtin/syscalls/sigprocmask/#description","title":"Description","text":"<p>sigprocmask is used examine and / or alter the signal mask of the calling thread. Passing SIG_SETMASK as the how parameter will replace the entire mask with the set value, while passing SIG_SETMASK &amp; SIG_BLOCK adds the set value to the existing mask. SIG_SETMASK &amp; SIG_UNBLOCK removes the set value from the existing mask, while SIG_SETMASK &amp; SIG_UNBLOCK =0 returns the current mask without changing it. If a non-null oldset is passed, the existing mask will be stored in oldset.</p> <p>Using this function, it is possible to temporarily block certain signals or alter them to ignore them without actually modifying their disposition.</p>"},{"location":"docs/events/builtin/syscalls/sigprocmask/#arguments","title":"Arguments","text":"<ul> <li><code>how</code>:<code>int(SIG_SETMASK, SIG_BLOCK, SIG_UNBLOCK)</code> - specifies what action to take with the set parameter.</li> <li><code>set</code>:<code>const sigset_t *restrict</code>[K,TOCTOU] - a pointer to the signal set defining the signals which are to be blocked, unblocked or returned.</li> <li><code>oldset</code>:<code>sigset_t *restrict</code>[K,U] - a pointer (allocated by the caller) to a sigset_t structure in which the existing mask will be store (if non-null).</li> </ul>"},{"location":"docs/events/builtin/syscalls/sigprocmask/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/sigprocmask/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sigprocmask/#do_sigprocmask","title":"do_sigprocmask","text":""},{"location":"docs/events/builtin/syscalls/sigprocmask/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/sigprocmask/#purpose","title":"Purpose","text":"<p>Analyzation of the use of the sigprocmask syscall and tracking the changes made to the signal mask.</p>"},{"location":"docs/events/builtin/syscalls/sigprocmask/#example-use-case","title":"Example Use Case","text":"<p>This function can be used in a process that needs to temporarily block certain signals.</p>"},{"location":"docs/events/builtin/syscalls/sigprocmask/#issues","title":"Issues","text":"<p>sigprocmask() is vulnerable to TOCTOU (Time of Check, Time of Use) attacks which could result in security issues.</p>"},{"location":"docs/events/builtin/syscalls/sigprocmask/#related-events","title":"Related Events","text":"<ul> <li>signal() - Used to send a signal to a process or thread.</li> <li>sigaddset() - Used to add an individual signal to a signal set.</li> <li>sigdelset() - Used to delete an individual signal from a signal set.</li> <li>sigemptyset() - Used to initialise or clear a signal set to the empty set.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sigreturn/","title":"sigreturn","text":""},{"location":"docs/events/builtin/syscalls/sigreturn/#intro","title":"Intro","text":"<p>sigreturn - restore process state after receiving a signal</p>"},{"location":"docs/events/builtin/syscalls/sigreturn/#description","title":"Description","text":"<p>The <code>sigreturn()</code> system call restores the calling process' pre-signal state, and is usually used when the user wants to implement their own signal handlers. This can be done by setting the <code>SA_SIGINFO</code> flag when registering the signal handler, and then calling <code>sigreturn()</code> in order to restore the process state. One of the main advantages of using <code>sigreturn()</code> is that it is significantly faster than <code>sigaction()</code>.</p> <p>However, there are some drawbacks to using this system call. Most notably, any change that is made to the process state after calling <code>sigreturn()</code>, before the process is switched from the kernel to user space again, will be lost. This includes changes to any data structures, resources, or file descriptors, as well as any additional system calls that might be made.</p>"},{"location":"docs/events/builtin/syscalls/sigreturn/#arguments","title":"Arguments","text":"<p>This system call takes no arguments.</p>"},{"location":"docs/events/builtin/syscalls/sigreturn/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sigreturn/#do_signal","title":"do_signal","text":""},{"location":"docs/events/builtin/syscalls/sigreturn/#type","title":"Type","text":"<p>kprobes</p>"},{"location":"docs/events/builtin/syscalls/sigreturn/#purpose","title":"Purpose","text":"<p>This function is hooked in order to catch the <code>sigreturn()</code> system call and perform any necessary cleanup tasks.</p>"},{"location":"docs/events/builtin/syscalls/sigreturn/#example-use-case","title":"Example Use Case","text":"<p>One use case for <code>sigreturn()</code> might be a signal handler that can be used to safely shut down a process. Since <code>sigreturn()</code> restores the process's state to its state before the signal, it can be used in order to safely shut down the process without causing any errors or data inconsistencies.</p>"},{"location":"docs/events/builtin/syscalls/sigreturn/#issues","title":"Issues","text":"<p>There are no known issues with the <code>sigreturn()</code> system call.</p>"},{"location":"docs/events/builtin/syscalls/sigreturn/#related-events","title":"Related Events","text":"<ul> <li><code>sigaction()</code> - register a signal handler</li> <li><code>sigprocmask()</code> - manipulate a process's signal mask</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sigsuspend/","title":"sigsuspend","text":""},{"location":"docs/events/builtin/syscalls/sigsuspend/#intro","title":"Intro","text":"<p>sigsuspend - temporarily replaces the signal mask of the executing thread with the given set of signals.</p>"},{"location":"docs/events/builtin/syscalls/sigsuspend/#description","title":"Description","text":"<p>The sigsuspend() system call suspends the caller until a signal is received. It is equivalent to</p> <pre><code>sigprocmask(SIG_SETMASK, &amp;mask, NULL);\npause();\n</code></pre> <p>The mask given as argument is used as the signal mask of the process during the period of suspension; upon return from the call it is restored to the previous value. While sigsuspend() is being executed, any signal may be accepted, except SIGKILL and SIGSTOP.</p> <p>The sigsuspend() function shall not return if it is interrupted by a signal handler and the signal handler does not return.</p>"},{"location":"docs/events/builtin/syscalls/sigsuspend/#arguments","title":"Arguments","text":"<ul> <li><code>mask</code>:const sigset_t*[K] - pointer to a signal set specifying the new signal mask for the process.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sigsuspend/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sigsuspend/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sigsuspend/#sigsuspend_1","title":"sigsuspend","text":""},{"location":"docs/events/builtin/syscalls/sigsuspend/#type","title":"Type","text":"<p>kprobe + kretprobe</p>"},{"location":"docs/events/builtin/syscalls/sigsuspend/#purpose","title":"Purpose","text":"<p>To monitor when the program defines a new signal mask and waits until a signal is received.</p>"},{"location":"docs/events/builtin/syscalls/sigsuspend/#example-use-case","title":"Example Use Case","text":"<p>When monitoring a program that handles signals and the need to know when a new signal mask is set and in which order the signals are handled. </p>"},{"location":"docs/events/builtin/syscalls/sigsuspend/#issues","title":"Issues","text":"<p>If a signal is sent with a higher priority than SIGKILL and SIGSTOP, it might be missed by the call to sigsuspend().</p>"},{"location":"docs/events/builtin/syscalls/sigsuspend/#related-events","title":"Related Events","text":"<ul> <li>sigprocmask()</li> <li>sigsuspend()</li> <li>sigpending()</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/socket/","title":"socket","text":""},{"location":"docs/events/builtin/syscalls/socket/#intro","title":"Intro","text":"<p>socket - create an endpoint for communication</p>"},{"location":"docs/events/builtin/syscalls/socket/#description","title":"Description","text":"<p>The socket() system call creates an endpoint for communication and returns a file descriptor that refers to that endpoint. It takes three arguments: domain, type, and protocol. These arguments define the properties of the communication protocol.</p> <p>The domain argument specifies a communication domain within which communication will take place. This argument specifies the protocol of the socket created and the type of address to be used.</p> <p>The type argument specifies the communications style and is typically one of SOCK_STREAM, SOCK_DGRAM, or SOCK_SEQPACKET.</p> <p>The protocol argument ranges from 0 to 255 and specifies the particular protocol to be used with the socket. Common values are IPPROTO_TCP, IPPROTO_UDP, IPPROTO_ICMP, and IPPROTO_IGMP.</p> <p>Edge-cases, drawbacks or advantages of using socket() could include: * Socket connection-less datagrams are faster than connection-oriented messages. * Socket connections are reliable and do not incur the same signal latency as connection-less datagrams. * Socket connection-oriented streams can provide reliable transmission of data at a higher bandwidth than datagrams, but the signal latency is greater.</p>"},{"location":"docs/events/builtin/syscalls/socket/#arguments","title":"Arguments","text":"<ul> <li><code>domain</code>:<code>int</code>[K] - The domain argument specifies the communication domain within which communication will take place.</li> <li><code>type</code>:<code>int</code>[K] - The type argument specifies the communications style and is typically one of SOCK_STREAM, SOCK_DGRAM, or SOCK_SEQPACKET.</li> <li><code>protocol</code>:<code>int</code>[K] - The protocol argument specifies the particular protocol to be used with the socket between 0 and 255.</li> </ul>"},{"location":"docs/events/builtin/syscalls/socket/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/socket/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/socket/#sys_socket","title":"sys_socket","text":""},{"location":"docs/events/builtin/syscalls/socket/#type","title":"Type","text":"<p>KProbes</p>"},{"location":"docs/events/builtin/syscalls/socket/#purpose","title":"Purpose","text":"<p>To monitor the usage of the socket system call.</p>"},{"location":"docs/events/builtin/syscalls/socket/#example-use-case","title":"Example Use Case","text":"<p>The socket() system call can be used when creating a network service. For example, a web server can be created by creating a socket, binding it to an address, and listening for connections.</p>"},{"location":"docs/events/builtin/syscalls/socket/#issues","title":"Issues","text":"<p>socket() system call can be vulnerable to TOCTOU (time of check, time of use) issues.</p>"},{"location":"docs/events/builtin/syscalls/socket/#related-events","title":"Related Events","text":"<ul> <li>socketpair() - create a pair of connected sockets</li> <li>accept() - accept a connection on a socket</li> <li>bind() - bind a name to a socket</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/socketcall/","title":"socketcall","text":""},{"location":"docs/events/builtin/syscalls/socketcall/#intro","title":"Intro","text":"<p>socketcall - System call used to pass arguments of other socket calls</p>"},{"location":"docs/events/builtin/syscalls/socketcall/#description","title":"Description","text":"<p>The <code>socketcall()</code> system call is used to pass a set of arguments of other socket related system calls in a single system call. This is used in many architectures since it has the advantage of reducing the number of system calls made when performing multiple operations executing multiple syscalls. However, this can be a security concern.</p>"},{"location":"docs/events/builtin/syscalls/socketcall/#arguments","title":"Arguments","text":"<ul> <li><code>call</code>: <code>int</code> - Specifies the actual call to perform, which should be one of the SOCKET_CMD constants.</li> <li><code>args</code>: <code>unsigned long*</code> - Pointer to a vector of arguments for the call, described in detail here.</li> </ul>"},{"location":"docs/events/builtin/syscalls/socketcall/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/socketcall/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/socketcall/#do_socketcall","title":"do_socketcall","text":""},{"location":"docs/events/builtin/syscalls/socketcall/#type","title":"Type","text":"<p>KProbes</p>"},{"location":"docs/events/builtin/syscalls/socketcall/#purpose","title":"Purpose","text":"<p>This function is hooked to monitor and trace socket calls being executed.</p>"},{"location":"docs/events/builtin/syscalls/socketcall/#example-use-case","title":"Example Use Case","text":"<p>socketcall can be used to batch together multiple socket related system calls. This is useful when a program needs to perform a series of socket operations, such as connecting to a server, sending data, and then receiving data.</p>"},{"location":"docs/events/builtin/syscalls/socketcall/#issues","title":"Issues","text":"<p>Due to the nature of this system call, it introduces a security concern as the parameters are not verified by the kernel and can lead to a TOCTOU vulnerability.</p>"},{"location":"docs/events/builtin/syscalls/socketcall/#related-events","title":"Related Events","text":"<ul> <li>accept4</li> <li>connect</li> <li>getsockopt</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/socketpair/","title":"socketpair","text":""},{"location":"docs/events/builtin/syscalls/socketpair/#intro","title":"Intro","text":"<p>socketpair - creates an unnamed pair of connected sockets</p>"},{"location":"docs/events/builtin/syscalls/socketpair/#description","title":"Description","text":"<p>The socketpair() system call creates a pair of connected anonymous unix domain sockets, which can be used in place of a pipe(2) to handle data exchange between processes. It is similar to socket(2), but differs in that it creates two connected sockets, rather than just one. It is typically used by programs that need to pass a file descriptor over a unix domain socket. The domain argument specifies a communications domain in which the sockets are to be created. The sockets may be used to pass file descriptors referring to any type of file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/socketpair/#arguments","title":"Arguments","text":"<ul> <li><code>domain</code>:<code>int</code>[K] - the communications domain in which the sockets are to be created; currently supported domains are AF_UNIX, AF_INET, AF_INET6.</li> <li><code>type</code>:<code>int</code>[K] - specifies the type of sockets created to be either SOCK_STREAM or SOCK_DGRAM.</li> <li><code>protocol</code>:<code>int</code>[K] - specifies a particular protocol to be used with the sockets. Normally only a single protocol exists to support a particular socket type within a given domain.</li> <li><code>sv</code>:<code>int[2]</code>[K] - used to return two file descriptors referring to the newly created sockets.</li> </ul>"},{"location":"docs/events/builtin/syscalls/socketpair/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/socketpair/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/socketpair/#socketpair_1","title":"socketpair","text":""},{"location":"docs/events/builtin/syscalls/socketpair/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/socketpair/#purpose","title":"Purpose","text":"<p>Hooks the socketpair syscall in order to monitor its use in applications.</p>"},{"location":"docs/events/builtin/syscalls/socketpair/#example-use-case","title":"Example Use Case","text":"<p>socketpair() is commonly used to create communication between two processes. It can be used by shell commands such as pipe, which use socketpair to create a pipe between two processes, or by applications that need to pass a file descriptor over a unix domain socket.</p>"},{"location":"docs/events/builtin/syscalls/socketpair/#issues","title":"Issues","text":"<p>None</p>"},{"location":"docs/events/builtin/syscalls/socketpair/#related-events","title":"Related Events","text":"<ul> <li>connect </li> <li>socket </li> <li>accept</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/splice/","title":"splice","text":""},{"location":"docs/events/builtin/syscalls/splice/#intro","title":"Intro","text":"<p>splice - combines two file descriptors into a single file</p>"},{"location":"docs/events/builtin/syscalls/splice/#description","title":"Description","text":"<p>The splice() system call first appeared in Linux 2.6.17; it moves data between two file descriptors without copying between kernel address space and user address space. It can relate any two file objects that support the splice file operation.  </p> <p>It is an ideal operation if an application needs to move data directly from one file descriptor to another, for example to write data directly to disk or to read data directly from disk within a single process.</p>"},{"location":"docs/events/builtin/syscalls/splice/#arguments","title":"Arguments","text":"<ul> <li><code>fd_in</code>:<code>int</code>[K] - an input file descriptor from which data is read.  </li> <li><code>off_in</code>:<code>off_t*</code>[K] - a pointer to an offset into <code>fd_in</code>.  </li> <li><code>fd_out</code>:<code>int</code>[K] - an output file descriptor to which data is written.  </li> <li><code>off_out</code>:<code>off_t*</code>[K] - a pointer to an offset into <code>fd_out</code>.  </li> <li><code>len</code>:<code>size_t</code>[K] - the number of bytes to copy between file descriptors.  </li> <li><code>flags</code>:<code>unsigned int</code>[K] - one or more of the SPLICE_F_MOVE, SPLICE_F_NONBLOCK, SPLICE_F_MORE, and/or SPLICE_F_GIFT options can be specified in flags.</li> </ul>"},{"location":"docs/events/builtin/syscalls/splice/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/splice/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/splice/#vfs_splice_to_pipe","title":"<code>vfs_splice_to_pipe</code>","text":""},{"location":"docs/events/builtin/syscalls/splice/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/splice/#purpose","title":"Purpose","text":"<p>Detect when a splice is executed, regardless of parameters.</p>"},{"location":"docs/events/builtin/syscalls/splice/#example-use-case","title":"Example Use Case","text":"<p>An application that writes data directly to a file from another file in the same process can use the splice() system call.</p>"},{"location":"docs/events/builtin/syscalls/splice/#issues","title":"Issues","text":"<p>On Linux systems with SELinux, the splice() system call can fail due to SELinux policies restricting access to certain resources, such as network sockets.</p>"},{"location":"docs/events/builtin/syscalls/splice/#related-events","title":"Related Events","text":"<ul> <li><code>writev</code></li> <li><code>readv</code></li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/ssetmask/","title":"ssetmask","text":""},{"location":"docs/events/builtin/syscalls/ssetmask/#intro","title":"Intro","text":"<p>ssetmask - Change calling thread signal mask</p>"},{"location":"docs/events/builtin/syscalls/ssetmask/#description","title":"Description","text":"<p>The ssetmask function sets the signal mask of the calling thread to the argument newmask, and returns the previous signal mask of the thread. The calls have no effect on signals that are ignored. The ssetmask() function is equivalent to sigprocmask(2).</p>"},{"location":"docs/events/builtin/syscalls/ssetmask/#arguments","title":"Arguments","text":"<ul> <li><code>newmask</code>:<code>long</code>[K] - The signal mask to be set.</li> </ul>"},{"location":"docs/events/builtin/syscalls/ssetmask/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/ssetmask/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/ssetmask/#ssetmask_1","title":"ssetmask","text":""},{"location":"docs/events/builtin/syscalls/ssetmask/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/ssetmask/#purpose","title":"Purpose","text":"<p>To detect when threads change their signal masks.</p>"},{"location":"docs/events/builtin/syscalls/ssetmask/#example-use-case","title":"Example Use Case","text":"<p>ssetmask() can be used to detect if a thread is attempting to block certain signals. This is useful to detect certain malicious activities, as it can indicate the presence of signal handlers.</p>"},{"location":"docs/events/builtin/syscalls/ssetmask/#issues","title":"Issues","text":"<p>None</p>"},{"location":"docs/events/builtin/syscalls/ssetmask/#related-events","title":"Related Events","text":"<ul> <li>signal(2) - Send signal.</li> <li>sigaction(2) - Change signal action.</li> <li>sigprocmask(2) - Examine and change blocked signals.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/stat/","title":"stat","text":""},{"location":"docs/events/builtin/syscalls/stat/#intro","title":"Intro","text":"<p>stat - Obtains information about a file, given its pathname</p>"},{"location":"docs/events/builtin/syscalls/stat/#description","title":"Description","text":"<p>The <code>stat</code> syscall is used to obtain information about a file or directory,  given its pathname. The information is retrieved in the form of a <code>struct stat</code>  object, which contains information such as the file's size, last access and modification times, and owner. It is also used to detect if a file exists,  or why it does not exist, so that proper exception handling can be done.</p> <p>There is a potential Time of Check, Time of Use (TOCTOU) race condition when using <code>stat</code> to check the existence of a file. If used in the wrong context, it can lead to errors.</p>"},{"location":"docs/events/builtin/syscalls/stat/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code>[U] - Pathname of the file or directory being examined.   </li> <li><code>statbuf</code>:<code>struct stat*</code>[K] - Pointer to the location of the <code>stat</code> struct in memory, where all the results of the function call will be stored.</li> </ul>"},{"location":"docs/events/builtin/syscalls/stat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/stat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/stat/#do_sys_stat","title":"do_sys_stat","text":""},{"location":"docs/events/builtin/syscalls/stat/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/stat/#purpose","title":"Purpose","text":"<p>To detect stat syscalls and collect information about them.</p>"},{"location":"docs/events/builtin/syscalls/stat/#example-use-case","title":"Example Use Case","text":"<p>A user-space program might use <code>stat</code> to check the existence of a file, and then take some action based on the result.</p>"},{"location":"docs/events/builtin/syscalls/stat/#issues","title":"Issues","text":"<p>There is a potential TOCTOU race condition when using <code>stat</code> to check the existence of a file. </p>"},{"location":"docs/events/builtin/syscalls/stat/#related-events","title":"Related Events","text":"<ul> <li><code>lstat</code> - A related syscall which facilitates the acquisition of information about a file on a filesystem. It does not follow symbolic links.  </li> <li><code>fstat</code> - A related syscall which regards an already opened file for information instead of a pathname.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/stat64/","title":"stat64","text":""},{"location":"docs/events/builtin/syscalls/stat64/#intro","title":"Intro","text":"<p>stat64 - Get the status information of a file</p>"},{"location":"docs/events/builtin/syscalls/stat64/#description","title":"Description","text":"<p>The <code>stat64()</code> system call gets the status information of the file pointed to by <code>pathname</code>, and returns it in the <code>statbuf</code> structure, which includes information like file type, size, inode, etc. The <code>statbuf</code> structure needs to be allocated by the caller, as it will be filled in by the kernel. </p> <p>The <code>stat64()</code> system call is vulnerable to Time-of-Check Time-of-Use (TOCTOU) race conditions, as the <code>statbuf</code> argument contains the pointer to the status information of the file; if the file is changed between the checks, the information that is returned by <code>stat64()</code> could be wrong.</p>"},{"location":"docs/events/builtin/syscalls/stat64/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code>[U] - Path to the file to be stat'ed</li> <li><code>statbuf</code>:<code>struct stat64*</code>[U] - Pointer to <code>struct stat64</code> in user-space, that will be filled in by the kernel.</li> </ul>"},{"location":"docs/events/builtin/syscalls/stat64/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/stat64/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/stat64/#sys_stat64","title":"sys_stat64","text":""},{"location":"docs/events/builtin/syscalls/stat64/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/stat64/#purpose","title":"Purpose","text":"<p>Observe where the <code>stat64()</code> system call is used in the kernel.</p>"},{"location":"docs/events/builtin/syscalls/stat64/#example-use-case","title":"Example Use Case","text":"<p>The <code>stat64()</code> system call can be used to get the status information of a file before executing it to check for permission, etc.</p>"},{"location":"docs/events/builtin/syscalls/stat64/#issues","title":"Issues","text":"<p>The <code>stat64()</code> system call is vulnerable to TOCTOU race conditions, where the <code>statbuf</code> argument contains the pointer to the status information of the file; if the file is changed between the checks, the information that is returned by <code>stat64()</code> could be wrong.</p>"},{"location":"docs/events/builtin/syscalls/stat64/#related-events","title":"Related Events","text":"<ul> <li>open64: Related as it is needed before executing a file to open it and get its information.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/statfs/","title":"statfs","text":""},{"location":"docs/events/builtin/syscalls/statfs/#intro","title":"Intro","text":"<p>statfs - copies information relating to mounted filesystems</p>"},{"location":"docs/events/builtin/syscalls/statfs/#description","title":"Description","text":"<p>The <code>statfs</code> system call obtains details of the mounted file system specified by the path. The information is stored in the struct <code>statfs</code>, which is returned to the user at <code>buf</code>. The <code>statfs</code> system call is commonly used for finding out the total size of the file system, the number of available blocks or the number of free blocks.</p>"},{"location":"docs/events/builtin/syscalls/statfs/#arguments","title":"Arguments","text":"<ul> <li><code>path</code>:<code>const char*</code>[U] - path of the mounted file system</li> <li><code>buf</code>:<code>struct statfs*</code>[U] - pointer to a buffer where the statfs data will be stored</li> </ul>"},{"location":"docs/events/builtin/syscalls/statfs/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/statfs/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/statfs/#sys_statfs","title":"sys_statfs","text":""},{"location":"docs/events/builtin/syscalls/statfs/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/statfs/#purpose","title":"Purpose","text":"<p>To keep track of when and how often the <code>statfs</code> system call is used.</p>"},{"location":"docs/events/builtin/syscalls/statfs/#example-use-case","title":"Example Use Case","text":"<p>The <code>statfs</code> system call could be used to gather file system statistics, such as the size and number of free blocks, for monitoring the health of the system.</p>"},{"location":"docs/events/builtin/syscalls/statfs/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/statfs/#related-events","title":"Related Events","text":"<ul> <li>mount (from which relevant statfs information can be obtained)</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/statfs64/","title":"statfs64","text":""},{"location":"docs/events/builtin/syscalls/statfs64/#intro","title":"Intro","text":"<p>statfs64 - obtain information about a mounted file system.</p>"},{"location":"docs/events/builtin/syscalls/statfs64/#description","title":"Description","text":"<p>The statfs64 system call obtains information about a mounted file system on the Linux operating system. It copies the file system parameters from the super block structure in the kernel memory to the user land structure <code>struct statfs64</code> provided in the <code>buf</code> argument. </p> <p>The <code>size_t</code> argument <code>sz</code> specifies the size of the provided <code>buf</code> structure, so that the kernel can decide which version of the struct will be used. No data will be copied in case the provided <code>sz</code> size doesn't match the size of the corresponding struct in the kernel.</p>"},{"location":"docs/events/builtin/syscalls/statfs64/#arguments","title":"Arguments","text":"<ul> <li><code>path</code>:<code>const char*</code>[U] - path of the file system that should be queried.</li> <li><code>sz</code>:<code>size_t</code>[U] - this argument specifies the size of the <code>buf</code> argument, allowing the kernel to determine which version of the <code>struct statfs64</code> will be used.</li> <li><code>buf</code>:<code>struct statfs64*</code>[U] - pointer to a user-space buffer, where the information collected from the kernel will be stored.</li> </ul>"},{"location":"docs/events/builtin/syscalls/statfs64/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/statfs64/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/statfs64/#do_statfs","title":"do_statfs","text":""},{"location":"docs/events/builtin/syscalls/statfs64/#type","title":"Type","text":"<p>Kprobes + Uprobe</p>"},{"location":"docs/events/builtin/syscalls/statfs64/#purpose","title":"Purpose","text":"<p>Monitors This syscall, to collect information about the mounted file systems.</p>"},{"location":"docs/events/builtin/syscalls/statfs64/#example-use-case","title":"Example Use Case","text":"<p>It can be used to collect information on mounted file systems, such as available disk space, block size and total number of blocks.</p>"},{"location":"docs/events/builtin/syscalls/statfs64/#issues","title":"Issues","text":"<p>The <code>size_t</code> parameter <code>sz</code> can cause issues if the user-space buffer size is not large enough for the corresponding struct size in the kernel.</p>"},{"location":"docs/events/builtin/syscalls/statfs64/#related-events","title":"Related Events","text":"<ul> <li>mount()</li> <li>umount2()</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/statx/","title":"statx","text":""},{"location":"docs/events/builtin/syscalls/statx/#intro","title":"Intro","text":"<p>The <code>statx</code> syscall is used to get information about a filesystem object. It's similar to the <code>stat</code> syscall, but supports a more fine-grained mask argument which controls which fields are returned.</p>"},{"location":"docs/events/builtin/syscalls/statx/#description","title":"Description","text":"<p><code>statx</code> allows to get information about various filesystem objects (like regular files, directories, links). Its main advantage over the <code>stat</code> syscall is the ability to specify a mask argument which controls which fields are returned in the <code>struct statx</code> pointer argument. This reduces the amount of system calls to retrieve multiple bits of information about a filesystem object, and makes the call more efficient.</p> <p>In addition, <code>statx</code> supports some flags which modify the operation, like AT_NO_AUTOMOUNT which tell the system not to mount a filesystem automatically when necessary.</p> <p>The <code>statx</code> syscall is part of the new libpfc library which simplifies common filesystem operation.</p>"},{"location":"docs/events/builtin/syscalls/statx/#arguments","title":"Arguments","text":"<ul> <li><code>dirfd</code>:<code>int</code> - File descriptor for a directory from which the relative path is evaluated, or <code>AT_FDCWD</code> for the current working directory.</li> <li><code>pathname</code>:<code>const char*</code>[U] - Null-terminated pathname relative to the <code>dirfd</code> argument.</li> <li><code>flags</code>:<code>int</code>[K] - Flags which modify the operation. See the <code>statx</code> manual page for the available set of flags.</li> <li><code>mask</code>:<code>unsigned int</code>[K] - Bitmask field which defines what fields of the <code>struct statx</code> pointer argument to populate. </li> <li><code>statxbuf</code>:<code>struct statx*</code>[U] - Pointer to a <code>struct statx</code> which will be populated with the information from the filesystem object, according to the <code>mask</code> argument.</li> </ul>"},{"location":"docs/events/builtin/syscalls/statx/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/statx/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/statx/#do_sys_stat","title":"do_sys_stat","text":""},{"location":"docs/events/builtin/syscalls/statx/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/statx/#purpose","title":"Purpose","text":"<p>To observe calls to the <code>statx</code> syscall, and get information about the arguments being passed.</p>"},{"location":"docs/events/builtin/syscalls/statx/#example-use-case","title":"Example Use Case","text":"<p>You can use <code>statx</code> to get information about a file in order to determine if it should be included in a tarball, like when making a backup or when creating an archive. By specifying the appropriate bitmask for the <code>mask</code> argument, you can retrieve only the necessary information. </p>"},{"location":"docs/events/builtin/syscalls/statx/#issues","title":"Issues","text":"<p>The kernel does not support the <code>FOLLOW</code> flag, which enables the syscall to follow symbolic links. This limits the usefulness of the syscall when dealing with links.</p>"},{"location":"docs/events/builtin/syscalls/statx/#related-events","title":"Related Events","text":"<ul> <li><code>stat</code> - Syscall to get information about a filesystem object, which does not support a bitmask argument. </li> <li><code>fstatat</code> - Syscall to get information about a filesystem object given a file descriptor and a relative path. </li> <li><code>openat</code> - Syscall to open a file given a file descriptor and a relative path.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/stime/","title":"stime","text":""},{"location":"docs/events/builtin/syscalls/stime/#intro","title":"Intro","text":"<p>stime - set the system's date and time</p>"},{"location":"docs/events/builtin/syscalls/stime/#description","title":"Description","text":"<p>The stime system call sets the system's idea of the current calendar time and time of day. The time argument is the time in seconds since the epoch, and time should always be non-negative. The time argument is interpreted as UTC by the kernel. The syscall does not check whether any arguments are out of range, leading to a potential TOCTOU (time of check, time of use) vulnerability.</p>"},{"location":"docs/events/builtin/syscalls/stime/#arguments","title":"Arguments","text":"<ul> <li><code>t</code>:<code>const time_t*</code>[K] - timestamp of current time in seconds since the Epoch.</li> </ul>"},{"location":"docs/events/builtin/syscalls/stime/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/stime/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/stime/#sys_stime","title":"sys_stime","text":""},{"location":"docs/events/builtin/syscalls/stime/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/stime/#purpose","title":"Purpose","text":"<p>To log the invocation of the <code>stime()</code> system call.</p>"},{"location":"docs/events/builtin/syscalls/stime/#example-use-case","title":"Example Use Case","text":"<p>The <code>stime</code> system call can be used to manually adjust the system time. One example use case can be to periodically invoke this system call to keep the system time in sync with an NTP server.</p>"},{"location":"docs/events/builtin/syscalls/stime/#issues","title":"Issues","text":"<p>Due to the lack of input sanitation, this system call has been found vulnerable to TOCTOU (Time of Check / Time of Use) vulnerability in certain cases.</p>"},{"location":"docs/events/builtin/syscalls/stime/#related-events","title":"Related Events","text":"<ul> <li><code>nanosleep</code> - to suspend execution of the current thread.</li> <li><code>clock_settime</code> - to change the current time of a clock relative to an epoch</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/stty/","title":"stty","text":""},{"location":"docs/events/builtin/syscalls/stty/#intro","title":"Intro","text":"<p>stty - sets the parameters associated with the terminal.</p>"},{"location":"docs/events/builtin/syscalls/stty/#description","title":"Description","text":"<p>The stty utility sets or reports terminal characteristics (POSIX termios style) for open terminals in the pseudo-terminal family. The terminal characteristics determine how input and output behave on the input and output streams of the terminal. All subsequent reads and writes on the terminal use these characteristics until the characteristics are re-set with stty.</p> <p>The POSIX terminal interface is derived from the Unix system and provides more comprehensive control of the terminal than the more traditional interface derived from System V and supplied as the ioctl function.</p>"},{"location":"docs/events/builtin/syscalls/stty/#arguments","title":"Arguments","text":"<ul> <li><code>command_string</code>:<code>string</code>[K] - A stty command string made of words, separators, and quote marks that contains one or more stty commands to be performed on the terminal output or input.</li> </ul>"},{"location":"docs/events/builtin/syscalls/stty/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/stty/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/stty/#syscall","title":"Syscall","text":""},{"location":"docs/events/builtin/syscalls/stty/#type","title":"Type","text":"<p>Probe</p>"},{"location":"docs/events/builtin/syscalls/stty/#purpose","title":"Purpose","text":"<p>To detect calls to the stty syscall.</p>"},{"location":"docs/events/builtin/syscalls/stty/#example-use-case","title":"Example Use Case","text":"<p>stty can be used to change the baud rate and other aspects of the serial port operation, thus it is a common event used in debugging serial port issues.</p>"},{"location":"docs/events/builtin/syscalls/stty/#issues","title":"Issues","text":"<p>N/A</p>"},{"location":"docs/events/builtin/syscalls/stty/#related-events","title":"Related Events","text":"<ul> <li>tcgets</li> <li>tcsetattr</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/swapoff/","title":"swapoff","text":""},{"location":"docs/events/builtin/syscalls/swapoff/#intro","title":"Intro","text":"<p>swapoff - unregister a path from the list of used swap devices</p>"},{"location":"docs/events/builtin/syscalls/swapoff/#description","title":"Description","text":"<p>The <code>swapoff()</code> function unregisters the path pointed to by the <code>path</code> parameter from the list of used swap devices. This call can be used to deactivate swap devices without reboot. Since the Linux kernel version 4.14, swap devices can also be limited to a specific range of physical memory pages. This allows creating swap devices out of unused physical memory. </p>"},{"location":"docs/events/builtin/syscalls/swapoff/#arguments","title":"Arguments","text":"<ul> <li><code>path</code>:<code>const char*</code>[K] - path to the swap device.  </li> </ul>"},{"location":"docs/events/builtin/syscalls/swapoff/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/swapoff/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/swapoff/#sys_swapoff","title":"sys_swapoff","text":""},{"location":"docs/events/builtin/syscalls/swapoff/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/swapoff/#purpose","title":"Purpose","text":"<p>Used to unregister the path pointed to by the path parameter from the list of used swap devices.</p>"},{"location":"docs/events/builtin/syscalls/swapoff/#example-use-case","title":"Example Use Case","text":"<p>When we want to unregister a swap device without rebooting the system.</p>"},{"location":"docs/events/builtin/syscalls/swapoff/#issues","title":"Issues","text":"<p>On some systems, swapoff() fails with an \"Operation not permitted\" error if called from a non-root process.</p>"},{"location":"docs/events/builtin/syscalls/swapoff/#related-events","title":"Related Events","text":"<p>The <code>swapon()</code> syscall can be used in combination with <code>swapoff()</code> to activate and deactivate swap devices.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/swapon/","title":"swapon","text":""},{"location":"docs/events/builtin/syscalls/swapon/#intro","title":"Intro","text":"<p>swapon - allow a process to start using a designated swap area</p>"},{"location":"docs/events/builtin/syscalls/swapon/#description","title":"Description","text":"<p>The swapon() system call allows a process to start using a designated swap area on a file or a device that is setup for paging and/or swapping. Both regular files and block special files can be used for this purpose.</p> <p>When path is NULL, the kernel will use the first entry in the /etc/fstab as the default swap area. If the swap flag is passed as NULL, the kernel will default to 0. swapon() provides an easy way to enable swap on a single partition at a time.</p> <p>Some of the advantages of using swapon() are that the swap area can be easily re-enabled on reboot, the memory use can be easily monitored with the free command, and it can be used on freshly installed systems. However, one of the drawbacks is that the system will still be left with active memory pages until they are paged out. This could lead to excessive paging activity during bootup, leading to degraded system performance.</p>"},{"location":"docs/events/builtin/syscalls/swapon/#arguments","title":"Arguments","text":"<ul> <li><code>path</code>:<code>const char*</code>[K] - Path to a block special device or a regular file that will be used for swapping. If set to NULL, then the first entry in the /etc/fstab will be used.</li> <li><code>swapflags</code>:<code>int</code>[K] - Flags which indicate what type of swap to use. The allowed flags are: </li> <li>SWAP_FLAG_PREFER - Only use the specified swap file if it's better than the existing one.</li> <li>SWAP_FLAG_DISCARD - Discard pages from the swap file as soon as they are used.</li> </ul>"},{"location":"docs/events/builtin/syscalls/swapon/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/swapon/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/swapon/#do_swapon","title":"do_swapon","text":""},{"location":"docs/events/builtin/syscalls/swapon/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/swapon/#purpose","title":"Purpose","text":"<p>Hooking do_swapon allows tracing when the system starts using a designated swap area on a file or a device.</p>"},{"location":"docs/events/builtin/syscalls/swapon/#sys_swapon","title":"sys_swapon","text":""},{"location":"docs/events/builtin/syscalls/swapon/#type_1","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/swapon/#purpose_1","title":"Purpose","text":"<p>Hooking sys_swapon provides a way to monitor when a user process attempts to start using a designated swap area.</p>"},{"location":"docs/events/builtin/syscalls/swapon/#example-use-case","title":"Example Use Case","text":"<p>Swapon may be used when a user needs to add a new swap area to an existing system. If the file or block special device is set up correctly, the user can call swapon to enable the swap area.  </p>"},{"location":"docs/events/builtin/syscalls/swapon/#issues","title":"Issues","text":"<p>Due to the way the kernel manages swap, it is possible that this system call may return an error (EINVAL) if the swap area specified is already in use.</p>"},{"location":"docs/events/builtin/syscalls/swapon/#related-events","title":"Related Events","text":"<p>The swapon() system call is related to the swaponall() system call, which is used to enable all swap areas specified in the /etc/fstab. It is also related to the swapoff() system call, which is used to disable a swap area.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/symlink/","title":"symlink","text":""},{"location":"docs/events/builtin/syscalls/symlink/#intro","title":"Intro","text":"<p>symlink - creates a symbolic link to a file in the file system.</p>"},{"location":"docs/events/builtin/syscalls/symlink/#description","title":"Description","text":"<p>The <code>symlink</code> event creates a symbolic link at the given path to the target file. This link is similar to a regular file, but it points to the actual file rather than containing a copy of the contents. This is useful for creating multiple references to the same file without taking up more space. The main drawback is that if the target file is changed, so are all the links pointing to it.</p>"},{"location":"docs/events/builtin/syscalls/symlink/#arguments","title":"Arguments","text":"<ul> <li><code>target</code>:<code>const char*</code>[K] - The path to the file that will be pointed to.</li> <li><code>linkpath</code>:<code>const char*</code>[K] - The path of the symbolic link that will be created.</li> </ul>"},{"location":"docs/events/builtin/syscalls/symlink/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/symlink/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/symlink/#sys_symlink","title":"sys_symlink","text":""},{"location":"docs/events/builtin/syscalls/symlink/#type","title":"Type","text":"<p>kretprobe</p>"},{"location":"docs/events/builtin/syscalls/symlink/#purpose","title":"Purpose","text":"<p>Hooked to trace the execution of the <code>sys_symlink</code> kernel function, which is the entrypoint for the <code>symlink</code> syscall.</p>"},{"location":"docs/events/builtin/syscalls/symlink/#example-use-case","title":"Example Use Case","text":"<p>A use case for the <code>symlink</code> event could be analyzing the behavior of different system processes when creating symbolic links. This could help identify potential malicious actors and vulnerabilities in the system, or analyze how processes interact with files and other processes.</p>"},{"location":"docs/events/builtin/syscalls/symlink/#issues","title":"Issues","text":"<p>The main issue with the <code>symlink</code> event is that it is vulnerable to TOCTOU (time of check, time of use) attacks. This means that the target file could be changed before the <code>symlink</code> syscall is triggered, leading to a change of the reference for the symbolic link. </p>"},{"location":"docs/events/builtin/syscalls/symlink/#related-events","title":"Related Events","text":"<ul> <li><code>unlink</code> - deletes the file referenced by a given path.</li> <li><code>link</code> - creates a hard link to a file in the file system.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/symlinkat/","title":"symlinkat","text":""},{"location":"docs/events/builtin/syscalls/symlinkat/#intro","title":"Intro","text":"<p>symlinkat - Creates a symbolic link named by linkpath to an object referenced by target. </p>"},{"location":"docs/events/builtin/syscalls/symlinkat/#description","title":"Description","text":"<p>Symlinkat creates a symbolic link with the name specified in <code>linkpath</code> to the object referenced by <code>target</code>. It differs from <code>symlink</code> in that <code>linkpath</code> is relative to the directory file descriptor provided in <code>newdirfd</code>.</p> <p>Normally, symbolic links can only point to other files located in the same filesystem. However, when the <code>target</code> argument is prefixed with <code>/proc/self/fd/</code>, it can reference a file descriptor opened by the same process.</p> <p>There are a few possible edge-cases when using <code>symlinkat</code>. If <code>linkpath</code> already exists, the existing link will be overwritten, and if the directory referenced by <code>newdirfd</code> is not writable, a <code>EACCES</code> error will be returned.</p>"},{"location":"docs/events/builtin/syscalls/symlinkat/#arguments","title":"Arguments","text":"<ul> <li><code>target</code>:<code>const char*</code>[U] - The target to which the symbolic link points.</li> <li><code>newdirfd</code>:<code>int</code>[U] - The file descriptor for the target directory.</li> <li><code>linkpath</code>:<code>const char*</code>[U] - The name of the link to be created.</li> </ul>"},{"location":"docs/events/builtin/syscalls/symlinkat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/symlinkat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/symlinkat/#sys_symlinkat","title":"sys_symlinkat","text":""},{"location":"docs/events/builtin/syscalls/symlinkat/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/symlinkat/#purpose","title":"Purpose","text":"<p>Trace calls to symlinkat, including the arguments passed to it.</p>"},{"location":"docs/events/builtin/syscalls/symlinkat/#example-use-case","title":"Example Use Case","text":"<p>Tracing the origin of symbolic links created in the system. This can be used to monitor privilege escalations and other malicious actions.</p>"},{"location":"docs/events/builtin/syscalls/symlinkat/#issues","title":"Issues","text":"<p>The <code>target</code> argument can reference parts of the filesystem. This means that if <code>target</code> contains a relative path, its interpretation will depend on the current working directory of the process.</p>"},{"location":"docs/events/builtin/syscalls/symlinkat/#related-events","title":"Related Events","text":"<p>The <code>lstat</code> event can be used to check if a file is a symbolic link, and if so, which file or directory it points to.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sync/","title":"sync","text":""},{"location":"docs/events/builtin/syscalls/sync/#intro","title":"Intro","text":"<p>sync - waits until all disk write operations have been completed</p>"},{"location":"docs/events/builtin/syscalls/sync/#description","title":"Description","text":"<p>The sync command causes all in-memory modified blocks to be written to disk. This is useful in order to ensure the full integrality and consistency of the data in the case of a system crash or power failure. However, it is not a full backup solution and it should be used in combination with other data safety measures. Moreover, regular synchronization of the disks is suggested in order to minimize the impact of unclean shutdown.</p>"},{"location":"docs/events/builtin/syscalls/sync/#arguments","title":"Arguments","text":"<ul> <li><code>None</code></li> </ul>"},{"location":"docs/events/builtin/syscalls/sync/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sync/#sync_file_range","title":"sync_file_range","text":""},{"location":"docs/events/builtin/syscalls/sync/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/sync/#purpose","title":"Purpose","text":"<p>Detecting when a process is syncing files to create a superblock barrier.</p>"},{"location":"docs/events/builtin/syscalls/sync/#sys_sync","title":"sys_sync","text":""},{"location":"docs/events/builtin/syscalls/sync/#type_1","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/sync/#purpose_1","title":"Purpose","text":"<p>Detecting calls to the sys_sync function in the kernel.</p>"},{"location":"docs/events/builtin/syscalls/sync/#example-use-case","title":"Example Use Case","text":"<p>For example, the sync command can be used to make sure that the in-memory modified blocks are written to disk before rebooting the system.</p>"},{"location":"docs/events/builtin/syscalls/sync/#issues","title":"Issues","text":"<p>Depending on the file system used, the sync command doesn't guarantee that the data is flushed completely. </p>"},{"location":"docs/events/builtin/syscalls/sync/#related-events","title":"Related Events","text":"<p>fsync - sync data and associated metadata for specified file</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sync_file_range/","title":"sync_file_range","text":""},{"location":"docs/events/builtin/syscalls/sync_file_range/#intro","title":"Intro","text":"<p>sync_file_range - synchronizes a file range with the underlying hardware</p>"},{"location":"docs/events/builtin/syscalls/sync_file_range/#description","title":"Description","text":"<p>The <code>sync_file_range</code> system call causes all modified data and metadata  stored in a file range of the provided file descriptor to be transferred  to the underlying hardware associated with the file descriptor. This  system call is capable of both flushing and fsyncing the given file range.  It allows for more precise control over which blocks of a file are flushed to the underlying hardware, allowing certain operations to be  asynchronous, without incurring the overhead of the <code>fdatasync</code> or  <code>fsync</code> system calls. It also allows operations to bypass the page cache  and touch a range of blocks directly.</p> <p>There are some drawbacks to taking advantage of this syscall, one of  which is the potential race conditions due to TOCTOU (time of check,  time of use). It is important for the caller to be aware of the  possibility of race conditions, and to properly use the <code>O_SYNC</code> flag  or the <code>SYNC_FILE_RANGE_WRITE</code> flag if they wish to mitigate race  conditions.</p>"},{"location":"docs/events/builtin/syscalls/sync_file_range/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[U] - File descriptor of the file to synchronize.</li> <li><code>offset</code>:<code>off_t</code>[U] - Offset within the file to the start of the region to sync.</li> <li><code>nbytes</code>:<code>off_t</code>[U] - Number of bytes in the range to sync.</li> <li><code>flags</code>:<code>unsigned int</code>[U] - Bitmask indicating what action should be taken for the range.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sync_file_range/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user-space (for example, pointer to user-space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/sync_file_range/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sync_file_range/#vfs_sync_file_range","title":"vfs_sync_file_range","text":""},{"location":"docs/events/builtin/syscalls/sync_file_range/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/sync_file_range/#purpose","title":"Purpose","text":"<p>Hooks the <code>vfs_sync_file_range</code> function, which is the kernel entry point for the <code>sync_file_range</code> syscall.</p>"},{"location":"docs/events/builtin/syscalls/sync_file_range/#example-use-case","title":"Example Use Case","text":"<p><code>sync_file_range</code> can be used to synchronize certain parts of files without fsyncing the entire file. An example would be a database that updates small parts of a database file in a single operation. The database might use <code>sync_file_range</code> to synchronize the relevant blocks, rather than fsyncing the entire database file.</p>"},{"location":"docs/events/builtin/syscalls/sync_file_range/#issues","title":"Issues","text":"<p>Some filesystems may not support all options of the <code>flags</code> parameter, while others may support additional flags. This can lead to unexpected behaviour, and should be carefully considered by the caller. Additionally, <code>sync_file_range</code> is vulnerable to TOCTOU and race conditions, so be careful when using it.</p>"},{"location":"docs/events/builtin/syscalls/sync_file_range/#related-events","title":"Related Events","text":"<p>The <code>fdatasync</code> system call is similar to <code>sync_file_range</code>, in that it flushes modified data and metadata to the underlying hardware. However, <code>fdatasync</code> flushes the entire file, while <code>sync_file_range</code> only flushes a portion of the file. Additionally, <code>fsync</code> can be used to synchronize both the metadata and data of a file, while <code>sync_file_range</code> only synchronizes the data.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/syncfs/","title":"syncfs","text":""},{"location":"docs/events/builtin/syscalls/syncfs/#intro","title":"Intro","text":"<p>syncfs - synchronize all file system data on the device associated with a file descriptor</p>"},{"location":"docs/events/builtin/syscalls/syncfs/#description","title":"Description","text":"<p>The syncfs() system call synchronizes all data associated with the device opened via the file descriptor fd. It calls the file system's sync() operation, which transfers all cached data to permanent storage, and then the fsync() call. This is typically used to ensure that everything written to a file by the application is really on permanent storage.</p> <p>syncfs() is similar to sync(), but applies only to the filesystem associated with the file descriptor fd.</p>"},{"location":"docs/events/builtin/syscalls/syncfs/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - file descriptor pointing to a filesystem device.</li> </ul>"},{"location":"docs/events/builtin/syscalls/syncfs/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/syncfs/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/syncfs/#syncfs_1","title":"syncfs","text":""},{"location":"docs/events/builtin/syscalls/syncfs/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/syncfs/#purpose","title":"Purpose","text":"<p>Used to synchronize all data associated with a filesystem device.</p>"},{"location":"docs/events/builtin/syscalls/syncfs/#example-use-case","title":"Example Use Case","text":"<p>Let's say you wanted to take a backup of a file system in a file descriptor. The syncfs() system call is the one to do this, as it transfers all cached data to permanent storage.</p>"},{"location":"docs/events/builtin/syscalls/syncfs/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/syncfs/#related-events","title":"Related Events","text":"<ul> <li>sync - synchronize all file system data </li> <li>fsync - synchronize files or directories</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sysctl/","title":"sysctl","text":""},{"location":"docs/events/builtin/syscalls/sysctl/#intro","title":"Intro","text":"<p>sysctl - enables privileged processes to examine and modify the kernel parameters.</p>"},{"location":"docs/events/builtin/syscalls/sysctl/#description","title":"Description","text":"<p>The sysctl() system call is used by privileged processes to examine and modify kernel parameters. It is primarily used by system daemons, such as syslogd(8) and sshd(8), as well as by programs such as top(1) and ps(1). </p> <p>The first argument of sysctl() is a structure of type __sysctl_args, which consists of a list of integers that identify a particular kernel variable, and a string (or more accurately, an array of binary bytes) that is used to set the value for that variable. All kernel variables accessible via sysctl() can be prefixed using a period delimited sequence of integers. </p> <p>The kernel variables are divided in to two classes; read only and read/write. Making sysctl() calls to read/write variables requires the caller to either possess the CAP_SYS_ADMIN capability or be running as root. Making sysctl() calls to read only variables requires the caller to either possess the CAP_SYS_RAWIO capability or be running as root. </p>"},{"location":"docs/events/builtin/syscalls/sysctl/#arguments","title":"Arguments","text":"<ul> <li><code>args</code>:<code>struct __sysctl_args*</code>[K] - pointer to a structure of type __sysctl_args which contains the kernel variable information.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sysctl/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sysctl/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sysctl/#sysctl_1","title":"sysctl","text":""},{"location":"docs/events/builtin/syscalls/sysctl/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/sysctl/#purpose","title":"Purpose","text":"<p>To hook the syscall to call a certain function (with certain args) on every call, with both entry and exit full stack.</p>"},{"location":"docs/events/builtin/syscalls/sysctl/#example-use-case","title":"Example Use Case","text":"<p>An example use case for sysctl would be to monitor changes to kernel settings. For example, an application might be developed to increase the security of the system by monitoring system settings and alerting administrators if settings are changed outside of the expected range.</p>"},{"location":"docs/events/builtin/syscalls/sysctl/#issues","title":"Issues","text":"<p>One of the issues with using sysctl is that it is vulnerable to time-of-check-time-of-use (TOCTOU) attacks. If a malicious user is able to cause a race condition between the check and set operations on a sysctl variable, they may be able to modify a system setting without authorization. </p>"},{"location":"docs/events/builtin/syscalls/sysctl/#related-events","title":"Related Events","text":"<ul> <li>getrlimit</li> <li>setrlimit</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sysfs/","title":"sysfs","text":""},{"location":"docs/events/builtin/syscalls/sysfs/#intro","title":"Intro","text":"<p>sysfs - a system call for managing and querying the Linux kernel's sysfs file system.</p>"},{"location":"docs/events/builtin/syscalls/sysfs/#description","title":"Description","text":"<p>sysfs is a filesystem used by the Linux kernel to export information about devices and driver configuration options. It is used by user space applications to read and write configuration and device-specific data. sysfs is read-only from user space and is used to query the kernel for system parameters such as CPU and memory size. It also provides access to shared kernel trace information and can be used to access procfs.</p> <p>The sysfs system call allows user space processes to read and write sysfs entries. It takes an option as an argument which specifies the action to be performed. The optional argument is of type <code>int</code> and is read-only.</p>"},{"location":"docs/events/builtin/syscalls/sysfs/#arguments","title":"Arguments","text":"<ul> <li><code>option</code>:<code>int</code>[K] - specifies the action to be performed by the sysfs system call.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sysfs/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sysfs/#hooks","title":"Hooks","text":"<p>The <code>sysfs</code> system call is not hooked. </p>"},{"location":"docs/events/builtin/syscalls/sysfs/#example-use-case","title":"Example Use Case","text":"<p>The sysfs system call is typically used to query kernel parameters and device-specific data. This allows user-space programs to get information about the devices and drivers supported by the kernel without having to know any kernel-specific details.</p> <p>For instance, if a program needs to determine the size of the physical memory installed in a system, it can call sysfs with the <code>option</code> set to <code>MEM_SIZE</code> and the kernel will return the size of the memory in bytes.</p>"},{"location":"docs/events/builtin/syscalls/sysfs/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/sysfs/#related-events","title":"Related Events","text":"<ul> <li><code>procfs</code> - system call for managing and querying the Linux kernel's procfs filesystem.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/sysinfo/","title":"sysinfo","text":""},{"location":"docs/events/builtin/syscalls/sysinfo/#intro","title":"Intro","text":"<p>sysinfo - reads various system information</p>"},{"location":"docs/events/builtin/syscalls/sysinfo/#description","title":"Description","text":"<p>The sysinfo() system call is used to retrieve various system information related to the system's current status. It returns, among other metrics, the amount of time in idle, system, user and iowait, as well as the number of running and total processes, and the total amount of free and available memory.</p> <p>This system call provides a highly efficient and convenient way to quickly access many system metrics, making it useful for the monitoring of system performance. However, it is subject to TOCTOU (time of check, time of use) vulnerabilities, so it is important to take appropriate precaution when using it.</p>"},{"location":"docs/events/builtin/syscalls/sysinfo/#arguments","title":"Arguments","text":"<ul> <li><code>info</code>:<code>struct sysinfo*</code>[K] - A pointer to a struct sysinfo, which receives all the data accumulated by sysinfo.</li> </ul>"},{"location":"docs/events/builtin/syscalls/sysinfo/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/sysinfo/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/sysinfo/#sys_newstat","title":"sys_newstat","text":""},{"location":"docs/events/builtin/syscalls/sysinfo/#type","title":"Type","text":"<p>kprobes + ftrace</p>"},{"location":"docs/events/builtin/syscalls/sysinfo/#purpose","title":"Purpose","text":"<p>To measure the amount of time the system is in idle, user and system mode, as well as the amount of free and available system memory.</p>"},{"location":"docs/events/builtin/syscalls/sysinfo/#example-use-case","title":"Example Use Case","text":"<p>A system administrator could use this system call to measure and monitor the performance of their system in real-time.</p>"},{"location":"docs/events/builtin/syscalls/sysinfo/#issues","title":"Issues","text":"<p>sysinfo() is subject to TOCTOU (time of check, time of use) vulnerabilities, so it is important to take appropriate precaution when using it.</p>"},{"location":"docs/events/builtin/syscalls/sysinfo/#related-events","title":"Related Events","text":"<ul> <li>sys_exit - when this event is triggered, sysinfo can be used to provide a more accurate picture of the system's current performance.</li> <li>sys_fork - this event allows the user to measure the number of active processes in the system.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/syslog/","title":"syslog","text":""},{"location":"docs/events/builtin/syscalls/syslog/#intro","title":"Intro","text":"<p>syslog - writes to system log.</p>"},{"location":"docs/events/builtin/syscalls/syslog/#description","title":"Description","text":"<p>The syslog() function allows the calling process to make a system logging request. It passes the message pointed to by bufp, of length len, to the appropriate logging utility. type is a priority value as described in syslog(3). </p> <p>Syslog is a convenient API to report system events. It is used in kernel and user space. However, no authentication or encryption is used and any user can access syslog, so it is insecure for sensitive and critical information.</p>"},{"location":"docs/events/builtin/syscalls/syslog/#arguments","title":"Arguments","text":"<ul> <li><code>type</code>:<code>int</code> - Type of message to log. </li> <li><code>bufp</code>:<code>char*</code>[U] - Pointer to the message to be written to syslog.</li> <li><code>len</code>:<code>int</code> - Length of message.</li> </ul>"},{"location":"docs/events/builtin/syscalls/syslog/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/syslog/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/syslog/#do_syslog","title":"do_syslog","text":""},{"location":"docs/events/builtin/syscalls/syslog/#type","title":"Type","text":"<p>Kprobe.</p>"},{"location":"docs/events/builtin/syscalls/syslog/#purpose","title":"Purpose","text":"<p>Monitors syscall execution and collects arguments given by the user.</p>"},{"location":"docs/events/builtin/syscalls/syslog/#example-use-case","title":"Example Use Case","text":"<p>Syslog can be used to log errors and warnings in applications. For example, if an application experiences an error, it may log this error to syslog so that it can be monitored and tracked.</p>"},{"location":"docs/events/builtin/syscalls/syslog/#issues","title":"Issues","text":"<p>User data can be easily accessed by any user since there is no authentication or encryption used, making it vulnerable to malicious users.</p>"},{"location":"docs/events/builtin/syscalls/syslog/#related-events","title":"Related Events","text":"<ul> <li>syslog_imageinit - Linking an image in the kernel for log reporting. </li> <li>syslog_device - Linking a syslog device for log reporting.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/tee/","title":"tee","text":""},{"location":"docs/events/builtin/syscalls/tee/#intro","title":"Intro","text":"<p>tee - duplicates data from one file descriptor to another</p>"},{"location":"docs/events/builtin/syscalls/tee/#description","title":"Description","text":"<p>The tee system call duplicates data from one file descriptor to another, useful for streaming data between different programs. Though the main operation is to copy a file descriptor to another, the flags argument allows different additional behavior in the write or read, like avoiding writes to blocking descriptors, or allocating new blocks for output. The len argument also allows control of the length of data to copy, instead of all data from input file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/tee/#arguments","title":"Arguments","text":"<ul> <li><code>fd_in</code>:<code>int</code>[U] - file descriptor for input</li> <li><code>fd_out</code>:<code>int</code>[K,U] - file descriptor for output</li> <li><code>len</code>:<code>size_t</code>[U] - length of data to be copied</li> <li><code>flags</code>:<code>unsigned int</code>[U, opt] - flags specified additional behavior like avoid writes to blocking descriptors or allocating new blocks for output</li> </ul>"},{"location":"docs/events/builtin/syscalls/tee/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/tee/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/tee/#sys_tee","title":"sys_tee","text":""},{"location":"docs/events/builtin/syscalls/tee/#type","title":"Type","text":"<p>Kprobe </p>"},{"location":"docs/events/builtin/syscalls/tee/#purpose","title":"Purpose","text":"<p>To capture data read and written to the kernel via tee.</p>"},{"location":"docs/events/builtin/syscalls/tee/#example-use-case","title":"Example Use Case","text":"<p>A network packet streaming application that needs to read from the network and write the same data to another program.</p>"},{"location":"docs/events/builtin/syscalls/tee/#issues","title":"Issues","text":"<p>On systems with non-uniform memory architecture, the write to user space may be unaligned and not fit on a page, leading to errors of EFAULT.</p>"},{"location":"docs/events/builtin/syscalls/tee/#related-events","title":"Related Events","text":"<ul> <li>write</li> <li>read</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/tgkill/","title":"tgkill","text":""},{"location":"docs/events/builtin/syscalls/tgkill/#intro","title":"Intro","text":"<p>tgkill - Sending a signal to a thread in another thread group.</p>"},{"location":"docs/events/builtin/syscalls/tgkill/#description","title":"Description","text":"<p>The tgkill syscall is used to send a signal to a thread in another thread group. It is the same as calling kill, but allows a thread to be targeted in another thread group, instead of needing to rely on a separate process. </p> <p>The tgkill syscall is useful for situations when thread-to-thread and thread-group-to-thread-group communications are needed, but when signaling would otherwise be too imprecise.</p> <p>The main disadvantage of tgkill is that it only works on two specific threads, not thread groups in general. This means it may be difficult to send a signal to all threads in another thread group.</p>"},{"location":"docs/events/builtin/syscalls/tgkill/#arguments","title":"Arguments","text":"<ul> <li><code>tgid</code>:<code>int</code> - The thread group identifier of the target process.</li> <li><code>tid</code>:<code>int</code> - The thread identifier of the target thread in the thread group.</li> <li><code>sig</code>:<code>int</code>[K] - The signal to be sent to the thread.</li> </ul>"},{"location":"docs/events/builtin/syscalls/tgkill/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/tgkill/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/tgkill/#do_tgkill","title":"do_tgkill","text":""},{"location":"docs/events/builtin/syscalls/tgkill/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/tgkill/#purpose","title":"Purpose","text":"<p>Hooked to do_tgkill to monitor when tgkill is executed, and the arguments it is called with.</p>"},{"location":"docs/events/builtin/syscalls/tgkill/#example-use-case","title":"Example Use Case","text":"<p>tgkill can be useful in situations where two threads need to communicate, but are in different thread groups. For example, if one thread is in a daemon thread group and another is in a user process thread group, tgkill can be used to signal between the two.</p>"},{"location":"docs/events/builtin/syscalls/tgkill/#issues","title":"Issues","text":"<p>None</p>"},{"location":"docs/events/builtin/syscalls/tgkill/#related-events","title":"Related Events","text":"<p>Signal events (such as kill) and thread management events (such as clone).</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/time/","title":"time","text":""},{"location":"docs/events/builtin/syscalls/time/#intro","title":"Intro","text":"<p>time - Get the current time in seconds since the Epoch</p>"},{"location":"docs/events/builtin/syscalls/time/#description","title":"Description","text":"<p>The <code>time</code> function is a system call which returns the number of seconds that have elapsed since 1970-01-01 00:00:00 UTC ( known as the Epoch). The return value is stored in the timespec pointed to by the argument <code>tloc</code>, which must be non-null.</p> <p>The <code>time</code>function is often used for basic performance timing in programs, as the time value can easily be compared to other time values. It is also useful for seed generation for random number generators, since it provides a unique value which is difficult to predict.</p> <p>However, the time returned by <code>time</code> is not necessarily monotonic. It can vary due to a variety of factors, such as discrepancies in hardware clocks, manual updates to the date/time, and daylight saving time adjustments. Therefore, <code>time</code> is not suitable for applications which require consistent, monotonic timing.</p>"},{"location":"docs/events/builtin/syscalls/time/#arguments","title":"Arguments","text":"<ul> <li><code>tloc</code>:<code>time_t*</code>[K] - Pointer to timespec structure in which the time should be stored.</li> </ul>"},{"location":"docs/events/builtin/syscalls/time/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/time/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/time/#time_1","title":"time","text":""},{"location":"docs/events/builtin/syscalls/time/#type","title":"Type","text":"<p>kprobes</p>"},{"location":"docs/events/builtin/syscalls/time/#purpose","title":"Purpose","text":"<p>The <code>time</code> function is used to get the current time since the Epoch. Hooking this function allows for monitoring of when the time is requested and may indicate a possible start of an attacker's activities.</p>"},{"location":"docs/events/builtin/syscalls/time/#example-use-case","title":"Example Use Case","text":"<p>This event can be used to monitor for suspicious timing in programs. For instance, if a program is consistently requesting the current time, this may indicate that the program is attempting to guess an unpredictable value, such as a seed for a random number generator.</p>"},{"location":"docs/events/builtin/syscalls/time/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/time/#related-events","title":"Related Events","text":"<ul> <li><code>gettimeofday</code> - Get the current time in milliseconds since the Epoch.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/timer_create/","title":"timer_create","text":""},{"location":"docs/events/builtin/syscalls/timer_create/#intro","title":"Intro","text":"<p>timer_create - creates a per-process timer </p>"},{"location":"docs/events/builtin/syscalls/timer_create/#description","title":"Description","text":"<p><code>timer_create()</code> is a system call used to create a per-process timer that sends a signal when it expires. It is a function that creates a timer with a specified clock (<code>CLOCK_REALTIME</code>, <code>CLOCK_MONOTONIC</code>, <code>CLOCK_PROCESS_CPUTIME_ID</code>, <code>CLOCK_THREAD_CPUTIME_ID</code>, <code>CLOCK_MONOTONIC_RAW</code>, <code>CLOCK_REALTIME_COARSE</code> and <code>CLOCK_MONOTONIC_COARSE</code>) and it accepts a <code>sigevent</code> structure that has information about the signal that will be sent when the timer is triggered. The timer ID is returned in the <code>timer_t</code> pointer that is one of the parameters of the syscall.</p> <p>The <code>timer_create()</code> syscall is useful for applications which need to be woken up at a particular time for a certain task. For example, a process can use <code>timer_create()</code> to cause a signal to be sent when a certain amount of time has passed.</p>"},{"location":"docs/events/builtin/syscalls/timer_create/#arguments","title":"Arguments","text":"<ul> <li><code>clockid</code>:<code>const clockid_t</code>[K] - identifier of the clock to be used (realtime, monotonic etc...)</li> <li><code>sevp</code>:<code>struct sigevent*</code>[KU] - pointer to sigevent structure which includes information about the signal that will be sent when the timer expires.</li> <li><code>timer_id</code>:<code>timer_t</code>[K] - pointer to the created timer\u00b4s ID.</li> </ul>"},{"location":"docs/events/builtin/syscalls/timer_create/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/timer_create/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/timer_create/#timer_create_1","title":"timer_create","text":""},{"location":"docs/events/builtin/syscalls/timer_create/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/timer_create/#purpose","title":"Purpose","text":"<p>Trigger events when timer_create is executed</p>"},{"location":"docs/events/builtin/syscalls/timer_create/#example-use-case","title":"Example Use Case","text":"<p>For example, timer_create is used to set up asynchronous events to trigger a signal after a certain amount of time. This can be used in applications that need a certain action to be performed at a certain time, such as scheduling a task or sending an alert to the user after a certain amount of time.</p>"},{"location":"docs/events/builtin/syscalls/timer_create/#issues","title":"Issues","text":"<p>The main problem with timer_create is that it is susceptible to Time of Check to Time of Use (TOCTOU) attacks. This means that the timer can be triggered before the desired time, thus allowing malicious actors to do their deed before the timer has expired.</p>"},{"location":"docs/events/builtin/syscalls/timer_create/#related-events","title":"Related Events","text":"<ul> <li><code>timer_settime()</code> - used to arm the timer created with <code>timer_create()</code>.</li> <li><code>timer_delete()</code> - used to delete a timer created with <code>timer_create()</code>.</li> <li><code>timer_gettime()</code> - used to get the remaining time of a timer created with <code>timer_create()</code>.</li> <li><code>timer_getoverrun()</code> - used to get the number of missed occurrences of the timer created with <code>timer_create()</code>.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/timer_delete/","title":"timer_delete","text":""},{"location":"docs/events/builtin/syscalls/timer_delete/#intro","title":"Intro","text":"<p>timer_delete - deletes previously created timer</p>"},{"location":"docs/events/builtin/syscalls/timer_delete/#description","title":"Description","text":"<p>timer_delete() deletes the specified timer, timer_id. The timer must have been  created by a previous call to timer_create(2) and must not have been already  deleted. The associated clock, allocated memory and timer overrun handlers are  all released. If a required underlying alarm request was issued to the real-time  clock, it is also canceled. After a successful timer_delete() call, the timer_t  value is invalid and should not be reused.</p>"},{"location":"docs/events/builtin/syscalls/timer_delete/#arguments","title":"Arguments","text":"<ul> <li><code>timer_id</code>:<code>timer_t</code>[K] - ID of the timer to be deleted.</li> </ul>"},{"location":"docs/events/builtin/syscalls/timer_delete/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/timer_delete/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/timer_delete/#timer_delete_1","title":"timer_delete","text":""},{"location":"docs/events/builtin/syscalls/timer_delete/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/timer_delete/#purpose","title":"Purpose","text":"<p>Investigate the performance of timer_delete system call.</p>"},{"location":"docs/events/builtin/syscalls/timer_delete/#example-use-case","title":"Example Use Case","text":"<p>timer_delete can be used to delete a timer, which was created by a previous  call to timer_create(2), in order to prevent it from expiring.</p>"},{"location":"docs/events/builtin/syscalls/timer_delete/#issues","title":"Issues","text":"<p>If a call to timer_delete() fails, the timer may be left in an undefined state,  which can cause the timer to be reused at a future point in time.</p>"},{"location":"docs/events/builtin/syscalls/timer_delete/#related-events","title":"Related Events","text":"<p>timer_create(2) - creates a timer, which can later be deleted by timer_delete().</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/timer_getoverrun/","title":"timer_getoverrun","text":""},{"location":"docs/events/builtin/syscalls/timer_getoverrun/#intro","title":"Intro","text":"<p>timer_getoverrun - returns an overrun count</p>"},{"location":"docs/events/builtin/syscalls/timer_getoverrun/#description","title":"Description","text":"<p>The timer_getoverrun function returns the overrun count for a specified timer. The overrun count is equal to the number of times the expiration callback was invoked since the last time the timer expired.</p> <p>The timer_getoverrun function works by reading the timer's state and therefore the overrun count may be stale by the time it is returned. If the timer is in the process of expiring, the overrun count may not agree with the actual overrun count since the expiration callback started running.</p>"},{"location":"docs/events/builtin/syscalls/timer_getoverrun/#arguments","title":"Arguments","text":"<ul> <li><code>timer_id</code>   : <code>timer_t</code> - identifier of the timer whose overrun count should be returned.</li> </ul>"},{"location":"docs/events/builtin/syscalls/timer_getoverrun/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/timer_getoverrun/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/timer_getoverrun/#sys_timer_getoverrun","title":"sys_timer_getoverrun","text":""},{"location":"docs/events/builtin/syscalls/timer_getoverrun/#type","title":"Type","text":"<p>KProbes</p>"},{"location":"docs/events/builtin/syscalls/timer_getoverrun/#purpose","title":"Purpose","text":"<p>Used to log the timer identifier and the overrun count.</p>"},{"location":"docs/events/builtin/syscalls/timer_getoverrun/#example-use-case","title":"Example Use Case","text":"<p>This event can be used to track the behavior of a timer and its overrun count over time.</p>"},{"location":"docs/events/builtin/syscalls/timer_getoverrun/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/timer_getoverrun/#related-events","title":"Related Events","text":"<ul> <li>timer_settime - used to set up the timer which will be tracked with timer_getoverrun.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/timer_gettime/","title":"timer_gettime","text":""},{"location":"docs/events/builtin/syscalls/timer_gettime/#intro","title":"Intro","text":"<p>timer_gettime - Get the current value of the timer specified by timerid.</p>"},{"location":"docs/events/builtin/syscalls/timer_gettime/#description","title":"Description","text":"<p>The timer_gettime() system call gets the current value of the timer specified by timerid. It stores the amount of time until the timer expires into the itimerspec pointed to by curr_value. Additional flags, like TIMER_ABSTIME may modify the behavior of this call by setting the reference from which the relative waiting time is calculated. If the timer is disarmed, the itimerspec is set to 0.</p>"},{"location":"docs/events/builtin/syscalls/timer_gettime/#arguments","title":"Arguments","text":"<ul> <li><code>timer_id</code>:<code>timer_t</code> - ID of timer to query.</li> <li><code>curr_value</code>:<code>struct itimerspec*</code>K[TOCTOU] - Pointer to a preallocated itimerspec structure, to which the timer's current value will be written.</li> </ul>"},{"location":"docs/events/builtin/syscalls/timer_gettime/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/timer_gettime/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/timer_gettime/#sys_timer_gettime","title":"sys_timer_gettime","text":""},{"location":"docs/events/builtin/syscalls/timer_gettime/#type","title":"Type","text":"<p>kprobe.</p>"},{"location":"docs/events/builtin/syscalls/timer_gettime/#purpose","title":"Purpose","text":"<p>To detect calls to timer_gettime() and to monitor the parameters passed to it.</p>"},{"location":"docs/events/builtin/syscalls/timer_gettime/#example-use-case","title":"Example Use Case","text":"<p>This event could be used to detect application calls to timer_gettime() and to gather additional data regarding the timer associated with this call. This data can be used for investigation or profiling purposes.</p>"},{"location":"docs/events/builtin/syscalls/timer_gettime/#issues","title":"Issues","text":"<p>No known issues at the moment.</p>"},{"location":"docs/events/builtin/syscalls/timer_gettime/#related-events","title":"Related Events","text":"<ul> <li>timer_create</li> <li>timer_settime</li> <li>timer_delete</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/timer_gettime32/","title":"timer_gettime32","text":""},{"location":"docs/events/builtin/syscalls/timer_gettime32/#intro","title":"Intro","text":"<p>timer_gettime32 - Gets a timer expiration and interval for a 32-bit specific timer</p>"},{"location":"docs/events/builtin/syscalls/timer_gettime32/#description","title":"Description","text":"<p>The timer_gettime32() system call gets the expiration and interval for the timer specified by <code>timer_id</code>. If <code>setting</code> is not NULL, the structure pointed to by <code>setting</code> is used to return the expiration and interval of the timer. The structure used is the 32-bit version of <code>itimerspec</code>: <code>struct old_itimerspec32</code>.</p> <p>This system call is specific to 32-bit architectures, and should not be used on 64-bit architectures, where the <code>timer_gettime</code> system call should be used instead.</p>"},{"location":"docs/events/builtin/syscalls/timer_gettime32/#arguments","title":"Arguments","text":"<ul> <li><code>timer_id</code>:<code>timer_t</code>[KU] - The timer for which the expiration and interval should be retrieved.</li> <li><code>setting</code>:<code>struct old_itimerspec32*</code>[KU] - A pointer to a <code>struct old_itimerspec32</code> structure. The expiration and interval will be stored in this structure.</li> </ul>"},{"location":"docs/events/builtin/syscalls/timer_gettime32/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it).</li> </ul>"},{"location":"docs/events/builtin/syscalls/timer_gettime32/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/timer_gettime32/#timer_gettime32_1","title":"timer_gettime32","text":""},{"location":"docs/events/builtin/syscalls/timer_gettime32/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/timer_gettime32/#purpose","title":"Purpose","text":"<p>The purpose of hooking this function is to gain visibility into the timer expiration and interval requested for a specific timer.</p>"},{"location":"docs/events/builtin/syscalls/timer_gettime32/#example-use-case","title":"Example Use Case","text":"<p>This event can be used to observe what timers are being used in a system. This can be used in conjunction with other tracepoints and events to answer questions such as what timers are the longest running, or when something is timed out.</p>"},{"location":"docs/events/builtin/syscalls/timer_gettime32/#issues","title":"Issues","text":"<p>This system call is specific to 32-bit Linux architectures and should not be used on 64-bit architectures.</p>"},{"location":"docs/events/builtin/syscalls/timer_gettime32/#related-events","title":"Related Events","text":"<ul> <li><code>timer_settime32</code> - Used to set a timer expiration and interval for a 32-bit specific timer</li> <li><code>timer_create</code> - Creates a timer with a given expiration and interval</li> <li><code>timer_delete</code> - Deletes a timer</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/timer_settime/","title":"timer_settime","text":""},{"location":"docs/events/builtin/syscalls/timer_settime/#intro","title":"Intro","text":"<p>timer_settime -  sets the timer referred to by timerid to the values specified in value</p>"},{"location":"docs/events/builtin/syscalls/timer_settime/#description","title":"Description","text":"<p>The timer_settime() function establishes the timer, timerid, to expire at the time specified by value. When the timer expires, the specific reasons for this expiration can be obtained by inspecting the value of the overrun argument. The timer can be one-shot or periodic. If a timer is re-established with timer_settime() while it is in a pending state, the time of the next expiration is reset.</p> <p>The flags argument is formed by ORing together one or more of the following flags: - TIMER_ABSTIME: use absolute value for setting timer. - TIMER_RELTIME: use relative value for setting timer.</p>"},{"location":"docs/events/builtin/syscalls/timer_settime/#arguments","title":"Arguments","text":"<ul> <li><code>timer_id</code>:<code>timer_t</code>[K] - Identifier of the timer.</li> <li><code>flags</code>:<code>int</code>[K] - flags for setting timer.</li> <li><code>new_value</code>:<code>const struct itimerspec*</code>[K] - struct of new relative or absolute values for setting timer.</li> <li><code>old_value</code>:<code>struct itimerspec*</code>[K, TOCTOU] - struct of old values.</li> </ul>"},{"location":"docs/events/builtin/syscalls/timer_settime/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/timer_settime/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/timer_settime/#sys_timer_settime","title":"sys_timer_settime","text":""},{"location":"docs/events/builtin/syscalls/timer_settime/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/timer_settime/#purpose","title":"Purpose","text":"<p>To monitor the arguments and parameters of the timer_settime syscall</p>"},{"location":"docs/events/builtin/syscalls/timer_settime/#__do_timer_settime","title":"__do_timer_settime","text":""},{"location":"docs/events/builtin/syscalls/timer_settime/#type_1","title":"Type","text":"<p>Jprobes</p>"},{"location":"docs/events/builtin/syscalls/timer_settime/#purpose_1","title":"Purpose","text":"<p>To intercept completed syscalls and inspect the return value of the timer_settime syscall</p>"},{"location":"docs/events/builtin/syscalls/timer_settime/#example-use-case","title":"Example Use Case","text":"<p>timer_settime is typically used in applications to set a timer that will trigger a callback when it elapses. The callback can be used to execute periodic tasks or to perform timeouts.</p>"},{"location":"docs/events/builtin/syscalls/timer_settime/#issues","title":"Issues","text":"<p>At the time of writing, timer_settime is vulnerable to a TOCTOU race condition. Since the argument <code>old_value</code> is passed as non-const, and the value of old_value might change between the time it is checked and the time it is used.</p>"},{"location":"docs/events/builtin/syscalls/timer_settime/#related-events","title":"Related Events","text":"<ul> <li>timer_create</li> <li>timer_gettime</li> <li>timer_getoverrun</li> <li>timer_delete</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/timer_settime32/","title":"timer_settime32","text":""},{"location":"docs/events/builtin/syscalls/timer_settime32/#intro","title":"Intro","text":"<p>timer_settime32 - Sets the time of an interval timer</p>"},{"location":"docs/events/builtin/syscalls/timer_settime32/#description","title":"Description","text":"<p>timer_settime32 is used to set the time of an interval timer, based on the <code>timer_id</code>, to a new value stored in the <code>new</code> argument. The timer will be reset to <code>new</code> after the timer expires. The <code>flags</code> argument can be passed to determine how the timer behaves when it expires. The previous timer value is stored in the <code>old</code> argument.</p> <p>Whenever the timer expires, the timer value is reset to <code>new</code> and the associated signal is sent to the process specified when the timer was set.</p> <p>One advantage of using this system call is that the interval timer is reset automatically each time it expires, which eliminates the cost of checking the timer value and resetting it each time.</p> <p>However, one disadvantage is that the timer does not halt when a signal is sent to the process, as the timer will still reset.</p>"},{"location":"docs/events/builtin/syscalls/timer_settime32/#arguments","title":"Arguments","text":"<ul> <li><code>timer_id</code>:<code>timer_t</code>[K] - Timer identifier</li> <li><code>flags</code>:<code>int</code>[K] - Flags to determine timer behavior</li> <li><code>new</code>:<code>struct old_itimerspec32*</code>[K, U] - Pointer to new timer value</li> <li><code>old</code>:<code>struct old_itimerspec32*</code>[K, U, TOCTOU, OPT] - Pointer to old timer value.</li> </ul>"},{"location":"docs/events/builtin/syscalls/timer_settime32/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/timer_settime32/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/timer_settime32/#do_timer_settime","title":"do_timer_settime","text":""},{"location":"docs/events/builtin/syscalls/timer_settime32/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/timer_settime32/#purpose","title":"Purpose","text":"<p>Hooking this function can be used to gain information about the context in which a timer is being set.</p>"},{"location":"docs/events/builtin/syscalls/timer_settime32/#lock_timer_base","title":"lock_timer_base","text":""},{"location":"docs/events/builtin/syscalls/timer_settime32/#type_1","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/timer_settime32/#purpose_1","title":"Purpose","text":"<p>Hooking this function can be used to gain information about the context in which a timer is being set or modified.</p>"},{"location":"docs/events/builtin/syscalls/timer_settime32/#example-use-case","title":"Example Use Case","text":"<p>This system call can be used to track when a certain program takes longer than expected to execute, as well as track other events that may occur periodically.</p>"},{"location":"docs/events/builtin/syscalls/timer_settime32/#issues","title":"Issues","text":"<p>One issue with timer_settime32 is that the time may not be as accurate as desired, as the operating system may adjust times to conserve system resources.</p>"},{"location":"docs/events/builtin/syscalls/timer_settime32/#related-events","title":"Related Events","text":"<p>The related events to timer_settime32 are timer_gettime32, timer_delete and timer_create.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_create/","title":"timerfd_create","text":""},{"location":"docs/events/builtin/syscalls/timerfd_create/#intro","title":"Intro","text":"<p>timerfd_create - creates a file descriptor for use with the timerfd routines.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_create/#description","title":"Description","text":"<p>The timerfd_create() system call creates a new timer object and returns a file descriptor that refers to it. The clockid argument specifies the clock that is used to mark the progress of the timer. The flags argument specifies optional creation flags; currently only TFD_CLOEXEC is supported.</p> <p>Once created, the file descriptor can be used to wait for the expiration of the timer using read(), select(), or poll().</p>"},{"location":"docs/events/builtin/syscalls/timerfd_create/#arguments","title":"Arguments","text":"<ul> <li><code>clockid</code>:<code>int</code> - specifies the clock that is used to mark the progress of the timer.</li> <li><code>flags</code>:<code>int</code>[OPT] - specifies optional creation flags; currently only TFD_CLOEXEC is supported.</li> </ul>"},{"location":"docs/events/builtin/syscalls/timerfd_create/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/timerfd_create/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/timerfd_create/#sys_timerfd_create","title":"sys_timerfd_create","text":""},{"location":"docs/events/builtin/syscalls/timerfd_create/#type","title":"Type","text":"<p>KProbe</p>"},{"location":"docs/events/builtin/syscalls/timerfd_create/#purpose","title":"Purpose","text":"<p>To hook the kernel entry point for the timerfd_create system call.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_create/#example-use-case","title":"Example Use Case","text":"<p>A process that needs to track time at the system level could use this event to create a file descriptor for a timer and use that to track time in the process.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_create/#issues","title":"Issues","text":"<p>No known issues.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_create/#related-events","title":"Related Events","text":"<p>timerfd_settime, timerfd_gettime</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_gettime/","title":"timerfd_gettime","text":""},{"location":"docs/events/builtin/syscalls/timerfd_gettime/#intro","title":"Intro","text":"<p>timerfd_gettime() - get the expiration(s) of a timer created with timerfd.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_gettime/#description","title":"Description","text":"<p>The timerfd_gettime() system call retrieves the current value of a timer created by the timerfd_create() system call. It stores the expiration(s) in the given structure pointed to by the <code>curr_value</code> argument. The <code>fd</code> argument should be a file descriptor that refers to the timer.</p> <p>This event might be useful to retrieve the expiration values of a given timer in order to get insight into the state of the timer at any given time. One potential edge-case is that the given <code>fd</code> argument does not refer to a timer, in which case an error will be returned.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_gettime/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - file descriptor crated by the timerfd_create() system call.</li> <li><code>curr_value</code>:<code>struct itimerspec*</code>[U] - pointer to the struct itimerspec which will hold the current and/or next expiration(s) of the timer.</li> </ul>"},{"location":"docs/events/builtin/syscalls/timerfd_gettime/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/timerfd_gettime/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/timerfd_gettime/#timer_refresh","title":"timer_refresh()","text":""},{"location":"docs/events/builtin/syscalls/timerfd_gettime/#type","title":"Type","text":"<p>Function probe.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_gettime/#purpose","title":"Purpose","text":"<p>The timer_refresh() is hooked to check that the expiry times are up to date and to act accordingly, like set the next expiry time.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_gettime/#timer_del","title":"timer_del()","text":""},{"location":"docs/events/builtin/syscalls/timerfd_gettime/#type_1","title":"Type","text":"<p>Kretprobes - return probes.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_gettime/#purpose_1","title":"Purpose","text":"<p>The timer_del() is hooked to detect when a timer has been deleted and to free the related data.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_gettime/#example-use-case","title":"Example Use Case","text":"<p>The timerfd_gettime() system call can be used to retrieve the expiration values of a timer in order to, for example, display a progress indicator or monitor how close a timer is to expiring.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_gettime/#issues","title":"Issues","text":"<p>Currently, no issues with this event have been identified.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_gettime/#related-events","title":"Related Events","text":"<p>timerfd_create() - create a timer, timerfd_settime() - set expiration values for a timer, timerfd_gettime() - get the expiration(s) of a timer.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_gettime32/","title":"timerfd_gettime32","text":""},{"location":"docs/events/builtin/syscalls/timerfd_gettime32/#intro","title":"Intro","text":"<p>timerfd_gettime32 -  Return the current value of the timer referenced by the file descriptor ufd.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_gettime32/#description","title":"Description","text":"<p>The timerfd_gettime32() system call returns the current value of the timer referenced by the file descriptor ufd into the buffer pointed to by the otmr argument. It is intended to replace the use of the obsolete timer_gettime(2) system call.</p> <p>The timerfd_gettime32() system call supports both absolute (based on calendar time) and relative (based on process start time) timers and is unaffected by changes in the system time (see adjtime(2)).</p> <p>The buffer otmr argument used in timerfd_gettime32 is used to return an old-style itimerspec structure, that is:</p> <pre><code>struct old_itimerspec32 {\nstruct old_timespec32 it_interval;  /* Timer period */\nstruct old_timespec32 it_value;     /* Timer expiration */\n};\n</code></pre> <p>Advantages of using timerfd_gettime32() is that it provides a mechanism for atomically retrieving the timer's current value, as well as providing relative/absolute timers and being unaffected by changes in system time.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_gettime32/#arguments","title":"Arguments","text":"<ul> <li><code>ufd</code>:<code>int</code> - A file descriptor that refers to a timer created via timerfd_create(2).</li> <li><code>otmr</code>:<code>struct old_itimerspec32*</code> - Pointer to a struct old_itimerspec32 object which will be used to return the timer's current value.</li> </ul>"},{"location":"docs/events/builtin/syscalls/timerfd_gettime32/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/timerfd_gettime32/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/timerfd_gettime32/#sys_timerfd_gettime32","title":"sys_timerfd_gettime32","text":""},{"location":"docs/events/builtin/syscalls/timerfd_gettime32/#type","title":"Type","text":"<p>probes</p>"},{"location":"docs/events/builtin/syscalls/timerfd_gettime32/#purpose","title":"Purpose","text":"<p>To measure the execution time of the timerfd_gettime32 system call.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_gettime32/#example-use-case","title":"Example Use Case","text":"<p>The timerfd_gettime32 system call might be used in an application to retrieve the current value of a timer that was created via the timerfd_create(2) system call for use with a signal handler.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_gettime32/#issues","title":"Issues","text":"<p>There is currently no known issue associated with the timerfd_gettime32 system call.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_gettime32/#related-events","title":"Related Events","text":"<ul> <li>timerfd_create(2)</li> <li>timerfd_settime32(2)</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_settime/","title":"timerfd_settime","text":""},{"location":"docs/events/builtin/syscalls/timerfd_settime/#intro","title":"Intro","text":"<p>timerfd_settime - set the expiration and interval of an installed timer</p>"},{"location":"docs/events/builtin/syscalls/timerfd_settime/#description","title":"Description","text":"<p>The timerfd_settime() system call arms (starts) or disarms (stops) the timer referred to by the file descriptor <code>fd</code>. It does this by setting the timer's expiration and interval according to the values specified in the <code>struct itimerspec</code> pointed to by the <code>new_value</code> argument. If the <code>old_value</code> argument is non-NULL, then the previous <code>struct itimerspec</code> is returned in this location. This syscall also allows the user to specify the <code>TFD_TIMER_ABSTIME</code> descriptor to indicate that <code>new_value-&gt;it_value</code> is evaluated relative to the CLOCK_REALTIME clock.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_settime/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>: <code>int</code> - file descriptor referring to the timer instance.</li> <li><code>flags</code>: <code>int</code> - flags specifying the behavior of the timer. Flags: <code>TFD_TIMER_ABSTIME</code></li> <li><code>new_value</code>: <code>const struct itimerspec*</code> [K] - pointer to the new timer value.</li> <li><code>old_value</code>: <code>struct itimerspec*</code> [K] - pointer to the previous timer value</li> </ul>"},{"location":"docs/events/builtin/syscalls/timerfd_settime/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/timerfd_settime/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/timerfd_settime/#sys_timerfd_settime","title":"<code>sys_timerfd_settime</code>","text":""},{"location":"docs/events/builtin/syscalls/timerfd_settime/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/timerfd_settime/#purpose","title":"Purpose","text":"<p>To monitor the duration of timerfd_settime system calls.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_settime/#example-use-case","title":"Example Use Case","text":"<p>This event can be used for monitoring a timer. For example, it can be used to record the time at which an application sets a timer.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_settime/#issues","title":"Issues","text":"<p>None known.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_settime/#related-events","title":"Related Events","text":"<ul> <li><code>timerfd_gettime</code> - read the timer expiration and interval</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_settime32/","title":"timerfd_settime32","text":""},{"location":"docs/events/builtin/syscalls/timerfd_settime32/#intro","title":"Intro","text":"<p>timerfd_settime32 - sets or reads the expiration and interval settings of a timer created by <code>timerfd_create3</code></p>"},{"location":"docs/events/builtin/syscalls/timerfd_settime32/#description","title":"Description","text":"<p>This syscall is used to set or read the expiration and interval settings of a timer created by <code>timerfd_create3</code>, a timer that is awoken when a time elapses until the timer is reset with a new expiration time. This syscall is called with two pointers to struct <code>old_itimerspec32</code> objects, <code>utmr</code> and <code>otmr</code>, which store the values of the timer both before and after it being set. A <code>ufd</code> and <code>flags</code> are also passed to the function, <code>ufd</code> corresponding to the file descriptor associated to the timer, and <code>flags</code>, an options field.</p> <p>One advantage of using this syscall is that it provides an easy (and fast) way of setting and managing a timer. It is particularly handy when used with a <code>CLOCK_MONOTONIC</code> clock, since it will neither gain nor lose time. On top of that, timers set with <code>timerfd_settime</code> will never expire earlier than its intended time, which can be quite useful when working with time-sensitive tasks.</p> <p>One drawback is that if Linux kernel is modified with a newer version of it, applications need to be recompiled against newer version in order for <code>timerfd_settime32</code> to be used properly.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_settime32/#arguments","title":"Arguments","text":"<ul> <li><code>ufd</code>: <code>int</code> - The file descriptor associated with the timer.</li> <li><code>flags</code>: <code>int</code> - Option flags to indicate whether the new settings are affected at expiration or after current expiration.</li> <li><code>utmr</code>: <code>struct old_itimerspec32*</code> - Pointer to a <code>struct old_itimerspec32</code> object defining the new timer settings.</li> <li><code>otmr</code>: <code>struct old_itimerspec32*</code>[OPT] - Pointer to a <code>struct old_itimerspec32</code> object where the previous settings of the timer are stored.</li> </ul>"},{"location":"docs/events/builtin/syscalls/timerfd_settime32/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/timerfd_settime32/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/timerfd_settime32/#timerfd_settime32_1","title":"timerfd_settime32","text":""},{"location":"docs/events/builtin/syscalls/timerfd_settime32/#type","title":"Type","text":"<p>kprobe + nop</p>"},{"location":"docs/events/builtin/syscalls/timerfd_settime32/#purpose","title":"Purpose","text":"<p>To trace the syscall timerfd_settime32 with the intention of monitoring when the timer is set and gather information about the duration of time for which the user is expecting the timer to expire.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_settime32/#example-use-case","title":"Example Use Case","text":"<p>One example use case for this syscall is when we need to keep track of time needed for certain tasks. This can be particularly useful when we are doing performance analysis, as we can use this to check which operations are taking more time.</p> <p>For example, we can measure how much time it takes to perform a certain task by setting a timer with this funciton and checking how much time it takes for the timer to expire.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_settime32/#issues","title":"Issues","text":"<p>One common issue with using timerfd_settime32 is that we are relying on the accuracy of the system timer. In a system with an unstable clock, maybe due to scheduling, this could cause our timer to expire earlier or later than it is supposed to.</p>"},{"location":"docs/events/builtin/syscalls/timerfd_settime32/#related-events","title":"Related Events","text":"<ul> <li><code>timerfd_create3</code>: Used to create the timer associated with <code>timerfd_settime32</code>.</li> <li><code>epoll_wait</code>: Used to wait for timers to expire. </li> <li><code>timer_gettime</code>: Used to access or alter the timer's expiration settings.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/times/","title":"times","text":""},{"location":"docs/events/builtin/syscalls/times/#intro","title":"Intro","text":"<p>times - Get process and child process times</p>"},{"location":"docs/events/builtin/syscalls/times/#description","title":"Description","text":"<p>The <code>times()</code> syscall retrieves the running times of the current process and of given child processes. Upon successful completion, the <code>buf</code> argument, if it is not NULL, is filled with an array of <code>struct tms</code> values.</p> <p>A <code>struct tms</code> value has the following form:</p> <pre><code>struct tms {\nclock_t tms_utime; // user time\nclock_t tms_stime; // system time\nclock_t tms_cutime; // user time of process and child processes\nclock_t tms_cstime; // system time of process and child processes\n};\n</code></pre> <p>The <code>clock_t</code> type is an arithmetic type which is capable of representing times.</p> <p>This syscall is useful for profiling applications or to measure their running time. It can also be used to get an idea of the time a process and its children spent in user and system mode.</p>"},{"location":"docs/events/builtin/syscalls/times/#arguments","title":"Arguments","text":"<ul> <li><code>buf</code>:<code>struct tms*</code>[U] - Pointer to a <code>struct tms</code>, filled with an array of <code>struct tms</code> values upon successful completion.</li> </ul>"},{"location":"docs/events/builtin/syscalls/times/#available-tags","title":"Available Tags","text":"<ul> <li>U - Originated from user space (Pointer to user space memory used to get it).</li> </ul>"},{"location":"docs/events/builtin/syscalls/times/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/times/#sys_times","title":"sys_times","text":""},{"location":"docs/events/builtin/syscalls/times/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/times/#purpose","title":"Purpose","text":"<p>Hooked to record timing information for the <code>times()</code> syscall.</p>"},{"location":"docs/events/builtin/syscalls/times/#example-use-case","title":"Example Use Case","text":"<p>The <code>times()</code> syscall can be used in the following example to get more insight into a process and child processes running times:</p> <pre><code>struct tms t;\n\nif (times(&amp;t) != -1) {\nprintf(\"User time of this process: %lld ms\\n\", t.tms_utime * MSEC_PER_SEC);\nprintf(\"System time of this process: %lld ms\\n\", t.tms_stime * MSEC_PER_SEC);\nprintf(\"User time of this process and its childrens: %lld ms\\n\", t.tms_cutime * MSEC_PER_SEC);\nprintf(\"System time of this process and its childrens: %lld ms\\n\", t.tms_cstime * MSEC_PER_SEC);\n}\n</code></pre>"},{"location":"docs/events/builtin/syscalls/times/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/times/#related-events","title":"Related Events","text":"<ul> <li><code>execve()</code> - execute a program</li> <li><code>clone()</code> - create a child process</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/tkill/","title":"tkill","text":""},{"location":"docs/events/builtin/syscalls/tkill/#intro","title":"Intro","text":"<p>tkill - send a signal to a specified process or thread</p>"},{"location":"docs/events/builtin/syscalls/tkill/#description","title":"Description","text":"<p>The tkill() system call sends the signal <code>sig</code> to the thread <code>tid</code>. The thread <code>tid</code> has to be a thread of the calling process. The tkill() system call is a more specific alternative to kill(2).</p> <p>When the signal is delivered, it is as if signal() had been called with the signal number <code>sig</code> and the argument siginfo_t* set to NULL from within the thread <code>tid</code>. Note that software support for thread-directed signals has been removed from the kernel.</p> <p>The <code>tkill()</code> system call differs from tkill() in that <code>tkill()</code> behaves as <code>kill()</code> does, in that it does not set errno if the process or process group does not exist. Note that regardless of the signal number sent, no signals shall be generated when sending a signal to a nonexistent process or process group.</p>"},{"location":"docs/events/builtin/syscalls/tkill/#arguments","title":"Arguments","text":"<ul> <li><code>tid</code>:<code>int</code>[K] - The thread ID of the thread to be signaled.</li> <li><code>sig</code>:<code>int</code>[K] - The signal number passed to the thread.</li> </ul>"},{"location":"docs/events/builtin/syscalls/tkill/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/tkill/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/tkill/#tkill_1","title":"tkill","text":""},{"location":"docs/events/builtin/syscalls/tkill/#type","title":"Type","text":"<p>Kprobes </p>"},{"location":"docs/events/builtin/syscalls/tkill/#purpose","title":"Purpose","text":"<p>To gather information on system calls called by the thread.</p>"},{"location":"docs/events/builtin/syscalls/tkill/#example-use-case","title":"Example Use Case","text":"<p>tkill() is most commonly used to kill threads that are stuck or have gone into an unexpected state.</p>"},{"location":"docs/events/builtin/syscalls/tkill/#issues","title":"Issues","text":"<p>The tkill() system call is not always successful in delivering the signal, so it is necessary to use a signal-safe system call such as rt_sigqueueinfo() to ensure that the signal is delivered.</p>"},{"location":"docs/events/builtin/syscalls/tkill/#related-events","title":"Related Events","text":"<ul> <li>signal()</li> <li>kill()</li> <li>tkill()</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/truncate/","title":"truncate","text":""},{"location":"docs/events/builtin/syscalls/truncate/#intro","title":"Intro","text":"<p>truncate - Change the size of a file to a specified length</p>"},{"location":"docs/events/builtin/syscalls/truncate/#description","title":"Description","text":"<p>The truncate() system call causes the regular file referenced by path or referenced by the file descriptor fd to have a size of exactly length bytes.</p> <p>If the file previously was larger than length, the extra data is discarded.  If the file was previously shorter, it is extended, and the extended part reads as null bytes (\u2018\\0\u2019).</p>"},{"location":"docs/events/builtin/syscalls/truncate/#arguments","title":"Arguments","text":"<ul> <li><code>path</code>:<code>const char*</code>[U] - The path of the file to be truncated.</li> <li><code>length</code>:<code>off_t</code>[K] - The length of the file.</li> </ul>"},{"location":"docs/events/builtin/syscalls/truncate/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/truncate/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/truncate/#sys_truncate","title":"sys_truncate","text":""},{"location":"docs/events/builtin/syscalls/truncate/#type","title":"Type","text":"<p>KPROBE</p>"},{"location":"docs/events/builtin/syscalls/truncate/#purpose","title":"Purpose","text":"<p>sys_truncate is hooked to gather information about a regular file being truncated.</p>"},{"location":"docs/events/builtin/syscalls/truncate/#example-use-case","title":"Example Use Case","text":"<p>Truncate can be used to reduce the size of a file, with the extra data being discarded if it is longer than the specified length.</p>"},{"location":"docs/events/builtin/syscalls/truncate/#issues","title":"Issues","text":"<p>If the length specified is longer than the actual size of the file, security issues may arise if the file is allocated and filled with data afterwards.</p>"},{"location":"docs/events/builtin/syscalls/truncate/#related-events","title":"Related Events","text":"<p>fchmodat, creat, ftruncate</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/truncate64/","title":"truncate64","text":""},{"location":"docs/events/builtin/syscalls/truncate64/#intro","title":"Intro","text":"<p>truncate64() - truncate a file to a specified length</p>"},{"location":"docs/events/builtin/syscalls/truncate64/#description","title":"Description","text":"<p>The truncate64() system call is used to truncate a file to a specified length.  If the file is larger than the length specified, the extra data is lost. If the file is shorter than the length specified, the file will be extended with NUL bytes (<code>\\0</code>). The truncate64() system call operates on files, not directories.</p>"},{"location":"docs/events/builtin/syscalls/truncate64/#arguments","title":"Arguments","text":"<ul> <li><code>path</code>:<code>const char*</code> - pathname of the file whose length is to be changed</li> <li><code>length</code>:<code>off_t</code> - size to which the file should be truncated</li> </ul>"},{"location":"docs/events/builtin/syscalls/truncate64/#available-tags","title":"Available Tags","text":"<p>N/A</p>"},{"location":"docs/events/builtin/syscalls/truncate64/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/truncate64/#sys_truncate64","title":"sys_truncate64","text":""},{"location":"docs/events/builtin/syscalls/truncate64/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/truncate64/#purpose","title":"Purpose","text":"<p>To detect when the <code>truncate64</code> system call is called</p>"},{"location":"docs/events/builtin/syscalls/truncate64/#example-use-case","title":"Example Use Case","text":"<p>truncate64() can be used to ensure that a certain file does not exceed a certain size. For example, it can be used to ensure a log file does not exceed 1GB in size.</p>"},{"location":"docs/events/builtin/syscalls/truncate64/#issues","title":"Issues","text":"<p>The truncate64() system call does not check if the current user has the necessary permissions to truncate the file, this must be done manually.</p>"},{"location":"docs/events/builtin/syscalls/truncate64/#related-events","title":"Related Events","text":"<ul> <li>open() - to open a file handle before truncating it</li> <li>ftruncate64() - similar system call, but which operates on an open file descriptor</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/tuxcall/","title":"tuxcall","text":""},{"location":"docs/events/builtin/syscalls/tuxcall/#intro","title":"Intro","text":"<p>tuxcall - handle requests from userspace, typically IOCTL calls</p>"},{"location":"docs/events/builtin/syscalls/tuxcall/#description","title":"Description","text":"<p>tuxcall is a way for programs running in userspace to make requests to the kernel. It is typically used to control devices and configure hardware. The kernel will check the associated data structures and privileges and then process the request and return a response to the user program. The drawbacks of using tuxcall are that it can be complex and time-consuming to debug and debug when using multiple threads and ioctls.</p>"},{"location":"docs/events/builtin/syscalls/tuxcall/#arguments","title":"Arguments","text":"<ul> <li><code>cmd</code>: <code>int</code>[K] - defines the command to be executed. </li> <li><code>arg</code>: <code>void *</code>[K] - a void pointer to a data structure associated with the command. </li> </ul>"},{"location":"docs/events/builtin/syscalls/tuxcall/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/tuxcall/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/tuxcall/#syscall_entry_tuxcall","title":"syscall_entry_tuxcall","text":""},{"location":"docs/events/builtin/syscalls/tuxcall/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/tuxcall/#purpose","title":"Purpose","text":"<p>To trace tuxcall system calls</p>"},{"location":"docs/events/builtin/syscalls/tuxcall/#example-use-case","title":"Example Use Case","text":"<p>A program running in user space is using tuxcall to configure a device. It will pass the relevant data structures and arguments to the kernel via the tuxcall syscall and wait for a response. </p>"},{"location":"docs/events/builtin/syscalls/tuxcall/#issues","title":"Issues","text":"<p>One of the major issues with tuxcall is that it can be difficult to debug when errors occur due to the complexity of the system. </p>"},{"location":"docs/events/builtin/syscalls/tuxcall/#related-events","title":"Related Events","text":"<ul> <li>ioctl - performs io control operations </li> <li>read - read data from a file descriptor</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/ulimit/","title":"ulimit","text":""},{"location":"docs/events/builtin/syscalls/ulimit/#intro","title":"Intro","text":"<p>ulimit - set or get the resource limit of the current process</p>"},{"location":"docs/events/builtin/syscalls/ulimit/#description","title":"Description","text":"<p>ulimit is a command provides control over the resourcing of a process. The ulimit command can be used to set the limits on the system resources that can be used by the process. The limits can be set for any of the following that the system supports: files, memory, number of processes, maximum CPU time, and more. With some limits, ulimit also has the ability to query the current limit. </p> <p>Ulimit can be used to protect systems from resource abuse by allowing users to put an upper limit on the amount of certain resources they can allocate to their processes. This ensures that runaway processes or user abuse of resources is avoided. </p>"},{"location":"docs/events/builtin/syscalls/ulimit/#arguments","title":"Arguments","text":"<ul> <li><code>resource</code>:<code>int</code>[K,U] - the resource to use.</li> <li><code>limit</code>:<code>string</code>[K,U] - the new resource limit. Can be a number, 'hard' or 'soft'.</li> </ul>"},{"location":"docs/events/builtin/syscalls/ulimit/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/ulimit/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/ulimit/#do_ulimit","title":"do_ulimit","text":""},{"location":"docs/events/builtin/syscalls/ulimit/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/ulimit/#purpose","title":"Purpose","text":"<p>to monitor the resource limit of the current process.</p>"},{"location":"docs/events/builtin/syscalls/ulimit/#example-use-case","title":"Example Use Case","text":"<p>Ulimit can be used to guard against an individual user or process from going wild and consuming too much resources by putting a limit on the resources that can be used.</p>"},{"location":"docs/events/builtin/syscalls/ulimit/#issues","title":"Issues","text":"<p>Ulimit might not be available in all systems, so it is important to check what the supported resources are before using it.</p>"},{"location":"docs/events/builtin/syscalls/ulimit/#related-events","title":"Related Events","text":"<p>setrlimit</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/umask/","title":"umask","text":""},{"location":"docs/events/builtin/syscalls/umask/#intro","title":"Intro","text":"<p>umask - set file mode creation mask</p>"},{"location":"docs/events/builtin/syscalls/umask/#description","title":"Description","text":"<p>The umask system call sets the calling process's file mode creation mask (umask) to <code>mask</code> and returns the previous value of the mask. The umask is used to determine the file permission bits of newly created files. A process calls umask before creating new files and directories with the intention that files will be created with the specified mode. The mode argument is bitwise-ANDed with the complement of the file mode creation mask of the process (as returned by a call to umask) to turn off specified bits in the file permission, thus restricting the permissions of newly-created files.</p> <p>UMask is designed to be used in a secure way to ensure that no unintended consequences arise due to unexpected permissions. It should not be used to relax constraints. Allowing a process to execute arbitrary external code with arbitrary permissions is a security risk.</p>"},{"location":"docs/events/builtin/syscalls/umask/#arguments","title":"Arguments","text":"<ul> <li><code>mask</code>:<code>mode_t</code>[K] - The new file mode creation mask, or 0 for no change. The bit pattern of the mask is CNMSFU, where S is the set-user-ID and F is the set-group-ID permission bit.</li> </ul>"},{"location":"docs/events/builtin/syscalls/umask/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/umask/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/umask/#sys_umask","title":"sys_umask","text":""},{"location":"docs/events/builtin/syscalls/umask/#type","title":"Type","text":"<p>Tracepoint.</p>"},{"location":"docs/events/builtin/syscalls/umask/#purpose","title":"Purpose","text":"<p>Tracking the umask modifications of a process over time.</p>"},{"location":"docs/events/builtin/syscalls/umask/#example-use-case","title":"Example Use Case","text":"<p>Umask can be used to monitor changes to the file mode creation mask of a process. It can be used to ensure that the process is only setting the file mode creation mask to pre-defined values, and that no unintended consequences arise due to unexpected permissions.</p>"},{"location":"docs/events/builtin/syscalls/umask/#issues","title":"Issues","text":"<p>Using umask to relax constraints can be a security risk. Allowing a process to execute arbitrary external code with arbitrary permissions is a breach of security.</p>"},{"location":"docs/events/builtin/syscalls/umask/#related-events","title":"Related Events","text":"<ul> <li>chmod() - used to change the permission of a file or directory.</li> <li>stat() - used to get the file mode of a file or directory.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/umount/","title":"umount","text":""},{"location":"docs/events/builtin/syscalls/umount/#intro","title":"Intro","text":"<p>umount - Unmount file systems on linux</p>"},{"location":"docs/events/builtin/syscalls/umount/#description","title":"Description","text":"<p>The umount function is used to unmount a given file system from the specified target on linux. This is done by issuing a request to the virtual file system to detach the file system as well as any associated mount points. Umount can also be used to unmount all mount points in a given target. Note that unmounting a filesystem removes the filesystem from both user and kernel spaces, so it is important to first ensure that nothing in user space is actively using the filesystem.</p> <p>There are some edge cases to consider when using umount. For example, the \"lazy unmount\" option can be used to prevent processes from being impacted by an unmount event by keeping them alive until the next time they try to access the filesystem. However, if the filesystem is mounted with a read-only flag, the lazy unmount will not be applied as the processes should be able to keep running despite the filesystem being unmounted.</p>"},{"location":"docs/events/builtin/syscalls/umount/#arguments","title":"Arguments","text":"<ul> <li><code>target</code>:<code>const char*</code> - Pathname of the block special device or directory to be unmounted.</li> </ul>"},{"location":"docs/events/builtin/syscalls/umount/#available-tags","title":"Available Tags","text":"<ul> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/umount/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/umount/#sys_umount","title":"sys_umount","text":""},{"location":"docs/events/builtin/syscalls/umount/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/umount/#purpose","title":"Purpose","text":"<p>Hooking the sys_umount function is used to gather information about filesystem usage by monitoring both the entry and exit of any umount call.</p>"},{"location":"docs/events/builtin/syscalls/umount/#example-use-case","title":"Example Use Case","text":"<p>One common use case might be monitoring the usage of a given filesystem. When an unmount is requested, this event would be triggered with the corresponding arguments. Analysing this data could be helpful to track usage patterns, or troubleshoot issues with the unmount operation.</p>"},{"location":"docs/events/builtin/syscalls/umount/#issues","title":"Issues","text":"<p>If umount is issued with no target specified, it will try to unmount all mount points, which could have unintended effects on the system. It may be a good idea to have monitoring systems in place to detect in case it is used in this manner.</p>"},{"location":"docs/events/builtin/syscalls/umount/#related-events","title":"Related Events","text":"<ul> <li>mount</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/umount2/","title":"umount2","text":""},{"location":"docs/events/builtin/syscalls/umount2/#intro","title":"Intro","text":"<p>umount2 - system call used to unmount a filesystem.</p>"},{"location":"docs/events/builtin/syscalls/umount2/#description","title":"Description","text":"<p>The umount2() system call is used to unmount a filesystem from the target directory. It requires the mountpoint directory and an additional set of flags to indicate if the umount should be cascaded or not. The usefulness of this system call is that it allows for more control in the filesystem, allowing a more fine grain unmounting of a filesystem.</p> <p>There are, however, a few drawbacks associated with using the umount2() system call. Not all filesystems are supported, and some could fail due to different implementation. Additionally, there is no default action, requiring the user to provide the needed flags for an unmount operation.</p>"},{"location":"docs/events/builtin/syscalls/umount2/#arguments","title":"Arguments","text":"<ul> <li><code>target</code>:<code>const char*</code>[K] - the directory mountpoint from which the filesystem should be unmounted.</li> <li><code>flags</code>:<code>int</code>[K] - the flags used in the unmounting operation.</li> </ul>"},{"location":"docs/events/builtin/syscalls/umount2/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/umount2/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/umount2/#sys_umount2","title":"sys_umount2","text":""},{"location":"docs/events/builtin/syscalls/umount2/#type","title":"Type","text":"<p>Kprobe + Kretprobe.</p>"},{"location":"docs/events/builtin/syscalls/umount2/#purpose","title":"Purpose","text":"<p>To collect the arguments and return the unmounting operation results of the umount2() system call.</p>"},{"location":"docs/events/builtin/syscalls/umount2/#example-use-case","title":"Example Use Case","text":"<p>A common use case for umount2() is when the user needs to unmount a filesystem and wants more control on the unmounting operation.</p>"},{"location":"docs/events/builtin/syscalls/umount2/#issues","title":"Issues","text":"<p>One downside of umount2() is that no default action is taken. The user must specify the flags so that the operation is successful.</p>"},{"location":"docs/events/builtin/syscalls/umount2/#related-events","title":"Related Events","text":"<ul> <li>mount2 - the system call used to mount a filesystem.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/uname/","title":"uname","text":""},{"location":"docs/events/builtin/syscalls/uname/#intro","title":"Intro","text":"<p>uname - get the system name</p>"},{"location":"docs/events/builtin/syscalls/uname/#description","title":"Description","text":"<p>The uname() system call wraps the get_utsname() kernel function and is used to get information about the current system, including the system name, version and the release. The struct utsname argument, buf, passes the system information to user space.</p>"},{"location":"docs/events/builtin/syscalls/uname/#arguments","title":"Arguments","text":"<ul> <li><code>buf</code>:<code>struct utsname*</code>[K, U] - pointer to a buffer to store the utsname struct.</li> </ul>"},{"location":"docs/events/builtin/syscalls/uname/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/uname/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/uname/#sys_uname","title":"sys_uname","text":""},{"location":"docs/events/builtin/syscalls/uname/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/uname/#purpose","title":"Purpose","text":"<p>To trace when the uname() syscall is called and get the arguments passed.</p>"},{"location":"docs/events/builtin/syscalls/uname/#example-use-case","title":"Example Use Case","text":"<p>In a security monitoring system, the uname() syscall can be used to identify if a system is undergoing changes to its core characteristics.</p>"},{"location":"docs/events/builtin/syscalls/uname/#issues","title":"Issues","text":"<p>None</p>"},{"location":"docs/events/builtin/syscalls/uname/#related-events","title":"Related Events","text":"<p>The get_utsname() kernel function, from which this syscall originates.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/unlink/","title":"unlink","text":""},{"location":"docs/events/builtin/syscalls/unlink/#intro","title":"Intro","text":"<p>unlink - Removes a file name for the file system.</p>"},{"location":"docs/events/builtin/syscalls/unlink/#description","title":"Description","text":"<p>unlink removes the specified pathname from the file system. If the specified pathname is the last link to a file and no processes have the file open, then the file is deleted and the space it was using is made available. This system call fails if the pathname specified is a directory or if the pathname has more than one link.</p> <p>unevent is used to unlink a file name and may also be used to remove directories, provided the directory is empty. However, unlink is not secure against race conditions and can be impacted by the TOCTOU (Time of Check, Time of Use) bug.</p>"},{"location":"docs/events/builtin/syscalls/unlink/#arguments","title":"Arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code>[K, U] - Pathname of the file to unlink. Must be a file, and not a directory.</li> </ul>"},{"location":"docs/events/builtin/syscalls/unlink/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/unlink/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/unlink/#do_unlinkat","title":"do_unlinkat","text":""},{"location":"docs/events/builtin/syscalls/unlink/#type","title":"Type","text":"<p>Kprobe + Kreteprobe</p>"},{"location":"docs/events/builtin/syscalls/unlink/#purpose","title":"Purpose","text":"<p>To log the syscall arguments and the syscall return value upon execution, as well as determine the origin of the syscall.</p>"},{"location":"docs/events/builtin/syscalls/unlink/#example-use-case","title":"Example Use Case","text":"<p>unlink is used to remove a file or directory from the file system, with one important caveat - in order to unlink a directory, the directory must be empty, otherwise, unlink fails. This system call is often used to clean up unused files that have been created during the course of running a program.</p>"},{"location":"docs/events/builtin/syscalls/unlink/#issues","title":"Issues","text":"<p>The C language doesn\u2019t require the system calls to detect errors on their own, so the errors returned by unlink can be unpredictable. Additionally, it is vulnerable to TOCTOU bug, where a potential attacker might be able to exploit the race condition to the system's disadvantage.</p>"},{"location":"docs/events/builtin/syscalls/unlink/#related-events","title":"Related Events","text":"<p>The unlink event is related to other system calls that can be used to manipulate files and directories, such as open, close, read, and write. It may also be used in combination with link and symlink to create, rename, and delete links to files in the system.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/unlinkat/","title":"unlinkat","text":""},{"location":"docs/events/builtin/syscalls/unlinkat/#intro","title":"Intro","text":"<p>unlinkat - system call that deletes a file name, relative to an open directory</p>"},{"location":"docs/events/builtin/syscalls/unlinkat/#description","title":"Description","text":"<p>unlinkat is a system call that deletes a file name, relative to an open directory. The purpose of unlinkat is to provide a more secure and robust way to delete a file than the remove() syscall, as it allows users to avoid race conditions while deleting a file. </p> <p>Unlinkat also allows a user to delete links without traversing whole directory hierarchies, by providing the location of the file (directory) and its name as two separate arguments.</p> <p>Unlinkat also provides the option to not traverse symbolic links with the O_NOFOLLOW flag. This allows users to delete symbolic links more securely.</p>"},{"location":"docs/events/builtin/syscalls/unlinkat/#arguments","title":"Arguments","text":"<ul> <li><code>dirfd</code>:<code>int</code>[K] - an open file descriptor referring to a directory.</li> <li><code>pathname</code>:<code>const char*</code>[KU] - a string containing the name of the file to be deleted, relative to the directory referred to by dirfd.</li> <li><code>flags</code>:<code>int</code>[K] - optional flags that can include O_NOFOLLOW, AT_REMOVEDIR, or AT_SYMLINK_NOFOLLOW.</li> </ul>"},{"location":"docs/events/builtin/syscalls/unlinkat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/unlinkat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/unlinkat/#sys_unlinkat","title":"sys_unlinkat","text":""},{"location":"docs/events/builtin/syscalls/unlinkat/#type","title":"Type","text":"<p>Tracepoint</p>"},{"location":"docs/events/builtin/syscalls/unlinkat/#purpose","title":"Purpose","text":"<p>To monitor file deletions.</p>"},{"location":"docs/events/builtin/syscalls/unlinkat/#example-use-case","title":"Example Use Case","text":"<p>Finding malicious file deletions.</p>"},{"location":"docs/events/builtin/syscalls/unlinkat/#issues","title":"Issues","text":"<p>unlinkat is vulnerable to TOCTOU (time of check, time of use) attacks if the O_NOFOLLOW flag is not included.</p>"},{"location":"docs/events/builtin/syscalls/unlinkat/#related-events","title":"Related Events","text":"<p>unlink(), remove(), readlinkat(), openat()</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/unshare/","title":"unshare","text":""},{"location":"docs/events/builtin/syscalls/unshare/#intro","title":"Intro","text":"<p>unshare - separate a process's execution context into its own process.</p>"},{"location":"docs/events/builtin/syscalls/unshare/#description","title":"Description","text":"<p>The unshare system call allows a process to separate its execution context into its own process. This system call can be used to create a new process from an existing one, or to create a new \"lightweight\" process (LWP), which executes in a shared memory context with the creating process. The flags parameter specifies which parts of the execution context to unshare, with CLONE_NEW[CGROUP|IPC|NET|NS|PID|USER]. It returns 0 on success, or a negative error code on error.</p>"},{"location":"docs/events/builtin/syscalls/unshare/#arguments","title":"Arguments","text":"<ul> <li><code>flags</code>:<code>int</code>[K] - specifies the type of context to unshare. See flags section in man page for more details.</li> </ul>"},{"location":"docs/events/builtin/syscalls/unshare/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/unshare/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/unshare/#sys_unshare","title":"sys_unshare","text":""},{"location":"docs/events/builtin/syscalls/unshare/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/unshare/#purpose","title":"Purpose","text":"<p>To detect the unshare syscall.</p>"},{"location":"docs/events/builtin/syscalls/unshare/#task_unshare","title":"task_unshare","text":""},{"location":"docs/events/builtin/syscalls/unshare/#type_1","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/unshare/#purpose_1","title":"Purpose","text":"<p>To detect the task_unshare function call.</p>"},{"location":"docs/events/builtin/syscalls/unshare/#example-use-case","title":"Example Use Case","text":"<p>An example of using unshare is a container. By using this system call, a process can separate its execution context, thus creating a new process (or LWP) in a shared memory context with its parent while also allowing it to have its own environment variables and IPC namespaces, among others.</p>"},{"location":"docs/events/builtin/syscalls/unshare/#issues","title":"Issues","text":"<p>When unsharing a process, all of its children must also be unshared or they will remain in the original process's context.</p>"},{"location":"docs/events/builtin/syscalls/unshare/#related-events","title":"Related Events","text":"<ul> <li>fork - Create a child process.</li> <li>clone - Create a child process in a different memory address space. </li> <li>setns - Set namespace for process.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/uselib/","title":"uselib","text":""},{"location":"docs/events/builtin/syscalls/uselib/#intro","title":"Intro","text":"<p>uselib - load library into the calling process address space.</p>"},{"location":"docs/events/builtin/syscalls/uselib/#description","title":"Description","text":"<p>The uselib() system call loads a shared library into the calling process's virtual address space, typically at an address chosen by the kernel. After it has been called, the library routines can be used. The library is only loaded for the duration of the process; it is private to each process and other processes do not see the loaded library. Care must be taken when using uselib() because if the same library is loaded multiple times and then unloaded, calls by the process to routines in the libraries will fail and result in an segmentation violation.</p> <p>There are some edge-cases where uselib() might not work properly, such as when the calling program is not authorised to access the specified library, or if the library is not for the correct architecture.</p>"},{"location":"docs/events/builtin/syscalls/uselib/#arguments","title":"Arguments","text":"<ul> <li><code>library</code>:<code>const char*</code>[K] - Path to the library to load.</li> </ul>"},{"location":"docs/events/builtin/syscalls/uselib/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/uselib/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/uselib/#do_uselib","title":"do_uselib","text":""},{"location":"docs/events/builtin/syscalls/uselib/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/uselib/#purpose","title":"Purpose","text":"<p>To trace the arguments of the uselib system call.</p>"},{"location":"docs/events/builtin/syscalls/uselib/#example-use-case","title":"Example Use Case","text":"<p>Monitor the libraries being loaded by a process. This can be used to detect attempts to perform malicious behavior by loading malicious libraries, or to identify mistakes in program design.</p>"},{"location":"docs/events/builtin/syscalls/uselib/#issues","title":"Issues","text":"<p>This system call is not supported on all architectures. Additionally, this system call is not available in the newest versions of the Linux kernel and has been replaced by other system calls.</p>"},{"location":"docs/events/builtin/syscalls/uselib/#related-events","title":"Related Events","text":"<ul> <li>execve</li> <li>munmap</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/userfaultfd/","title":"userfaultfd","text":"<p>```yaml</p>"},{"location":"docs/events/builtin/syscalls/userfaultfd/#userfaultfd","title":"userfaultfd","text":""},{"location":"docs/events/builtin/syscalls/userfaultfd/#intro","title":"Intro","text":"<p>userfaultfd - Used to handle page faults in user space.</p>"},{"location":"docs/events/builtin/syscalls/userfaultfd/#description","title":"Description","text":"<p>userfaultfd is a mechanism by which applications can handle page faults in user space. This syscall creates a file descriptor which can receive notification of page faults occurring in a designated memory region. The application can then handle page faults in its own context, allowing for a finer control over how to respond to page faults.</p> <p>The flags parameter indicates what type of faults can be handled. By setting certain flags the application can choose only certain types of page faults that it is interested in.</p>"},{"location":"docs/events/builtin/syscalls/userfaultfd/#arguments","title":"Arguments","text":"<ul> <li><code>flags</code>:<code>int</code>[U, OPT] - Indicates which page faults the application is interested in. Possible values include <code>O_NONBLOCK</code>, <code>O_CLOEXEC</code> and <code>UFFD_API_FEATURES_EVENT</code>.</li> </ul>"},{"location":"docs/events/builtin/syscalls/userfaultfd/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/userfaultfd/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/userfaultfd/#kernel_userfaultfd","title":"kernel_userfaultfd","text":""},{"location":"docs/events/builtin/syscalls/userfaultfd/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/userfaultfd/#purpose","title":"Purpose","text":"<p>To track all calls to the kernel_userfaultfd entry point.</p>"},{"location":"docs/events/builtin/syscalls/userfaultfd/#example-use-case","title":"Example Use Case","text":"<p>A user space application that needs to be able to handle page faults occurring in a specific sections of its address space, such as when servicing page faults from a user space page cache.</p>"},{"location":"docs/events/builtin/syscalls/userfaultfd/#issues","title":"Issues","text":"<p>No known issues.</p>"},{"location":"docs/events/builtin/syscalls/userfaultfd/#related-events","title":"Related Events","text":"<p>All related page fault events.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/ustat/","title":"ustat","text":""},{"location":"docs/events/builtin/syscalls/ustat/#intro","title":"Intro","text":"<p>ustat - determine file system information associated with a mounted file system.</p>"},{"location":"docs/events/builtin/syscalls/ustat/#description","title":"Description","text":"<p>The <code>ustat</code> system call is used to retrieve information about the mounted file system containing the directory whose file descriptor is passed in. This information describes the amount of blocks and file nodes associated with that file system, as well as the size of each. Depending on the flags passed, some of this information might be obtained from the filesystem itself, or from the system buffer cache.  </p> <p>When used in conjunction with the <code>parse-arguments</code> flag, the device argument is used to specify the exact file system from which to obtain the information. This is useful in cases where multiple file systems are present over the same device.  </p>"},{"location":"docs/events/builtin/syscalls/ustat/#arguments","title":"Arguments","text":"<ul> <li><code>dev</code>:<code>dev_t</code>[K] - device containing the file system  </li> <li><code>ubuf</code>:<code>struct ustat*</code>[U] - pointer to a buffer in user space used to write the information obtained  </li> </ul>"},{"location":"docs/events/builtin/syscalls/ustat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/ustat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/ustat/#sys_ustat","title":"sys_ustat","text":""},{"location":"docs/events/builtin/syscalls/ustat/#type","title":"Type","text":"<p>kprobe</p>"},{"location":"docs/events/builtin/syscalls/ustat/#purpose","title":"Purpose","text":"<p>The purpose of this hook is to evaluate the arguments associated with the <code>ustat</code> system call, before its execution.</p>"},{"location":"docs/events/builtin/syscalls/ustat/#example-use-case","title":"Example Use Case","text":"<p>A file system event monitor application could use the <code>ustat</code> call to return the information related to a given file system, such as the blocks and file nodes associated with it.  </p>"},{"location":"docs/events/builtin/syscalls/ustat/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/ustat/#related-events","title":"Related Events","text":"<ul> <li>statfs - get file system information.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/utime/","title":"utime","text":""},{"location":"docs/events/builtin/syscalls/utime/#intro","title":"Intro","text":"<p>utime - changes file last access and modification times.</p>"},{"location":"docs/events/builtin/syscalls/utime/#description","title":"Description","text":"<p>The utime() system call changes the access and modification times of the inode specified by filename. The atime, mtime, and ctime arguments correspond to the values for the access, modification and inode change times respectively.  If times is NULL, the access and modification times of the file are set to the current time.</p> <p>When utime is called from userspace, two types of privileges can be exercised: * The owner of the file can call utime, and it will set the file's access and modification times to the current time.  * The process must have root privileges to be able to change the times to a specified value other than the current time. </p> <p>utime is vulnerable to the Time Of Check Time Of Use (TOCTOU) race condition, where an attacker could modify the file after it has been checked but before it has been modified.</p>"},{"location":"docs/events/builtin/syscalls/utime/#arguments","title":"Arguments","text":"<ul> <li><code>filename</code>:<code>const char*</code>[K] - Path name of the file whose access and modification times are being modified.</li> <li><code>times</code>:<code>const struct utimbuf*</code>[K] - Specifies new access and/or modification time. If NULL, the access and modification times of the file are set to the current time.</li> </ul>"},{"location":"docs/events/builtin/syscalls/utime/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/utime/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/utime/#do_utimes","title":"do_utimes","text":""},{"location":"docs/events/builtin/syscalls/utime/#type","title":"Type","text":"<p>Tracepoint</p>"},{"location":"docs/events/builtin/syscalls/utime/#purpose","title":"Purpose","text":"<p>This kernel function is typically the entry point for the <code>utime</code> syscall, so it was hooked to capture request for this syscall.</p>"},{"location":"docs/events/builtin/syscalls/utime/#example-use-case","title":"Example Use Case","text":"<p>A system administrator may want to use utime to reset the modification and/or access times on a set of files in response to changing file access laws.</p>"},{"location":"docs/events/builtin/syscalls/utime/#issues","title":"Issues","text":"<p>A common TOCTOU race condition when using utime can be avoided by using the utimensat() syscall.</p>"},{"location":"docs/events/builtin/syscalls/utime/#related-events","title":"Related Events","text":"<p><code>utimensat</code>, <code>futimens</code>, <code>utimes</code>, <code>futimesat</code></p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/utimensat/","title":"utimensat","text":""},{"location":"docs/events/builtin/syscalls/utimensat/#intro","title":"Intro","text":"<p>utimensat - Change file timestamps with nanosecond precision</p>"},{"location":"docs/events/builtin/syscalls/utimensat/#description","title":"Description","text":"<p>The utimensat system call creates, checks, and/or modifies the timestamps of a file relative to a directory file descriptor. It provides nanosecond precision and some additional flags that the utime and utimes system calls do not provide.</p> <p>The 'times' argument is a pointer to a two-element array that specifies the access and modification times respectively. If either timestamp is set to the special value UTIME_OMIT, then that particular timestamp is not set. If 'times' is set to NULL, then the access and modification times of the 'pathname' are set to the current time.</p> <p>The flags argument is a bitfield that is used to indicate whether the times are relative to the directory referenced by the file descriptor 'dirfd' (AT_SYMLINK_NOFOLLOW), or whether the operation should be applied to the symlink itself (AT_SYMLINK_NOFOLLOW).</p> <p>The utimensat system call is similar to utime and utimes, but with more precise control over timestamp behavior.</p>"},{"location":"docs/events/builtin/syscalls/utimensat/#arguments","title":"Arguments","text":"<ul> <li><code>dirfd</code>:<code>int</code>[K] - A file descriptor referring to a directory, or the special value AT_FDCWD, which can be used to indicate the current working directory.</li> <li><code>pathname</code>:<code>const char</code>* <code>[K]</code> - A pointer to a string containing the pathname of a file relative to the directory referred to by the file descriptor 'dirfd'.</li> <li><code>times</code>:<code>struct timespec</code>* <code>[K]</code> - A pointer to a two-element array specifying the access and modification times respectively. The values are measured as nanoseconds since the Epoch (Jan 1 1970). If either timestamp is set to the special value UTIME_OMIT, then that particular timestamp is not set. If 'times' is set to NULL, then the access and modification times of the 'pathname' are set to the current time.</li> <li><code>flags</code>:<code>int</code>[K] - A bit-field indicating whether the times are relative to the directory referred to by the file descriptor 'dirfd' (AT_SYMLINK_NOFOLLOW), or whether the operation should be applied to the symlink itself (AT_SYMLINK_NOFOLLOW).</li> </ul>"},{"location":"docs/events/builtin/syscalls/utimensat/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space. </li> <li>U - Originated from user space (for example, pointer to user space memory used to get it) </li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use) </li> <li>OPT - Optional argument - might not always be available (passed with null value) </li> </ul>"},{"location":"docs/events/builtin/syscalls/utimensat/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/utimensat/#do_utimes","title":"do_utimes","text":""},{"location":"docs/events/builtin/syscalls/utimensat/#type","title":"Type","text":"<p>Tracepoint</p>"},{"location":"docs/events/builtin/syscalls/utimensat/#purpose","title":"Purpose","text":"<p>To analyze the arguments and return values of the utimensat system call.</p>"},{"location":"docs/events/builtin/syscalls/utimensat/#example-use-case","title":"Example Use Case","text":"<p>Utimensat could be used to set timestamps to a target file while allowing a user to avoid issues with Time Of Check To Time Of Use (TOCTOU) race condition by therefore providing a more secure setting of timestamps.</p>"},{"location":"docs/events/builtin/syscalls/utimensat/#issues","title":"Issues","text":"<p>Utimensat system call may fail in certain situations due to filesystem type that do not support nanosecond timestamp updates.</p>"},{"location":"docs/events/builtin/syscalls/utimensat/#related-events","title":"Related Events","text":"<ul> <li><code>utime</code>,<code>utimes</code> - These related system calls can modify timestamps for files, but with less precision. </li> <li><code>futimesat</code> - Like utimensat, but operates on a file instead of a pathname.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/utimensat_time32/","title":"utimensat_time32","text":""},{"location":"docs/events/builtin/syscalls/utimensat_time32/#intro","title":"Intro","text":"<p>utimensat_time32 - Change the timestamps of a file with nanosecond precision using a relative or an absolute 30-bit timestamp</p>"},{"location":"docs/events/builtin/syscalls/utimensat_time32/#description","title":"Description","text":"<p>The utimensat_time32 system call changes the timestamps of a file, similar to the utime system call. It is part of the Advanced Linux Programming Interface (ALP) and offers an improved timestamp range and higher precision of file time handling compared to its predecessor. It supports nanosecond resolution on 32-bit architectures inside the old_timespec32 structure which can be used to specify an absolute or relative timestamp.</p> <p>The flags parameter can be used to indicate if the t parameter should be used as an absolute (0) or relative (UTIME_NOW, UTIME_OMIT) timestamp for the file. If the AT_SYMLINK_NOFOLLOW flag is passed, the system call does not follow symbolic links, but fails when the specified file is a symbolic link.</p> <p>Are there any edge-cases, drawbacks or advantages of using it? Due to its use of the old_timespec32 structure, utimensat_time32 can only specify a time in a range of ~1902 to 2038. As such, it is not suitable for applications needing a more flexible timestamp range. </p>"},{"location":"docs/events/builtin/syscalls/utimensat_time32/#arguments","title":"Arguments","text":"<ul> <li><code>dfd</code>:<code>unsigned int</code>[K] - The file descriptor of the directory containing the file whose timestamps should be changed. A value of AT_FDCWD can be used to indicate the current working directory.</li> <li><code>filename</code>:<code>char*</code>[U] - Pointer to the name of the file whose timestamps should be changed.</li> <li><code>t</code>:<code>struct old_timespec32*</code>[U] - Pointer to the timespec structure containing the desired new timestamp for last access and modification time.</li> <li><code>flags</code>:<code>int</code>[K] - Flags controlling the behavior of the system call. Can be used to indicate if timestamp should be set relatively (UTIME_NOW) or absolutely (0).</li> </ul>"},{"location":"docs/events/builtin/syscalls/utimensat_time32/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/utimensat_time32/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/utimensat_time32/#sys_utimensat_time32","title":"sys_utimensat_time32","text":""},{"location":"docs/events/builtin/syscalls/utimensat_time32/#type","title":"Type","text":"<p>Kprobe.</p>"},{"location":"docs/events/builtin/syscalls/utimensat_time32/#purpose","title":"Purpose","text":"<p>Locate applications making syscalls to utimensat_time32 and analyze their parameters.</p>"},{"location":"docs/events/builtin/syscalls/utimensat_time32/#example-use-case","title":"Example Use Case","text":"<p>A system administrator could use this event to monitor writes to important files or directories and log whenever their timestamps are changed by any user or process.</p>"},{"location":"docs/events/builtin/syscalls/utimensat_time32/#issues","title":"Issues","text":"<p>Due to the limited range of timespec values (1902-2038), utimensat_time32 is not suitable for applications needing more flexible timestamp handling.</p>"},{"location":"docs/events/builtin/syscalls/utimensat_time32/#related-events","title":"Related Events","text":"<p>utimensat, utimensat_time64</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/utimes/","title":"utimes","text":""},{"location":"docs/events/builtin/syscalls/utimes/#intro","title":"Intro","text":"<p>utimes -  System call to change the access and modification times of a given file or file descriptor.</p>"},{"location":"docs/events/builtin/syscalls/utimes/#description","title":"Description","text":"<p><code>utimes</code> is a syscall used to set the access and or modification time of file <code>filename</code> or file descriptor <code>fd</code> to the user specified value(s) in the <code>times</code> argument. If the <code>times</code> argument is null, the access and modification time of the given file or file descriptor will be set to the current time. </p> <p>The <code>utimes</code> system call is especially useful when creating a backup of a file or when trying to reset the times of a file in order to keep it up to date with latest modifications. There are some caveats to using <code>utimes</code>, however. <code>utimes</code> will only work on files that are owned by the user, and it is vulnerable to TOCTOU (time of check, time of use) attacks, as the file or file descriptor may be changed between the time of checking and the time of updating.</p>"},{"location":"docs/events/builtin/syscalls/utimes/#arguments","title":"Arguments","text":"<ul> <li><code>filename</code>:<code>char*</code>[K, U, OPT] - Pointer to a null-terminated filename string.</li> <li><code>times</code>:<code>struct timeval*</code>[K, U] - Pointer to an array of two <code>struct timeval</code> objects. The first object contains the desired access time, and the second object contains the desired modification time.</li> </ul>"},{"location":"docs/events/builtin/syscalls/utimes/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/utimes/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/utimes/#sys_utimes","title":"sys_utimes","text":""},{"location":"docs/events/builtin/syscalls/utimes/#type","title":"Type","text":"<p>Kprobes + Tracepoints</p>"},{"location":"docs/events/builtin/syscalls/utimes/#purpose","title":"Purpose","text":"<p>To monitor changes to the files access and modification times.</p>"},{"location":"docs/events/builtin/syscalls/utimes/#open_exec","title":"open_exec","text":""},{"location":"docs/events/builtin/syscalls/utimes/#type_1","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/utimes/#purpose_1","title":"Purpose","text":"<p>To monitor usage of the <code>utimes</code> syscall.</p>"},{"location":"docs/events/builtin/syscalls/utimes/#example-use-case","title":"Example Use Case","text":"<p>A backup program that wishes to keep the creation and modification dates of the backed up files up to date without altering the content of the original file.</p>"},{"location":"docs/events/builtin/syscalls/utimes/#issues","title":"Issues","text":"<p><code>utimes</code> is not supported on all platforms, including Linux on PowerPC and Solaris.</p>"},{"location":"docs/events/builtin/syscalls/utimes/#related-events","title":"Related Events","text":"<ul> <li>open</li> <li>access</li> <li>stat</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/vfork/","title":"vfork","text":""},{"location":"docs/events/builtin/syscalls/vfork/#intro","title":"Intro","text":"<p>vfork - system call used to make a copy of the current process</p>"},{"location":"docs/events/builtin/syscalls/vfork/#description","title":"Description","text":"<p>The vfork() system call is used by a program to create a copy (child process) of itself. The child process runs in the same address space as the parent process until it either calls execve() or exits. This allows for faster process creation since the child process inherits many of the attributes of the parent process. However, if neither execve() or exit() is called, a deadlock can occur when the parent process attempts to execute code before the child process has terminated.</p> <p>The vfork() system call creates a child process that share the same memory space as the parent, but the parent process will not run until the child process either calls execve() or exits. This usage of memory allows for higher speed process creation, but can lead to problems if the child process does not call execve() or exit().</p>"},{"location":"docs/events/builtin/syscalls/vfork/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>: <code>pid_t</code>[K] - The pid of the child process created by the call.</li> </ul>"},{"location":"docs/events/builtin/syscalls/vfork/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/vfork/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/vfork/#sys_vfork","title":"sys_vfork","text":""},{"location":"docs/events/builtin/syscalls/vfork/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/vfork/#purpose","title":"Purpose","text":"<p>Hook sys_vfork to track the pid of the child process and the return values of the call.</p>"},{"location":"docs/events/builtin/syscalls/vfork/#example-use-case","title":"Example Use Case","text":"<p>vfork() is often used to create simple command-line programs or shell scripts. For example, <code>man fork</code> is executed by calling <code>vfork()</code> to create a new process and execute the <code>man</code> command in it.</p>"},{"location":"docs/events/builtin/syscalls/vfork/#issues","title":"Issues","text":"<p>The main issue regarding vfork() is the potential for deadlock, since the parent process can not continue executing until the child process calls exit() or execve(). Programs using vfork() should ensure that the child process does not run for too long or in an infinite loop.</p>"},{"location":"docs/events/builtin/syscalls/vfork/#related-events","title":"Related Events","text":"<ul> <li>fork() - A system call to create a new process that does not share memory with the parent process.</li> <li>execve() - A system call to execute a new program in the child process created by vfork().</li> <li>clone() - A system call to create a new process that shares the memory space of the parent process.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/vhangup/","title":"vhangup","text":""},{"location":"docs/events/builtin/syscalls/vhangup/#intro","title":"Intro","text":"<p>vhangup - Revoke access to all descriptors associated with the caller's tty</p>"},{"location":"docs/events/builtin/syscalls/vhangup/#description","title":"Description","text":"<p>The vhangup() system call will cause all descriptors associated with the caller's tty to be revoked. On Mac OS X, and many other Unix-like operating systems, this system call has been made obsolete by the setsid() system call. On some Linux-based systems, using this system call may reset certain signal -&gt; PID mappings and socket connection state.</p> <p>Using vhangup may also cause some process wait states to be reset. Note that, using this system call may cause certain terminal state to be reset, such as terminal baud rate, size and control characters.</p>"},{"location":"docs/events/builtin/syscalls/vhangup/#arguments","title":"Arguments","text":"<p>None</p>"},{"location":"docs/events/builtin/syscalls/vhangup/#available-tags","title":"Available Tags","text":"<p>N/A</p>"},{"location":"docs/events/builtin/syscalls/vhangup/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/vhangup/#vhangup_1","title":"vhangup","text":""},{"location":"docs/events/builtin/syscalls/vhangup/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/vhangup/#purpose","title":"Purpose","text":"<p>To monitor calls of vhangup system call.</p>"},{"location":"docs/events/builtin/syscalls/vhangup/#example-use-case","title":"Example Use Case","text":"<p>When debugging a program that utilizes terminal control, vhangup can be used to reset the state of the terminal.</p>"},{"location":"docs/events/builtin/syscalls/vhangup/#issues","title":"Issues","text":"<p>No known issues.</p>"},{"location":"docs/events/builtin/syscalls/vhangup/#related-events","title":"Related Events","text":"<p>setsid</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/vm86/","title":"vm86","text":""},{"location":"docs/events/builtin/syscalls/vm86/#intro","title":"Intro","text":"<p>vm86 - Allows a user space program to execute 8086-CPU instructions in virtual 8086 mode.</p>"},{"location":"docs/events/builtin/syscalls/vm86/#description","title":"Description","text":"<p>The vm86() system call provides a program with a way to execute 8086 instructions in virtual 8086 mode, with access to the protected-mode resources of the kernel such as memory and I/O ports. It provides a program a safe and controlled way to enter the realm of protected mode code. It is useful when emulation a x86 instruction set which is normally executed in 16-bit mode.</p> <p>There are few drawbacks when using this system call. Notably, it cannot be used in a multithreaded environment, as the virtual 8086 mode facility is not thread-safe. It also requires full control over the current processes virtual address space, meaning that the process must be single-threaded, without shared memory.</p>"},{"location":"docs/events/builtin/syscalls/vm86/#arguments","title":"Arguments","text":"<ul> <li><code>fn</code>:<code>unsigned long</code>[K] - A bitmask indicating the requested functions.</li> <li><code>v86</code>:<code>struct vm86plus_struct*</code>[K] - A pointer to a struct vm86plus_struct containing a state to be used when entering or leaving virtual 8086 mode.</li> </ul>"},{"location":"docs/events/builtin/syscalls/vm86/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/vm86/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/vm86/#entry-point","title":"Entry point","text":""},{"location":"docs/events/builtin/syscalls/vm86/#type","title":"Type","text":"<p>Kprobes</p>"},{"location":"docs/events/builtin/syscalls/vm86/#purpose","title":"Purpose","text":"<p>To monitor the entry of system call vm86</p>"},{"location":"docs/events/builtin/syscalls/vm86/#example-use-case","title":"Example Use Case","text":"<p>A typical use case is when an emulator is running a 32-bit x86 instruction set in 16-bit mode. This can be done by using the vm86() system call, which switches the virtual address spaces for the process and loads up the registers and segments. The process can then execute the 16-bit code in the virtual 8086 mode environment.</p>"},{"location":"docs/events/builtin/syscalls/vm86/#issues","title":"Issues","text":"<p>The virtual 8086 mode environment is not thread safe, so the vm86() system call cannot be used in a multithreaded environment. It also requires full control over the current processes virtual address space, meaning that the process must be single-threaded, without shared memory.</p>"},{"location":"docs/events/builtin/syscalls/vm86/#related-events","title":"Related Events","text":"<ul> <li>execve() - Used to run ARM emulator</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/vm86old/","title":"vm86old","text":""},{"location":"docs/events/builtin/syscalls/vm86old/#intro","title":"Intro","text":"<p>vm86old - Invoke real-mode software on 80386 and above processors.</p>"},{"location":"docs/events/builtin/syscalls/vm86old/#description","title":"Description","text":"<p>vm86old is used to run real-mode programs, i.e. DOS programs, on 80386 and above processors. It provides the necessary information for invoking real-mode programs, along with the protection of the operating system and any other applications running in protected mode.</p> <p>Using this system call comes with certain advantages and drawbacks. On one hand it preserves the system integrity as it keeps DOS mode separate from protected mode; however, it also limits the program from performing certain tasks that would otherwise be possible if they ran in the same context.</p>"},{"location":"docs/events/builtin/syscalls/vm86old/#arguments","title":"Arguments","text":"<ul> <li><code>info</code>: <code>struct vm86_struct*</code>[K] - Pointer to a <code>vm86_struct</code> structure that describes the real-mode program that the system call should run.</li> </ul>"},{"location":"docs/events/builtin/syscalls/vm86old/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/vm86old/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/vm86old/#do_vm86_old","title":"do_vm86_old","text":""},{"location":"docs/events/builtin/syscalls/vm86old/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/vm86old/#purpose","title":"Purpose","text":"<p>To monitor calls to the vm86old system call.</p>"},{"location":"docs/events/builtin/syscalls/vm86old/#example-use-case","title":"Example Use Case","text":"<p>A driver could use this system call to run real-mode programs from kernel-space.</p>"},{"location":"docs/events/builtin/syscalls/vm86old/#issues","title":"Issues","text":"<p>Due to the nature of the system call, the security of the system is affected as it enables running code in unprotected mode, meaning that malicious code could be used to exploit the underlying system.</p>"},{"location":"docs/events/builtin/syscalls/vm86old/#related-events","title":"Related Events","text":"<ul> <li><code>sigreturn</code> - Returns the state of the calling thread the way it was at the time of the syscall.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/vmsplice/","title":"vmsplice","text":""},{"location":"docs/events/builtin/syscalls/vmsplice/#intro","title":"Intro","text":"<p>vmsplice - read data from a pipe into a user address space</p>"},{"location":"docs/events/builtin/syscalls/vmsplice/#description","title":"Description","text":"<p>The vmsplice() system call transfers a count of up to <code>nr_segs</code> elements from  a user address space, into the specified pipe. Any type of pipe can be used,  including anonymous pipes (created using the pipe() system call) and  directed pipes created using the openat() system call with the O_PATH flag.  The <code>flags</code> argument can be set to VMSPLICE_F_MOVE, to transfer ownership of  the pages containing the iovec elements. The <code>iov</code> argument points to an  array of <code>iovec</code> structures, each consisting of a pointer to a location in  the user address space <code>iov_base</code>, and its length <code>iov_len</code>.</p> <p>Vmsplice does not check for the validity of the memory area, nor for its read access rights. Passing of invalid addresses (such as kernel space addresses) can corrupt the system.</p>"},{"location":"docs/events/builtin/syscalls/vmsplice/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - file descriptor of pipe.</li> <li><code>iov</code>:<code>const struct iovec*</code>[K] - pointer to a user space buffer containing the iovec elements to copy into the pipe. </li> <li><code>nr_segs</code>:<code>unsigned long</code>[K] - number of elements in <code>iov</code>.</li> <li><code>flags</code>:<code>unsigned int</code>[K] - indicate the type of action available with the <code>iov</code> buffer. Can be set to VMSPLICE_F_MOVE, to transfer ownership of the pages containing the <code>iov</code> elements.</li> </ul>"},{"location":"docs/events/builtin/syscalls/vmsplice/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/vmsplice/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/vmsplice/#vfs_splice_from_pipe","title":"vfs_splice_from_pipe","text":""},{"location":"docs/events/builtin/syscalls/vmsplice/#type","title":"Type","text":"<p>Kprobes + kretprobes</p>"},{"location":"docs/events/builtin/syscalls/vmsplice/#purpose","title":"Purpose","text":"<p>Monitor process activity in terms of manipulating pipes</p>"},{"location":"docs/events/builtin/syscalls/vmsplice/#example-use-case","title":"Example Use Case","text":"<p>One example use case of vmsplice() could be an application that copies data from the user's shared memory space to a pipe, which will then be read by another application. This method of inter-process communication is efficient and helps to ensure data integrity.</p>"},{"location":"docs/events/builtin/syscalls/vmsplice/#issues","title":"Issues","text":"<p>The vmsplice() system call is vulnerable to TOCTOU (Time of Check, Time of Use) attacks. This is because the memory passed to it is not checked for validity or for read access rights. Passing kernel space addresses to it could corrupt the system.</p>"},{"location":"docs/events/builtin/syscalls/vmsplice/#related-events","title":"Related Events","text":"<p>The splice system call can be used to send data from one pipe to another pipe, and can be combined with vmsplice() to pass data from user space memory to a pipe. The sendfile() system call can also be used to pass the contents of a file to a socket or pipe.</p> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/vserver/","title":"vserver","text":""},{"location":"docs/events/builtin/syscalls/vserver/#intro","title":"Intro","text":"<p>vserver - Allows to control an isolated context within the same Linux kernel.</p>"},{"location":"docs/events/builtin/syscalls/vserver/#description","title":"Description","text":"<p>The vserver syscall is a way to create isolated execution contexts within the same Linux kernel. It provides mechanisms such as users, process groups, or network rules to separate processes and resources, allowing to conserve or maximize system resources depending on their use. Furthermore, each vserver context can have their own root directory and assign access rights to files and folders within it.</p> <p>The syscall allows to create and delete vserver contexts, modify their properties or enter them. It also has the capability to list all existing vserver contexts and show their properties. The level of isolation that it provides is comparable to virtualization, with the advantage that it allows context switching directly from the kernel and does not require extra overhead for running a virtual machine.</p>"},{"location":"docs/events/builtin/syscalls/vserver/#arguments","title":"Arguments","text":"<ul> <li><code>cmd</code>:<code>int</code>[K] - Controls the action to perform on the vserver context, it could be for creating, deleting, entering or modifying.</li> <li><code>arg1</code>:<code>char *</code>[U,TOCTOU] - A pointer to a user page containing the data for the operation defined by the <code>cmd</code> argument.</li> <li><code>size</code>:<code>size_t</code>[K] - The size of the data pointed by <code>arg1</code> in bytes.</li> <li><code>flags</code>:<code>int</code>[OPT] - Optional flags related to the provided data, could affect the interaction and output of the command. </li> </ul>"},{"location":"docs/events/builtin/syscalls/vserver/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/vserver/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/vserver/#personality","title":"<code>personality()</code>","text":""},{"location":"docs/events/builtin/syscalls/vserver/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/vserver/#purpose","title":"Purpose","text":"<p>Personality() is hooked when using the vserver syscall in order to identify when is called to change the process execution context.</p>"},{"location":"docs/events/builtin/syscalls/vserver/#example-use-case","title":"Example Use Case","text":"<p>One of the most common use cases of the vserver syscall, and one of the reasons why it was designed, is to provide deployment scalability by creating resource-isolated execution contexts. This use case allows to minimize deployment times and maximize resources while running multiple applications on the same machine that require different configurations.</p> <p>In addition, due to the level of isolation that it provides and the direct interaction with the kernel, it can also be used for security purposes. An example could be an application running in an isolated vserver context for which access rights can be set and traffic monitored by the vserver context.</p>"},{"location":"docs/events/builtin/syscalls/vserver/#issues","title":"Issues","text":"<p>Using this syscall is resource-intensive as it requires a lot of resource management that is not always necessary. This can lead to less efficient usage of the system resources.</p> <p>In addition, there are several security issues related to vserver, as it does not provide hardware-level isolation, which can make it vulnerable against attacks aiming to escape a sandboxed environment.</p> <p>Finally, the data passed in the <code>arg1</code> argument should be checked carefully as it is passed from user space and is vulnerable to TOCTOU (time-of-check-time-of-use) attacks.</p>"},{"location":"docs/events/builtin/syscalls/vserver/#related-events","title":"Related Events","text":"<ul> <li>clone() - Clones the process into another one, useful when entering a vserver context.</li> <li>setns() - Changes the process's execution context, used when entering a vserver context.</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/wait4/","title":"wait4","text":""},{"location":"docs/events/builtin/syscalls/wait4/#intro","title":"Intro","text":"<p>wait4 - wait for a process to change state.</p>"},{"location":"docs/events/builtin/syscalls/wait4/#description","title":"Description","text":"<p>The <code>wait4()</code> system call suspends execution of the calling process until a  specified process has changed state, or until a signal is received, or until the  delay, as specified by an argument, has passed. This syscall allows to retrieve  information about the child process which changed from the provided parameters.  The main purpose of this call is to allow the process to wait for the termination  of a child that it created using one of the <code>fork()</code> syscall family functions.</p> <p>The <code>wait4()</code> syscall attempts to return the exit status of the process  specified by <code>pid</code>. If <code>pid</code> is equal to -1, it matches any process whose  process group ID is equal to the process group ID of the caller, or any process  when it is not a member of a process group.</p> <p>When <code>options</code> is set to 0, the status is returned immediately. If <code>pid</code> is equal  to 0, <code>wait4()</code> matches any process with the same process group ID as the caller.</p> <p>If <code>rusage</code> is not NULL, the resource usage of the terminating process and its  children is returned as part of <code>rusage</code>.</p>"},{"location":"docs/events/builtin/syscalls/wait4/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>pid_t</code>[K] - the process ID of a child process for which status is  requested.</li> <li><code>wstatus</code>:<code>int*</code>[K] - the address of a buffer where the status of the  terminated process is to be stored.</li> <li><code>options</code>:<code>int</code>[K] - the options argument can be used to change the behavior of  <code>wait4()</code>.</li> <li><code>rusage</code>:<code>struct rusage*</code>[K] - a pointer to a <code>struct rusage</code> where the resource  usage information of the terminated process (and its children) will be stored.</li> </ul>"},{"location":"docs/events/builtin/syscalls/wait4/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> </ul>"},{"location":"docs/events/builtin/syscalls/wait4/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/wait4/#sys_wait4","title":"sys_wait4","text":""},{"location":"docs/events/builtin/syscalls/wait4/#type","title":"Type","text":"<p>Kprobe + Kretprobe</p>"},{"location":"docs/events/builtin/syscalls/wait4/#purpose","title":"Purpose","text":"<p>Hooked to trace information about a process and collect the return code value of  <code>wait4()</code>.</p>"},{"location":"docs/events/builtin/syscalls/wait4/#example-use-case","title":"Example Use Case","text":"<p>The <code>wait4()</code> syscall is useful whenever processes need to be monitored. It can  be used to track the execution of a child process and react accordingly if it  fails. For example, an Alert rule can be triggered if the child process leaves  the system in an unexpected state. </p>"},{"location":"docs/events/builtin/syscalls/wait4/#issues","title":"Issues","text":"<p>It should be noted that <code>wait4()</code>'s status value is the same as that of the  <code>wait()</code> syscall.</p>"},{"location":"docs/events/builtin/syscalls/wait4/#related-events","title":"Related Events","text":"<ul> <li><code>exit()</code></li> <li><code>wait()</code></li> <li><code>fork()</code></li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/waitid/","title":"waitid","text":""},{"location":"docs/events/builtin/syscalls/waitid/#intro","title":"Intro","text":"<p>waitid - Wait for processes or process groups to change state</p>"},{"location":"docs/events/builtin/syscalls/waitid/#description","title":"Description","text":"<p><code>waitid</code> allows the caller to block until one of the caller's child processes changes state, or until a signal being caught by the caller is triggered. The caller may request information about the child process on which it blocked, its status and its resource usage data. If a process group ID is given, instead of a process ID, <code>waitid</code> will wait for any member of the given process group to change state. </p> <p>Due to time of check, time of use (TOCTOU), race conditions and similar issues, <code>waitid</code> should be used carefully as the process changing state may not be the one expected and other issues may arise.</p>"},{"location":"docs/events/builtin/syscalls/waitid/#arguments","title":"Arguments","text":"<ul> <li><code>idtype</code>:<code>int</code>[K] - Type of ID to wait for. It can be <code>P_PID</code>, <code>P_PGID</code> or <code>P_ALL</code>. </li> <li><code>id</code>:<code>pid_t</code>[K] - Process or process group ID. </li> <li><code>infop</code>:<code>struct siginfo*</code>[U] - Const pointer to a <code>siginfo_t</code> struct. If non NULL, the status of the child process will be stored there. </li> <li><code>options</code>:<code>int</code>[K] - Value can have the <code>WEXITED</code> or <code>WNOHANG</code> flag set, amongst others.</li> <li><code>rusage</code>:<code>struct rusage*</code>[U] - Pointer to a <code>rusage_t</code> structure. If non NULL the resource usage data of the process on which it blocked will be stored there. </li> </ul>"},{"location":"docs/events/builtin/syscalls/waitid/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/waitid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/waitid/#sys_wait4","title":"sys_wait4","text":""},{"location":"docs/events/builtin/syscalls/waitid/#type","title":"Type","text":"<p>Kprobes.</p>"},{"location":"docs/events/builtin/syscalls/waitid/#purpose","title":"Purpose","text":"<p>Trace when a <code>waitid</code> syscall is executed.</p>"},{"location":"docs/events/builtin/syscalls/waitid/#example-use-case","title":"Example Use Case","text":"<p><code>waitid</code> can be used when a child process must complete a certain task before continuing execution. The calling process can wait for the child to change its state using <code>waitid</code>, for example when the child terminates.</p>"},{"location":"docs/events/builtin/syscalls/waitid/#issues","title":"Issues","text":"<p>Due to TOCTOU-like issues, <code>waitid</code> should be used with extra care as the process changing state may not be the one expected.</p>"},{"location":"docs/events/builtin/syscalls/waitid/#related-events","title":"Related Events","text":"<ul> <li>waitpid</li> <li>wait4 </li> <li>wait</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/waitpid/","title":"waitpid","text":""},{"location":"docs/events/builtin/syscalls/waitpid/#intro","title":"Intro","text":"<p>waitpid - wait for a process to change its state</p>"},{"location":"docs/events/builtin/syscalls/waitpid/#description","title":"Description","text":"<p>The waitpid() system call suspends execution of the calling process until a child process specified by pid argument has changed state. By giving the WNOHANG or WUNTRACED options to waitpid() call, the calling process can specify that it should return immediately if there is no process state change. The status pointer argument may be specified as NULL.</p>"},{"location":"docs/events/builtin/syscalls/waitpid/#arguments","title":"Arguments","text":"<ul> <li><code>pid</code>:<code>pid_t</code> - Specifies a set of child processes for which to wait.</li> <li><code>status</code>:<code>int*</code>[U] - A pointer to an integer into which status information about the child process will be stored. This can be NULL if the calling process is not interested in this information.</li> <li><code>options</code>:<code>int</code> - May be specified to include WNOHANG or WUNTRACED, which modify the behavior of the waitpid() system call.</li> </ul>"},{"location":"docs/events/builtin/syscalls/waitpid/#available-tags","title":"Available Tags","text":"<ul> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/waitpid/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/waitpid/#do_wait","title":"do_wait()","text":""},{"location":"docs/events/builtin/syscalls/waitpid/#type","title":"Type","text":"<p>KProbes</p>"},{"location":"docs/events/builtin/syscalls/waitpid/#purpose","title":"Purpose","text":"<p>Used to monitor usage of waitpid in the system.</p>"},{"location":"docs/events/builtin/syscalls/waitpid/#example-use-case","title":"Example Use Case","text":"<p>This event can be used to monitor and detect when a process with a specified pid has changed state. </p>"},{"location":"docs/events/builtin/syscalls/waitpid/#issues","title":"Issues","text":"<p>None.</p>"},{"location":"docs/events/builtin/syscalls/waitpid/#related-events","title":"Related Events","text":"<ul> <li>fork()</li> <li>execve()</li> <li>signal()</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/write/","title":"write","text":""},{"location":"docs/events/builtin/syscalls/write/#intro","title":"Intro","text":"<p>write - a syscall for writing data to a specified file descriptor</p>"},{"location":"docs/events/builtin/syscalls/write/#description","title":"Description","text":"<p>The write syscall is used to write data to a specified file descriptor. It takes three arguments: a file descriptor <code>fd</code>, a pointer to the data <code>buf</code> and its size <code>count</code>. It returns the number of bytes written, or -1 if there was an error. </p> <p>Writing more bytes than the buffer size may cause a buffer overflow and should be avoided. Data should also be checked before writing to make sure that it is valid. It is important to note that the write syscall is non-atomic and may be interrupted by signals.</p>"},{"location":"docs/events/builtin/syscalls/write/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code> - file descriptor to write the data to</li> <li><code>buf</code>:<code>void*</code>[K, U] - pointer to the data to be written</li> <li><code>count</code>:<code>size_t</code>[K] - number of bytes to write from the buffer </li> </ul>"},{"location":"docs/events/builtin/syscalls/write/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> </ul>"},{"location":"docs/events/builtin/syscalls/write/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/write/#sys_write","title":"sys_write","text":""},{"location":"docs/events/builtin/syscalls/write/#type","title":"Type","text":"<p>Kprobe</p>"},{"location":"docs/events/builtin/syscalls/write/#purpose","title":"Purpose","text":"<p>To collect data from all write syscall invocation.</p>"},{"location":"docs/events/builtin/syscalls/write/#example-use-case","title":"Example Use Case","text":"<p>A system administrator could use the write syscall to write data to a logfile.</p>"},{"location":"docs/events/builtin/syscalls/write/#issues","title":"Issues","text":"<p>If the buffer size is larger than the specified count, the write syscall may cause a buffer overflow.</p>"},{"location":"docs/events/builtin/syscalls/write/#related-events","title":"Related Events","text":"<ul> <li>read - allows a file descriptor to be read into a buffer</li> <li>open - allows a file to be opened and set a file descriptor </li> <li>close - closes a previously opened file descriptor</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/builtin/syscalls/writev/","title":"writev","text":""},{"location":"docs/events/builtin/syscalls/writev/#intro","title":"Intro","text":"<p>writev - atomically write data from multiple buffers to a file descriptor</p>"},{"location":"docs/events/builtin/syscalls/writev/#description","title":"Description","text":"<p>The <code>writev()</code> system call writes data from multiple buffers, as specified by <code>iov</code> into a file descriptor <code>fd</code>. The number of buffers to write is given in <code>iovcnt</code>. The <code>iov</code> is a pointer to a list of <code>struct iovec</code>s, which define multiple non-contiguous buffers. Each <code>struct iovec</code> contains a starting address and length of a data buffer. <code>writev()</code> atomicly writes all of the data in the given buffers. If all the buffers are written then the <code>writev()</code> system call returns the total number of bytes written to the file descriptor <code>fd</code>. </p>"},{"location":"docs/events/builtin/syscalls/writev/#arguments","title":"Arguments","text":"<ul> <li><code>fd</code>:<code>int</code>[K] - A file descriptor that identifies the file into which <code>writev()</code> will write data.</li> <li><code>iov</code>:<code>const struct iovec*</code>[K,U] - A pointer to the <code>struct iovec</code> that defines  the multiple non-contiguous buffers.</li> <li><code>iovcnt</code>:<code>int</code>[OPT,K] - The number of buffers to write, as specified by <code>iov</code>.</li> </ul>"},{"location":"docs/events/builtin/syscalls/writev/#available-tags","title":"Available Tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>OPT - Optional argument - might not always be available (passed with null value)</li> </ul>"},{"location":"docs/events/builtin/syscalls/writev/#hooks","title":"Hooks","text":""},{"location":"docs/events/builtin/syscalls/writev/#sys_writev","title":"sys_writev","text":""},{"location":"docs/events/builtin/syscalls/writev/#type","title":"Type","text":"<p>kprobes</p>"},{"location":"docs/events/builtin/syscalls/writev/#purpose","title":"Purpose","text":"<p>Hooked to trace the sys_writev syscall.</p>"},{"location":"docs/events/builtin/syscalls/writev/#example-use-case","title":"Example Use Case","text":"<p><code>writev()</code> is often used when writing to a socket. For example, when sending data to a web server the data is usually split into multiple chunks and <code>writev()</code> is used to write the data in a single operation, atomically.</p>"},{"location":"docs/events/builtin/syscalls/writev/#issues","title":"Issues","text":"<p>There are no known issues with the <code>writev()</code> system call.</p>"},{"location":"docs/events/builtin/syscalls/writev/#related-events","title":"Related Events","text":"<ul> <li>readv</li> </ul> <p>This document was automatically generated by OpenAI and needs review. It might not be accurate and might contain errors. The authors of Tracee recommend that the user reads the \"events.go\" source file to understand the events and their arguments better.</p>"},{"location":"docs/events/custom/analyze/","title":"Analyze","text":"<p>The tracee subcommand <code>analyze</code> allows you to execute behavior signatures on past data.  For example, you can collect the ptrace event into one node using the following command:</p> <pre><code>tracee --events=ptrace --output=json:events.json\n</code></pre> <p>Then, on another node, you can check if the behavior signature for anti-debugging was triggered using the following command:</p> <pre><code>tracee analyze --events=anti_debugging events.json\n</code></pre> <p>The <code>analyze</code> command can also be used to test new signatures from the collected past data. You can run tracee on a node, collect several events, and based on the collected events, create your behavior signature. Afterward, you can test if the signature would be triggered using the <code>analyze</code> command.</p>"},{"location":"docs/events/custom/golang/","title":"Golang Signatures","text":"<p>There are 2 ways you can get your own golang signatures working with tracee.</p> <ol> <li> <p>Built-In Golang signatures</p> <p>Tip</p> <p>This is the preferred way to get your own golang signatures integrated into Tracee, as you will find in the next part of this page, but it needs a better end-user experience (being worked).</p> <p>In order to get your golang signature compiled with tracee, you can create a file called <code>signatures/golang/signature_example.go</code> and place the following code in it:</p> <p>Signature</p> <pre><code>package main\n\nimport (\n\"fmt\"\n\"strings\"\n\n\"github.com/aquasecurity/tracee/signatures/helpers\"\n\"github.com/aquasecurity/tracee/types/detect\"\n\"github.com/aquasecurity/tracee/types/protocol\"\n\"github.com/aquasecurity/tracee/types/trace\"\n)\n\ntype signatureExample struct {\ncb detect.SignatureHandler\n}\n\nfunc (sig *signatureExample) Init(ctx detect.SignatureContext) error {\nsig.cb = ctx.Callback\n\nreturn nil\n}\n\nfunc (sig *signatureExample) GetMetadata() (\ndetect.SignatureMetadata,\nerror,\n) {\nreturn detect.SignatureMetadata{\nID:          \"Mine-0.1.0\",\nVersion:     \"0.1.0\",\nName:        \"My Own Signature\",\nEventName:   \"mine\",\nDescription: \"My Own Signature Detects Stuff\",\n}, nil\n}\n\nfunc (sig *signatureExample) GetSelectedEvents() (\n[]detect.SignatureEventSelector,\nerror,\n) {\n\nreturn []detect.SignatureEventSelector{\n{Source: \"tracee\", Name: \"openat\"},\n{Source: \"tracee\", Name: \"execve\"},\n}, nil\n}\n\nfunc (sig *signatureExample) OnEvent(event protocol.Event) error {\nswitch e := event.Payload.(type) {\ncase trace.Event:\nif e.ArgsNum == 0 {\nreturn nil\n}\n\nswitch e.EventName {\ncase \"openat\", \"execve\":\narg, err := helpers.GetTraceeArgumentByName(e, \"pathname\", helpers.GetArgOps{DefaultArgs: false})\nif err != nil {\nreturn err\n}\n\nif s, ok := arg.Value.(string); ok {\nif strings.Contains(s, \"/etc/passwd\") {\nm, _ := sig.GetMetadata()\n\nfound := detect.Finding{\nEvent:       event,\nSigMetadata: m,\n}\n\nsig.cb(found)\n}\n}\n}\ndefault:\nreturn fmt.Errorf(\"failed to cast event's payload\")\n}\n\nreturn nil\n}\n\nfunc (sig *signatureExample) OnSignal(s detect.Signal) error {\nreturn nil\n}\n\nfunc (sig *signatureExample) Close() {}\n</code></pre> <p>Then, edit <code>signatures/golang/export.go</code> and place your new signature there:</p> <pre><code>var ExportedSignatures = []detect.Signature{\n...\n&amp;signatureExample{},\n}\n</code></pre> <p>Follow instructions on how to build Tracee and you will get your new signature available to use. You may even select only the signatures you created:</p> <pre><code>sudo ./dist/tracee \\\n    --output json \\\n    --events mine\n</code></pre> <pre><code>{\"timestamp\":1680191445996958642,\"threadStartTime\":1680191445994222553,\"processorId\":4,\"processId\":329031,\"cgroupId\":10793,\"threadId\":329031,\"parentProcessId\":45580,\"hostProcessId\":329031,\"hostThreadId\":329031,\"hostParentProcessId\":45580,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"zsh\",\"hostName\":\"hb\",\"container\":{},\"kubernetes\":{},\"eventId\":\"6030\",\"eventName\":\"mine\",\"matchedPolicies\":[\"\"],\"argsNum\":0,\"returnValue\":11,\"syscall\":\"\",\"stackAddresses\":null,\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[],\"metadata\":{\"Version\":\"0.1.0\",\"Description\":\"My Own Signature Detects Stuff\",\"Tags\":null,\"Properties\":{\"signatureID\":\"Mine-0.1.0\",\"signatureName\":\"My Own Signature\"}}}\n</code></pre> <p>Be creative! You can create signatures that would do pretty much anything! Examples of such signatures would: for every X event, connect to a cached external data-source and return a positive detection for cases A, B or C.</p> </li> <li> <p>Create a golang signature plugin and dynamically load it during runtime</p> <p>Attention</p> <p>Eventually you will find out that Golang Plugins aren't very useful if you consider all the problems that emerge from using it:</p> <ol> <li> <p>Can't use different go versions (need to compile the go plugin    with the exact same version that was used to build Tracee).</p> </li> <li> <p>Both Tracee and your golang plugin signature must be built with the    exact same GOPATH or you will get a \"plugin was built with a    different version of package XXX\" error.</p> </li> <li> <p>Any dependency you have in your plugin should be of the same    version with the dependencies of Tracee.</p> </li> <li> <p>Compiling tracee statically is sometimes useful to have a complete    portable eBPF tracing/detection solution. One good example when    statically compiling tracee is a good idea is to have a single    binary capable of running in GLIBC (most of them) and MUSL (Alpine)    powered Linux distros.</p> </li> </ol> <p>At the end, creating a golang signature plugin won't have the practical effects as a plugin mechanism should have, so it is preferred to have built-in golang signatures (re)distributed with newer binaries (when you need to add/remove signatures from your environment) FOR NOW.</p> </li> </ol>"},{"location":"docs/events/custom/overview/","title":"Custom Events","text":"<p>Tracee comes with lots of events, but you can extend it with events specific to your use case. There are two ways to extend Tracee with your own events:</p> <ol> <li>Go</li> <li>Rego</li> </ol> <p>Once you created your own event, you can load it using the <code>signatures-dir</code> flag. For example, if you created your event in the path <code>/tmp/myevents</code> to use it you would start tracee with:</p> <pre><code>tracee --signatures-dir=/tmp/myevents\n</code></pre> <p>Tip</p> <p>Tracee also uses the custom events to add a few events, if you pass your own directory for <code>signatures-dir</code> you will not load the tracee Behaviour events,  to avoid such problems, you can either place your own events under the same directory of the tracee custom events, or pass multiple directories for example: <pre><code>tracee --signatures-dir=/tmp/myevents --signatures-dir=./dist/signatures\n</code></pre></p> <p>\ud83d\udc48 Please use the side-navigation on the left in order to browse the different topics.</p>"},{"location":"docs/events/custom/rego/","title":"Rego Signatures","text":"<p>Tip</p> <p>Differently than golang built-in signatures, with Rego signatures you are able to add and/or remove signatures to Tracee without the need of recompiling it (or re-distributing the binary) BUT it may come with a performance price to pay.</p> <p>In order to create your own Rego signature you need to create a <code>.rego</code> file that has the following Rego Rules (now, in this context, rules are Rego's language constructs):</p> <p>rego_metadoc</p> <p>A document rule that defines the rule's metadata.</p> <p>Tracee_selected_events</p> <p>A set rule that defines the event selectors.</p> <p>Tracee_match</p> <p>A boolean or a document rule that defines the logic of the signature. If bool is \"returned\", a true evaluation will generate a Finding with no data. If a document is \"returned\", any non-empty evaluation will generate a Finding with the returned document as the Finding's \"Data\".</p> <p>Signature</p> <pre><code>package tracee.Mine\n\nimport data.tracee.helpers\n\n__rego_metadoc__ := {\n    \"id\": \"Mine-0.1.0\",\n    \"version\": \"0.1.0\",\n    \"name\": \"My Own Signature\",\n    \"eventName\": \"mine\",\n    \"description\": \"My Own Signature Detects Stuff\",\n}\n\neventSelectors := [\n    {\n        \"source\": \"tracee\",\n        \"name\": \"openat\",\n    },\n    {\n        \"source\": \"tracee\",\n        \"name\": \"execve\",\n    },\n]\n\ntracee_selected_events[eventSelector] {\n    eventSelector := eventSelectors[_]\n}\n\ntracee_match {\n    input.eventName == \"openat\"\n    arg_value = helpers.get_tracee_argument(\"pathname\")\n    startswith(arg_value, \"/etc/passwd\")\n}\n\ntracee_match {\n    input.eventName == \"execve\"\n    arg_value = helpers.get_tracee_argument(\"pathname\")\n    startswith(arg_value, \"/etc/passwd\")\n}\n</code></pre> <p>After placing your <code>signature_example.rego</code> inside <code>signatures/rego</code> directory you may execute tracee selecting only the event you just created, if that is what you want:</p> <pre><code>sudo ./dist/tracee \\\n    --output json\n    --signatures-dir signatures/rego \\\n    --events mine\n</code></pre> <pre><code>{\"timestamp\":1680190419485136510,\"threadStartTime\":1680190419369780383,\"processorId\":4,\"processId\":320908,\"cgroupId\":16273,\"threadId\":320908,\"parentProcessId\":1635,\"hostProcessId\":320908,\"hostThreadId\":320908,\"hostParentProcessId\":1635,\"userId\":1000,\"mountNamespace\":4026531841,\"pidNamespace\":4026531836,\"processName\":\"terminator\",\"hostName\":\"hb\",\"container\":{},\"kubernetes\":{},\"eventId\":\"6000\",\"eventName\":\"mine\",\"matchedPolicies\":[\"\"],\"argsNum\":0,\"returnValue\":10,\"syscall\":\"\",\"stackAddresses\":null,\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[],\"metadata\":{\"Version\":\"0.1.0\",\"Description\":\"My Own Signature Detects Stuff\",\"Tags\":null,\"Properties\":{\"signatureID\":\"Mine-0.1.0\",\"signatureName\":\"My Own Signature\"}}}\n</code></pre> <p>See signatures/rego for example Rego signatures.</p>"},{"location":"docs/filters/filtering/","title":"Tracing Event Filtering","text":"<pre><code>sudo ./dist/tracee --scope help\nsudo ./dist/tracee --events help\nsudo ./dist/tracee --scope xxx --events xxx\n</code></pre> <p>Tracee output might become too hard to consume when tracing all the events from a system. Luckily, Tracee has a powerful mechanism to accurately filter just the information that is relevant to the user using the <code>--scope</code> and <code>--events</code> flags.</p> <p>With those command line flags you define expressions that tell tracee what you are interested in based on event metadata filtering capabilities. Only events that match given criteria will be traced.</p> <p>Tip</p> <p>You can filter events by most of the visible fields from Tracee events.</p>"},{"location":"docs/filters/filtering/#initial-example","title":"Initial Example","text":"<p>All the examples bellow this item can be executed with the following tracee prefix command:</p> <pre><code>sudo ./dist/tracee \\\n    --output json \\\n    --scope comm=bash \\\n    --scope follow\n    --output option:parse-arguments \\\n    &lt;rest of filters&gt;\n</code></pre> <p>This will allow you to test the filtering rules by executing a new process in any running shell and might serve as a good indicative if your filter works as expected.</p>"},{"location":"docs/filters/filtering/#filters-and-operators","title":"Filters and Operators","text":"<ol> <li> <p>Event and Scope <code>(Operators: event \"-\" and scope \"follow\". Prefix/Suffix: *)</code></p> <pre><code>1) --events openat\n2) --events execve,open\n3) --events 'open*'\n4) --events '-open*,-dup*'\n5) --events 'fs,-dup*'\n6) --scope follow\n</code></pre> <p>Note</p> <p>The event \"-\" remove operator will work like it means.</p> <p>Note</p> <p>The event 'fs,-dup' will select all file-system events but dup events.</p> <p>Note</p> <p>The \"follow\" operator will make tracee follow all newly created child processes of the parents being filtered.</p> </li> <li> <p>Event Arguments <code>(Operators: =, !=. Prefix/Suffix: *)</code></p> <pre><code>1) --events openat --events openat.args.pathname=/etc/shadow\n2) --events openat --events openat.args.pathname='/tmp*'\n3) --events openat --events openat.args.pathname!=/tmp/1,/bin/ls\n</code></pre> <p>Note</p> <p>Multiple values are ORed if used with = operator But ANDed if used with any other operator.</p> <p>Tip</p> <p>As a syntax sugar, the event options filter can be set without the <code>--events openat</code>, since by <code>--events openat.args.pathname=/etc/shadow</code> tracee infers that openat must be filtered.</p> </li> <li> <p>Event Return Code <code>(Operators: =, !=, &lt;, &gt;)</code></p> <pre><code>1) --events openat.args.pathname=/etc/shadow --events 'openat.retval&gt;0'\n2) --events openat.args.pathname=/etc/shadow --events 'openat.retval&lt;0'\n</code></pre> <p>Tip</p> <p>Try <code>cat /etc/shadow</code> as a regular use and filter for <code>retval&lt;0</code>.</p> </li> <li> <p>Event Context <code>(Operators: vary by field)</code></p> <pre><code>1) --events openat.context.container --events openat.args.pathname=/etc/shadow\n</code></pre> <p>Note</p> <p>The following is a list of available context fields: 1)  \"timestamp\" 2)  \"processorId\" 3)  \"p\", \"pid\", \"processId\" 4)  \"tid\", \"threadId\" 5)  \"ppid\", \"parentProcessId\" 6)  \"hostTid\", \"hostThreadId\" 7)  \"hostPid\", \"hostParentProcessId\" 8)  \"uid\", \"userId\" 9)  \"mntns\", \"mountNamespace\" 10) \"pidns\", \"pidNamespace\" 11) \"processName\", \"comm\" 12) \"hostName\" 13) \"cgroupId\" 14) \"host\" (inversion of \"container\") 15) \"container\" 16) \"containerId\" 17) \"containerImage\" 18) \"containerName\" 19) \"podName\" 20) \"podNamespace\" 21) \"podUid\" 22) \"syscall\"  </p> <p>Tip</p> <p>Open a container and try <code>cat /etc/shadow</code>.</p> </li> <li> <p>Event Sets</p> <pre><code>1) --events fs\n2) --events lsm_hooks,network_events\n</code></pre> <p>Note</p> <p>Selects a set of events to tracee according to pre-defined sets which can be listed by using <code>list</code> command line argument.</p> </li> <li> <p>Container <code>(Operators: =, != and \"new\". Boolean)</code></p> <pre><code>1) --scope container # all container events\n2) --scope '!container' # events from the host only\n3) --scope container=new # containers created after tracee-ebf execution\n4) --scope container=3f93da58be3c --events openat\n5) --scope container=new --events openat.args.pathname=/etc/shadow\n</code></pre> <p>Note</p> <p>The new flag allows to filter newly created containers only.  </p> </li> <li> <p>Command <code>(Operators: =, !=)</code></p> <pre><code>1) --scope comm=cat,vim,ping\n2) --scope comm!=ping\n</code></pre> <p>Note</p> <p>Do not use given command prefix for these examples as they're filtering by command name as well.</p> </li> <li> <p>Binary Path <code>(Operators: =, !=)</code></p> <pre><code>1) --scope binary=/usr/bin/ls\n2) --scope binary=host:/usr/bin/ls\n3) --scope binary=4026532448:/usr/bin/ls\n</code></pre> <p>Note</p> <ol> <li>Mount namespace id or the special \"host:\" prefix can be used for finer filtering</li> <li>Given path must be absolute; i.e starts with \"/\"</li> <li>Symbolic link paths are not supported</li> </ol> </li> <li> <p>PID <code>(Operators: =, !=, &lt;, &gt; and \"new\")</code></p> <pre><code>1) --scope pid=new # newly created events (after tracee execution)\n2) --scope pid=510,1709 # # pids 510 and 1709\n3) --scope 'pid&gt;0' --scope pid 'pid&lt;1000'\n4) --scope pid=2578238 --scope follow --events openat.args.pathname=/etc/shadow\n</code></pre> <p>Note</p> <p>This filter can be used to filter a specific process or thread: 1. Providing a tgid (aka pid) will filter all threads of the process. 2. Providing a tid (where tid != tgid) will only filter the specific thread.</p> </li> <li> <p>Process Tree</p> <pre><code>1) --scope tree=476165 # events descending from process 476165\n2) --scope tree!=5023 # events that do not descend from process 5023\n</code></pre> </li> <li> <p>UID <code>(Operators: =, !=, &lt;, &gt;)</code></p> <pre><code>1) --scope uid=0\n2) --scope 'uid&gt;0'\n3) --scope 'uid&gt;0' --scope uid!=1000 # do not filter root and uid=1000\n</code></pre> </li> <li> <p>UTS Namespace (hostnames) <code>(Operators: =, !=)</code></p> <pre><code>1) --scope uts!=ab356bc4dd554 \n</code></pre> </li> <li> <p>PID Namespace <code>(Operators: =, !=)</code></p> <pre><code>1) --scope pidns!=4026531836\n</code></pre> </li> <li> <p>MOUNT Namespace <code>(Operators: =, !=)</code></p> <pre><code>1) --scope mntns=4026531840\n</code></pre> </li> </ol>"},{"location":"docs/forensics/","title":"Getting Started with Forensics","text":"<p>Tracee has a unique feature that lets you capture interesting artifacts from running applications, using the <code>--capture</code> flag.</p> <pre><code>sudo ./dist/tracee --help capture\nsudo ./dist/tracee --capture xxx\n</code></pre> <p>Tip</p> <p>All captured artifacts are saved in Tracee's \"output directory\", which can be configured using <code>--capture dir:/path/to/dir</code>. You may also use <code>--capture clear-dir</code> if you want contents of the destination directory to be cleared every time you execute tracee.</p>"},{"location":"docs/forensics/#artifacts-types","title":"Artifacts Types","text":"<p>Tracee can capture the following types of artifacts:</p> <ol> <li> <p>I/O Files</p> <p>Anytime a file is being written to and/or read from, the contents of the file will be captured. I/O files can be filtered using 3 optional filters: 1. path - prefix of the file written/read. Up to 3 path filters can be    provided per capture type. 2. type - file's type can be <code>pipe</code>, <code>socket</code> or <code>regular</code>. 3. fd - standard FD, one of the following: <code>stdin</code>, <code>stdout</code> and <code>stderr</code>.</p> <p>write example <pre><code>sudo ./dist/tracee \\\n   --output json \\\n   --scope comm=bash \\\n   --scope follow \\\n   --output option:parse-arguments \\\n   --capture dir:/tmp/tracee/ \\\n   --capture write='/tmp/*'\n</code></pre></p> <p>Note</p> <p>Using file capture without filter name will be path by default. Hence, <code>--capture write='/tmp/*</code> is the same as <code>--capture write:path='/tmp/*</code>.</p> <pre><code>echo write testing 123 &gt; /tmp/testing.txt\n</code></pre> <pre><code>{\"timestamp\":1657321167356748797,\"threadStartTime\":620311624458929,\"processorId\":7,\"processId\":2578238,\"cgroupId\":1,\"threadId\":2578238,\"parentProcessId\":2578237,\"hostProcessId\":2578238,\"hostThreadId\":2578238,\"hostParentProcessId\":2578237,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"bash\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"722\",\"eventName\":\"security_file_open\",\"argsNum\":6,\"returnValue\":0,\"stackAddresses\":null,\"syscall\":\"openat\",\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"/tmp/testing.txt\"},{\"name\":\"flags\",\"type\":\"string\",\"value\":\"O_WRONLY|O_CREAT|O_TRUNC|O_LARGEFILE\"},{\"name\":\"dev\",\"type\":\"dev_t\",\"value\":271581185},{\"name\":\"inode\",\"type\":\"unsigned long\",\"value\":1966101},{\"name\":\"ctime\",\"type\":\"unsigned long\",\"value\":1657321027326584850},{\"name\":\"syscall_pathname\",\"type\":\"const char*\",\"value\":\"/tmp/testing.txt\"}]}\n{\"timestamp\":1657321167356729582,\"threadStartTime\":620311624458929,\"processorId\":7,\"processId\":2578238,\"cgroupId\":1,\"threadId\":2578238,\"parentProcessId\":2578237,\"hostProcessId\":2578238,\"hostThreadId\":2578238,\"hostParentProcessId\":2578237,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"bash\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"257\",\"eventName\":\"openat\",\"argsNum\":4,\"returnValue\":3,\"stackAddresses\":null,\"syscall\":\"openat\",\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"dirfd\",\"type\":\"int\",\"value\":-100},{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"/tmp/testing.txt\"},{\"name\":\"flags\",\"type\":\"string\",\"value\":\"O_WRONLY|O_CREAT|O_TRUNC\"},{\"name\":\"mode\",\"type\":\"mode_t\",\"value\":438}]}\n</code></pre> <p>Note</p> <p>You can read captured files written at <code>/tmp/tracee/out</code>: <pre><code>sudo cat /tmp/tracee/out/host/write.dev-271581185.inode-1966101\n</code></pre></p> <pre><code>write testing 123\n</code></pre> <p>read example</p> <pre><code>sudo ./dist/tracee \\\n   --output json \\\n   --scope comm=bash \\\n   --scope follow \\\n   --output option:parse-arguments \\\n   --capture dir:/tmp/tracee/ \\\n   --capture read:type=pipe \\\n   --capture read:fd=stdin'\n</code></pre> <pre><code>echo read testing 123 | cat\n</code></pre> <pre><code>{\"timestamp\":1685285181028166900,\"threadStartTime\":1685285181026565700,\"processorId\":1,\"processId\":182934,\"cgroupId\":1,\"threadId\":182934,\"parentProcessId\":147428,\"hostProcessId\":184128,\"hostThreadId\":184128,\"hostParentProcessId\":148293,\"userId\":0,\"mountNamespace\":4026532277,\"pidNamespace\":4026532279,\"processName\":\"cat\",\"hostName\":\"Alon-Zivony\",\"container\":{},\"kubernetes\":{},\"eventId\":\"720\",\"eventName\":\"vfs_read\",\"matchedPolicies\":[\"\"],\"argsNum\":5,\"returnValue\":17,\"syscall\":\"read\",\"stackAddresses\":null,\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"\"},{\"name\":\"dev\",\"type\":\"dev_t\",\"value\":12},{\"name\":\"inode\",\"type\":\"unsigned long\",\"value\":174033},{\"name\":\"count\",\"type\":\"size_t\",\"value\":131072},{\"name\":\"pos\",\"type\":\"off_t\",\"value\":0}]}\n{\"timestamp\":1685285181028267200,\"threadStartTime\":1685285181026565700,\"processorId\":1,\"processId\":182934,\"cgroupId\":1,\"threadId\":182934,\"parentProcessId\":147428,\"hostProcessId\":184128,\"hostThreadId\":184128,\"hostParentProcessId\":148293,\"userId\":0,\"mountNamespace\":4026532277,\"pidNamespace\":4026532279,\"processName\":\"cat\",\"hostName\":\"Alon-Zivony\",\"container\":{},\"kubernetes\":{},\"eventId\":\"720\",\"eventName\":\"vfs_read\",\"matchedPolicies\":[\"\"],\"argsNum\":5,\"returnValue\":0,\"syscall\":\"read\",\"stackAddresses\":null,\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"\"},{\"name\":\"dev\",\"type\":\"dev_t\",\"value\":12},{\"name\":\"inode\",\"type\":\"unsigned long\",\"value\":174033},{\"name\":\"count\",\"type\":\"size_t\",\"value\":131072},{\"name\":\"pos\",\"type\":\"off_t\",\"value\":0}]}\n</code></pre> </li> </ol> <p>!!! Note        You can read captured files read at <code>/tmp/tracee/out</code>:        <pre><code>sudo cat /tmp/tracee/out/host/read.dev-12.inode-176203\n</code></pre></p> <pre><code>    ```text\n    read testing 123\n    ```\n</code></pre> <ol> <li> <p>Executed Files</p> <p>Anytime a binary is executed, the binary file will be captured. If the same binary is executed multiple times, it will be captured just once.</p> <pre><code>sudo ./dist/tracee \\\n   --output json \\\n   --scope comm=bash \\\n   --scope follow \\\n   --output option:parse-arguments \\\n   --capture dir:/tmp/tracee/ \\\n   --capture exec\n</code></pre> <pre><code>/bin/ls\n</code></pre> <pre><code>{\"timestamp\":1657322300531713371,\"threadStartTime\":620311624458929,\"processorId\":21,\"processId\":2578238,\"cgroupId\":1,\"threadId\":2578238,\"parentProcessId\":2578237,\"hostProcessId\":2578238,\"hostThreadId\":2578238,\"hostParentProcessId\":2578237,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"bash\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"56\",\"eventName\":\"clone\",\"argsNum\":5,\"returnValue\":3331757,\"stackAddresses\":null,\"syscall\":\"clone\",\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"flags\",\"type\":\"string\",\"value\":\"CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID\"},{\"name\":\"stack\",\"type\":\"void*\",\"value\":\"0x0\"},{\"name\":\"parent_tid\",\"type\":\"int*\",\"value\":\"0x0\"},{\"name\":\"child_tid\",\"type\":\"int*\",\"value\":\"0x7fd7ce0d3a10\"},{\"name\":\"tls\",\"type\":\"unsigned long\",\"value\":0}]}\n{\"timestamp\":1657322300534562489,\"threadStartTime\":620311624458929,\"processorId\":21,\"processId\":2578238,\"cgroupId\":1,\"threadId\":2578238,\"parentProcessId\":2578237,\"hostProcessId\":2578238,\"hostThreadId\":2578238,\"hostParentProcessId\":2578237,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"bash\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"3\",\"eventName\":\"close\",\"argsNum\":1,\"returnValue\":0,\"stackAddresses\":null,\"syscall\":\"close\",\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"fd\",\"type\":\"int\",\"value\":3}]}\n</code></pre> <p>Note</p> <p>You will have a copy of each executed file written at <code>/tmp/tracee/out</code>: <pre><code>ldd /bin/ls\n</code></pre></p> <pre><code>linux-vdso.so.1 (0x00007ffca632c000)\nlibselinux.so.1 =&gt; /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007f9a930d5000)\nlibc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f9a92ead000)\nlibpcre2-8.so.0 =&gt; /lib/x86_64-linux-gnu/libpcre2-8.so.0 (0x00007f9a92e16000)\n/lib64/ld-linux-x86-64.so.2 (0x00007f9a93136000)\n</code></pre> <pre><code>ldd /tmp/tracee/out/host/exec.1657322052835478987.ls\n</code></pre> <pre><code>linux-vdso.so.1 (0x00007ffe337fb000)\nlibselinux.so.1 =&gt; /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007feeb1fa5000)\nlibc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007feeb1d7d000)\nlibpcre2-8.so.0 =&gt; /lib/x86_64-linux-gnu/libpcre2-8.so.0 (0x00007feeb1ce6000)\n/lib64/ld-linux-x86-64.so.2 (0x00007feeb2006000)\n\n```console\nsudo chmod +x /tmp/tracee/out/host/exec.1657322052835478987.ls\n/tmp/tracee/out/host/exec.1657322052835478987.ls\n</code></pre> </li> <li> <p>Memory Files</p> <p>Anytime a memory unpacker is detected, the suspicious memory region will be captured. This is triggered when memory protection changes from Write+Execute to Write.</p> <pre><code>sudo ./dist/tracee \\\n   --output none \\\n   --scope comm=bash \\\n   --scope follow \\\n   --capture dir:/tmp/tracee/ \\\n   --capture mem\n</code></pre> <p>Note</p> <p>You may opt not to have any output from tracee with <code>--output none</code> command flag is given. This makes tracee to work in capture mode only.</p> </li> <li> <p>Network PCAP Files</p> <p>Anytime a network packet is delivered to a process, traced by tracee, this packet might be captured into one or multiple pcap files.</p> <p>Attention</p> <p>The default behavior when capturing network traffic is to capture ALL traffic, despite given event filters. If you want to make capture feature to follow the given event filters, like for example capturing DNS events only, then you have to provide <code>--capture pcap-options:filtered</code> argument in the command line. Then only net_packet_XXX events will be captured (IPv4, IPv6, TCP, UDP, ICMP, ICMPv6, DNS, HTTP, etc).</p> <p>A good way to test this behavior is to execute:</p> <pre><code>sudo ./dist/tracee \\\n    --events net_packet_ipv4 \\\n    --capture network \\\n    --capture pcap-options:filtered\n</code></pre> <p>and observe a single pcap file for all ipv4 packets created:</p> <pre><code>find /tmp/tracee/out/pcap/\n</code></pre> <pre><code>/tmp/tracee/out/pcap/\n/tmp/tracee/out/pcap/single.pcap\n</code></pre> <p>You can select only dns packets, for example:</p> <pre><code>sudo ./dist/tracee \\\n    --events net_packet_dns \\\n    --capture network \\\n    --capture pcap-options:filtered\n</code></pre> <p>and the file <code>/tmp/tracee/out/pcap/single.pcap</code> would only contain DNS related packets:</p> <pre><code>find /tmp/tracee/out/pcap/\n</code></pre> <pre><code>/tmp/tracee/out/pcap/\n/tmp/tracee/out/pcap/single.pcap\n</code></pre> <pre><code>sudo tcpdump -n -r /tmp/tracee/out/pcap/single.pcap | head -2\n</code></pre> <pre><code>reading from file /tmp/tracee/out/pcap/single.pcap, link-type NULL (BSD loopback), snapshot length 262144\n16:53:48.870629 IP 127.0.0.1.55569 &gt; 127.0.0.53.53: 33361+ [1au] A? www.uol.com.br. (43)\n16:53:48.870690 IP 127.0.0.1.55569 &gt; 127.0.0.53.53: 25943+ [1au] AAAA? www.uol.com.br. (43)\n</code></pre> <p>A great thing is that you may have multiple pcap files, divided by:</p> <ol> <li>single: a single pcap file containing all packets (the default)</li> <li>process: one file per process executed, ordered by host and container</li> <li>container: one file for the host and one pcap file per container</li> <li>per-command: one file per command executed (even if multiple times)</li> </ol> <p>and you can even have multiple ways at the same time. Example: a ping command is executed inside a container. You want to summarize captured traffic per container and per command. You will find the same captured data for that ping command inside <code>commands/container_id/ping.pcap</code> and inside <code>containers/container_id.pcap</code>.</p> <pre><code>sudo ./dist/tracee \\\n    --events net_packet_icmp \\\n    --capture network \\\n    --capture pcap-options:filtered \\\n    --capture pcap:process,container,command\n</code></pre> <pre><code>cd /tmp/tracee/out\nfind pcap\n</code></pre> <pre><code>pcap\npcap/commands\npcap/commands/b86533d11f3\npcap/commands/b86533d11f3/ping.pcap\npcap/commands/host\npcap/commands/host/sshd.pcap\npcap/commands/host/zerotier-one.pcap\npcap/commands/host/node.pcap\npcap/commands/fd95a035ce5\npcap/commands/fd95a035ce5/ping.pcap\npcap/processes\npcap/processes/b86533d11f3\npcap/processes/b86533d11f3/ping_1261180_1663772450241192.pcap\npcap/processes/host\npcap/processes/host/node_186708_1573567360495399.pcap\npcap/processes/host/node_1196826_1662656211119567.pcap\npcap/processes/host/zerotier-one_7882_137007714376.pcap\npcap/processes/host/sshd_1196773_1662654999660718.pcap\npcap/processes/fd95a035ce5\npcap/processes/fd95a035ce5/ping_1261163_1663769383806467.pcap\npcap/containers\npcap/containers/host.pcap\npcap/containers/b86533d11f3.pcap\npcap/containers/fd95a035ce5.pcap\n</code></pre> <p>you can see the packets by executing tcpdump on any pcap file:</p> <pre><code>tcpdump -r pcap/containers/b86533d11f3.pcap\n</code></pre> <pre><code>reading from file pcap/containers/b86533d11f3.pcap, link-type NULL (BSD loopback), snapshot length 65535\n02:52:00.524035 IP 172.17.0.3 &gt; dns.google: ICMP echo request, id 5, seq 476, length 64\n02:52:00.533145 IP dns.google &gt; 172.17.0.3: ICMP echo reply, id 5, seq 476, length 64\n02:52:01.525455 IP 172.17.0.3 &gt; dns.google: ICMP echo request, id 5, seq 477, length 64\n02:52:01.535414 IP dns.google &gt; 172.17.0.3: ICMP echo reply, id 5, seq 477, length 64\n02:52:02.526715 IP 172.17.0.3 &gt; dns.google: ICMP echo request, id 5, seq 478, length 64\n02:52:02.536444 IP dns.google &gt; 172.17.0.3: ICMP echo reply, id 5, seq 478, length 64\n02:52:03.528739 IP 172.17.0.3 &gt; dns.google: ICMP echo request, id 5, seq 479, length 64\n02:52:03.538622 IP dns.google &gt; 172.17.0.3: ICMP echo reply, id 5, seq 479, length 64\n</code></pre> <pre><code>tcpdump -r pcap/commands/b86533d11f3/ping.pcap\n</code></pre> <pre><code>reading from file pcap/commands/b86533d11f3/ping.pcap, link-type NULL (BSD loopback), snapshot length 65535\n02:52:00.524035 IP 172.17.0.3 &gt; dns.google: ICMP echo request, id 5, seq 476, length 64\n02:52:00.533145 IP dns.google &gt; 172.17.0.3: ICMP echo reply, id 5, seq 476, length 64\n02:52:01.525455 IP 172.17.0.3 &gt; dns.google: ICMP echo request, id 5, seq 477, length 64\n02:52:01.535414 IP dns.google &gt; 172.17.0.3: ICMP echo reply, id 5, seq 477, length 64\n02:52:02.526715 IP 172.17.0.3 &gt; dns.google: ICMP echo request, id 5, seq 478, length 64\n02:52:02.536444 IP dns.google &gt; 172.17.0.3: ICMP echo reply, id 5, seq 478, length 64\n02:52:03.528739 IP 172.17.0.3 &gt; dns.google: ICMP echo request, id 5, seq 479, length 64\n02:52:03.538622 IP dns.google &gt; 172.17.0.3: ICMP echo reply, id 5, seq 479, length 64\n</code></pre> <p>Note</p> <p>Note that the same packets were written to 2 different pcap files: the pcap file describing the container <code>b86533d11f3</code> (because it was executing a single process: ping) and the pcap file describing ANY ping command executed in that container (commands/b86533d11f3/ping.pcap).</p> <p>The format for the pcap filenames inside <code>output_dir</code> is the following:</p> <ol> <li>single:    ./pcap/single.pcap</li> <li>processes:    ./pcap/processes/<code>container_id</code>/<code>process_comm</code>/<code>host_tid</code>/<code>task_starttime</code>.pcap</li> <li>containers:    ./pcap/containers/<code>container_id</code>.pcap</li> <li>commands:    ./pcap/commands/<code>container_id</code>/<code>process_comm</code>.pcap</li> </ol> <p>Attention</p> <p>By default, all pcap files will contain packets with headers only. That might too little for introspection, since sometimes one might be interested in a few bytes of the captured packet (or event it all). Next item shows how to capture a specific packet payload size.</p> <p>In order to capture a specific payload size you may specify:</p> <pre><code>sudo ./dist/tracee \\\n    --events net_packet_tcp \\\n    --capture network \\\n    --capture pcap-options:filtered \\\n    --capture pcap:single,command \\\n    --capture pcap-snaplen:default\n</code></pre> <p>To capture packet headers + 96 bytes of payload. Or replace <code>default</code> by:</p> <ol> <li>headers: capture up to L4 headers only</li> <li>max: full sized packets into pcap. WARNING: big pcap files.</li> <li>256b, 512b, 1024b, ... (any number plus \"b\")</li> <li>16kb, 32kb, 64kb,  ... (any number plus \"kb\")</li> </ol> <p>when specifying a payload size, it refers to the payload AFTER the layer4 headers (and not the entire packet length).</p> </li> <li> <p>Loaded Kernel Modules</p> <p>Anytime a kernel module is loaded, the binary file will be captured. If the same binary is loaded multiple times, it will be captured just once.</p> <pre><code>sudo ./dist/tracee \\\n    --output none \\\n    --scope comm=bash \\\n    --scope follow \\\n    --capture clear-dir \\\n    --capture module\n</code></pre> <p>Captured module will be found in tracee destination directory, just like any other captured file would be:</p> <pre><code>sudo ls /tmp/tracee/out/host\n</code></pre> <pre><code>module.dev-271581185.inode-4071826.pid-3668786.c8b62228208f4bdbf21df09c01046b73dd44733841675bf3c0ff969fbedab616\n</code></pre> <p>AND, the captured module is an exact copy of the loaded module:</p> <pre><code>sudo rmmod lkm_example\nsudo insmod /tmp/tracee/out/host/module.dev-271581185.inode-4071826.pid-3668786.c8b62228208f4bdbf21df09c01046b73dd44733841675bf3c0ff969fbedab616\n</code></pre> <pre><code>lsmod | grep example\n\n```text\nlkm_example            16384  0\n</code></pre> <pre><code>sudo rmmod lkm_example\n</code></pre> <p>you can even load/unload it.</p> <p>Note</p> <p>Example kernel module taken from this blog</p> </li> <li> <p>BPF programs</p> <p>Wheneber a BPF program is loaded, the BPF bytecode will be captured. This captured bytecode represents the BPF program as it was loaded by the loading process. It is basically the BPF section of the compiled ELF that loads the BPF program, which contains the program instructions themselves. You can disassemble the bytecode with the help of <code>binutils-bpf</code> package and the following command line: <code>objdump -D -b binary -m bpf &lt;path&gt;</code></p> <pre><code>$ sudo ./dist/tracee-ebpf \\\n   --output none \\\n   --scope comm=bash \\\n   --scope follow \\\n   --capture clear-dir \\\n   --capture bpf\n</code></pre> <p>Captured bpf bytecode will be found in tracee destination directory, just like any other captured file would be:</p> <p><pre><code>$ sudo ls /tmp/tracee/out/host\n  bpf.name-test_prog.pid-3668786.c8b62228208f4bdbf21df09c01046b73dd44733841675bf3c0ff969fbedab616\n</code></pre>    The hex value after the last \".\" is the hash of the bpf bytecode.</p> </li> </ol>"},{"location":"docs/integrating/container-engines/","title":"Tracee Events Container Enrichment","text":"<p>Tracee is capable of extracting information about running containers. It does that by tracking container namespaces creation kernel events and enriching those events by communicating with the relevant container's runtime and SDK.</p> <p>Experimental</p> <p>This feature is experimental and should be explicitly enabled in tracee, by using the <code>--container</code> flag OR, if running tracee container image, setting the <code>CONTAINERS_ENRICHMENT</code> environment flag (see example bellow).</p> <ol> <li> <p>Running tracee manually</p> <p>If running tracee directly (not in a container), it will automatically search for known supported runtimes in their socket's default locations.</p> </li> <li> <p>Running tracee using a docker container</p> <p>When running tracee from a container, the runtime sockets must be manually mounted in order for the enrichment features to work.</p> <p>Using containerd as our runtime for example, this can be done by running tracee like:</p> <pre><code>docker run \\\n    --name tracee --rm -it \\\n    --pid=host --cgroupns=host --privileged \\\n    -v /etc/os-release:/etc/os-release-host:ro \\\n    -v /var/run/containerd:/var/run/containerd \\\n    -e CONTAINERS_ENRICHMENT=1 \\\n    aquasec/tracee:v0.16.0-rc-14-gd8fa9648e\n</code></pre> <p>Most container runtimes have their sockets installed by default in <code>/var/run</code>. If your system includes multiple container runtimes, tracee can track them all, however one should mount either all their runtime sockets or <code>/var/run</code> in it's entirety to do so.</p> </li> </ol>"},{"location":"docs/integrating/container-engines/#supported-container-runtime-engines","title":"Supported Container Runtime Engines","text":"<p>Currently, tracee will look in the following paths for auto-discovering the listed runtimes:</p> <ol> <li> <p>Docker:     <code>/var/run/docker.sock</code></p> </li> <li> <p>Containerd: <code>/var/run/containerd/containerd.sock</code></p> </li> <li> <p>CRI-O:      <code>/var/run/crio/crio.sock</code></p> </li> <li> <p>Podman:     <code>/var/run/podman/podman.sock</code></p> </li> </ol> <p>Tip</p> <p>Nested environments are somewhat tricky with this feature as evidenced by the docker mounting instructions. Tracee does not auto-discover this nesting and so sockets must be appropriately mounted and set up for tracee to enrich all containers correctly.</p>"},{"location":"docs/integrating/container-engines/#viewing-enrichment-output","title":"Viewing enrichment output","text":"<p>As a user, when container enrichment is enabled the event output will include enriched fields in these cases:</p> <ol> <li> <p>Running tracee with a json format will include all container enriched fields</p> <pre><code>docker run \\\n    --name tracee --rm -it \\\n    --pid=host --cgroupns=host --privileged \\\n    -v /etc/os-release:/etc/os-release-host:ro \\\n    -v /var/run/docker.sock:/var/run/docker.sock \\\n    aquasec/tracee:v0.16.0-rc-14-gd8fa9648e \\\n    --output json --containers\n</code></pre> </li> <li> <p>Running in container filtering mode and with enrichment enabled will add the image name to the table printer</p> <pre><code>docker run \\\n    --name tracee --rm -it \\\n    --pid=host --cgroupns=host --privileged \\\n    -v /etc/os-release:/etc/os-release-host:ro \\\n    -v /var/run/containerd:/var/run/containerd \\\n    aquasec/tracee:v0.16.0-rc-14-gd8fa9648e \\\n    --scope container --containers\n</code></pre> </li> </ol>"},{"location":"docs/integrating/healthz/","title":"Special: Healthz Endpoint","text":"<p>tracee supports a flag <code>--healthz</code> which enable a <code>/healthz</code> endpoint that returns if <code>OK</code> if the process are healthy.</p> <p>Example:</p> <pre><code>tracee --healthz\ncurl http://localhost:3366/healthz\n</code></pre> <pre><code>OK\n</code></pre> <p>The port used is the default port <code>3366</code> for <code>tracee</code>. It can be customized with the flag <code>--listen-addr</code>. </p> <p>Example:</p> <pre><code>tracee --healthz --listen-addr=:8080\ncurl http://localhost:8080/healthz\n</code></pre> <pre><code>OK\n</code></pre>"},{"location":"docs/integrating/prometheus/","title":"Prometheus","text":"<p>Integrating with Prometheus</p> <p>Performance</p> <p>Current Prometheus integration targets performance numbers for event production, consumption and detection. It does not target the detections themselves.</p> <p>Tracee is enabled for prometheus scraping by default. Scraping can be done through the following URLs:</p> <p>tracee can be scraped through <code>:3366/metrics</code></p> <p>Metrics addresses can be changed through tracee command line arguments <code>metrics</code> and <code>listen-addr</code>, check <code>--help</code> for more information.</p> <p>Tip</p> <p>Check this tutorial for more information as well.</p>"},{"location":"docs/outputs/logging/","title":"Logging","text":"<p>Configure log severity:</p> <pre><code>sudo ./dist/tracee --log debug\n</code></pre> <p>Redirect logs to a file if needed:</p> <pre><code>sudo ./dist/tracee --scope comm=bash --scope follow --events openat --output json:/tmp/tracee.events --log file:/tmp/tracee.log\n</code></pre> <p>Logs can be aggregated for a given interval to delay its output:</p> <pre><code>sudo ./dist/tracee --log debug --log aggregate:5s\n</code></pre> <p>Filter logs which message contains specified words:</p> <pre><code>sudo ./dist/tracee --log filter:msg=foo,bar\n</code></pre> <p>Filter logs using regular expressions against messages:</p> <pre><code>sudo ./dist/tracee --log filter:regex='^foo'\n</code></pre> <p>Filter logs originating from a specific package:</p> <pre><code>sudo ./dist/tracee --log filter:pkg=core\n</code></pre> <p>Filter logs originating from a specific file:</p> <pre><code>sudo ./dist/tracee --log filter:file=/pkg/cmd/flags/logger.go\n</code></pre> <p>Filter logs based on their severity level:</p> <pre><code>sudo ./dist/tracee --log filter:lvl=error\n</code></pre> <p>Filter logs originating from libbpf:</p> <pre><code>sudo ./dist/tracee --log filter:libbpf\n</code></pre> <p>All <code>--log filter</code> options can also be used with <code>--log filter-out</code> for the opposite behavior. For more information, please refer to the <code>--log</code> help in the CLI.</p>"},{"location":"docs/outputs/output-formats/","title":"Tracing Output Formats","text":"<p>The <code>--output</code> flag controls where and how Tracee will output events, by specifying <code>--output &lt;format&gt;:&lt;destination&gt;</code>.  You can use the <code>--output</code> flag multiple times to output events in multiple ways. To see all output options you can run <code>tracee --help output</code>.</p> <p>The following output formats are supported:</p> <ul> <li><code>table[:/path/to/file]</code> - output events in table format (default). The default path to file is stdout.</li> <li><code>table-verbose[:/path/to/file]</code> - output events in table format with extra fields per event. The default path to file is stdout.</li> <li><code>json[:/path/to/file]</code> - output events in json format. The default path to file is stdout.</li> <li><code>gob[:/path/to/file]</code> - output events in gob format. The default path to file is stdout.</li> <li><code>gotemplate=/path/to/template[:/path/to/file]</code> - output events formatted using a given gotemplate file. The default path to file is stdout.</li> <li><code>forward:http://url/fluent</code> - send events in json format using the Forward protocol to a Fluent receiver</li> <li><code>webhook:http://url/webhook</code> - send events in json format to the webhook url</li> <li><code>none</code> - ignore stream of events output, usually used with --capture</li> </ul>"},{"location":"docs/outputs/output-formats/#examples","title":"Examples","text":""},{"location":"docs/outputs/output-formats/#table","title":"Table","text":"<pre><code>sudo ./dist/tracee --output table --scope comm=bash --scope follow --events openat\n</code></pre> <pre><code>TIME             UID    COMM             PID     TID     RET              EVENT                ARGS\n11:21:51:254199  1000   exa              1639459 1639459 3                openat               dirfd: -100, pathname: /etc/ld.so.cache, flags: O_RDONLY|O_CLOEXEC, mode: 0\n11:21:51:254285  1000   exa              1639459 1639459 3                openat               dirfd: -100, pathname: /lib/x86_64-linux-gnu/libgcc_s.so.1, flags: O_RDONLY|O_CLOEXEC, mode: 0\n11:21:51:254418  1000   exa              1639459 1639459 3                openat               dirfd: -100, pathname: /lib/x86_64-linux-gnu/libm.so.6, flags: O_RDONLY|O_CLOEXEC, mode: 0\n\nEnd of events stream\nStats: {EventCount:3 EventsFiltered:0 NetCapCount:0 BPFLogsCount:0 ErrorCount:0 LostEvCount:0 LostWrCount:0 LostNtCapCount:0 LostBPFLogsCount:0}\n</code></pre>"},{"location":"docs/outputs/output-formats/#table-verbose","title":"Table (Verbose)","text":"<pre><code>```console\nsudo ./dist/tracee --output table-verbose --scope comm=bash --scope follow --events openat\n```\n\n```text\nTIME             UTS_NAME         CONTAINER_ID  MNT_NS       PID_NS       UID    COMM             PID     TID     PPID    RET              EVENT                ARGS\n11:22:16:970700  fujitsu                        4026531840   4026531836   1000   exa              1643836 1643836 3795408 3                openat               dirfd: -100, pathname: /etc/ld.so.cache, flags: 524288, mode: 0\n11:22:16:970783  fujitsu                        4026531840   4026531836   1000   exa              1643836 1643836 3795408 3                openat               dirfd: -100, pathname: /lib/x86_64-linux-gnu/libgcc_s.so.1, flags: 524288, mode: 0\n11:22:16:970913  fujitsu                        4026531840   4026531836   1000   exa              1643836 1643836 3795408 3                openat               dirfd: -100, pathname: /lib/x86_64-linux-gnu/libm.so.6, flags: 524288, mode: 0\n\nEnd of events stream\nStats: {EventCount:3 EventsFiltered:0 NetCapCount:0 BPFLogsCount:0 ErrorCount:0 LostEvCount:0 LostWrCount:0 LostNtCapCount:0 LostBPFLogsCount:0}\n```\n</code></pre>"},{"location":"docs/outputs/output-formats/#json","title":"JSON","text":"<pre><code>sudo ./dist/tracee --output json --scope comm=bash --scope follow --events openat\n</code></pre> <pre><code>{\"timestamp\":1657290245020855990,\"threadStartTime\":615325807626168,\"processorId\":22,\"processId\":1664936,\"cgroupId\":1,\"threadId\":1664936,\"parentProcessId\":3795408,\"hostProcessId\":1664936,\"hostThreadId\":1664936,\"hostParentProcessId\":3795408,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"exa\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"257\",\"eventName\":\"openat\",\"argsNum\":4,\"returnValue\":3,\"stackAddresses\":null,\"syscall\":\"openat\",\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"dirfd\",\"type\":\"int\",\"value\":-100},{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"/etc/ld.so.cache\"},{\"name\":\"flags\",\"type\":\"int\",\"value\":524288},{\"name\":\"mode\",\"type\":\"mode_t\",\"value\":0}]}\n{\"timestamp\":1657290245020940791,\"threadStartTime\":615325807626168,\"processorId\":22,\"processId\":1664936,\"cgroupId\":1,\"threadId\":1664936,\"parentProcessId\":3795408,\"hostProcessId\":1664936,\"hostThreadId\":1664936,\"hostParentProcessId\":3795408,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"exa\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"257\",\"eventName\":\"openat\",\"argsNum\":4,\"returnValue\":3,\"stackAddresses\":null,\"syscall\":\"openat\",\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"dirfd\",\"type\":\"int\",\"value\":-100},{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"/lib/x86_64-linux-gnu/libgcc_s.so.1\"},{\"name\":\"flags\",\"type\":\"int\",\"value\":524288},{\"name\":\"mode\",\"type\":\"mode_t\",\"value\":0}]}\n</code></pre> <p>Tip</p> <p>A good tip is to pipe tracee json output to jq tool, this way you can select fields, rename them, filter values, and many other things:</p> <pre><code>sudo ./dist/tracee -o json -o option:parse-arguments\n-trace comm=ping | jq -c '. | {eventId, hostName, processName,\nhostProcessId,UserId}'\n</code></pre>"},{"location":"docs/outputs/output-formats/#gob","title":"GOB","text":"<pre><code>sudo ./dist/tracee --output json --scope comm=bash --scope follow --events openat\n</code></pre>"},{"location":"docs/outputs/output-formats/#gotemplate","title":"GOTEMPLATE","text":"<p>When authoring a Go template the data source is Tracee's <code>trace.Event</code> struct, which is defined in <code>https://github.com/aquasecurity/tracee/blob/main/types/trace/trace.go#L15</code>.</p> <p>Go template can utilize helper functions from Sprig.</p> <p>For example templates, see tracee/cmd/tracee-rules/templates.</p>"},{"location":"docs/outputs/output-options/","title":"Tracing Output Options","text":"<p>Tracee supports different output options for customizing the way events are printed. For a complete list of available options, run <code>tracee --help output</code>.</p> <p>Available options:</p> <ol> <li> <p>option:stack-addresses </p> <p>Pick stack memory address from each event</p> <pre><code>sudo ./dist/tracee --output json --scope comm=bash --scope follow --events openat --output option:stack-addresses\n</code></pre> <pre><code>{\"timestamp\":1657291777566819000,\"threadStartTime\":616858353946737,\"processorId\":9,\"processId\":1948212,\"cgroupId\":1,\"threadId\":1948212,\"parentProcessId\":3795408,\"hostProcessId\":1948212,\"hostThreadId\":1948212,\"hostParentProcessId\":3795408,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"exa\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"257\",\"eventName\":\"openat\",\"argsNum\":4,\"returnValue\":3,\"stackAddresses\":[140395297729336,140395297614210],\"args\":[{\"name\":\"dirfd\",\"type\":\"int\",\"value\":-100},{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"/etc/ld.so.cache\"},{\"name\":\"flags\",\"type\":\"int\",\"value\":524288},{\"name\":\"mode\",\"type\":\"mode_t\",\"value\":0}]}\n</code></pre> </li> <li> <p>option:parse-arguments</p> <p>In order to have a better experience with the output provided by tracee, you may opt to parse event arguments to a human *readable format.</p> <pre><code>sudo ./dist/tracee --output json --scope comm=bash --scope follow --events security_file_open --output option:parse-arguments\n</code></pre> <pre><code>{\"timestamp\":1657292314817581101,\"threadStartTime\":617395606682013,\"processorId\":9,\"processId\":2045288,\"cgroupId\":1,\"threadId\":2045288,\"parentProcessId\":3795408,\"hostProcessId\":2045288,\"hostThreadId\":2045288,\"hostParentProcessId\":3795408,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"bash\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"722\",\"eventName\":\"security_file_open\",\"argsNum\":7,\"returnValue\":0,\"stackAddresses\":null,\"syscall\":\"execve\",\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"/usr/bin/exa\"},{\"name\":\"flags\",\"type\":\"string\",\"value\":\"O_RDONLY|O_LARGEFILE\"},{\"name\":\"dev\",\"type\":\"dev_t\",\"value\":271581185},{\"name\":\"inode\",\"type\":\"unsigned long\",\"value\":2493759},{\"name\":\"ctime\",\"type\":\"unsigned long\",\"value\":1653730234432691496},{\"name\":\"syscall_pathname\",\"type\":\"const char*\",\"value\":\"\"}]}\n{\"timestamp\":1657292314817690279,\"threadStartTime\":617395606682013,\"processorId\":9,\"processId\":2045288,\"cgroupId\":1,\"threadId\":2045288,\"parentProcessId\":3795408,\"hostProcessId\":2045288,\"hostThreadId\":2045288,\"hostParentProcessId\":3795408,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"bash\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"722\",\"eventName\":\"security_file_open\",\"argsNum\":7,\"returnValue\":0,\"stackAddresses\":null,\"syscall\":\"execve\",\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2\"},{\"name\":\"flags\",\"type\":\"string\",\"value\":\"O_RDONLY|O_LARGEFILE\"},{\"name\":\"dev\",\"type\":\"dev_t\",\"value\":271581185},{\"name\":\"inode\",\"type\":\"unsigned long\",\"value\":2752590},{\"name\":\"ctime\",\"type\":\"unsigned long\",\"value\":1653730015033811838},{\"name\":\"syscall_pathname\",\"type\":\"const char*\",\"value\":\"\"}]}\n</code></pre> <p>As you can see now, the files were opened with the O_RDONLY and O_LARGEFILE flags. The names of the flags are received instead of the real raw int value:</p> <pre><code>{\"name\":\"flags\",\"type\":\"string\",\"value\":\"O_RDONLY|O_LARGEFILE\"}\n</code></pre> </li> <li> <p>option:parse-arguments-fds</p> <p>In order to have a better experience with the output provided by tracee, you may opt to parse event fd arguments to be enriched with file paths. This option also enables <code>parse-arguments</code>.</p> <pre><code>sudo ./dist/tracee --output json --scope comm=bash --scope follow --events read --output option:parse-arguments-fds\n</code></pre> <pre><code>{\"timestamp\":1658356809979365547,\"threadStartTime\":11570447751601,\"processorId\":1,\"processId\":239413,\"cgroupId\":10575,\"threadId\":239413,\"parentProcessId\":91515,\"hostProcessId\":239413,\"hostThreadId\":239413,\"hostParentProcessId\":91515,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"cat\",\"hostName\":\"ubuntu-impish\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"0\",\"eventName\":\"read\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":null,\"syscall\":\"read\",\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"fd\",\"type\":\"int\",\"value\":\"3=/etc/locale.alias\"},{\"name\":\"buf\",\"type\":\"void*\",\"value\":93921853269152},{\"name\":\"count\",\"type\":\"size_t\",\"value\":4096}]}\n{\"timestamp\":1658356809979748006,\"threadStartTime\":11570447751601,\"processorId\":1,\"processId\":239413,\"cgroupId\":10575,\"threadId\":239413,\"parentProcessId\":91515,\"hostProcessId\":239413,\"hostThreadId\":239413,\"hostParentProcessId\":91515,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"cat\",\"hostName\":\"ubuntu-impish\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"0\",\"eventName\":\"read\",\"argsNum\":3,\"returnValue\":1867,\"stackAddresses\":null,\"syscall\":\"read\",\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"fd\",\"type\":\"int\",\"value\":\"3=/etc/passwd\"},{\"name\":\"buf\",\"type\":\"void*\",\"value\":139658814046208},{\"name\":\"count\",\"type\":\"size_t\",\"value\":131072}]}\n</code></pre> <p>As you can see now, the value of fd is enriched with its file path following the <code>\"fd=filepath\"</code> format (string type in JSON).</p> <pre><code>{\"name\":\"fd\",\"type\":\"int\",\"value\":\"3=/etc/locale.alias\"}\n...\n{\"name\":\"fd\",\"type\":\"int\",\"value\":\"3=/etc/passwd\"}\n</code></pre> </li> <li> <p>option:exec-env</p> <p>Sometimes it is also important to know the execution environment variables whenever an event is detected, specially when detecting execve event.</p> <pre><code>sudo ./dist/tracee --output json --scope comm=bash --scope follow --events execve --output option:parse-arguments --output option:exec-env\n</code></pre> <pre><code>{\"timestamp\":1657294974430672155,\"threadStartTime\":620055219867435,\"processorId\":11,\"processId\":2531912,\"cgroupId\":1,\"threadId\":2531912,\"parentProcessId\":2490011,\"hostProcessId\":2531912,\"hostThreadId\":2531912,\"hostParentProcessId\":2490011,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"bash\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"59\",\"eventName\":\"execve\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":null,\"syscall\":\"execve\",\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"/bin/ls\"},{\"name\":\"argv\",\"type\":\"const char*const*\",\"value\":[\"ls\"]},{\"name\":\"envp\",\"type\":\"const char*const*\",\"value\":[\"SHELL=/bin/bash\",\"COLORTERM=truecolor\",\"LESS=-RF --mouse\",\"HISTCONTROL=ignoreboth\",\"HISTSIZE=1000000\",\"DEBFULLNAME=Rafael David Tinoco\",\"EDITOR=nvim\",\"PWD=/home/rafaeldtinoco/work/ebpf/tracee\",\"LOGNAME=rafaeldtinoco\",\"DEB_BUILD_PROFILES=parallel=36 nocheck nostrip noudeb doc\",\"LINES=82\",\"HOME=/home/rafaeldtinoco\",\"LANG=C.UTF-8\",\"COLUMNS=106\",\"MANROFFOPT=-c\",\"DEBEMAIL=rafaeldtinoco@ubuntu.com\",\"LC_TERMINAL=iTerm2\",\"PROMPT_COMMAND=echo -ne \\\"\\\\033]0;$what\\\\007\\\"; history -a\",\"BAT_THEME=GitHub\",\"TERM=screen-256color\",\"USER=rafaeldtinoco\",\"GIT_PAGER=batcat --theme=\\\"GitHub\\\" -p --pager=less --tabs 0\",\"MANPAGER=bash -c 'col -bx | batcat --theme=\\\"GitHub\\\" -l man -p'\",\"LC_TERMINAL_VERSION=3.5.0beta5\",\"DEB_BUILD_OPTIONS=parallel=36 nocheck nostrip noudeb doc\",\"SHLVL=2\",\"PAGER=batcat --theme=\\\"GitHub\\\" -p --pager=less --tabs 0\",\"BAT_STYLE=plain\",\"PROMPT_DIRTRIM=2\",\"SYSTEMD_PAGER=batcat --theme=\\\"GitHub\\\" -p --pager=less --tabs 0\",\"LC_CTYPE=C.UTF-8\",\"LESS_HISTFILE=/dev/null\",\"PS1=\\\\u@\\\\h \\\\w $ \",\"PATH=/home/rafaeldtinoco/bin:/home/rafaeldtinoco/go/bin:.:/sbin:/bin:/usr/sbin:/usr/bin:/snap/bin:/snap/sbin:/usr/local/bin:/usr/local/sbin:/usr/games/\",\"HISTFILESIZE=1000000\",\"DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus\",\"SSH_TTY=/dev/pts/3\",\"OLDPWD=/home/rafaeldtinoco\",\"_=/bin/ls\"]}]}\n</code></pre> <p>As  you can see, from the execve event we can also see the process environment variables in place:</p> <pre><code>{\"name\":\"envp\",\"type\":\"const char*const*\",\"value\":[\"SHELL=/bin/bash\",\"COLORTERM=truecolor\",\"LESS=-RF --mouse\",\"HISTCONTROL=ignoreboth\",\"HISTSIZE=1000000\",\"DEBFULLNAME=Rafael David Tinoco\",\"EDITOR=nvim\",\"PWD=/home/rafaeldtinoco/work/ebpf/tracee\",\"LOGNAME=rafaeldtinoco\",\"DEB_BUILD_PROFILES=parallel=36 nocheck nostrip noudeb doc\",\"LINES=82\",\"HOME=/home/rafaeldtinoco\",\"LANG=C.UTF-8\",\"COLUMNS=106\",\"MANROFFOPT=-c\",\"DEBEMAIL=rafaeldtinoco@ubuntu.com\",\"LC_TERMINAL=iTerm2\",\"PROMPT_COMMAND=echo -ne \\\"\\\\033]0;$what\\\\007\\\"; history -a\",\"BAT_THEME=GitHub\",\"TERM=screen-256color\",\"USER=rafaeldtinoco\",\"GIT_PAGER=batcat --theme=\\\"GitHub\\\" -p --pager=less --tabs 0\",\"MANPAGER=bash -c 'col -bx | batcat --theme=\\\"GitHub\\\" -l man -p'\",\"LC_TERMINAL_VERSION=3.5.0beta5\",\"DEB_BUILD_OPTIONS=parallel=36 nocheck nostrip noudeb doc\",\"SHLVL=2\",\"PAGER=batcat --theme=\\\"GitHub\\\" -p --pager=less --tabs 0\",\"BAT_STYLE=plain\",\"PROMPT_DIRTRIM=2\",\"SYSTEMD_PAGER=batcat --theme=\\\"GitHub\\\" -p --pager=less --tabs 0\",\"LC_CTYPE=C.UTF-8\",\"LESS_HISTFILE=/dev/null\",\"PS1=\\\\u@\\\\h \\\\w $ \",\"PATH=/home/rafaeldtinoco/bin:/home/rafaeldtinoco/go/bin:.:/sbin:/bin:/usr/sbin:/usr/bin:/snap/bin:/snap/sbin:/usr/local/bin:/usr/local/sbin:/usr/games/\",\"HISTFILESIZE=1000000\",\"DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus\",\"SSH_TTY=/dev/pts/3\",\"OLDPWD=/home/rafaeldtinoco\",\"_=/bin/ls\"]}\n</code></pre> </li> <li> <p>option:exec-hash</p> <p>This is a special output option for sched_process_exec so user can get the file hash and process ctime (particularly interesting if you would like to compare executed binaries from a list of known hashes, for example).</p> <pre><code>sudo ./dist/tracee --output json --scope comm=bash --scope follow --events sched_process_exec --output option:parse-arguments --output option:exec-hash\n</code></pre> <pre><code>{\"timestamp\":1657295236470126167,\"threadStartTime\":620317257297855,\"processorId\":3,\"processId\":2578324,\"cgroupId\":1,\"threadId\":2578324,\"parentProcessId\":2578238,\"hostProcessId\":2578324,\"hostThreadId\":2578324,\"hostParentProcessId\":2578238,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"exa\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"707\",\"eventName\":\"sched_process_exec\",\"argsNum\":14,\"returnValue\":0,\"stackAddresses\":null,\"syscall\":\"execve\",\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"cmdpath\",\"type\":\"const char*\",\"value\":\"/bin/exa\"},{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"/usr/bin/exa\"},{\"name\":\"argv\",\"type\":\"const char**\",\"value\":[\"exa\",\"--color=auto\"]},{\"name\":\"dev\",\"type\":\"dev_t\",\"value\":271581185},{\"name\":\"inode\",\"type\":\"unsigned long\",\"value\":2493759},{\"name\":\"invoked_from_kernel\",\"type\":\"int\",\"value\":0},{\"name\":\"ctime\",\"type\":\"unsigned long\",\"value\":1653730234432691496},{\"name\":\"stdin_type\",\"type\":\"string\",\"value\":\"S_IFCHR\"},{\"name\":\"inode_mode\",\"type\":\"umode_t\",\"value\":33261},{\"name\":\"interp\",\"type\":\"const char*\",\"value\":\"/bin/exa\"},{\"name\":\"interpreter_pathname\",\"type\":\"const char*\",\"value\":\"/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2\"},{\"name\":\"interpreter_dev\",\"type\":\"dev_t\",\"value\":271581185},{\"name\":\"ineterpreter_inode\",\"type\":\"unsigned long\",\"value\":2752590},{\"name\":\"sha256\",\"type\":\"const char*\",\"value\":\"\"}]}\n</code></pre> <p>At the end of the event, you will also get information about the loader </p> </li> </ol>"},{"location":"docs/policies/","title":"Overview","text":"<p>In this section you can find the reference documentation for Tracee's policies.</p> <p>A policy is a yaml document where you can specify a scope and associate it with a set of rules. A scope defines the workloads to which the policy applies. A rule defines events to be matched and actions to take on them.</p> <p>You can load multiple (up to 64) policies into Tracee using the --policy flag providing a path to the policy file.</p> <p>Following is a sample policy:</p> <pre><code>name: overview policy\ndescription: sample overview policy\nscope:\n- global\nrules:\n- event: dropped_executable\n- event: security_file_open\nfilters:\n- args.pathname=/tmp/*\n- event: sched_process_exec\nfilters: - uid=0\n- event: close\nfilters:\n- retval!=0\n</code></pre> <p>This policy applies to any workload (global) and will log the dropped_executable, security_file_open, sched_process_exec and close events. Several filters are set to log only specific events:</p> <ol> <li> <p>An argument filter (args.pathname) is set on the security_file_open event to log only files which were opened from the /tmp directory</p> </li> <li> <p>A context filter (uid) is set on the sched_process_exec event to log only processes executed by the root user (uid 0)</p> </li> <li> <p>A return value filter (retval) is set on the close event to log only failed close syscalls</p> </li> </ol> <p>While specifying event filters is optional, policies must have the <code>name</code>, <code>description</code>, <code>scope</code> and <code>rules</code> fields.</p> <p>Note</p> <p>A current limitation is that only one rule can be defined per any event type in a policy</p> <p>More information about defining a scope and the available filters can be found in the next sections.</p>"},{"location":"docs/policies/rules/","title":"Rules","text":"<p>Rules determine which events a policy should trace. </p>"},{"location":"docs/policies/rules/#events","title":"Events","text":"<p>An event can match all occurrences of events for a specific scope, or specific events depending on its filters. Events support three types of filters: <code>context</code>, <code>arguments</code> and <code>return value</code>. </p>"},{"location":"docs/policies/rules/#context-filters","title":"Context filters","text":"<p>Context is data which is collected along the event. They can be filtered like:</p> <pre><code>name: sample_context_filter\ndescription: sample context filter\nscope:\n- global\nrules:\nevent: sched_process_exec\nfilters:\n- pid=1000\n</code></pre> <p>The context filters supported are:</p>"},{"location":"docs/policies/rules/#p-pid-processid","title":"p, pid, processId","text":"<pre><code>event: sched_process_exec\nfilters:\n- pid=1000\n</code></pre>"},{"location":"docs/policies/rules/#tid-threadid","title":"tid, threadId","text":"<pre><code>event: sched_process_exec\nfilters:\n- tid=13819\n</code></pre>"},{"location":"docs/policies/rules/#ppid-parentprocessid","title":"ppid, parentProcessId","text":"<pre><code>event: sched_process_exec\nfilters:\n- ppid=1000\n</code></pre>"},{"location":"docs/policies/rules/#hosttid-hostthreadid","title":"hostTid, hostThreadId","text":"<pre><code>event: sched_process_exec\nfilters:\n- hostTid=1000\n</code></pre>"},{"location":"docs/policies/rules/#hostpid","title":"hostPid","text":"<pre><code>event: sched_process_exec\nfilters:\n- hostPid=1000\n</code></pre>"},{"location":"docs/policies/rules/#hostparentprocessid","title":"hostParentProcessId","text":"<pre><code>event: sched_process_exec\nfilters:\n- hostParentProcessId=1\n</code></pre>"},{"location":"docs/policies/rules/#uid-userid","title":"uid, userId","text":"<pre><code>event: sched_process_exec\nfilters:\n- uid=0\n</code></pre>"},{"location":"docs/policies/rules/#mntns-mountnamespace","title":"mntns, mountNamespace","text":"<pre><code>event: sched_process_exec\nfilters:\n- mntns=4026531840\n</code></pre>"},{"location":"docs/policies/rules/#pidns-pidnamespace","title":"pidns, pidNamespace","text":"<pre><code>event: sched_process_exec\nfilters:\n- pidns=4026531836\n</code></pre>"},{"location":"docs/policies/rules/#comm-processname","title":"comm, processName","text":"<pre><code>event: sched_process_exec\nfilters:\n- comm=uname\n</code></pre>"},{"location":"docs/policies/rules/#hostname","title":"hostName","text":"<pre><code>event: sched_process_exec\nfilters:\n- hostName=hostname\n</code></pre>"},{"location":"docs/policies/rules/#cgroupid","title":"cgroupId","text":"<pre><code>event: sched_process_exec\nfilters:\n- cgroupId=5247\n</code></pre>"},{"location":"docs/policies/rules/#container","title":"container","text":"<pre><code>event: sched_process_exec\nfilters:\n- container=66c2778945e29dfd36532d63c38c2ce4ed1\n</code></pre>"},{"location":"docs/policies/rules/#containerid","title":"containerId","text":"<pre><code>event: sched_process_exec\nfilters:\n- containerId=66c2778945e29dfd36532d63c38c2ce4ed1\n</code></pre>"},{"location":"docs/policies/rules/#containerimage","title":"containerImage","text":"<pre><code>event: sched_process_exec\nfilters:\n- containerImage=ubuntu:latest\n</code></pre>"},{"location":"docs/policies/rules/#containername","title":"containerName","text":"<pre><code>event: sched_process_exec\nfilters:\n- containerName=test\n</code></pre>"},{"location":"docs/policies/rules/#podname","title":"podName","text":"<pre><code>event: sched_process_exec\nfilters:\n- podName=daemonset/test\n</code></pre>"},{"location":"docs/policies/rules/#podnamespace","title":"podNamespace","text":"<pre><code>event: sched_process_exec\nfilters:\n- podNamespace=production\n</code></pre>"},{"location":"docs/policies/rules/#poduid","title":"podUid","text":"<pre><code>event: sched_process_exec\nfilters:\n- podUid=66c2778945e29dfd36532d63c38c2ce4ed16a002c44cb254b8e\n</code></pre>"},{"location":"docs/policies/rules/#argument-filter","title":"Argument filter","text":"<p>Events have arguments, which can be filtered. </p> <pre><code>name: sample_argument_filter\ndescription: sample argument filter\nscope:\n- global\nrules:\nevent: security_file_open\nfilters:\n- args.pathname=/tmp*\n</code></pre> <p>Arguments can be found on the respective event definition, in this case security_file_open, or the user can test the event output in CLI before defining a policy, e.g:</p> <pre><code>tracee -e security_file_open --output json\n</code></pre> <pre><code>{\"timestamp\":1680182976364916505,\"threadStartTime\":1680179107675006774,\"processorId\":0,\"processId\":676,\"cgroupId\":5247,\"threadId\":676,\"parentProcessId\":1,\"hostProcessId\":676,\"hostThreadId\":676,\"hostParentProcessId\":1,\"userId\":131,\"mountNamespace\":4026532574,\"pidNamespace\":4026531836,\"processName\":\"systemd-oomd\",\"hostName\":\"josedonizetti-x\",\"container\":{},\"kubernetes\":{},\"eventId\":\"730\",\"eventName\":\"security_file_open\",\"matchedPolicies\":[\"\"],\"argsNum\":6,\"returnValue\":0,\"syscall\":\"openat\",\"stackAddresses\":null,\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"/proc/meminfo\"},{\"name\":\"flags\",\"type\":\"string\",\"value\":\"O_RDONLY|O_LARGEFILE\"},{\"name\":\"dev\",\"type\":\"dev_t\",\"value\":45},{\"name\":\"inode\",\"type\":\"unsigned long\",\"value\":4026532041},{\"name\":\"ctime\",\"type\":\"unsigned long\",\"value\":1680179108391999988},{\"name\":\"syscall_pathname\",\"type\":\"const char*\",\"value\":\"/proc/meminfo\"}]}\n</code></pre>"},{"location":"docs/policies/rules/#return-value-filter","title":"Return value filter","text":"<p>Return values can also be filtered.</p> <pre><code>name: sample_return_value\ndescription: sample return filter\nscope:\n- global\nrules:\nevent: close\nfilters:\n- retval!=0\n</code></pre>"},{"location":"docs/policies/scopes/","title":"Scopes","text":"<p>Scope defines the workload a policy will be observing. The supported scopes are:</p>"},{"location":"docs/policies/scopes/#global","title":"global","text":"<p>Events are collected from the whole host: <pre><code>scope:\n- global\n</code></pre></p>"},{"location":"docs/policies/scopes/#uid","title":"uid","text":"<p>Events are collected from the specific user id:</p> <pre><code>scope:\n- uid=0\n</code></pre>"},{"location":"docs/policies/scopes/#pid","title":"pid","text":"<p>Events are collected from the specific pid:</p> <pre><code>scope:\n- pid=1000\n</code></pre>"},{"location":"docs/policies/scopes/#mntns","title":"mntns","text":"<p>Events are collected from the mount namespace:</p> <pre><code>scope:\n- mntns=4026531840\n</code></pre>"},{"location":"docs/policies/scopes/#pidns","title":"pidns","text":"<p>Events are collected from the pid namespace:</p> <pre><code>scope:\n- pidns=4026531836\n</code></pre>"},{"location":"docs/policies/scopes/#uts","title":"uts","text":"<p>Events are collected from uts namespace:</p> <pre><code>scope:\n- uts=ab356bc4dd554\n</code></pre>"},{"location":"docs/policies/scopes/#comm","title":"comm","text":"<p>Events are collected from process named <code>uname</code>:</p> <pre><code>scope:\n- comm=uname\n</code></pre>"},{"location":"docs/policies/scopes/#container","title":"container","text":"<p>Events are collected only from containers:</p> <pre><code>scope:\n- container\n</code></pre>"},{"location":"docs/policies/scopes/#container_1","title":"!container","text":"<p>Events are collected from everything but containers:</p> <pre><code>scope:\n- !container\n</code></pre>"},{"location":"docs/policies/scopes/#tree","title":"tree","text":"<p>Events are collected from process tree:</p> <pre><code>scope:\n- tree=1000\n</code></pre>"},{"location":"docs/policies/scopes/#binary-bin","title":"binary, bin","text":"<p>Events are collected from binary:</p> <pre><code>scope:\n- binary=/usr/bin/dig\n</code></pre>"},{"location":"docs/policies/scopes/#follow","title":"follow","text":"<p>Events collected follow process children:</p> <pre><code>scope:\n- follow\n</code></pre>"},{"location":"getting-started/kubernetes-quickstart/","title":"Getting started with tracee in Kubernetes","text":"<p>This guide was tested using minikube, an easy way to run Kubernetes on your development machine, but should work the same with most other Kubernetes clusters.</p>"},{"location":"getting-started/kubernetes-quickstart/#prerequisites","title":"Prerequisites","text":"<ul> <li>minikube - see installation instructions here. Note that Tracee doesn't support ARM/Apple silicon yet.</li> <li>Helm - see installation instructions and dependencies here.</li> </ul> Verify step <pre><code>minikube start &amp;&amp; kubectl get po -A\n</code></pre> <pre><code>NAMESPACE     NAME                               READY   STATUS    RESTARTS   AGE \nkube-system   coredns-565d847f94-kd9xx           1/1     Running   0          15s \nkube-system   etcd-minikube                      1/1     Running   0          26s \nkube-system   kube-apiserver-minikube            1/1     Running   0          26s \nkube-system   kube-controller-manager-minikube   1/1     Running   0          26s \nkube-system   kube-proxy-cvqjm                   1/1     Running   0          15s \nkube-system   kube-scheduler-minikube            1/1     Running   0          26s \nkube-system   storage-provisioner                1/1     Running   0          15s \n</code></pre>"},{"location":"getting-started/kubernetes-quickstart/#install-tracee","title":"Install Tracee","text":"<p>The provided Helm chart will install Tracee as a DaemonSet so that it's tracing all the nodes in the cluster.</p> <pre><code>helm repo add aqua https://aquasecurity.github.io/helm-charts/\nhelm repo update\nhelm install tracee aqua/tracee --namespace tracee-system --create-namespace\n</code></pre> Verify step <pre><code>kubectl get pods\n</code></pre> <pre><code>NAME           READY   STATUS    RESTARTS   AGE \ntracee-fcjmp   1/1     Running   0          4m11s\n</code></pre>"},{"location":"getting-started/kubernetes-quickstart/#interacting-with-tracee","title":"Interacting with Tracee","text":"<p>Once installed, Tracee immediately starts producing system activity events, such as processes and containers activity, network activity, and more. To see the events that Tracee produces, use can use the <code>kubectl logs</code> command.</p> <pre><code>kubectl logs -f daemonset/tracee -n tracee-system\n</code></pre> <p>In production scenario you would want to collect and ship the events to a persistent storage.</p>"},{"location":"getting-started/kubernetes-quickstart/#exercising-a-security-event","title":"Exercising a security event","text":"<p>To see Tracee in action, let's simulate a security event. We'll do a \"file-less\" execution, which is a common evasion technique used by some malware, and is flagged by Tracee as suspicious activity. To simulate this, we'll use the tracee-tester example image it will simulate the suspicious activity without harming your environment.</p> <pre><code>kubectl run tracee-tester --image=aquasec/tracee-tester -- TRC-105\n</code></pre> <p>You can see the event in the logs:</p> <pre><code>kubectl -n tracee-system logs -f ds/tracee | grep fileless_execution \n</code></pre> Result <pre><code>{\n\"timestamp\": 1671119128028881186,\n\"threadStartTime\": 883410317491,\n\"processorId\": 1,\n\"processId\": 9,\n\"cgroupId\": 8972,\n\"threadId\": 9,\n\"parentProcessId\": 8,\n\"hostProcessId\": 6136,\n\"hostThreadId\": 6136,\n\"hostParentProcessId\": 6135,\n\"userId\": 0,\n\"mountNamespace\": 4026532816,\n\"pidNamespace\": 4026532817,\n\"processName\": \"3\",\n\"hostName\": \"tracee-tester\",\n\"containerId\": \"c7e3c75bf167348bf79262bf6e688088f9b4d54ebcc79464f40b52b80c73ff55\",\n\"containerImage\": \"docker.io/aquasec/tracee:latest\",\n\"containerName\": \"tracee\",\n\"podName\": \"tracee-wk8wh\",\n\"podNamespace\": \"tracee-system\",\n\"podUID\": \"5cb83966-e274-48f1-89fb-25bd748d2773\",\n\"eventId\": \"6023\",\n\"eventName\": \"fileless_execution\",\n\"argsNum\": 15,\n\"returnValue\": 0,\n\"stackAddresses\": null,\n\"syscall\": \"execve\",\n\"contextFlags\": {\n\"containerStarted\": true,\n\"isCompat\": false\n},\n\"args\": [\n{\n\"name\": \"cmdpath\",\n\"type\": \"const char*\",\n\"value\": \"/dev/fd/3\"\n},\n{\n\"name\": \"pathname\",\n\"type\": \"const char*\",\n\"value\": \"memfd: \"\n},\n{\n\"name\": \"dev\",\n\"type\": \"dev_t\",\n\"value\": 1\n},\n{\n\"name\": \"inode\",\n\"type\": \"unsigned long\",\n\"value\": 1033\n},\n{\n\"name\": \"ctime\",\n\"type\": \"unsigned long\",\n\"value\": 1671119128024105994\n},\n{\n\"name\": \"inode_mode\",\n\"type\": \"umode_t\",\n\"value\": 33279\n},\n{\n\"name\": \"interpreter_pathname\",\n\"type\": \"const char*\",\n\"value\": \"/lib/x86_64-linux-gnu/ld-2.28.so\"\n},\n{\n\"name\": \"interpreter_dev\",\n\"type\": \"dev_t\",\n\"value\": 234\n},\n{\n\"name\": \"interpreter_inode\",\n\"type\": \"unsigned long\",\n\"value\": 1704546\n},\n{\n\"name\": \"interpreter_ctime\",\n\"type\": \"unsigned long\",\n\"value\": 1671118551446622730\n},\n{\n\"name\": \"argv\",\n\"type\": \"const char**\",\n\"value\": [\n\"\"\n]\n},\n{\n\"name\": \"interp\",\n\"type\": \"const char*\",\n\"value\": \"/dev/fd/3\"\n},\n{\n\"name\": \"stdin_type\",\n\"type\": \"string\",\n\"value\": \"S_IFCHR\"\n},\n{\n\"name\": \"stdin_path\",\n\"type\": \"char*\",\n\"value\": \"/dev/null\"\n},\n{\n\"name\": \"invoked_from_kernel\",\n\"type\": \"int\",\n\"value\": 0\n}\n]\n}\n</code></pre>"},{"location":"getting-started/kubernetes-quickstart/#next-steps","title":"Next steps","text":"<p>Familiarize with the different events, filters, and configuration options in the documentation.</p> <p>Read other tutorials.</p> <p>For help and support, feel free to use GitHub Discussions.</p>"},{"location":"getting-started/installing/docker/","title":"Docker","text":"<p>Tracee, as a runtime detection tool, is built and distributed as a docker container. Tracee, as an introspection tool, can either be used as a docker image, binary artifacts or OS packages.</p> <p>Check Getting Started for how to run tracee.</p>"},{"location":"getting-started/installing/getting/","title":"Getting Tracee","text":"<p>You're able to use tracee by any of these means:</p> <ol> <li>docker hub container image</li> <li>distributed binaries (<code>tracee.tar.gz</code>).</li> <li>building from the source</li> <li>building environment</li> <li>building container images</li> <li>building OS packages</li> </ol>"},{"location":"getting-started/installing/kubernetes/","title":"Install Tracee on Kubernetes","text":"<p>In the deploy/ directory you will find Yaml files to deploy Tracee in a Kubernetes environment either with Helm or with a static yaml.</p> <p>Tip</p> <p>The preferred way to deploy Tracee is through its Helm chart!</p> <ol> <li> <p>Install Tracee using Helm</p> <ol> <li> <p>Add Aqua chart repository:</p> <pre><code>helm repo add aqua https://aquasecurity.github.io/helm-charts/\nhelm repo update\n</code></pre> <p>or clone the Helm chart:</p> <pre><code>git clone --depth 1 --branch v0.16.0-rc-14-gd8fa9648e https://github.com/aquasecurity/tracee.git\ncd tracee\n</code></pre> </li> <li> <p>Install the chart from the Aqua chart repository:</p> <pre><code>helm install tracee aqua/tracee \\\n        --namespace tracee-system --create-namespace\n</code></pre> <p>or install the Helm chart from a local directory:</p> <pre><code>helm install tracee ./deploy/helm/tracee \\\n        --namespace tracee-system --create-namespace\n</code></pre> </li> </ol> </li> <li> <p>Install Tracee Manually</p> <p>To install Tracee </p> <pre><code>kubectl create namespace tracee-system\nkubectl create -n tracee-system \\\n    -f https://raw.githubusercontent.com/aquasecurity/tracee/main/deploy/kubernetes/tracee/tracee.yaml\n</code></pre> </li> </ol>"},{"location":"getting-started/installing/kubernetes/#platform-support","title":"Platform Support","text":"<p>This approach assumes that host nodes have either BTF available or kernel headers available under conventional location. See Tracee's prerequisites for more info. For the major Kubernetes platforms this should work out-of-the-box, including GKE, EKS, AKS, minikube.</p>"},{"location":"getting-started/installing/override-os-files/","title":"Special: Overriding OS needed files","text":"<p>Tracee supports eBPF CO-RE (Compile Once - Run Everywhere) technology and, because of that, it might need some information about the Linux OS it is running at. Tracee, through libbpfgo, must have access to /etc/os-release file AND either /boot/config-$(uname-r) OR /proc/config.gz files (KernelConfig API at helpers/kernel_config).</p> <p>Note that, despite having this need, tracee will try to execute as CO-RE eBPF program in any environment it is executed.</p>"},{"location":"getting-started/installing/override-os-files/#os-release","title":"OS-RELEASE","text":"<p>Tracee will show you collected information about the running Linux OS with the <code>--log debug</code> argument:</p> <pre><code>sudo ./dist/tracee --log debug --scope uid=1000 --scope pid=new --events execve\n</code></pre> <pre><code>{\"level\":\"debug\",\"ts\":1670976393.7308447,\"msg\":\"osinfo\",\"ARCH\":\"x86_64\",\"PRETTY_NAME\":\"\\\"Manjaro Linux\\\"\",\"ID\":\"manjaro\",\"ID_LIKE\":\"arch\",\"BUILD_ID\":\"rolling\",\"KERNEL_RELEASE\":\"5.15.81-1-MANJARO\",\"pkg\":\"urfave\",\"file\":\"urfave.go\",\"line\":53}\n{\"level\":\"debug\",\"ts\":1670976393.73088,\"msg\":\"RuntimeSockets: failed to register default\",\"socket\":\"containerd\",\"error\":\"failed to register runtime socket stat /var/run/containerd/containerd.sock: no such file or directory\",\"pkg\":\"flags\",\"file\":\"containers.go\",\"line\":45}\n{\"level\":\"debug\",\"ts\":1670976393.730894,\"msg\":\"RuntimeSockets: failed to register default\",\"socket\":\"crio\",\"error\":\"failed to register runtime socket stat /var/run/crio/crio.sock: no such file or directory\",\"pkg\":\"flags\",\"file\":\"containers.go\",\"line\":45}\n{\"level\":\"debug\",\"ts\":1670976393.7309017,\"msg\":\"RuntimeSockets: failed to register default\",\"socket\":\"podman\",\"error\":\"failed to register runtime socket stat /var/run/podman/podman.sock: no such file or directory\",\"pkg\":\"flags\",\"file\":\"containers.go\",\"line\":45}\n{\"level\":\"debug\",\"ts\":1670976393.7310617,\"msg\":\"osinfo\",\"security_lockdown\":\"none\",\"pkg\":\"urfave\",\"file\":\"urfave.go\",\"line\":116}\n{\"level\":\"debug\",\"ts\":1670976393.733237,\"msg\":\"BTF\",\"bpfenv\":false,\"btfenv\":false,\"vmlinux\":true,\"pkg\":\"initialize\",\"file\":\"bpfobject.go\",\"line\":40}\n{\"level\":\"debug\",\"ts\":1670976393.7332687,\"msg\":\"BPF: using embedded BPF object\",\"pkg\":\"initialize\",\"file\":\"bpfobject.go\",\"line\":69}\n{\"level\":\"debug\",\"ts\":1670976393.7355402,\"msg\":\"unpacked CO:RE bpf object file into memory\",\"pkg\":\"initialize\",\"file\":\"bpfobject.go\",\"line\":144}\nTIME             UID    COMM             PID     TID     RET              EVENT                ARGS\n21:06:35:386730  1000   gio-launch-desk  743960  743960  0                execve               pathname: /home/gg/.local/bin/gnome-terminal, argv: [gnome-terminal]\n...\n</code></pre> <p>BUT os-release file might not exist:</p> <p>Because you're running in a distribution that does not have /etc/os-release, or because you're running inside a container that does not support it, you may face the following error:</p> <pre><code>sudo ./dist/tracee --log debug --scope uid=1000 --scope pid=new --events execve\n</code></pre> <pre><code>{\"level\":\"debug\",\"ts\":1670976530.5685039,\"msg\":\"osinfo\", \"warning: os-release file could not be found\",\"error\",\"open /etc/os-release: no such file or directory\",\"pkg\":\"urfave\",\"file\":\"urfave.go\",\"line\":33}\n...\nTIME             UID    COMM             PID     TID     RET              EVENT                ARGS\n...\n\nEnd of events stream\nStats: {EventCount:1 ErrorCount:0 LostEvCount:0 LostWrCount:0 LostNtCount:0}\n</code></pre> <p>Note</p> <p>But do note that tracee shall continue working (informing only the KERNEL_RELEASE OSInfo option).</p> <p>If you need to override the underlying Linux OS information, because you're running inside a container that already has /etc/os-release file, for example, you may create another os-release file and inform tracee by using LIBBPFGO's environment variable <code>LIBBPFGO_OSRELEASE_FILE</code>:</p> <pre><code>sudo LIBBPFGO_OSRELEASE_FILE=/etc/os-release.orig ./dist/tracee --scope uid=1000 --scope pid=new --events execve\n</code></pre> <p>If you're running tracee inside a docker container, you can simply bind mount <code>/etc/os-release</code> from the host as <code>/etc/os-release-host</code> into the guest.</p>"},{"location":"getting-started/installing/override-os-files/#kconfig","title":"KCONFIG","text":"<p>Tracee needs access to kconfig file (/proc/config.gz OR /boot/config-$(uname -r)) in order to:</p> <ol> <li>Check if the kernel of your running environment supports needed eBPF features</li> <li>Provide kconfig variables to its eBPF counter-part (so eBPF program take decisions)</li> </ol> <p>Warning</p> <p>Tracee should NOT fail when it cannot find a kconfig file:</p> <pre><code>sudo ./dist/tracee --log debug --scope uid=1000 --scope pid=new --events execve\n</code></pre> <pre><code>{\"level\":\"debug\",\"ts\":1670976875.7735798,\"msg\":\"osinfo\",\"VERSION\":\"\\\"20.04.5 LTS (Focal Fossa)\\\"\",\"ID\":\"ubuntu\",\"ID_LIKE\":\"debian\",\"PRETTY_NAME\":\"\\\"Ubuntu 20.04.5 LTS\\\"\",\"VERSION_ID\":\"\\\"20.04\\\"\",\"VERSION_CODENAME\":\"focal\",\"KERNEL_RELEASE\":\"5.4.0-91-generic\",\"ARCH\":\"x86_64\",\"pkg\":\"urfave\",\"file\":\"urfave.go\",\"line\":53}\n...\n{\"level\":\"warn\",\"ts\":1670976875.7762284,\"msg\":\"KConfig: could not check enabled kconfig features\",\"error\":\"could not read /boot/config-5.4.0-91-generic: stat /boot/config-5.4.0-91-generic: no such file or directory\"}\n{\"level\":\"warn\",\"ts\":1670976875.7762842,\"msg\":\"KConfig: assuming kconfig values, might have unexpected behavior\"}\n...\n{\"level\":\"debug\",\"ts\":1670976876.0801573,\"msg\":\"KConfig: warning: assuming kconfig values, might have unexpected behavior\",\"pkg\":\"initialization\",\"file\":\"kconfig.go\",\"line\":30}\nTIME             UID    COMM             PID     TID     RET              EVENT                ARGS\n...\n</code></pre> <p>but do have in mind it is assuming some things from the host environment and its behavior might have inconsistencies.</p> <p>If you are running tracee in an environment that does not have a kconfig file (nor /proc/config.gz support), it is recommended that you provide the host kconfig file location to tracee through the <code>LIBBPFGO_KCONFIG_FILE</code> environment variable:</p> <pre><code>sudo LIBBPFGO_KCONFIG_FILE=/boot/config-other -E ./dist/tracee --log debug --scope uid=1000 --scope pid=new --events execve\n</code></pre> <pre><code>{\"level\":\"debug\",\"ts\":1670979362.3586345,\"msg\":\"osinfo\",\"VERSION_ID\":\"\\\"20.04\\\"\",\"VERSION_CODENAME\":\"focal\",\"KERNEL_RELEASE\":\"5.4.0-91-generic\",\"ARCH\":\"x86_64\",\"VERSION\":\"\\\"20.04.5 LTS (Focal Fossa)\\\"\",\"ID\":\"ubuntu\",\"ID_LIKE\":\"debian\",\"PRETTY_NAME\":\"\\\"Ubuntu 20.04.5 LTS\\\"\",\"pkg\":\"urfave\",\"file\":\"urfave.go\",\"line\":53}\n{\"level\":\"debug\",\"ts\":1670979362.358663,\"msg\":\"RuntimeSockets: failed to register default\",\"socket\":\"containerd\",\"error\":\"failed to register runtime socket stat /var/run/containerd/containerd.sock: no such file or directory\",\"pkg\":\"flags\",\"file\":\"containers.go\",\"line\":45}\n{\"level\":\"debug\",\"ts\":1670979362.3586702,\"msg\":\"RuntimeSockets: failed to register default\",\"socket\":\"docker\",\"error\":\"failed to register runtime socket stat /var/run/docker.sock: no such file or directory\",\"pkg\":\"flags\",\"file\":\"containers.go\",\"line\":45}\n{\"level\":\"debug\",\"ts\":1670979362.3586755,\"msg\":\"RuntimeSockets: failed to register default\",\"socket\":\"crio\",\"error\":\"failed to register runtime socket stat /var/run/crio/crio.sock: no such file or directory\",\"pkg\":\"flags\",\"file\":\"containers.go\",\"line\":45}\n{\"level\":\"debug\",\"ts\":1670979362.3586833,\"msg\":\"RuntimeSockets: failed to register default\",\"socket\":\"podman\",\"error\":\"failed to register runtime socket stat /var/run/podman/podman.sock: no such file or directory\",\"pkg\":\"flags\",\"file\":\"containers.go\",\"line\":45}\n{\"level\":\"debug\",\"ts\":1670979362.3588264,\"msg\":\"osinfo\",\"security_lockdown\":\"none\",\"pkg\":\"urfave\",\"file\":\"urfave.go\",\"line\":116}\n{\"level\":\"debug\",\"ts\":1670979362.3639433,\"msg\":\"BTF\",\"bpfenv\":false,\"btfenv\":false,\"vmlinux\":false,\"pkg\":\"initialize\",\"file\":\"bpfobject.go\",\"line\":40}\n{\"level\":\"debug\",\"ts\":1670979362.363965,\"msg\":\"BPF: no BTF file was found or provided\",\"pkg\":\"initialize\",\"file\":\"bpfobject.go\",\"line\":108}\n{\"level\":\"debug\",\"ts\":1670979362.3639715,\"msg\":\"BPF: trying non CO-RE eBPF\",\"file\":\"/tmp/tracee/tracee.bpf.5_4_0-91-generic.v0_8_0-rc-2-365-g0bac8f68.o\",\"pkg\":\"initialize\",\"file\":\"bpfobject.go\",\"line\":109}\n{\"level\":\"debug\",\"ts\":1670979362.4866858,\"msg\":\"Enricher\",\"error\":\"error registering enricher: unsupported runtime containerd\",\"pkg\":\"containers\",\"file\":\"containers.go\",\"line\":64}\n{\"level\":\"debug\",\"ts\":1670979362.486713,\"msg\":\"Enricher\",\"error\":\"error registering enricher: unsupported runtime crio\",\"pkg\":\"containers\",\"file\":\"containers.go\",\"line\":68}\n{\"level\":\"debug\",\"ts\":1670979362.486717,\"msg\":\"Enricher\",\"error\":\"error registering enricher: unsupported runtime docker\",\"pkg\":\"containers\",\"file\":\"containers.go\",\"line\":72}\nTIME             UID    COMM             PID     TID     RET              EVENT                ARGS\n...\n</code></pre> <p>If you're running tracee inside a docker container, you can simply bind mount /boot/config-$(uname -r) from the host as /boot/config-$(uname -r) into the guest and inform that through the <code>LIBBPFGO_KCONFIG_FILE</code> environment variable.</p> <p>Attention</p> <p>In case no kconfig file is found, tracee takes some decisions blindly and it may give you unexpected errors. Example:</p>"},{"location":"getting-started/installing/prerequisites/","title":"Prerequisites for running Tracee","text":"<p>A longterm supported kernel: 5.4, 5.10, 5.15, 5.18, 6.1, 6.2. Check kernel.org for current supported kernels.</p> <p>Note</p> <p>Most distributions long-term supported kernels are supported as well, including CentOS8 4.18 kernel.</p> <ul> <li> <p>For tracee:v0.16.0-rc-14-gd8fa9648e docker image, you should have one of the two:</p> <ol> <li>A kernel that has <code>/sys/kernel/btf/vmlinux</code> file available</li> <li>A kernel supported through BTFHUB <p>see libbpf CO-RE documentation for more info</p> </li> </ol> </li> </ul>"},{"location":"getting-started/installing/prerequisites/#permissions","title":"Permissions","text":"<p>For using the eBPF Linux subsystem, Tracee needs to run with sufficient capabilities:</p> <ul> <li>Manage eBPF maps limits (<code>CAP_SYS_RESOURCE</code>)</li> <li>Load and Attach eBPF programs:<ol> <li><code>CAP_BPF</code>+<code>CAP_PERFMON</code> for recent kernels (&gt;=5.8) where the kernel perf paranoid value in <code>/proc/sys/kernel/perf_event_paranoid</code> is equal to 2 or less</li> <li>or <code>CAP_SYS_ADMIN</code> otherwise</li> </ol> </li> <li><code>CAP_SYS_PTRACE</code> (to collect information about processes)</li> <li><code>CAP_NET_ADMIN</code> (to use tc for packets capture)</li> <li><code>CAP_SETPCAP</code> (if given - used to reduce bounding set capabilities)</li> <li><code>CAP_SYSLOG</code> (to access kernel symbols through /proc/kallsyms)</li> <li>On some environments (e.g. Ubuntu) <code>CAP_IPC_LOCK</code> might be required as well.</li> <li>On cgroup v1 environments, <code>CAP_SYS_ADMIN</code> is recommended if running from a   container in order to allow tracee to mount the cpuset cgroup controller.</li> </ul> <p>Alternatively, you may bypass the capabilities dropping feature if facing any issue.</p>"},{"location":"getting-started/installing/distros/fedora/","title":"Fedora Packages","text":"<p>Tracee does not provide Fedora packages out-of-the-box, but there is a quick way to build a Fedora package.</p>"},{"location":"getting-started/installing/distros/nix-nixos/","title":"Nix/NixOS (Community)","text":"<p>If installing tracee via nix please ensure you're running a kernel with libbpf CO-RE support, see Tracee's prerequisites for more info.</p> <p>Direct issues installing tracee via nix through the channels mentioned here.</p> <pre><code>nix-env --install -A nixpkgs.tracee\n</code></pre> <p>Or through your configuration as usual</p> <p>NixOS:</p> <pre><code>  # your other config ...\n  environment.systemPackages = with pkgs; [\n    # your other packages ...\n    tracee\n  ];\n</code></pre> <p>home-manager:</p> <pre><code>  # your other config ...\n  home.packages = with pkgs; [\n    # your other packages ...\n    tracee\n  ];\n</code></pre>"},{"location":"getting-started/installing/distros/ubuntu/","title":"Ubuntu Packages","text":"<p>Tracee does not provide Ubuntu packages out-of-the-box, but there is a quick way to build an Ubuntu package.</p>"},{"location":"tutorials/deploy-grafana-dashboard/","title":"Deploy Grafana Dashboard","text":"<p>Grafana is a visualization tools for exported metrics and logs, most commonly used alongside prometheus.</p> <p>Since version 0.7.0, tracee exports useful runtime metrics to prometheus.</p> <p>These metrics exports are enabled by default in all docker images and can be enabled using the <code>--metrics</code>.</p> <p>By using grafana and the new metrics from tracee, we can deploy a simple dashboard which tracks your tracee's instance performance and outputs.</p>"},{"location":"tutorials/deploy-grafana-dashboard/#pre-requisites","title":"Pre-requisites","text":"<p>The following tools must be available for use, they can all be installed either through docker or installed/built on your machine.</p> <ul> <li>Tracee</li> <li>Prometheus</li> <li>Grafana</li> </ul>"},{"location":"tutorials/deploy-grafana-dashboard/#run-tracee-with-metrics-enabled","title":"Run Tracee with Metrics Enabled","text":"<p>Tracee can be most easily deployed with metrics enabled by default and port forwarded through the following commands:</p> <pre><code>docker run \\\n    --name tracee --rm --pid=host \\\n    --cgroupns=host --privileged \\\n    -v /tmp/tracee:/tmp/tracee  \\\n    -v /etc/os-release:/etc/os-release-host:ro \\\n    -it -p 3366:3366 aquasec/tracee:v0.16.0-rc-14-gd8fa9648e\n</code></pre> <p>Of course, the forwarded metrics ports can be changed, but you should note that some of the later instructions depend on these ports.</p> <p>If running Tracee locally through built binaries, the metrics address may be overrides with the <code>--listen-addr</code> flag.</p>"},{"location":"tutorials/deploy-grafana-dashboard/#run-prometheus-and-configure-it-to-scrape-tracee","title":"Run Prometheus and Configure it to Scrape Tracee","text":"<p>Install prometheus or pull it's docker image. Then create the following configuration file, call it <code>prometheus.yml</code> to scrape Tracee:</p> <pre><code># A scrape configuration containing exactly one endpoint to scrape:\n# Here it's Tracee.\nscrape_configs:\n# The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.\n- job_name: 'prometheus'\n\n# Override the global default and scrape targets from this job every 5 seconds.\nscrape_interval: 5s\n\n#Scrape tracee's default metrics hosts.\n#If forwarding different ports make sure to change these addresses.\nstatic_configs:\n- targets: ['localhost:3366']\n</code></pre> <p>We must then start prometheus with the following command:</p> <pre><code>prometheus --config.file=/path/to/prometheus.yml\n</code></pre> <p>Or alternatively with docker:</p> <pre><code>docker run -p 9090:9090 -v /path/to/config:/etc/prometheus prom/prometheus\n</code></pre> <p>Then, try to access prometheus through <code>http://localhost:9090</code>. If successful, move to the next step, otherwise consult with prometheus documentation.</p>"},{"location":"tutorials/deploy-grafana-dashboard/#run-grafana-to-display-tracees-prometheus-metrics","title":"Run Grafana to display Tracee's Prometheus Metrics","text":"<p>After successfully deploying Tracee and Prometheus we may now run Grafana to visualize it's metrics.</p> <p>Install grafana using their instructions and enter the now available grafana website (by default it's usually through http://localhost:3000).</p> <p>After entering the website, logging in with username and password <code>admin</code> (and changing your password if you wish), you should see the homepage:</p> <p></p> <p>Add your data source by hovering the configuration tab (the gear icon), selecting \"Data Sources\" and pressing \"Add Data Source\" at the top left. Create a Prometheus Data Source and point it's URL to the relevant location (usually http://localhost:9090)</p> <p>You may now either create your own Dashboard or import our default dashboard.</p>"},{"location":"tutorials/deploy-grafana-dashboard/#import-tracees-default-dashboard","title":"Import Tracee's Default Dashboard","text":"<p>First download our Grafana Dashboard's json here.</p> <p>After adding the data source hover on the plus icon in the sidebar and select \"Import\". Press \"Upload JSON File\" at the top of the page and select the downloaded json from your file browser. Change the name and Dashboard UID if you wish and press \"Import\" to finish. </p> <p>Finally you will be redirected to the dashboard \ud83e\udd73</p>"},{"location":"tutorials/k8s-policies/","title":"Working with Tracee Policies on Kubernetes","text":""},{"location":"tutorials/k8s-policies/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure that you have the following:</p> <ul> <li>A Kubernetes cluster up and running</li> <li>kubectl command-line tool installed and configured to work with your cluster</li> <li>Helm v3 or later installed on your local machine</li> </ul>"},{"location":"tutorials/k8s-policies/#install-tracee-via-helm","title":"Install Tracee via Helm","text":"<p>To install Tracee using Helm, follow these steps:</p> <p>Add the Aqua Security Helm repository:</p> <pre><code>helm repo add aqua https://aquasecurity.github.io/helm-charts/\n</code></pre> <p>Install Tracee with the default settings:</p> <pre><code>helm install tracee aqua/tracee \\\n    --namespace tracee-system --create-namespace \\\n    --set hostPID=true\n</code></pre> <p>This command installs Tracee in the tracee-system namespace, enabling the use of the host's PID namespace.</p>"},{"location":"tutorials/k8s-policies/#add-a-new-tracee-policy","title":"Add a new Tracee policy","text":"<p>By default, Tracee comes with a policy for signature events. In this step, you will learn how to add a new policy suit your requirements.</p> <p>The <code>tracee-policies</code> configmap should have all policies tracee will load when booting. Let's take a look on the default policy:</p> <pre><code>kubectl get configmap -n tracee-system\n\nNAME               DATA   AGE\ntracee-config      1      58m\ntracee-policies    2      58m\n</code></pre> <p>Let's take a look at a look at the default policy:</p> <p><pre><code>kubectl describe configmap/tracee-policies -ntracee-system\n</code></pre> <pre><code>Name:         tracee-policies\nNamespace:    tracee-system\nData\n====\nsignatures.yaml:\n----\nname: signature_events\ndescription: traces all signature events\nscope:\n- global\nrules:\n- event: stdio_over_socket\n- event: k8s_api_connection\n- event: aslr_inspection\n- event: proc_mem_code_injection\n- event: docker_abuse\n- event: scheduled_task_mod\n- event: ld_preload\n- event: cgroup_notify_on_release\n- event: default_loader_mod\n- event: sudoers_modification\n- event: sched_debug_recon\n- event: system_request_key_mod\n- event: cgroup_release_agent\n- event: rcd_modification\n- event: core_pattern_modification\n- event: proc_kcore_read\n- event: proc_mem_access\n- event: hidden_file_created\n- event: anti_debugging\n- event: ptrace_code_injection\n- event: process_vm_write_inject\n- event: disk_mount\n- event: dynamic_code_loading\n- event: fileless_execution\n- event: illegitimate_shell\n- event: kernel_module_loading\n- event: k8s_cert_theft\n- event: proc_fops_hooking\n- event: syscall_hooking\n- event: dropped_executable\n</code></pre></p> <p>But let's supposed we also need tracee to trace all <code>execve</code> events, for it we need to change the configmap <code>tracee-policies</code> adding a new policy.</p> <p>Let's edit the tracee-policies ConfigMap using kubectl:</p> <pre><code>kubectl edit cm/tracee-policies -n tracee-system\n</code></pre> <p>The ConfigMap will open in your default text editor. Locate the signatures.yaml section.</p> <p>To add a new policy for tracking execve events, append the following YAML block under the signatures.yaml section, maintaining proper indentation:</p> <p><pre><code>events.yaml: |-\nname: execve_event\ndescription: traces all execve events\nscope:\n- global\nrules:\n- event: execve\n</code></pre> Save and close the file. The changes will be applied automatically.</p> <p>Note</p> <p>If you having a problem editing the configmap, you can apply it directly with: <pre><code>kubectl apply -f https://gist.githubusercontent.com/josedonizetti/3df19a61d39840441ea5be448d6c9354/raw/c50b9b66d7996bb27b6fac301d24d6390e356f8c/tracee-policies-configmap.yaml\n</code></pre></p> <p>Step 3: Restart Tracee Daemonset After modifying the Tracee policies, you need to restart the Tracee daemonset for the changes to take effect.</p> <p>Restart the Tracee daemonset using the following command:</p> <pre><code>kubectl rollout restart ds/tracee -n tracee-system\n</code></pre> <p>Wait for the daemonset to restart and stabilize. You can monitor the progress using the following command:</p> <pre><code>kubectl rollout status ds/tracee -n tracee-system\n</code></pre> <p>Then check for <code>execve</code> events:</p> <pre><code>kubectl logs -f ds/tracee -n tracee-system | grep execve\n</code></pre> <pre><code>{\"timestamp\":1684688250477166817,\"threadStartTime\":1684688250477064221,\"processorId\":7,\"processId\":35694,\"cgroupId\":1386180,\"threadId\":35694,\"parentProcessId\":1033,\"hostProcessId\":3242201,\"hostThreadId\":3242201,\"hostParentProcessId\":3205483,\"userId\":0,\"mountNamespace\":4026532829,\"pidNamespace\":4026532833,\"processName\":\"cri-dockerd\",\"hostName\":\"minikube\",\"container\":{},\"kubernetes\":{},\"eventId\":\"59\",\"eventName\":\"execve\",\"matchedPolicies\":[\"execve_event\"],\"argsNum\":2,\"returnValue\":0,\"syscall\":\"execve\",\"stackAddresses\":null,\"contextFlags\":{\"containerStarted\":false,\"isCompat\":false},\"args\":[{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"/opt/cni/bin/bridge\"},{\"name\":\"argv\",\"type\":\"const char*const*\",\"value\":[\"/opt/cni/bin/bridge\"]},{\"name\":\"envp\",\"type\":\"const char*const*\",\"value\":null}]}\n</code></pre> <p>Once the daemonset is up and running, the modified policies will be applied.</p> <p>Congratulations! You have successfully installed Tracee via Helm, modified the default policies to add an <code>execve</code> event policy.</p> <p>Note: Modifying the policies may have security implications, so it is important to carefully consider the events you enable based on your specific requirements and security considerations.</p> <p>Feel free to reach out if you have any further questions or need additional assistance!</p>"},{"location":"tutorials/overview/","title":"Tutorials","text":"<p>In this section you can find step-by-step guides that help you accomplish specific tasks.</p> <p>\ud83d\udc48 Please use the side-navigation on the left in order to browse the different topics.</p>"},{"location":"tutorials/promtail/","title":"Using Promtail, Loki and Grafana to access Tracee Logs","text":"<p>This tutorial will showcase how to install and configure promtail, loki, grafana and prometheus to then access Tracee logs from the cluster in Grafana.</p>"},{"location":"tutorials/promtail/#prerequisites","title":"Prerequisites","text":"<p>Please make sure to have  - Kubectl installed and connected to a Kubernetes cluster (any cluster will work for this purpose) - The Helm CLI installed</p> <p>To ensure everything is installed properly, please run the following command:</p> <pre><code>kubectl get nodes\n</code></pre> <p>and</p> <pre><code>helm version\n</code></pre>"},{"location":"tutorials/promtail/#installation","title":"Installation","text":"<p>We need to install an observability stack to access the logs of the pods inside our cluster. This will consist of: - Grafana (for Dashboards and querying logs) - Promtail for collecting logs from the pods on each node - Loki, which is feeding the logs inot Grafana</p> <p>And since it is easier to install Grafana together with Prometheus, we are also going to install Prometheus.</p> <p>If you are completely new to Loki, have a look at the following presentation:  Learning the tricks of Grafana Loki for distributed logging at scale in a Kubernetes environment </p>"},{"location":"tutorials/promtail/#grafana-and-prometheus","title":"Grafana and Prometheus","text":"<p>First, we are going to install the kube-prometheus-stack chart with Prometheus and Grafana.</p> <p>For this, we will need to specify some custom values that we will pass into the Helm Chart. </p> <p>Create a new file called <code>grafana-config.yaml</code> with the following content:</p> <pre><code>prometheus:\nprometheusSpec:\nserviceMonitorSelectorNilUsesHelmValues: false\nserviceMonitorSelector: {}\nserviceMonitorNamespaceSelector: {}\n\ngrafana:\nsidecar:\ndatasources:\ndefaultDatasourceEnabled: true\nadditionalDataSources:\n- name: Loki\ntype: loki\nurl: http://loki-loki-distributed-query-frontend.monitoring:3100\n</code></pre> <p>Next, we can install the kube-prometheus-stack chart into our cluster with the following commands:</p> <p>Create a namespace for all the monitoring tools</p> <pre><code>kubectl create ns monitoring\n</code></pre> <p>Add the kube-prometheus-stack Helm Chart to your Helm repository list:</p> <pre><code>helm repo add prometheus-community https://prometheus-community.github.io/helm-charts\n</code></pre> <p>Ensure you have the latest version of all your repositories:</p> <pre><code>helm repo update\n</code></pre> <p>Install the kube-prometheus-stack Helm Chart:</p> <pre><code>helm upgrade --install prom prometheus-community/kube-prometheus-stack -n monitoring --values grafana-config.yaml\n</code></pre> <p>Lastly, confirm that all the pods have been created properly by querying the namespace:</p> <pre><code>kubectl get all -n monitoring\n</code></pre>"},{"location":"tutorials/promtail/#promtail-and-loki","title":"Promtail and Loki","text":"<p>Next, we need to install Promtail and Loki inside the cluster to actually access logs.</p> <p>For this, first add the Grafana Helm Chart repository to you repository list:</p> <pre><code>helm repo add grafana https://grafana.github.io/helm-charts\n</code></pre> <p>Update your Helm repository list:</p> <pre><code>helm repo update\n</code></pre> <p>Next, create a file with the Helm Chart configuration for Prometail in a promtail-config.yaml:</p> <pre><code>config:\nserverPort: 8080\nclients:\n- url: http://loki-loki-distributed-gateway/loki/api/v1/push\n</code></pre> <p>Now we can install the Promtail Helm Chart inside our cluster:</p> <pre><code>helm upgrade --install promtail grafana/promtail --values promtail-config.yaml -n monitoring\n</code></pre> <p>Make sure that Promtail is running the same number of pods as there are nodes on the cluster since Promtail has to run one pod per node:</p> <pre><code>k get pods -n monitoring\n</code></pre> <p>For instance, if the cluster consists of three nodes, then there should be three Promtails pods inside of the monitoring namespace.</p> <p>Now, we can install Loki. Loki's job is to collect the logs from Promtail and forward them to Grafana.</p> <pre><code>helm upgrade --install loki grafana/loki-distributed -n monitoring\n</code></pre> <p>Loki will install a variety of components inside your cluster, so don't be alarmed by the number of pods it is starting, namely:</p> <pre><code>loki-loki-distributed-distributor-5db986bb4f-x444n\nloki-loki-distributed-query-frontend-bd6845f89-z6nx6\nloki-loki-distributed-gateway-79d4d4ff5d-sxx58\nloki-loki-distributed-querier-0\nloki-loki-distributed-ingester-0    \n</code></pre> <p>At this point, the following pods should be running inside the Kubernetes cluster:</p> <pre><code>NAME                                                     READY   STATUS    RESTARTS      AGE\nprom-prometheus-node-exporter-l4cm4                      1/1     Running   0             22m\nprom-kube-prometheus-stack-operator-84cf966ff5-96xdp     1/1     Running   0             22m\nprom-kube-state-metrics-dc769cd87-fmrsk                  1/1     Running   0             22m\nprom-grafana-6fdb45b4d5-2zxw7                            3/3     Running   0             22m\nalertmanager-prom-kube-prometheus-stack-alertmanager-0   2/2     Running   1 (22m ago)   22m\nprometheus-prom-kube-prometheus-stack-prometheus-0       2/2     Running   0             22m\npromtail-sxfl5                                           1/1     Running   0             4m7s\nloki-loki-distributed-gateway-79d4d4ff5d-sxx58           1/1     Running   0             72s\nloki-loki-distributed-distributor-5db986bb4f-x444n       1/1     Running   0             72s\nloki-loki-distributed-query-frontend-bd6845f89-z6nx6     1/1     Running   0             72s\nloki-loki-distributed-querier-0                          1/1     Running   0             72s\nloki-loki-distributed-ingester-0                         1/1     Running   0             72s\n</code></pre> <p>Since everything is running properly, we need to ensure that we can access Loki as a data source inside of Grafana.</p> <p>For this, port-forward to Grafana:</p> <pre><code>kubectl port-forward service/prom-grafana -n monitoring 3000:80\n</code></pre> <p>and open the Grafana UI on localhost:3000.</p> <p>Here, you will need the username and the password: username: admin password: prom-operator</p> <p>The password name is dependent on how you called the Helm Chart installation of the kube-prometheus-stack chart e.g. in our case, it was \"prom\".</p> <p>Now navigate on Grafana to: Explore  Here select Loki as a data source.</p>"},{"location":"tutorials/promtail/#tracee","title":"Tracee","text":"<p>Right now, we cannot access any logs from our cluster since we do not have any application that actively produces logs. Thus, we will install Tracee inside our cluster through the Tracee Helm Chart.</p> <p>Add the Tracee Helm Chart:</p> <pre><code>helm repo add aqua https://aquasecurity.github.io/helm-charts/\n</code></pre> <p>Update the repository list on Helm:</p> <pre><code>helm repo update\n</code></pre> <p>Install the Tracee Helm Chart inside your Kubernetes cluster:</p> <pre><code>helm install tracee aqua/tracee \\\n        --namespace tracee-system --create-namespace \\\n        --set hostPID=true\n</code></pre> <p>Now, ensure that Tracee is running inside the <code>tracee-system</code> namespace:</p> <pre><code>kubectl get all -n tracee-system\n</code></pre> <p>Similar to Promtail, also for Tracee one pod should run on each node of the Kubernetes cluster.</p>"},{"location":"tutorials/promtail/#accessing-tracee-logs","title":"Accessing Tracee Logs","text":"<p>Generally, it is possible to access logs from the Tracee pods directly through kubectl:</p> <pre><code>kubectl logs -f daemonset/tracee -n tracee-system\n</code></pre> <p>However, once you have all the above components installed, you can open the Grafana Dashboard, on the left, go to \"Explore\". There, you should be able to select Loki as a Datasource.</p> <p>Now, you can write log queries in LogQL to access the logs that are stored in the Tracee pods:</p> <p></p>"},{"location":"tutorials/verify-tracee-signature/","title":"Cosign: verify tracee signature","text":""},{"location":"tutorials/verify-tracee-signature/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure that you have the following:</p> <ul> <li>cosign</li> </ul>"},{"location":"tutorials/verify-tracee-signature/#verify-tracee-signature","title":"Verify tracee signature","text":"<p>Tracee images are signed with cosign keyless. To verify the signature we can run the command:</p> <pre><code>cosign verify aquasec/tracee:v0.16.0-rc-14-gd8fa9648e  --certificate-oidc-issuer https://token.actions.githubusercontent.com --certificate-identity-regexp https://github.com/aquasecurity/tracee | jq\n</code></pre>"}]}