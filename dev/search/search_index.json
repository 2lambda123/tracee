{"config":{"indexing":"full","jieba_dict":null,"jieba_dict_user":null,"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"<p></p>  <p>Before moving on, make sure to give us a star at the GitHub Project if you liked it. That is important for us. Thank you!</p>  <p>   </p>","title":"Getting Started"},{"location":"#tracee-runtime-security-and-forensics-using-ebpf","text":"<p>Tracee is a Runtime Security and forensics tool for Linux. It uses Linux eBPF technology to trace your system and applications at runtime, and analyzes collected events in order to detect suspicious behavioral patterns. It is usually delivered as a docker container, but there are other ways you can use it (even create your own customized tracee container).</p> <p>Watch a quick video demo of Tracee:</p> <p></p> <p>Check out the Tracee video hub for more videos.</p>","title":"Tracee: Runtime Security and Forensics using eBPF"},{"location":"#quickstart","text":"<p>Before you proceed, make sure you follow the [prerequiresites].</p> <ol> <li>Running tracee:v0.8.1</li> </ol> <pre><code>$ docker run \\\n     --name tracee --rm -it \\\n     --pid=host --cgroupns=host --privileged \\\n     -v /etc/os-release:/etc/os-release-host:ro \\\n     -e LIBBPFGO_OSRELEASE_FILE=/etc/os-release-host \\\n     aquasec/tracee:0.8.1\n</code></pre> <ol> <li>Running tracee:full</li> </ol> <pre><code>$ docker run \\\n     --name tracee --rm -it \\\n     --pid=host --cgroupns=host --privileged \\\n     -v /etc/os-release:/etc/os-release-host:ro \\\n     -e LIBBPFGO_OSRELEASE_FILE=/etc/os-release-host \\\n     -v /usr/src:/usr/src:ro \\\n     -v /lib/modules:/lib/modules:ro \\\n     -v /tmp/tracee:/tmp/tracee:rw \\\n     aquasec/tracee:full-0.8.1\n</code></pre>  <p>Notes</p> <ol> <li> <p>The default (latest) image is lightweight and portable. It is    supposed to support different kernel versions without having to build    source code. If the host kernel does not support BTF then you may use    the full container image. The full container will compile an eBPF    object during startup, if you do not have one already cached in    <code>/tmp/tracee</code>.</p> </li> <li> <p>You may need to change the volume mounts for the kernel headers based on    your setup. See Linux Headers section for    more info.</p> </li> <li> <p>Tracee supports enriching events with additional data from running    containers. In order to enable this capability please look    here.</p> </li> </ol>  <p>These docker commands run Tracee with default settings and start reporting detections to standard output. In order to simulate a suspicious behavior, you can simply run:</p> <pre><code>$ strace ls\n</code></pre> <p>in another terminal. This will trigger the Anti-Debugging signature, which is loaded by default, and you will get a warning:</p> <pre><code>INFO: probing tracee-ebpf capabilities...\nINFO: starting tracee-ebpf...\nINFO: starting tracee-rules...\nLoaded 14 signature(s): [TRC-1 TRC-13 TRC-2 TRC-14 TRC-3 TRC-11 TRC-9 TRC-4 TRC-5 TRC-12 TRC-8 TRC-6 TRC-10 TRC-7]\nServing metrics endpoint at :3366\nServing metrics endpoint at :4466\n\n*** Detection ***\nTime: 2022-03-25T08:04:22Z\nSignature ID: TRC-2\nSignature: Anti-Debugging\nData: map[]\nCommand: strace\nHostname: ubuntu-impish\n</code></pre>","title":"Quickstart"},{"location":"#trace","text":"<p>In some cases, you might want to leverage Tracee's eBPF event collection capabilities directly, without involving the detection engine. This might be useful for debugging, troubleshooting, analysising, researching OR education.</p> <p>Execute docker container with the word <code>trace</code> as an initial argument, and tracee-ebpf will be executed, instead of the full tracee detection engine.</p> <pre><code>$ docker run \\\n    --name tracee --rm -it \\\n    --pid=host --cgroupns=host --privileged \\\n    -v /etc/os-release:/etc/os-release-host:ro \\\n    -e LIBBPFGO_OSRELEASE_FILE=/etc/os-release-host \\\n    aquasec/tracee:0.8.1\n    trace\n</code></pre>  <p>Note</p> <p>See documentation or add the <code>--help</code> flag for more.</p>","title":"Trace"},{"location":"#components","text":"<p>Tracee is composed of the following sub-projects, which are hosted in the aquasecurity/tracee repository:</p> <ul> <li>Tracee-eBPF - Linux Tracing and Forensics using eBPF</li> <li>Tracee-Rules - Runtime Security Detection Engine</li> </ul>  <p>Tracee is an Aqua Security open source project. Learn about our open source work and portfolio Here. Join the community, and talk to us about any matter in GitHub Discussion or Slack.</p>","title":"Components"},{"location":"architecture/","text":"","title":"Architecture"},{"location":"architecture/#tracee-architecture-overview","text":"<p></p>  <p>Overview</p> <ol> <li> <p>Kernel eBPF programs GENERATE Tracee Events to Userland:</p> <ol> <li>Tracepoints</li> <li>Probes</li> <li>Trafic Control Hooks</li> </ol> </li> <li> <p>Userland events are COLLECTED and ENRICHED with more information:</p> <ol> <li>Kernel Events (Syscalls, Tracepoints, Kprobes)</li> <li>OS Events (Running Containers, ...)</li> <li>Derived (from other) Events</li> <li>Network Events</li> </ol> </li> <li> <p>DETECT patterns based on existing signatures:</p> <ol> <li>OPA/Rego signatures</li> <li>Golang signatures</li> <li>Go-CEL signatures (Proof-of-Concept / Experimental)</li> </ol> </li> <li> <p>Let other tools to CONSUME detection events:</p> <ol> <li>Capture Artifacts</li> <li>Postee</li> <li>Falco Sidekick</li> </ol> </li> <li> <p>ENFORCE</p> <ol> <li>Work in Progress</li> </ol> </li> </ol>","title":"Tracee Architecture Overview"},{"location":"architecture/#tracee-pipeline-concept","text":"<p></p>  <p>Pipeline</p> <ol> <li> <p>Multiple CPUs constantly generate events from the eBPF programs running    inside the kernel (inside an eBPF VM).</p> </li> <li> <p>The eBPF programs are executed whenever the kernel (or network) hooks    they're attached to are triggered.</p> </li> <li> <p>eBPF programs decide whether they should submit the events to    tracee-ebpf or not, based on given filters.</p> </li> <li> <p>Those events are sent to libbpfgo through a shared memory ring buffer    mechanism (called perfbuffer).</p> </li> <li> <p>libbpfgo sends collected events to tracee through golang    channels.</p> </li> <li> <p>tracee-ebpf parses received events and does multiple things:</p> <ol> <li>parse events for argument type conversions if requested</li> <li>enriches the events that need enrichment (containers, network, processes)</li> <li>capture artifacts from collected events into external files</li> </ol> </li> <li> <p>tracee-ebpf writes events to tracee-rules through a mechanism    called printer.</p> </li> <li> <p>tracee-rules receives events and evaluate them using either golang    or rego (or go-cel, as a proof-of-concept) signatures.</p> <ol> <li>Golang signatures are faster and do pretty much anything the language    allows. They might connect (or have cached) external data sources to    evaluate events, for example.</li> </ol> </li> <li> <p>Detections are spit out from tracee-rules if evaluations are    positive.</p> </li> </ol>  <p>This mechanism is what we call the tracee pipeline: to receive events from the kernel into userland (tracee-ebpf), then to parse and enrich those events and to submit them to tracee-rules for it to evaluate them looking for detection patterns described as signatures.</p>","title":"Tracee Pipeline Concept"},{"location":"building/building/","text":"<p>Note</p> <p>Consider also visiting the following instructions: 1. docker container as building environment 2. building tracee container images </p>  <ol> <li> <p>Building dependencies</p> <ol> <li>kernel readers if no CO-RE is needed</li> <li>clang (12 or 13)</li> <li>golang (1.17)</li> <li>libelf and libelf-dev    (or elfutils-libelf and elfutils-libelf-devel)</li> <li>zlib1g and lib1g-dev    (or zlib and zlib-devel)</li> </ol> </li> <li> <p>Clone tracee repository</p> <pre><code>$ git clone git@github.com:aquasecurity/tracee\nCloning into 'tracee'...\nremote: Enumerating objects: 13251, done.\nremote: Counting objects: 100% (555/555), done.\nremote: Compressing objects: 100% (240/240), done.\nremote: Total 13251 (delta 343), reused 369 (delta 280), pack-reused 12696\nReceiving objects: 100% (13251/13251), 11.75 MiB | 8.62 MiB/s, done.\nResolving deltas: 100% (8105/8105), done.\n</code></pre> </li> <li> <p>All makefiles have a help target to give you needed instrutions</p> <pre><code>$ make help\n\n# environment\n\n    $ make env                      # show makefile environment/variables\n\n# build\n\n    $ make all                      # build tracee-ebpf, tracee-rules &amp; rules\n    $ make bpf-core                 # build ./dist/tracee.bpf.core.o\n    $ make bpf-nocore               # build ./dist/tracee.bpf.XXX.o\n    $ make tracee-ebpf              # build ./dist/tracee-ebpf\n    $ make tracee-rules             # build ./dist/tracee-rules\n    $ make rules                    # build ./dist/rules\n\n# install\n\n    $ make install-bpf-nocore       # install BPF no CO-RE obj into /tmp/tracee\n    $ make uninstall-bpf-nocore     # uninstall BPF no CO-RE obj from /tmp/tracee\n\n# clean\n\n    $ make clean                    # wipe ./dist/\n    $ make clean-bpf-core           # wipe ./dist/tracee.bpf.core.o\n    $ make clean-bpf-nocore         # wipe ./dist/tracee.bpf.XXX.o\n    $ make clean-tracee-ebpf        # wipe ./dist/tracee-ebpf\n    $ make clean-tracee-rules       # wipe ./dist/tracee-rules\n    $ make clean-rules              # wipe ./dist/rules\n\n# test\n\n    $ make test-types               # run unit tests for types module\n    $ make test-unit                # run unit tests\n    $ make test-integration         # run integration tests\n    $ make test-rules               # opa test (tracee-rules)\n\n# flags\n\n    $ STATIC=1 make ...                 # build static binaries\n    $ BTFHUB=1 STATIC=1 make ...        # build static binaries, embed BTF\n</code></pre> </li> <li> <p>Build all targets at once (but bpf-nocore)</p> <pre><code>$ make all\nSubmodule 'libbpf' (https://github.com/libbpf/libbpf.git) registered for path '3rdparty/libbpf'\nCloning into '/home/rafaeldtinoco/tracee/3rdparty/libbpf'...\nmkdir -p dist/rules\nGOOS=linux CC=clang GOARCH=amd64 CGO_CFLAGS= CGO_LDFLAGS= go build \\\n    --buildmode=plugin \\\n    -o dist/rules/builtin.so \\\n    signatures/golang/export.go signatures/golang/kubernetes_api_connection.go signatures/golang/stdio_over_socket.go\n</code></pre> </li> <li> <p>Build a static binary by setting <code>STATIC=1</code></p> <pre><code>$ STATIC=1 make all\nCC=\"clang\" \\\n    CFLAGS=\"\"-fPIC\"\" \\\n    LD_FLAGS=\"\" \\\n    make \\\n    -C ./3rdparty/libbpf/src \\\n    BUILD_STATIC_ONLY=1 \\\n    DESTDIR=/home/rafaeldtinoco/tracee/dist/libbpf \\\n    OBJDIR=/home/rafaeldtinoco/tracee/dist/libbpf/obj \\\n    INCLUDEDIR= LIBDIR= UAPIDIR= prefix= libdir= \\\n    install install_uapi_headers\n...\n</code></pre> </li> <li> <p>Build a static binary with BTFHUB Support</p> <pre><code>$ BTFHUB=1 STATIC=1 make all\nCloning into '/home/rafaeldtinoco/tracee/3rdparty/btfhub'...\nremote: Enumerating objects: 205, done.\nremote: Counting objects: 100% (16/16), done.\nremote: Compressing objects: 100% (12/12), done.\nremote: Total 205 (delta 4), reused 10 (delta 3), pack-reused 189\nReceiving objects: 100% (205/205), 10.59 MiB | 7.56 MiB/s, done.\nResolving deltas: 100% (73/73), done.\nCloning into '/home/rafaeldtinoco/tracee/3rdparty/btfhub-archive'...\nremote: Enumerating objects: 1993, done.\nremote: Counting objects: 100% (28/28), done.\nremote: Compressing objects: 100% (23/23), done.\nReceiving objects:  15% (301/1993), 154.97 MiB | 15.72 MiB/s\n</code></pre>  <p>Note</p> <p>BTFHUB support will embed several very small files (BTF files) into your final binary. Those files will allow tracee-ebpf binary to be executed in kernels that doesn't have embedded BTF information (the ones described at the BTFHUB repository)</p>   <p>Attention</p> <p>compiling <code>tracee-rules</code> with STATIC=1 won't allow you to use golang based signatures as plugins, only as built-ins:</p>  <pre><code>2021/12/13 13:27:21 error opening plugin /tracee/dist/rules/builtin.so:\nplugin.Open(\"/tracee/dist/rules/builtin.so\"): Dynamic loading not supported\n</code></pre>   </li> </ol>","title":"Building from the source"},{"location":"building/containers/","text":"<p>These instructions are meant to describe how to build the official tracee containers images, instead of just downloading them from the Docker Hub.</p> <p>If you would like to have a local building and execution environment, read this instead.</p>","title":"Creating Tracee Container Images"},{"location":"building/containers/#generating-tracee-containers","text":"<p>Tracee containers come in 2 flavors:</p> <ol> <li> <p>tracee:latest</p> <p>Contains an executable binary with an embedded eBPF CO-RE enabled object that makes it portable against multiple environments and kernel versions.</p> <pre><code>$ BTFHUB={0,1} make -f builder/Makefile.tracee-container build-tracee\n</code></pre> </li> <li> <p>tracee:full</p> <p>Contains tracee source tree and required toolchain in order to, during the startup time, compile a eBPF non CO-RE object, to your specific running environment, and make the executable to use on execution time.</p> <pre><code>$ BTFHUB={0,1} make -f builder/Makefile.tracee-container build-tracee-full\n</code></pre>  <p>Note</p> <p><code>BTFHUB=1</code> adds support to some older kernels so user doesn't need to build specific non CO-RE eBPF objects to them.</p>  </li> </ol>","title":"Generating Tracee Containers"},{"location":"building/containers/#running-tracee-containers","text":"<p>Containers are supposed to be executed through docker cmdline directly, from the official built images. Nevertheless, during the image building process, it may be useful to execute them with correct arguments to see if they're working.</p> <p>User may execute built containers through <code>Makefile.tracee-container</code> file with the \"run\" targets:</p> <ol> <li> <p>To run the tracee:latest container:</p> <pre><code>$ make -f builder/Makefile.tracee-container run-tracee\n</code></pre> </li> <li> <p>To run the tracee:full container:</p> <pre><code>$ make -f builder/Makefile.tracee-container run-tracee-full\n</code></pre>  <p>Note</p> <p>Tracee-ebpf arguments are passed through the <code>ARG</code> variable: <pre><code>$ make -f builder/Makefile.tracee-container run-tracee ARG=\"--help\"\n</code></pre></p>  </li> </ol>","title":"Running Tracee Containers"},{"location":"building/containers/#running-tracee-ebpf-only","text":"<p>Generated containers allow user to run Tracee, as a complete security solution (tracee-ebpf passes events to tracee-rules and tracee-rules process events based on existing security signatures) or to run tracee-ebpf only, as an introspection tool.</p> <ol> <li>To run the <code>tracee:latest</code> container with tracee-ebpf only:</li> </ol> <pre><code>$ make -f builder/Makefile.tracee-container run-tracee-ebpf\n</code></pre> <ol> <li>To run the <code>tracee:full</code> container with tracee-ebpf only:</li> </ol> <pre><code>$ make -f builder/Makefile.tracee-container run-tracee-ebpf-full\n</code></pre>  <p>Note</p> <p>Tracee-ebpf arguments are passed through the <code>ARG</code> variable:</p> <pre><code>$ make -f builder/Makefile.tracee-container run-tracee-ebpf ARG=\"--debug\"\n</code></pre>","title":"Running Tracee-eBPF Only"},{"location":"building/environment/","text":"<p>These instructions are meant to describe how to create a local building and execution environment. If you would like to build tracee container(s) image(s), read this instead.</p>   <p>Note</p> <p>A building environment will let you build and execute tracee inside a docker container, containing all needed tools to build and execute it. If you're using an OSX environment, for example, you can install gmake (<code>brew install gmake</code>) and configure such environment by using Docker.</p>   <p>Attention</p> <p>If you want to build tracee on your local machine read this.</p>","title":"Creating a local building environment"},{"location":"building/environment/#quick-steps-impatient-readers","text":"<p>Example</p> <ul> <li> <p>Build and execute tracee-ebpf:</p> <pre><code>$ make -f builder/Makefile.tracee-make alpine-prepare\n$ make -f builder/Makefile.tracee-make alpine-shell\n\ntracee@f64bb4a2f0b1[/tracee]$ make clean\ntracee@f64bb4a2f0b1[/tracee]$ make tracee-ebpf\ntracee@f64bb4a2f0b1[/tracee]$ sudo ./dist/tracee-ebpf \\\n    -o option:parse-arguments \\\n    --trace comm=bash \\\n    --trace follow\n</code></pre> </li> </ul> <p>Now, in your host's bash shell, execute a command. You will see all events (except scheduler ones) being printed, in \"table format\", to stdout.</p> <ul> <li> <p>Build and execute tracee:</p> <pre><code>$ make -f builder/Makefile.tracee-make alpine-prepare\n$ make -f builder/Makefile.tracee-make alpine-shell\n\ntracee@f64bb4a2f0b1[/tracee]$ make clean\ntracee@f64bb4a2f0b1[/tracee]$ make all\ntracee@f64bb4a2f0b1[/tracee]$ sudo ./dist/tracee-ebpf \\\n    -o format:json \\\n    -o option:parse-arguments \\\n    --trace comm=bash \\\n    --trace follow | \\\n    ./dist/tracee-rules \\\n    --input-tracee file:stdin \\\n    --input-tracee format:json\n</code></pre> </li> </ul> <p>Now, in your host's bash shell, execute: <code>sudo strace /bin/ls</code> and observe tracee warning you about a possible risk (with its Anti-Debugging signature).</p>  <p>Now, for more patient readers ...</p>","title":"Quick steps (impatient readers)"},{"location":"building/environment/#how-to-build-and-use-the-environment","text":"<p>In order to have a controlled building environment for tracee, tracee provides a <code>Makefile.tracee-make</code> file that allows you to create and use a docker container environment to build &amp; test tracee-ebpf and tracee-rules.</p> <p>Two different environments are maintained for building tracee:</p> <ul> <li>Alpine</li> <li>Ubuntu</li> </ul> <p>The reason for that is that Alpine Linux is based in the musl C standard library, while the Ubuntu Linux uses glibc. By supporting both building environments we can always be sure that the project builds (and executes) correctly in both environments.</p>  <p>Attention</p> <p>Locally created containers, called <code>alpine-tracee-make</code> or <code>ubuntu-tracee-make</code>, share the host source code directory. This means that, if you build tracee binaries using <code>alpine</code> distribution, binaries tracee-ebpf and tracee-rules might not be compatible to the Linux distribution from your host OS.</p>","title":"How to build and use the environment"},{"location":"building/environment/#creating-a-builder-environment","text":"<ul> <li> <p>To create an alpine-tracee-make container:</p> <pre><code>$ make -f builder/Makefile.tracee-make alpine-prepare\n</code></pre> </li> <li> <p>To create an ubuntu-tracee-make container:</p> <pre><code>$ make -f builder/Makefile.tracee-make ubuntu-prepare\n</code></pre> </li> </ul>","title":"Creating a builder environment"},{"location":"building/environment/#executing-a-builder-environment","text":"<ul> <li> <p>To execute an alpine-tracee-make shell:</p> <pre><code>$ make -f builder/Makefile.tracee-make alpine-shell\n</code></pre> </li> <li> <p>To execute an ubuntu-tracee-make shell:</p> <pre><code>$ make -f builder/Makefile.tracee-make ubuntu-shell\n</code></pre> </li> </ul>","title":"Executing a builder environment"},{"location":"building/environment/#using-build-environment-as-a-make-replacement","text":"<p>Instead of executing a builder shell, you may use <code>alpine-tracee-make</code>, or <code>ubuntu-tracee-make</code>, as a replacement for the <code>make</code> command:</p> <pre><code>$ make -f builder/Makefile.tracee-make ubuntu-prepare\n$ make -f builder/Makefile.tracee-make ubuntu-make ARG=\"help\"\n$ make -f builder/Makefile.tracee-make ubuntu-make ARG=\"clean\"\n$ make -f builder/Makefile.tracee-make ubuntu-make ARG=\"bpf-core\"\n$ make -f builder/Makefile.tracee-make ubuntu-make ARG=\"tracee-ebpf\"\n$ make -f builder/Makefile.tracee-make ubuntu-make ARG=\"all\"\n</code></pre> <p>And, after the compilation, run the commands directly in your host:</p> <pre><code>$ sudo ./dist/tracee-ebpf \\\n    -o option:parse-arguments \\\n    --trace comm=bash \\\n    --trace follow\n</code></pre>  <p>Note: the generated binary must be compatible to your host (depending on glibc version, for example).</p>  <p>If you don't want to depend on host's libraries versions, or if you are using the <code>alpine-tracee-make</code> container as a replacement for <code>make</code>, and your host is not an Alpine Linux, then you may set <code>STATIC=1</code> variable so you can run compiled binaries in your host:</p> <pre><code>$ make -f builder/Makefile.tracee-make alpine-prepare\n$ make -f builder/Makefile.tracee-make alpine-make ARG=\"help\"\n$ STATIC=1 make -f builder/Makefile.tracee-make alpine-make ARG=\"all\"\n</code></pre> <p>and execute the static binary from your host:</p> <pre><code>$ ldd dist/tracee-ebpf\n  not a dynamic executable\n</code></pre>  <p>Attention</p> <p>compiling tracee-rules with STATIC=1 won't allow you to use golang based signatures:</p>  <pre><code>2021/12/13 13:27:21 error opening plugin /tracee/dist/rules/builtin.so:\nplugin.Open(\"/tracee/dist/rules/builtin.so\"): Dynamic loading not supported\n</code></pre>","title":"Using build environment as a make replacement"},{"location":"building/macosx/","text":"<p>Attention</p> <p>Building Tracee in an OSX environment is for development purposes only and experimental only.</p>","title":"Building Tracee in OSX"},{"location":"building/macosx/#requirements","text":"<ul> <li>Docker desktop</li> <li>brew</li> <li>findutils (<code>brew install findutils</code>)</li> <li>make (<code>brew install make</code>)</li> </ul>","title":"Requirements"},{"location":"building/macosx/#creating-a-local-building-enviroment","text":"<p>Just like as described at building environment, under OSX you may create your local building environment by using the same make targets:</p> <pre><code>$ gmake -f builder/Makefile.tracee-make alpine-prepare\n$ gmake -f builder/Makefile.tracee-make alpine-shell\n</code></pre> <pre><code>$ gmake -f builder/Makefile.tracee-make ubuntu-prepare\n$ gmake -f builder/Makefile.tracee-make ubuntu-shell\n</code></pre>","title":"Creating a local building enviroment"},{"location":"building/macosx/#executing-tracee-in-the-building-environment","text":"<p>Tracee isn't meant to run in OSX but, with Docker, you're able to test building it. If you try to run it from the building environment you may get the following error:</p> <pre><code>tracee@5fb7cc667842[/tracee]$ sudo ./dist/tracee-ebpf\nBPF: open /tmp/tracee/tracee.bpf.5_10_104-linuxkit.v0_8_0-rc-1-24-g72e0d02.o: no such file or directory\nBPF: ATTENTION:\nBPF: It seems tracee-ebpf can't load CO-RE eBPF obj and could not find\nBPF: the non CO-RE object in /tmp/tracee. You may build a non CO-RE eBPF\nBPF: obj by using the source tree and executing \"make install-bpf-nocore\".\n</code></pre> <p>That happens because the virtual machine supporting docker desktop containers, in OSX, does not have a kernel that supports eBPF CO-RE (it does not contain a kernel with BTF information embedded on it).</p> <p>In order for you to run tracee in OSX, it is recommended that you either use Vagrant and the provided Vagrantfile, use a virtual machine emulator (Parallels, VMware Fusion, ...) OR check the next section about how to obtain docker kernel headers installed if you want a \"Docker only experience\".</p>","title":"Executing tracee in the building environment"},{"location":"building/macosx/#obtaining-docker-kernel-headers","text":"<p>Docker for Mac does not come with Kernel headers. You need to do the following to execute non CO-RE Tracee:</p> <ol> <li> <p>Identify your docker version:</p> <pre><code>$ dockerver=$(docker version | grep  Version | head -n 1 | cut -d ':' -f 2 | xargs)\n</code></pre> </li> <li> <p>Run a container with Docker CLI, while mounting to the host path:</p> <pre><code>$ docker run -it -v /:/host \\\n    -v /var/run/docker.sock:/var/run/docker.sock \\\n    docker:$dockerver /bin/sh\n</code></pre> </li> <li> <p>Get the Kernel Header files from the linuxkit Docker image and copy it to the    host /usr/src path:</p> <pre><code>$ mkdir /host/kheader\n$ cd /host/kheader\n$ linux_version=\"${VERSION:-$(uname -r | cut -d - -f 1)}\"\n$ docker pull \"linuxkit/kernel:$linux_version\"\n$ docker save \"linuxkit/kernel:$linux_version\" &gt; \"linuxkit.tar\"\n$ tar -xf \"linuxkit.tar\"\n$ layertar=$(find . -name layer.tar)\n$ tar -xf \"$layertar\"\n$ tar -xf \"kernel-dev.tar\" --directory /host/\n</code></pre> </li> <li> <p>You can now run Tracee on your Docker for Mac</p> </li> </ol>","title":"Obtaining Docker Kernel Headers"},{"location":"building/macosx/#apple-silicon","text":"<p>Note</p> <p>Apple Silicon users might need to create their own virtual machine environment until Vagrant fully supports that architecture.</p>","title":"Apple Silicon"},{"location":"building/nocore-ebpf/","text":"<p>These instructions are meant to describe how to build tracee's eBPF object for your running kernel when it does not support CO-RE.</p>","title":"Running non CO-RE Tracee"},{"location":"building/nocore-ebpf/#introduction","text":"<p>Introduction</p> <p>As you are probably already aware, Tracee consists of:</p>  <p>Tracee-ebpf</p> <ul> <li>Userspace agent  <ol> <li>Handles lifecycle of ebpf programs  </li> <li>Receives events from eBPF programs  </li> </ol> </li> <li>eBPF code  <ol> <li>Programs loaded in the kernel for event collection</li> </ol> </li> </ul>   <p>Tracee-rules</p> <ul> <li>OPA signatures</li> <li>Golang signatures</li> <li>Go-Cel signatures (tech-preview)</li> </ul>   <p>tracee-ebpf leverages Linux's eBPF technology, which requires some kernel level integration. Tracee supports two eBPF integration modes:</p> <ol> <li> <p>CO-RE: a portable mode, which will seamlessly run on all supported    envs.</p> <p>The portable option, also known as CO-RE (compile once, run everywhere), requires that your operating system support BTF (BPF Type Format). Tracee will automatically run in CO-RE mode if it detects that the environment supports it. The tracee-ebpf binary has a CO-RE eBPF object embedded on it. When executed, it loads the CO-RE eBPF object into the kernel and each of its object's eBPF programs are executed when triggered by kernel probes, or tracepoints, for example.</p> <p>This mode requires no intervention or preparation on your side.  You can manually detect if your environments supports it by checking if the following file exists on your machine: <code>/sys/kernel/btf/vmlinux</code>.</p> </li> <li> <p>non CO-RE: a kernel-specific mode, requiring eBPF object to be built.</p> <p>If you want to run Tracee on a host without BTF support, there are 2 options: 1. to use BTF files from BTFHUB    and provide the TRACEE_BTF_FILE environment variable pointing to the BTF    file of your running kernel. 2. to have <code>../../Makefile</code> build and install the eBPF object for you    (instructions in this file). This will depend on having clang and a    kernel version specific kernel-header package.</p> </li> </ol>","title":"Introduction"},{"location":"building/nocore-ebpf/#the-need-for-a-non-co-re-ebpf-object-build","text":"<p>Until recently, tracee-ebpf was capable of building a non CO-RE (portable) eBPF object when the running kernel did not support BTF, one of the kernel features needed for eBPF portability among different kernels.</p> <p>That now is changed:</p> <p>It is the user responsibility to have the non CO-RE eBPF object correctly placed in <code>/tmp/tracee</code> directory. Tracee will load it, instead of loading the embedded CO-RE eBPF object, as a last resource if there is no:</p> <ol> <li>BTF file available in running kernel (<code>/sys/kernel/btf/vmlinux</code>).</li> <li>BTF file pointed by <code>TRACEE_BTF_FILE</code> environment variable.</li> <li>BTF file embedded into \"tracee-ebpf\" binary (BTFHUB).</li> </ol>  <p>Note</p> <p>Installing the non CO-RE eBPF object in the environment does not mean will will run tracee-ebpf with it by default. If your system supports CO-RE eBPF objects it will be chosen instead. If your system supports CO-RE eBPF but does not contain embedded BTF information, but is support by BTFHUB, then the CO-RE eBPF object will be used by default. The only way you can make sure the non CO-RE eBPF object is used is by always informing the <code>TRACEE_BPF_FILE=...</code> environment variable.</p>  <p>Reasoning behind this change</p> <p>With BTFHUB, it is now possible to run tracee-ebpf without compiling the eBPF object to each different kernel, thus removing the automatic builds (although the functionality is still kept through the Makefile).</p>","title":"The need for a non CO-RE eBPF object build"},{"location":"building/nocore-ebpf/#install-the-non-co-re-ebpf-object","text":"<p>By running:</p> <pre><code>$ make clean\n$ make all\n$ make install-bpf-nocore\n</code></pre> <p>make installs an eBPF object file under <code>/tmp/tracee</code> for the current running kernel. Example:</p> <pre><code>$ find /tmp/tracee\n/tmp/tracee\n/tmp/tracee/tracee.bpf.5_4_0-91-generic.v0_6_5-80-ge723a22.o\n</code></pre>  <p>Note</p> <p>This example, the Ubuntu Focal kernel 5.4.0-91-generic supports CO-RE, but the kernel does not have embedded BTF information available. In cases like this, the user may opt to either use BTFHUB btf files (with an environment variable TRACEE_BTF_FILE=.../5.4.0-91-generic.btf) OR to install the non CO-RE eBPF object and run tracee-ebpf command without an env variable.</p>","title":"Install the non CO-RE eBPF object"},{"location":"building/nocore-ebpf/#run-non-co-re-tracee-ebpf","text":"<p>If you install the non CO-RE eBPF object and run tracee-ebpf in an environment that needs it, then the debug output will look like:</p> <pre><code>$ sudo ./dist/tracee-ebpf --debug\n\nOSInfo: ARCH: x86_64\nOSInfo: VERSION: \"20.04.3 LTS (Focal Fossa)\"\nOSInfo: ID: ubuntu\nOSInfo: ID_LIKE: debian\nOSInfo: PRETTY_NAME: \"Ubuntu 20.04.3 LTS\"\nOSInfo: VERSION_ID: \"20.04\"\nOSInfo: VERSION_CODENAME: focal\nOSInfo: KERNEL_RELEASE: 5.8.0-63-generic\nBTF: bpfenv = false, btfenv = false, vmlinux = false\nBPF: no BTF file was found or provided, trying non CO-RE eBPF at\n     /tmp/tracee/tracee.bpf.5_8_0-63-generic.v0_6_5-20-g3353501.o\n</code></pre> <p>One way of forcing tracee-ebpf to use non CO-RE eBPF object, even in a kernel that supports CO-RE, is by setting the <code>TRACEE_BPF_FILE</code> environment, like this:</p> <pre><code>$ sudo TRACEE_BPF_FILE=/tmp/tracee/tracee.bpf.5_4_0-91-generic.v0_6_5-80-ge723a22.o ./dist/tracee-ebpf --debug -o option:parse-arguments --trace comm=bash --trace follow\nOSInfo: PRETTY_NAME: \"Ubuntu 20.04.3 LTS\"\nOSInfo: VERSION_ID: \"20.04\"\nOSInfo: VERSION_CODENAME: focal\nOSInfo: KERNEL_RELEASE: 5.4.0-91-generic\nOSInfo: ARCH: x86_64\nOSInfo: VERSION: \"20.04.3 LTS (Focal Fossa)\"\nOSInfo: ID: ubuntu\nOSInfo: ID_LIKE: debian\nBTF: bpfenv = true, btfenv = false, vmlinux = false\nBPF: using BPF object from environment: /tmp/tracee/tracee.bpf.5_4_0-91-generic.v0_6_5-80-ge723a22.o\nTIME             UID    COMM             PID     TID     RET              EVENT                ARGS\n...\n</code></pre>","title":"Run non CO-RE tracee-ebpf"},{"location":"building/nocore-ebpf/#use-the-building-environment","text":"<p>If you're willing to generate the non CO-RE eBPF object using the <code>tracee-make</code> building environment container, you're able to by doing:</p> <p><pre><code>$ make -f builder/Makefile.tracee-make alpine-prepare\n$ make -f builder/Makefile.tracee-make alpine-shell\n</code></pre> or <pre><code>$ make -f builder/Makefile.tracee-make ubuntu-prepare\n$ make -f builder/Makefile.tracee-make ubuntu-shell\n</code></pre></p> <p>and then, inside the docker container:</p> <pre><code>tracee@f65bab137305[/tracee]$ make clean\ntracee@f65bab137305[/tracee]$ make tracee-ebpf\ntracee@f65bab137305[/tracee]$ make install-bpf-nocore\n\ntracee@f65bab137305[/tracee]$ sudo ./dist/tracee-ebpf --debug\nKConfig: warning: could not check enabled kconfig features\n(could not read /boot/config-5.8.0-63-generic: ...)\nKConfig: warning: assuming kconfig values, might have unexpected behavior\nOSInfo: KERNEL_RELEASE: 5.8.0-63-generic\nOSInfo: ARCH: x86_64\nOSInfo: VERSION: \"21.04 (Hirsute Hippo)\"\nOSInfo: ID: ubuntu\nOSInfo: ID_LIKE: debian\nOSInfo: PRETTY_NAME: \"Ubuntu 21.04\"\nOSInfo: VERSION_ID: \"21.04\"\nOSInfo: VERSION_CODENAME: hirsute\nBTF: bpfenv = false, btfenv = false, vmlinux = false\nBPF: no BTF file was found or provided\nBPF: trying non CO-RE eBPF at /tmp/tracee/tracee.bpf.5_8_0-63-generic.v0_6_5-20-g0b921b1.o\nKConfig: warning: assuming kconfig values, might have unexpected behavior\nTIME             UID    COMM             PID     TID     RET ...\n</code></pre>","title":"Use the building environment"},{"location":"building/packaging/","text":"<p>These instructions are meant to describe how to build Linux distributions packages. If you would like to have a local building building and execution environment, read this instead.</p>","title":"Creating Tracee Linux packages"},{"location":"building/packaging/#ubuntu","text":"<p>You may use <code>builder/Makefile.packaging</code> to generate Ubuntu deb packages. It will use docker containers to generate appropriate packages, so you don't need to install build depencies in your OS.</p>  <p>Ubuntu</p>  <p>Building</p> <ul> <li>Bionic (LTS)</li> </ul> <pre><code>$ make -f builder/Makefile.packaging ubuntu-bin-bionic\n</code></pre> <ul> <li>Focal (LTS)</li> </ul> <pre><code>$ make -f builder/Makefile.packaging ubuntu-bin-focal\n</code></pre> <ul> <li>Jammy (LTS)</li> </ul> <pre><code>$ make -f builder/Makefile.packaging ubuntu-bin-jammy\n</code></pre>   <p>Versioning</p> <p>The ubuntu <code>.deb</code> packages have the following versioning format:</p> <p><code>tracee-{ebpf,rules}_version~ubuntuver~builddate-lastcommit_arch.deb</code></p> <p>Examples:</p> <pre><code># bionic\ntracee-ebpf_0.6.5-111~18.04~2201281255-3a6874a_amd64.deb\ntracee-rules_0.6.5-111~18.04~2201281255-3a6874a_amd64.deb\n\n# focal\ntracee-ebpf_0.6.5-111~20.04~2201281302-3a6874a_amd64.deb\ntracee-rules_0.6.5-111~20.04~2201281302-3a6874a_amd64.deb\n\n...\n</code></pre> <p>This allows upgrades among future releases of tracee AND ubuntu. It also allows you to upgrade to \"in between releases\" versions if a fix is needed.</p>   <p>Location</p> <p>The packages will be generated in <code>dist/</code> directory.</p>","title":"Ubuntu"},{"location":"building/packaging/#fedora","text":"<p>You may use <code>builder/Makefile.packaging</code> to generate Fedora rpm packages. It will use docker containers to generate appropriate packages, so you don't need to install build depencies in your OS.</p>  <p>Fedora</p>  <p>Building</p> <ul> <li>35 (still mantained)</li> </ul> <pre><code>make -f builder/Makefile.packaging fedora-bin-35\n</code></pre> <ul> <li>36 (latest)</li> </ul> <pre><code>make -f builder/makefile.packaging fedora-bin-36\n</code></pre> <ul> <li>37 (devel)</li> </ul> <pre><code>make -f builder/makefile.packaging fedora-bin-37\n</code></pre>   <p>Versioning</p> <p>The fedora <code>.rpm</code> packages have the following versioning format:</p> <p><code>tracee-{ebpf,rules}-version-f{34,35,36}.builddate.lastcommit.arch.rpm</code></p> <p>Examples:</p> <pre><code># f35\ntracee-ebpf-0.6.5.163-f35.2202140512.ef35306d.x86_64.rpm\ntracee-rules-0.6.5.163-f35.2202140512.ef35306d.x86_64.rpm\n\n# f36\ntracee-ebpf-0.6.5.163-f36.2202140514.ef35306d.x86_64.rpm\ntracee-rules-0.6.5.163-f36.2202140514.ef35306d.x86_64.rpm\n\n# f37\ntracee-ebpf-0.8.0.rc-f37.2207080417.07c8af7.x86_64.rpm\ntracee-rules-0.8.0.rc-f37.2207080417.07c8af7.x86_64.rpm\n...\n</code></pre> <p>This allows upgrades among future releases of tracee AND fedora. It also allows you to upgrade to \"in between releases\" versions if a fix is needed.</p>   <p>Location</p> <p>The packages will be generated in <code>dist/</code> directory.</p>","title":"Fedora"},{"location":"capturing/","text":"<p>Note</p> <p>This entire section is about running tracee-ebpf only, without piping events to tracee-rules but, instead, capturing artifacts from the environment being traced.</p>  <p>Tracee has a unique feature that lets you capture interesting artifacts from running applications, using the <code>--capture</code> flag.</p> <pre><code>$ sudo ./dist/tracee-ebpf --capture help\n$ sudo ./dist/tracee-ebpf --capture xxx\n</code></pre>  <p>Tip</p> <p>All captured artifacts are saved in Tracee's \"output directory\", which can be configured using <code>--capture dir:/path/to/dir</code>. You may also use <code>--capture clear-dir</code> if you want contents of the destination directory to be cleared every time you execute tracee.</p>","title":"Getting Started with Capturing"},{"location":"capturing/#artifacts-types","text":"<p>Tracee can capture the following types of artifacts:</p> <ol> <li> <p>Written Files</p> <p>Anytime a file is being written to, the contents of the file  will be captured. Written files can be filtered using an optional path  prefix.</p> <pre><code>$ sudo ./dist/tracee-ebpf \\\n   --output json \\\n   --trace comm=bash \\\n   --trace follow \\\n   --output option:parse-arguments \\\n   --capture dir:/tmp/tracee/ \\\n   --capture write=/tmp/*\n\n$ echo testing 123 &gt; /tmp/testing.txt\n</code></pre> <pre><code>{\"timestamp\":1657321167356748797,\"threadStartTime\":620311624458929,\"processorId\":7,\"processId\":2578238,\"cgroupId\":1,\"threadId\":2578238,\"parentProcessId\":2578237,\"hostProcessId\":2578238,\"hostThreadId\":2578238,\"hostParentProcessId\":2578237,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"bash\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"722\",\"eventName\":\"security_file_open\",\"argsNum\":6,\"returnValue\":0,\"stackAddresses\":null,\"args\":[{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"/tmp/testing.txt\"},{\"name\":\"flags\",\"type\":\"string\",\"value\":\"O_WRONLY|O_CREAT|O_TRUNC|O_LARGEFILE\"},{\"name\":\"dev\",\"type\":\"dev_t\",\"value\":271581185},{\"name\":\"inode\",\"type\":\"unsigned long\",\"value\":1966101},{\"name\":\"ctime\",\"type\":\"unsigned long\",\"value\":1657321027326584850},{\"name\":\"syscall_pathname\",\"type\":\"const char*\",\"value\":\"/tmp/testing.txt\"}]}\n{\"timestamp\":1657321167356729582,\"threadStartTime\":620311624458929,\"processorId\":7,\"processId\":2578238,\"cgroupId\":1,\"threadId\":2578238,\"parentProcessId\":2578237,\"hostProcessId\":2578238,\"hostThreadId\":2578238,\"hostParentProcessId\":2578237,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"bash\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"257\",\"eventName\":\"openat\",\"argsNum\":4,\"returnValue\":3,\"stackAddresses\":null,\"args\":[{\"name\":\"dirfd\",\"type\":\"int\",\"value\":-100},{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"/tmp/testing.txt\"},{\"name\":\"flags\",\"type\":\"string\",\"value\":\"O_WRONLY|O_CREAT|O_TRUNC\"},{\"name\":\"mode\",\"type\":\"mode_t\",\"value\":438}]}\n</code></pre>  <p>Note</p> <p>You can read captured files written at <code>/tmp/tracee/out</code>: <pre><code>$ sudo cat /tmp/tracee/out/host/write.dev-271581185.inode-1966101\ntesting 123\n</code></pre></p>  </li> <li> <p>Executed Files</p> <p>Anytime a binary is executed, the binary file will be captured. If the  same binary is executed multiple times, it will be captured just once.</p> <pre><code>$ sudo ./dist/tracee-ebpf \\\n   --output json \\\n   --trace comm=bash \\\n   --trace follow \\\n   --output option:parse-arguments \\\n   --capture dir:/tmp/tracee/ \\\n   --capture exec\n\n$ /bin/ls\n</code></pre> <pre><code>{\"timestamp\":1657322300531713371,\"threadStartTime\":620311624458929,\"processorId\":21,\"processId\":2578238,\"cgroupId\":1,\"threadId\":2578238,\"parentProcessId\":2578237,\"hostProcessId\":2578238,\"hostThreadId\":2578238,\"hostParentProcessId\":2578237,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"bash\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"56\",\"eventName\":\"clone\",\"argsNum\":5,\"returnValue\":3331757,\"stackAddresses\":null,\"args\":[{\"name\":\"flags\",\"type\":\"string\",\"value\":\"CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID\"},{\"name\":\"stack\",\"type\":\"void*\",\"value\":\"0x0\"},{\"name\":\"parent_tid\",\"type\":\"int*\",\"value\":\"0x0\"},{\"name\":\"child_tid\",\"type\":\"int*\",\"value\":\"0x7fd7ce0d3a10\"},{\"name\":\"tls\",\"type\":\"unsigned long\",\"value\":0}]}\n{\"timestamp\":1657322300534562489,\"threadStartTime\":620311624458929,\"processorId\":21,\"processId\":2578238,\"cgroupId\":1,\"threadId\":2578238,\"parentProcessId\":2578237,\"hostProcessId\":2578238,\"hostThreadId\":2578238,\"hostParentProcessId\":2578237,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"bash\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"3\",\"eventName\":\"close\",\"argsNum\":1,\"returnValue\":0,\"stackAddresses\":null,\"args\":[{\"name\":\"fd\",\"type\":\"int\",\"value\":3}]}\n</code></pre>  <p>Note</p> <p>You will have a copy of each executed file written at <code>/tmp/tracee/out</code>: <pre><code>$ ldd /bin/ls\nlinux-vdso.so.1 (0x00007ffca632c000)\nlibselinux.so.1 =&gt; /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007f9a930d5000)\nlibc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f9a92ead000)\nlibpcre2-8.so.0 =&gt; /lib/x86_64-linux-gnu/libpcre2-8.so.0 (0x00007f9a92e16000)\n/lib64/ld-linux-x86-64.so.2 (0x00007f9a93136000)\n\n$ ldd /tmp/tracee/out/host/exec.1657322052835478987.ls\nlinux-vdso.so.1 (0x00007ffe337fb000)\nlibselinux.so.1 =&gt; /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007feeb1fa5000)\nlibc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007feeb1d7d000)\nlibpcre2-8.so.0 =&gt; /lib/x86_64-linux-gnu/libpcre2-8.so.0 (0x00007feeb1ce6000)\n/lib64/ld-linux-x86-64.so.2 (0x00007feeb2006000)\n\n$ sudo chmod +x /tmp/tracee/out/host/exec.1657322052835478987.ls\n$ /tmp/tracee/out/host/exec.1657322052835478987.ls\n</code></pre></p>  </li> <li> <p>Memory Files</p> <p>Anytime a memory unpacker is detected, the suspicious memory region  will be captured. This is triggered when memory protection changes from  Write+Execute to Write.</p> <pre><code>$ sudo ./dist/tracee-ebpf \\\n   --output none \\\n   --trace comm=bash \\\n   --trace follow \\\n   --capture dir:/tmp/tracee/ \\\n   --capture mem\n</code></pre>  <p>Note</p> <p>You may opt not to have any output from tracee with <code>--output none</code> command flag is given. This makes tracee to work in capture mode only.</p>  </li> <li> <p>Network PCAP Files</p> <p>Anytime a packet goes through the network interface, the packet  is captured into the pcap file. Only packets that are generated by traced  processes are being captured.</p> <p>A good way to test this behavior is to execute:</p> <pre><code>$ sudo ./dist/tracee-ebpf \\\n    --output format:json \\\n    --output option:parse-arguments \\\n    --output option:detect-syscall \\\n    -trace comm=ping \\\n    --capture net=lo\n</code></pre> <p>and execute on the host:</p> <pre><code>$ ping 127.0.0.1\n</code></pre> <p>and observe pcap file:</p> <pre><code>$ tcpdump -n -r /tmp/tracee/out/host/capture.pcap\n\n15:48:33.109392 IP 127.0.0.1 &gt; 127.0.0.1: ICMP echo request, id 74, seq 1, length 64\n15:48:33.109440 IP 127.0.0.1 &gt; 127.0.0.1: ICMP echo reply, id 74, seq 1, length 64\n15:48:34.138680 IP 127.0.0.1 &gt; 127.0.0.1: ICMP echo request, id 74, seq 2, length 64\n15:48:34.138725 IP 127.0.0.1 &gt; 127.0.0.1: ICMP echo reply, id 74, seq 2, length 64\n</code></pre> <p>OR, mix capture and tracing options w/ different interfaces:</p> <pre><code>$ sudo ./dist/tracee-ebpf \\\n   --output format:json \\\n   --output option:parse-arguments \\\n   --output option:detect-syscall \\\n   -trace comm=ping \\\n   -trace event=net_packet \\\n   -trace net=docker0 \\\n   --capture net=lo\n</code></pre> <ol> <li> <p>If user executes on the host:</p> <pre><code>$ ping 1.1.1.1\n</code></pre> <p>it won't be captured into pcap file (since it won't go through lo).</p> </li> <li> <p>Now, if user executes on the host:</p> <pre><code>$ ping 127.0.0.1\n</code></pre> <p>this will be captured into the pcap file (lo interface captured).</p> </li> <li> <p>If user executes in a container:</p> <pre><code>$ ping 127.0.0.1\n</code></pre> <p>this won't be captured into pcap file (lo refers to the host only for now).</p> </li> <li> <p>Now, if user executes:</p> <pre><code>$ ping 1.1.1.1\n</code></pre> <p>this won't be captured into pcap file (but it will be traced because command is tracing docker0 interface).</p>  <p>Attention</p> <p>For now Tracee only supports: ETH, IP/IPv6 and  ICMP/UDP/TCP protocols.</p>  </li> </ol> </li> <li> <p>Loaded Kernel Modules</p> <p>Anytime a kernel module is loaded, the binary file will be captured.  If the same binary is loaded multiple times, it will be captured just once.</p> <pre><code>$ sudo ./dist/tracee-ebpf \\\n   --output none \\\n   --trace comm=bash \\\n   --trace follow \\\n   --capture clear-dir \\\n   --capture module\n</code></pre> <p>Captured module will be found in tracee destination directory, just like  any other captured file would be:</p> <pre><code>$ sudo ls /tmp/tracee/out/host\n  module.dev-271581185.inode-4071826.pid-3668786.c8b62228208f4bdbf21df09c01046b73dd44733841675bf3c0ff969fbedab616\n</code></pre> <p>AND, the captured module is an exact copy of the loaded module:</p> <pre><code>$ sudo rmmod lkm_example\n$ sudo insmod /tmp/tracee/out/host/module.dev-271581185.inode-4071826.pid-3668786.c8b62228208f4bdbf21df09c01046b73dd44733841675bf3c0ff969fbedab616\n$ lsmod | grep example\nlkm_example            16384  0\n$ sudo rmmod lkm_example\n</code></pre> <p>you can even load/unload it.</p>  <p>Note</p> <p>Example kernel module taken from this blog</p>  </li> </ol>","title":"Artifacts Types"},{"location":"contributing/guidelines/","text":"","title":"Source Code Guidelines"},{"location":"contributing/guidelines/#style-guide-for-contributors","text":"<p>For those willing to contribute to Tracee, this repository has code formatting guidelines being enforced. It is recommended that, before commiting your changes, you run the following command:</p> <ol> <li>Check for formatting issues</li> </ol>  <p>Check-fmt</p> <pre><code>$ make check-fmt\nChecking C and eBPF files and headers formatting...\nChecking golang files formatting...\n</code></pre>  <p>This will make sure PRs won't fail due to same checks being enforced.</p>   <ol> <li>Fix Go and C source files formatting</li> </ol>  <p>Fix-fmt</p> <pre><code>$ make fix-fmt\n\nFixing C and eBPF files and headers formatting...\nFormatting ./pkg/ebpf/c/missing_definitions.h\nFormatting ./pkg/ebpf/c/struct_flavors.h\nFormatting ./pkg/ebpf/c/tracee.bpf.c\nFormatting ./pkg/ebpf/c/vmlinux.h\n\nFixing golang files formatting...\npatching file pkg/ebpf/tracee.go\n\n$ git status -s\n M Makefile\n M builder/Makefile.checkers\n M pkg/ebpf/c/missing_definitions.h\n M pkg/ebpf/c/struct_flavors.h\n M pkg/ebpf/c/tracee.bpf.c\n M pkg/ebpf/c/vmlinux.h\n</code></pre>  <ol> <li>Static Check Go and C source files</li> </ol>  <p>Code-check</p> <pre><code>$ make code-check\n\nChecking Golang vet...\nmake[2]: warning: jobserver unavailable: using -j1.  Add '+' to parent make rule.\nGOOS=linux CC=clang GOARCH=amd64 CGO_CFLAGS=\"-I/home/rafaeldtinoco/work/ebpf/tracee-review/dist/libbpf\" CGO_LDFLAGS=\"-lelf -lz /home/rafaeldtinoco/work/ebpf/tracee-review/dist/libbpf/libbpf.a\" \\\ngo vet \\\n    -tags core,ebpf \\\n    ./...\n\nChecking Golang with StaticChecker...\nmake[2]: warning: jobserver unavailable: using -j1.  Add '+' to parent make rule.\nGOOS=linux CC=clang GOARCH=amd64 CGO_CFLAGS=\"-I/home/rafaeldtinoco/work/ebpf/tracee-review/dist/libbpf\" CGO_LDFLAGS=\"-lelf -lz /home/rafaeldtinoco/work/ebpf/tracee-review/dist/libbpf/libbpf.a\" \\\nstaticcheck -f stylish \\\n    -tags core,ebpf \\\n    ./...\n \u2716 0 problems (0 errors, 0 warnings, 0 ignored)\n</code></pre>","title":"Style Guide for Contributors"},{"location":"deep-dive/caching-events/","text":"<p>Tracee has an events caching (in-memory) mechanism. In order to check latest caching options you may execute:</p> <pre><code>$ ./dist/tracee-ebpf --cache help\n</code></pre>  <p>Read</p> <p>Before continuing, please read the architecture page, in order to understand the tracee pipeline concept, AND the performance page, to understand possible pain points.</p>  <p></p> <p>The caching happens in userland, it is an in-memory caching, and it helps with workload bursts: if kernel produces more events than userland is capable of processing (considering tracee-ebpf parsing and tracee-rules evaluations) then the events are kept in a sizeable cache (defined by user) so they're not lost (if cache isn't full).</p> <p>The effects of this are the following:</p> <ol> <li> <p>Detections might be delayed because of workload bursts, but not lost (if    cache isn't full).</p> </li> <li> <p>Event losses from the kernel perf/ring buffer will only happen when    cache is full.</p> </li> <li> <p>Any difference in ratio production:consumption (either from    kernel-&gt;tracee-ebpf or tracee-ebpf-&gt;tracee-rules**) can be    mitigated temporarily.</p> </li> </ol>","title":"Special: Caching Events"},{"location":"deep-dive/caching-events/#use-caching","text":"<p>Example using 1GB cache, container enrichment in the pipeline, argument parsing so arguments are formatted in a human consumable way, detect syscall that generated the event:</p> <pre><code>$ sudo ./dist/tracee-ebpf \\\n    --cache cache-type=mem \\\n    --cache mem-cache-size=1024 \\\n    --containers -o format:json \\\n    -o option:parse-arguments \\\n    -o option:detect-syscall \\\n    -trace container \\\n    --crs docker:/var/run/docker.sock\n</code></pre>  <p>We are using most of the options that could cause latencies in the event pipeline BUT we're not piping the events to tracee-rules.</p>   <p>Attention</p> <p>If you pipe tracee-ebpf output to another tool, like <code>jq</code>: <pre><code>| jq -c '. | {cgroupid, processname, containername}'\n</code></pre> You may cause latencies in tracee-ebpf pipeline because the event json processing from <code>jq</code> might not be as fast as how tracee-ebpf is capable of writing events to it (just like tracee-rules could do if being slow evaluating events).</p>","title":"Use caching"},{"location":"deep-dive/dropping-capabilities/","text":"<p>tracee-ebpf and tracee-rules both try to reduce capabilities upon startup.</p>","title":"Special: Dropping Capabilities"},{"location":"deep-dive/dropping-capabilities/#dropping-errors","text":"<p>Attention</p> <p>This session is important if you're facing errors while tracee-ebpf is trying to drop its capabilities or any other permissions errors.</p>  <p>Some environments won't allow capabilities dropping because of permission issues (for example - AWS Lambdas).</p>  <p>It might be a result of seccomp filter for example, restricting syscalls access.</p>  <p>Failure in capabilities dropping will result tracee's exit with a matching error, to guarantee that tracee isn't running with excess capabilities without the user agreement.</p> <p>To allow tracee to run with high capabilities and prevent errors, the <code>--allow-high-capabilities</code> flag can be used in tracee-rules, or <code>--caps allow-failed-drop</code> in tracee-ebpf. For docker users, to allow tracee-ebpf high capabilities the environment variable <code>ALLOW_HIGH_CAPABILITIES=1</code> should be used.</p>","title":"Dropping Errors"},{"location":"deep-dive/dropping-capabilities/#missing-capabilities-errors","text":"<p>New features and refactoring might result missing capabilities for tracee-ebpf. This may cause a wide variety of errors.</p> <p>Our team tries to solve bugs as quickly as possible, but it might still take some time to solve some bugs. Moreover, after a bug is fixed it might take some time until a new version of Tracee is released.</p> <p>To fix specific missing capabilities errors locally, users can add capabilities using the <code>--caps add</code> flag to tracee-ebpf. For docker users, the environment variable <code>CAPS_TO_PRESERVE=&lt;list_of_capabilities&gt;</code> should be used.</p> <p>In addition, the <code>--caps cancel-drop</code> flag can be used to cancel capability dropping of tracee-ebpf. For docker users, the environment variable <code>CANCEL_CAPS_DROP=1</code> should be used. We advise to not use this option unless required.</p>","title":"Missing Capabilities Errors"},{"location":"deep-dive/ordering-events/","text":"<p>Package sorting feature is responsible for sorting incoming events from the BPF programs chronologically.</p> <pre><code>sudo ./dist/tracee-ebpf \\\n    -o format:json \\\n    -o option:parse-arguments \\\n    -o option:detect-syscall \\\n    -o option:sort-events\n</code></pre>  <p>Information</p> <p>There are 3 known sources to events sorting issues:</p> <ol> <li> <p>In perf buffer, events are read in round robing order from CPUs buffers      (and not according to invocation time).</p> </li> <li> <p>Syscall events are invoked after internal events of the syscall (though      the syscall happened before the internal events).</p> </li> <li> <p>Virtual CPUs might enter sleep mode by host machine scheduler and send      events after some delay.</p> </li> </ol>","title":"Special: Ordering Events"},{"location":"deep-dive/ordering-events/#deep-dive-into-sorting-feature","text":"<p>To address the events perf buffers issue, the events are divided to queues according to the source CPU. This way the events are almost ordered (except for syscalls). The syscall events are inserted to their right chronological place manually.</p> <p>This way, all events which occurred before the last event of the most delaying CPU could be sent forward with guaranteed order.</p> <p>To make sure syscall events are not missed when sending, a small delay is needed. Lastly, to address the vCPU sleep issue (which might cause up to 2 events received in a delay), the events need to be sent after a delay which is bigger than max possible vCPU sleep time (which is just an increase of the syscall events delay sending).</p>","title":"Deep Dive Into Sorting Feature"},{"location":"deep-dive/ordering-events/#algorithm-for-nerds-d","text":"<p>To summarize the algorithm main logic, here is textual simulation of the operation (assume that 2 scheduler ticks are larger than max possible vCPU sleep time):  </p> <p>Tn = Timestamp (n == TOD) #m = Event's Source CPU  </p> <ol> <li> <p>Initial State</p> <pre><code>       [ CPU 0 ]    [ CPU 1 ]    [ CPU 2 ]\n  HEAD    T1           T2           T4\n          T3           T5\n          T6\n  TAIL    T8\n</code></pre> </li> <li> <p>Scheduler Tick #1</p> <pre><code>Incoming events: T9#1, T11#2, T13#1, T10#2, T12#2\n\nQueues state after insert:\n       [ CPU 0 ]    [ CPU 1 ]    [ CPU 2 ]\n  HEAD    T1           T2           T4\n          T3           T5           T10 +\n          T6           T9  +        T11 +\n  TAIL    T8           T13 +        T12 +\n\n  - No event sent.\n  - Oldest timestamp = T1.\n  - T8 is oldest timestamp in most recent timestamps.\n  - In 2 ticks from now: send all events up to T8.\n  - Bigger timestamps than T8 (+) will be sent in future scheduling.\n</code></pre> </li> <li> <p>Scheduler Tick #2</p> <pre><code>Incoming events: T7#0, T22#1, T23#2, T20#0, T25#1, T24#2, T21#0\n\nQueues state after insert:\n       [ CPU 0 ]    [ CPU 1 ]    [ CPU 2 ]\n  HEAD    T1  ^        T2  ^        T4  ^\n          T3  ^        T5  ^        T10\n          T6  ^        T9           T11\n          T7  +^       T13          T12\n          T8  ^        T22 +        T23 +\n          T20 +        T25 +        T24 +\n  TAIL    T21 +\n\n  - No event sent.\n  - Oldest timestamp = T1.\n  - T21 is oldest timestamp in most recent timestamps.\n  - In 2 ticks from now: send all events up to T21.\n  - T8 is previous oldest timestamp in most recent timestamps.\n  - Next tick: send all events up to T8.\n  - Bigger timestamps than T21 (+) will be sent in future scheduling.\n</code></pre> </li> <li> <p>Scheduler Tick #3</p> <pre><code>Incoming events: T30#0, T34#1, T35#2, T31#0, T36#2, T32#0, T37#2, T33#0, T38#2, T50#1, T51#1\n\nQueues state after insert:\n       [ CPU 0 ]    [ CPU 1 ]    [ CPU 2 ]\n  HEAD    T20 ^        T9  ^        T10 ^\n          T21 ^        T13 ^        T11 ^\n          T30 +        T22          T12 ^\n          T31 +        T23          T24\n          T32 +        T25          T35 +\n          T33 +        T34 +        T36 +\n                       T50 +        T37 +\n   TAIL                T51 +        T38 +\n\n  - Max sent timestamp = T8.\n  - Oldest timestamp = T9.\n  - T33 is oldest timestamp in most recent timestamps.\n  - In 2 ticks from now: send all events up to T33.\n  - T21 is previous oldest timestamp in most recent timestamps.\n  - Next tick: send all events up to T21.\n  - Bigger timestamps than T33 (+) will be sent in future scheduling.\n</code></pre> </li> </ol>","title":"Algorithm for Nerds =D"},{"location":"deep-dive/override-os-files/","text":"<p>Tracee supports eBPF CO-RE (Compile Once - Run Everywhere) technology and, because of that, it might need some information about the Linux OS it is running at. Tracee, through libbpfgo, must have access to /etc/os-release file AND either /boot/config-$(uname-r) OR /proc/config.gz files (KernelConfig API at helpers/kernel_config).</p>  <p>Note that, despite having this need, tracee will try to execute as CO-RE eBPF program in any environment it is executed.</p>","title":"Special: Overriding OS needed files"},{"location":"deep-dive/override-os-files/#os-release","text":"<p>Tracee will show you collected information about the running Linux OS with the <code>--debug</code> argument:</p> <pre><code>$ sudo ./dist/tracee-ebpf --debug --trace uid=1000 --trace pid=new --trace event=execve\nOSInfo: VERSION_ID: \"21.04\"\nOSInfo: VERSION_CODENAME: hirsute\nOSInfo: KERNEL_RELEASE: 5.11.0-31-generic\nOSInfo: VERSION: \"21.04 (Hirsute Hippo)\"\nOSInfo: ID: ubuntu\nOSInfo: ID_LIKE: debian\nOSInfo: PRETTY_NAME: \"Ubuntu 21.04\"\nBTF: bpfenv = false, btfenv = false, vmlinux = true\nBPF: using embedded BPF object\nunpacked CO:RE bpf object file into memory\nTIME             UID    COMM             PID     TID     RET              EVENT                ARGS\n02:34:43:212623  1000   bash             2787679 2787679 0                execve               pathname: /bin/true, argv: [/bin/true]\n</code></pre> <p>BUT os-release file might not exist:</p> <p>Because you're running in a distribution that does not have /etc/os-release, or because you're running inside a container that does not support it, you may face the following error:</p> <pre><code>$ sudo ./dist/tracee-ebpf --debug --trace uid=1000 --trace pid=new --trace event=execve\nOSInfo: KERNEL_RELEASE: 5.14.0-rc5+\nOSInfo: warning: os-release file could not be found\n(open /etc/os-release: no such file or directory)\nBTF: bpfenv = false, btfenv = false, vmlinux = true\nBPF: using embedded BPF object\nunpacked CO:RE bpf object file into memory\nTIME             UID    COMM             PID     TID     RET              EVENT                ARGS\n05:37:02:831787  1000   bash             13940   13940   0                execve               pathname: /bin/true, argv: [/bin/true]\n\nEnd of events stream\nStats: {EventCount:1 ErrorCount:0 LostEvCount:0 LostWrCount:0 LostNtCount:0}\n</code></pre>  <p>Note</p> <p>But do note that tracee-ebpf shall continue working (informing only the KERNEL_RELEASE OSInfo option).</p>  <p>If you need to override the underlaying Linux OS information, because you're running inside a container that already has /etc/os-release file, for example, you may create another os-release file and inform tracee-ebpf by using LIBBPFGO's environment variable <code>LIBBPFGO_OSRELEASE_FILE</code>:</p> <pre><code>$ sudo LIBBPFGO_OSRELEASE_FILE=/etc/os-release.orig ./dist/tracee-ebpf --debug --trace uid=1000 --trace pid=new --trace event=execve\nOSInfo: VERSION_CODENAME: impish\nOSInfo: ID: ubuntu\nOSInfo: ID_LIKE: debian\nOSInfo: KERNEL_RELEASE: 5.14.0-rc5+\nOSInfo: PRETTY_NAME: \"Ubuntu Impish Indri (development branch)\"\nOSInfo: VERSION_ID: \"21.10\"\nOSInfo: VERSION: \"21.10 (Impish Indri)\"\nBTF: bpfenv = false, btfenv = false, vmlinux = true\nBPF: using embedded BPF object\nunpacked CO:RE bpf object file into memory\nTIME             UID    COMM             PID     TID     RET              EVENT                ARGS\n05:39:24:100006  1000   bash             14014   14014   0                execve               pathname: /bin/true, argv: [/bin/true]\n</code></pre>  <p>If you're running tracee inside a docker container, you can simply bind mount /etc/os-release from the host as /etc/os-release-host into the guest and inform that through the <code>LIBBPFGO_OSRELEASE_FILE</code> environment variable.</p>","title":"OS-RELEASE"},{"location":"deep-dive/override-os-files/#kconfig","text":"<p>Tracee needs access to kconfig file (/proc/config.gz OR /boot/config-$(uname -r)) in order to:</p> <ol> <li>Check if the kernel of your running environment supports needed eBPF features</li> <li>Provide kconfig variables to its eBPF counter-part (so eBPF program take decisions)</li> </ol>  <p>Warning</p> <p>Tracee should NOT fail when it cannot find a kconfig file:</p> <pre><code>$ sudo ./dist/tracee-ebpf --debug --trace uid=1000 --trace pid=new --trace event=execve\nKConfig: warning: could not check enabled kconfig features\n(could not read /boot/config-5.14.0-rc5+: stat /boot/config-5.14.0-rc5+: no such file or directory)\nOSInfo: KERNEL_RELEASE: 5.14.0-rc5+\nOSInfo: PRETTY_NAME: \"Ubuntu Impish Indri (development branch)\"\nOSInfo: VERSION_ID: \"21.10\"\nOSInfo: VERSION: \"21.10 (Impish Indri)\"\nOSInfo: VERSION_CODENAME: impish\nOSInfo: ID: ubuntu\nOSInfo: ID_LIKE: debian\nBTF: bpfenv = false, btfenv = false, vmlinux = true\nBPF: using embedded BPF object\nunpacked CO:RE bpf object file into memory\nTIME             UID    COMM             PID     TID     RET              EVENT                ARGS\n05:44:18:877838  1000   bash             14089   14089   0                execve               pathname: /bin/true, argv: [/bin/true]\n</code></pre> <p>but do have in mind it is assuming some things from the host environment and its behavior might have inconsistencies.</p> <p>If you are running tracee in an environment that does not have a kconfig file (nor /proc/config.gz support), it is recommended that you provide the host kconfig file location to tracee through the <code>LIBBPFGO_KCONFIG_FILE</code> environment variable:</p>  <pre><code>$ sudo LIBBPFGO_KCONFIG_FILE=/boot/config-5.14.0-rc5+.orig ./dist/tracee-ebpf --debug --trace uid=1000 --trace pid=new --trace event=execve\nOSInfo: VERSION_CODENAME: impish\nOSInfo: ID: ubuntu\nOSInfo: ID_LIKE: debian\nOSInfo: KERNEL_RELEASE: 5.14.0-rc5+\nOSInfo: PRETTY_NAME: \"Ubuntu Impish Indri (development branch)\"\nOSInfo: VERSION_ID: \"21.10\"\nOSInfo: VERSION: \"21.10 (Impish Indri)\"\nBTF: bpfenv = false, btfenv = false, vmlinux = true\nBPF: using embedded BPF object\nunpacked CO:RE bpf object file into memory\nTIME             UID    COMM             PID     TID     RET              EVENT                ARGS\n05:47:45:245869  1000   bash             14165   14165   0                execve               pathname: /bin/true, argv: [/bin/true]\n</code></pre>  <p>If you're running tracee inside a docker container, you can simply bind mount /boot/config-$(uname -r) from the host as /boot/config-$(uname -r) into the guest and inform that through the <code>LIBBPFGO_KCONFIG_FILE</code> environment variable.</p>   <p>Attention</p> <p>In case no kconfig file is found, tracee takes some decisions blindly and it may give you unexpected errors. Example:</p>","title":"KCONFIG"},{"location":"deep-dive/performance/","text":"<p>Read</p> <p>Before continuing, please read the architecture page, in order to understand the tracee pipeline concept.</p>  <p></p>","title":"Special: Performance"},{"location":"deep-dive/performance/#pain-points","text":"<p>From the tracee pipeline concept page, you learned that there might be 2 pain points regarding tracee performance:</p> <ol> <li> <p>Path between kernel and tracee-ebpf (through perfbuffers + golang    channels)</p> <ol> <li>The only way to reduce the amount of events to userland is by bringing    all filters into eBPF programs. There are some problems by doing that:    the eBPF programs can't be too big, or too slow, not to impact the    kernel performance (one of the reasons why eBPF virtual machine    exists: to sandbox eBPF code).</li> </ol> </li> <li> <p>Path between tracee-ebpf and tracee-rules (currently: a pipe,    future: a channel)</p> <ol> <li> <p>Processing, parsing and enriching events in userland needs to be    unblocking AND as fast as possible. Any extra processing in    tracee-ebpf might delay the delivery of events from the kernel    all the way down to tracee-rules signatures.</p> </li> <li> <p>The communication in between tracee-ebpf and tracee-rules needs    to be fast and not to block the consumption of events coming from the    kernel. If this is blocked, then tracee will start loosing    events because it can't catch up with the speed the events are being    created in kernel.</p> </li> <li> <p>tracee-rules processing needs to be as fast as possible. Taking too    long to evaluate a detection from each received event will slow down the    consumption of the pipe in between tracee-ebpf and tracee-rules,    delaying also the path in between the kernel and tracee-ebpf.</p> </li> </ol> </li> </ol>","title":"Pain Points"},{"location":"deep-dive/performance/#addressing-pain-points","text":"<ol> <li> <p>Path in between kernel and tracee-ebpf:</p> <ol> <li>eBPF programs already do filtering in-kernel but not for all    possible filter inputs (this is being improved for next releases).</li> </ol> </li> <li> <p>Path in betwen tracee-ebpf and tracee-rules:</p> <ol> <li> <p>From measurements, the pipe used in between tracee-ebpf and    tracee-rules processes is NOT a bottleneck BUT the gob output    format (input format for tracee-rules) has better performance.</p> </li> <li> <p>The signatures processing might be a bottleneck. Using golang signatures    in tracee-rules, for evaluating detections, has bigger    performance and should be considered whenever possible.</p> </li> </ol> </li> </ol>","title":"Addressing Pain Points"},{"location":"deep-dive/performance/#test-concepts","text":"<p>Example using container enrichment in the pipeline, argument parsing so arguments are formatted in a human consumable way, detecting syscall that generated the event:</p> <pre><code>$ sudo ./dist/tracee-ebpf \\\n    --containers -o format:json \\\n    -o option:parse-arguments \\\n    -o option:detect-syscall \\\n    -trace container \\\n    --crs docker:/var/run/docker.sock\n</code></pre>  <p>We are using most of the options that could cause latencies in the event pipeline BUT we're not piping the events to tracee-rules.</p>   <p>Attention</p> <p>If you pipe tracee-ebpf output to another tool, like <code>jq</code>: <pre><code>| jq -c '. | {cgroupid, processname, containername}'\n</code></pre> You may cause latencies in tracee-ebpf pipeline because the event json processing from <code>jq</code> might not be as fast as how tracee-ebpf is capable of writing events to it (just like tracee-rules could do if being slow evaluating events).</p>","title":"Test Concepts"},{"location":"deep-dive/secure-tracing/","text":"<ol> <li> <p>Secure tracing</p> <p>When tracee-ebpf reads information from user programs, it is subject to a race condition where the user program might be able to change the arguments after tracee read them.</p> <p>For example, a program invoked:</p> <pre><code>execve(\"/bin/ls\", NULL, 0)\n</code></pre> <p>Tracee picked that up and will report that, then the program changed the first argument from <code>/bin/ls</code> to <code>/bin/bash</code>, and this is what the kernel will execute.</p> <p>To mitigate this, Tracee also provides \"LSM\" (Linux Security Module) based events, for example, the <code>bprm_check</code> event which can be reported by Tracee and cross-referenced with the reported regular syscall event.</p> </li> </ol>","title":"FAQ - Frequently Asked Questions"},{"location":"detecting/","text":"<p>Tracee is a runtime security detection engine, more than an introspection tool (tracee-ebpf) only. tracee-rules is a rules engine that helps you detect suspicious behavioral patterns in streams of events. It is primarily made to leverage events collected with tracee-ebpf into a Runtime Security solution.</p>  <p>Attention</p> <p>You may sometimes read rules or signatures. Both mean the same thing for tracee: a set of expressions that will define whether there was a security event detection or not.</p>  <p>There are 3 basic concepts for tracee-rules:</p> <ol> <li> <p>Inputs - Event sources to be processed.</p> <ol> <li>tracee-ebpf only current supported ource</li> </ol> </li> <li> <p>Rules (a.k.a Signatures) - behavioral pattern to detect from the input    source. Signatures can be authored in:</p> <ol> <li>Golang (high performance, more error prone)</li> <li>Rego (OPA) (high level declarative language)</li> <li>Go-Cel (tech-preview) (good performance, simple)</li> </ol> </li> <li> <p>Outputs - How to communicate detections:</p> <ol> <li>Print to stdout</li> <li>Post to a webhook</li> <li>Integrate with external systems</li> </ol> </li> </ol>","title":"Getting Started with Detecting"},{"location":"detecting/#getting-started","text":"<p>tracee-rules doesn't have any requirement, but in order to run with tracee-ebpf, make sure you follow the tracee-ebpf prerequisites.</p>  <p>Attention</p> <p>You can't customize (yet) tracee-rules execution when executing official tracee container. The official container is configured with a pre-set of signatures already enabled by default. In order to customize it you have to follow building/containers.md instructions and change the default entrypoint and signatures.</p>  <p>Check getting tracee in order to understand how to obtain tracee-rules.</p>","title":"Getting Started"},{"location":"detecting/#running-tracee-rules","text":"<ol> <li> <p>Running tracee-rules with trace-ebpf in the simplest possible way:</p> <pre><code>sudo ./dist/tracee-ebpf \\\n    -o format:gob \\\n    | tracee-rules \\\n    --input-tracee file:stdin \\\n    --input-tracee format:gob\n</code></pre> <p>This will:</p> <ol> <li>Start tracee-ebpf with the default tracing mode (default events).</li> <li>Configure tracee-ebpf to output events into stdout as gob format.</li> <li>Start tracee-rules with all built-in signatures enabled.</li> </ol> </li> <li> <p>A more realistic example</p> </li> </ol>  <p>Example</p> <p>Let's put together all that we learned from the tracing section, together with what we're learning at this section and see how we can trace events and pipe them to tracee-rules so detections occur:</p> <pre><code>$ sudo ./dist/tracee-ebpf \\\n    --output json \\\n    --trace comm=bash \\\n    --trace follow \\\n    --output option:detect-syscall \\\n    --output option:parse-arguments \\\n    --trace event=$(./dist/tracee-rules --list-events) \\\n    | ./dist/tracee-rules \\\n    --input-tracee format:json \\\n    --input-tracee file:stdin\n\nLoaded 14 signature(s): [TRC-1 TRC-13 TRC-2 TRC-14 TRC-3 TRC-11 TRC-9 TRC-4 TRC-5 TRC-12 TRC-6 TRC-10 TRC-7 TRC-15]\n</code></pre> <p>We are:</p> <ol> <li>tracing all executed commands from all existing and new <code>bash</code> processes,</li> <li>detecting syscalls that generated each event (if they're not syscalls),</li> <li>parsing captured event arguments into a human readable format,</li> <li>filtering for ALL events needed by all existing signatures,</li> <li>detecting behaviors described in all existing and loaded tracee-rules signatures.</li> </ol>","title":"Running tracee-rules"},{"location":"detecting/#selecting-signatures","text":"<p>When executing tracee-rules, you're able to select which signatures you would like it to load. Also, in order to make tracee-ebpf only trace for meaningful events (for the loaded signature(s)) you may request from tracee-rules which events are needed for the selected signatures.</p> <ol> <li> <p>List default (all) signatures</p> <pre><code>$ ./dist/tracee-rules --list\nLoaded 14 signature(s): [TRC-1 TRC-13 TRC-2 TRC-14 TRC-3 TRC-11 TRC-9 TRC-4 TRC-5 TRC-12 TRC-6 TRC-10 TRC-7 TRC-15]\nID         NAME                                VERSION DESCRIPTION\nTRC-1      Standard Input/Output Over Socket   0.1.0   Redirection of process's standard input/output to socket\nTRC-13     Kubernetes API server connection detected 0.1.0   A connection to the kubernetes API server was detected. The K8S API server is the brain of your K8S cluster, adversaries may try and communicate with the K8S API server to gather information/credentials, or even run more containers and laterally expand their grip on your systems.\nTRC-2      Anti-Debugging                      0.1.0   Process uses anti-debugging technique to block debugger\nTRC-14     CGroups Release Agent File Modification 0.1.0   An Attempt to modify CGroups release agent file was detected. CGroups are a Linux kernel feature which can change a process's resource limitations. Adversaries may use this feature for container escaping.\nTRC-3      Code injection                      0.1.0   Possible code injection into another process\nTRC-11     Container Device Mount Detected     0.1.0   Container device filesystem mount detected. A mount of a host device filesystem can be exploited by adversaries to perform container escape.\nTRC-9      New Executable Was Dropped During Runtime 0.1.0   An Executable file was dropped in your system during runtime. Usually container images are built with all binaries needed inside, a dropped binary may indicate an adversary infiltrated into your container.\nTRC-4      Dynamic Code Loading                0.1.0   Writing to executable allocated memory region\nTRC-5      Fileless Execution                  0.1.0   Executing a process from memory, without a file in the disk\nTRC-12     Illegitimate Shell                  0.1.0   A program on your server spawned a shell program. Shell is the linux command-line program, server programs usually don't run shell programs, so this alert might indicate an adversary is exploiting a server program to spawn a shell on your server.\nTRC-6      kernel module loading               0.1.0   Attempt to load a kernel module detection\nTRC-10     K8S TLS Certificate Theft Detected  0.1.0   Kubernetes TLS certificate theft was detected. TLS certificates are used to establish trust between systems, the kubernetes certificate is used to to enable secured communication between kubernetes components, like the kubelet, scheduler, controller and API server. An adversary may steal a kubernetes certificate on a compromised system to impersonate kuberentes components within the cluster.\nTRC-7      LD_PRELOAD                          0.1.0   Usage of LD_PRELOAD to allow hooks on process\nTRC-15     Hooking system calls by overriding the system call table entries 0.1.0   Usage of kernel modules to hook system calls\n</code></pre> </li> <li> <p>List events needed by default (all) signatures</p> <pre><code>$ ./dist/tracee-rules --list-events\nclose,dup,dup2,dup3,execve,hooked_syscalls,init_module,magic_write,mem_prot_alert,process_vm_writev,ptrace,sched_process_exec,sched_process_exit,security_bprm_check,security_file_open,security_kernel_read_file,security_sb_mount,security_socket_connect\n</code></pre> </li> <li> <p>List events needed for given signatures only</p>  <p>Tip</p> <p>If we chose to load a single signature, we can ask tracee-rules to give us the events needed by that signature. This will allow tracee-ebpf to just listen to those events.</p>  <pre><code>$ ./dist/tracee-rules --rules TRC-3 --list-events\nprocess_vm_writev,ptrace,security_file_open\n</code></pre> </li> </ol>","title":"Selecting Signatures"},{"location":"detecting/#tracing-with-selected-signatures","text":"<p>Example</p> <p>Let's pretend we would like to pick TRC-2 signature only and monitor all new processes happening as childs of all running <code>bash</code> processes.</p> <pre><code>$ sudo ./dist/tracee-ebpf --output json --trace comm=bash --trace follow --output option:detect-syscall --output option:parse-arguments --output option:exec-env --trace event=$(./dist/tracee-rules --rules TRC-2 --list-events) | ./dist/tracee-rules --input-tracee format:json --input-tracee file:stdin --rules TRC-2\nLoaded 1 signature(s): [TRC-2]\n\n*** Detection ***\nTime: 2022-07-09T21:42:45Z\nSignature ID: TRC-2\nSignature: Anti-Debugging\nData: map[]\nCommand: strace\nHostname: fujitsu\n</code></pre>","title":"Tracing with Selected Signatures"},{"location":"detecting/go-cel/","text":"<p>Tracee has introduced, on its last version, a new type of signatures, the Common Expression Language, or Go-Cel, signatures as a PROOF OF CONCEPT.</p>  <p>Go-cel</p> <p>The Common Expression Language (CEL) is a non-Turing complete language designed for simplicity, speed, safety, and portability. CEL's C-like syntax looks nearly identical to equivalent expressions in C++, Go, Java, and TypeScript.</p>   <p>Proof-of-concept</p> <p>Go-Cel based signatures are experimental and part an on going development proof-of-concept. The feature is not finished and writing signatures in Go-Cel might need tracee code updates such as creation of internal parser helpers and/or event types declaration in a protobuf wrapper internal structure.</p>  <p>This feature is enabled by placing CEL signature definition files (.cel, .yaml, .yml) in the  the <code>--rules-dir</code> directory. Sample definition files can be found in the <code>pkg/rules/celsig/testdata/rules/</code> directory.</p>  <p>Signature</p> <pre><code>kind: SignaturesConfig\napiVersion: tracee.aquasecurity.github.io/v1alpha1\nsignatures:\n  - metadata:\n      id: \"Mine-0.1.0\"\n      version: \"0.1.0\"\n      name: \"My Own Signature\"\n      description: \"My Own Signature Detects Stuff\"\n      tags:\n        - \"linux\"\n    eventSelectors:\n      - source: tracee\n        name: openat\n    expression: |-\n        input.eventName == 'openat' &amp;&amp;\n        input.stringArg('pathname').startsWith('/etc/passwd')\n</code></pre>  <p>After placing your <code>signature_example.yaml</code> inside <code>dist/rules</code> directory you may execute tracee selecting only the event you just created, if that is what you want:</p> <pre><code>$ sudo ./dist/tracee-ebpf \\\n    --output json \\\n    --trace comm=bash \\\n    --trace follow \\\n    --output option:detect-syscall \\\n    --output option:parse-arguments \\\n    -trace event=$(./dist/tracee-rules --rules Mine-0.1.0 --list-events) \\\n    | ./dist/tracee-rules \\\n    --input-tracee \\\n    format:json \\\n    --input-tracee file:stdin \\\n    --rules Mine-0.1.0\n\nLoaded 1 signature(s): [Mine-0.1.0]\n\n*** Detection ***\nTime: 2022-07-10T05:49:48Z\nSignature ID: Mine-0.1.0\nSignature: My Own Signature\nData: map[]\nCommand: batcat\nHostname: fujitsu\n</code></pre>  <p>Experimental</p> <p>Like said previously, Go-Cel signatures are experimental and considered proof-of-concept for now. If you decide to develop Go-Cel signatures you may face some issues:</p> <ol> <li> <p>Go-Cel depends on protobuf and <code>tracee.Event</code> is not yet a protobuf    object. Because of that, there is a wrapper in place converting    <code>tracee.Event</code> into <code>protobuf</code> so the evaluations can happen (check    files inside <code>pkg/rules/celsig/wrapper/</code> directory.</p> </li> <li> <p>When writting your signature, it might happen that the event you're    filtering for does not have all of its arguments types wrapper into    the protobuf wrapper. You may face errors such as:    <pre><code>Unrecognized event arg: eventName: \"openat\" name: \"mode\" type: \"mode_t\" valueType: uint32 value: 0\n</code></pre>    It means you have to add that type to Tracee's go-cel wrapper so it    is able to evaluate it.</p> </li> <li> <p>Your signature might need helpers/macros that don't exist yet. A good    source of an example is <code>pkg/rules/celsig/library.go</code> file and    functions:</p> <ul> <li><code>sockaddrArg</code></li> <li><code>stringArg</code></li> <li><code>argByName</code></li> </ul> </li> </ol>","title":"Signatures written in Go-Cel (POC)"},{"location":"detecting/golang/","text":"<p>There are 2 ways you can get your own golang signatures working with tracee.</p> <ol> <li> <p>Built-In Golang signatures</p>  <p>Tip</p> <p>This is the preferred way to get your own golang signatures integrated into Tracee, as you will find in the next part of this page, but it needs a better end-user experience (being worked).</p>  <p>In order to get your golang signature compiled with tracee, you can create a file called <code>signatures/golang/signature_example.go</code> and place the following code in it:</p>  <p>Signature</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n\n    \"github.com/aquasecurity/tracee/signatures/helpers\"\n    \"github.com/aquasecurity/tracee/types/detect\"\n    \"github.com/aquasecurity/tracee/types/protocol\"\n    \"github.com/aquasecurity/tracee/types/trace\"\n)\n\ntype signatureExample struct {\n    cb detect.SignatureHandler\n}\n\nfunc (sig *signatureExample) Init(cb detect.SignatureHandler) error {\n    sig.cb = cb\n\n    return nil\n}\n\nfunc (sig *signatureExample) GetMetadata() (\n    detect.SignatureMetadata,\n    error,\n) {\n    return detect.SignatureMetadata{\n        ID:          \"Mine-0.1.0\",\n        Version:     \"0.1.0\",\n        Name:        \"My Own Signature\",\n        Description: \"My Own Signature Detects Stuff\",\n        Tags:        []string{\"linux\"},\n    }, nil\n}\n\nfunc (sig *signatureExample) GetSelectedEvents() (\n    []detect.SignatureEventSelector,\n    error,\n) {\n\n    return []detect.SignatureEventSelector{\n        {Source: \"tracee\", Name: \"openat\"},\n        {Source: \"tracee\", Name: \"execve\"},\n    }, nil\n}\n\nfunc (sig *signatureExample) OnEvent(event protocol.Event) error {\n    switch e := event.Payload.(type) {\n    case trace.Event:\n        if e.ArgsNum == 0 {\n            return nil\n        }\n\n        switch e.EventName {\n        case \"openat\", \"execve\":\n            arg, err := helpers.GetTraceeArgumentByName(e, \"pathname\")\n            if err != nil {\n                return err\n            }\n\n            if s, ok := arg.Value.(string); ok {\n                if strings.Contains(s, \"/etc/passwd\") {\n                    m, _ := sig.GetMetadata()\n\n                    found := detect.Finding{\n                        Event:       event,\n                        SigMetadata: m,\n                    }\n\n                    sig.cb(found)\n                }\n            }\n        }\n    default:\n        return fmt.Errorf(\"failed to cast event's payload\")\n    }\n\n    return nil\n}\n\nfunc (sig *signatureExample) OnSignal(s detect.Signal) error {\n    return nil\n}\n\nfunc (sig *signatureExample) Close() {}\n</code></pre>  <p>Then, edit <code>signatures/golang/export.go</code> and place your new signature there:</p> <pre><code>var ExportedSignatures = []detect.Signature{\n    &amp;signatureExample{},\n}\n</code></pre> <p>Follow instructions on how to build Tracee and you will find your new signature included in tracee-rules. You may even select only the signatures you created:</p> <pre><code>$ sudo ./dist/tracee-ebpf \\\n    --output json \\\n    --trace comm=bash \\\n    --trace follow \\\n    --output option:detect-syscall \\\n    --output option:parse-arguments \\\n    -trace event=$(./dist/tracee-rules --rules Mine-0.1.0 --list-events) \\\n    | ./dist/tracee-rules \\\n    --input-tracee \\\n    format:json \\\n    --input-tracee file:stdin \\\n    --rules Mine-0.1.0\n\nLoaded 1 signature(s): [Mine-0.1.0]\n\n*** Detection ***\nTime: 2022-07-10T04:25:44Z\nSignature ID: Mine-0.1.0\nSignature: My Own Signature\nData: map[]\nCommand: batcat\nHostname: fujitsu\n</code></pre> <p>Be creative! You can create signatures that would do pretty much anything! Examples of such signatures would: for every X event, connect to a cached external data-source and return a positive detection for cases A, B or C.</p> </li> <li> <p>Create a golang signature plugin and dynamically load it during runtime</p>  <p>Attention</p> <p>Eventually you will find out that Golang Plugins aren't very useful if you consider all the problems that emerge from using it:</p> <ol> <li> <p>Can't use different go versions (need to compile the go plugin    with the exact same version that was used to build Tracee).</p> </li> <li> <p>Both Tracee and your golang plugin signature must be built with the    exact same GOPATH or you will get a \"plugin was built with a    different version of package XXX\" error.</p> </li> <li> <p>Any dependency you have in your plugin should be of the same    version with the dependencies of Tracee.</p> </li> <li> <p>Compiling tracee statically is sometimes useful to have a complete    portable eBPF tracing/detection solution. One good example when    statically compiling tracee is a good idea is to have a single    binary capable of running in GLIBC (most of them) and MUSL (Alpine)    powered Linux distros.</p> </li> </ol>  <p>At the end, creating a golang signature plugin won't have the practical effects as a plugin mechanism should have, so it is preferred to have built-in golang signatures (re)distributed with newer binaries (when you need to add/remove signatures from your environment) FOR NOW.</p> </li> </ol>","title":"Golang Signatures"},{"location":"detecting/rego/","text":"<p>Tip</p> <p>Differently than golang built-in signatures, with Rego signatures you are able to add and/or remove signatures to Tracee without the need of recompiling it (or re-distributing the binary) BUT it may come with a performance price to pay.</p>  <p>In order to create your own Rego signature you need to create a <code>.rego</code> file in the rules directory that has the following Rego Rules (now, in this context, rules are Rego's language constructs):</p>  <p>rego_metadoc</p> <p>A document rule that defines the rule's metadata.</p>   <p>Tracee_selected_events</p> <p>A set rule that defines the event selectors.</p>   <p>Tracee_match</p> <p>A boolean or a document rule that defines the logic of the signature. If bool is \"returned\", a true evaluation will generate a Finding with no data. If a document is \"returned\", any non-empty evaluation will generate a Finding with the returned document as the Finding's \"Data\".</p>    <p>Signature</p> <pre><code>package tracee.Mine\n\nimport data.tracee.helpers\n\n__rego_metadoc__ := {\n    \"id\": \"Mine-0.1.0\",\n    \"version\": \"0.1.0\",\n    \"name\": \"My Own Signature\",\n    \"description\": \"My Own Signature Detects Stuff\",\n    \"tags\": [\"linux\"],\n}\n\neventSelectors := [\n    {\n        \"source\": \"tracee\",\n        \"name\": \"openat\",\n    },\n    {\n        \"source\": \"tracee\",\n        \"name\": \"execve\",\n    },\n]\n\ntracee_selected_events[eventSelector] {\n    eventSelector := eventSelectors[_]\n}\n\ntracee_match {\n    input.eventName == \"openat\"\n    arg_value = helpers.get_tracee_argument(\"pathname\")\n    startswith(arg_value, \"/etc/passwd\")\n}\n\ntracee_match {\n    input.eventName == \"execve\"\n    arg_value = helpers.get_tracee_argument(\"pathname\")\n    startswith(arg_value, \"/etc/passwd\")\n}\n</code></pre>  <p>After placing your <code>signature_example.rego</code> inside <code>dist/rules</code> directory you may execute tracee selecting only the event you just created, if that is what you want:</p> <pre><code>$ sudo ./dist/tracee-ebpf \\\n    --output json \\\n    --trace comm=bash \\\n    --trace follow \\\n    --output option:detect-syscall \\\n    --output option:parse-arguments \\\n    -trace event=$(./dist/tracee-rules --rules Mine-0.1.0 --list-events) \\\n    | ./dist/tracee-rules \\\n    --input-tracee format:json \\\n    --input-tracee file:stdin \\\n    --rules Mine-0.1.0\n\nLoaded 1 signature(s): [Mine-0.1.0]\n\n*** Detection ***\nTime: 2022-07-10T05:23:01Z\nSignature ID: Mine-0.1.0\nSignature: My Own Signature\nData: map[]\nCommand: batcat\nHostname: fujitsu\n</code></pre> <p>See signatures/rego for example Rego signatures.</p>","title":"Rego Signatures"},{"location":"detecting/rules/","text":"<p>Tip</p> <p>To view the list of available rules, run Tracee with the <code>--list</code> flag.</p>  <p>Tracee currently distributes fully functional signatures, such as:</p>    Name Description Full Description     TRC-1 Standard Input/Output Over Socket Redirection of process's standard input/output to socket   TRC-2 Anti-Debugging Process uses anti-debugging technique to block debugger   TRC-3 Code injection Possible code injection into another process   TRC-4 Dynamic Code Loading Writing to executable allocated memory region   TRC-5 Fileless Execution Executing a process from memory, without a file in the disk   TRC-6 kernel module loading Attempt to load a kernel module detection   TRC-7 LD_PRELOAD Usage of LD_PRELOAD to allow hooks on process   TRC-9 New Executable Was Dropped During Runtime An Executable file was dropped in your system during runtime. Usually container images are built with all binaries needed inside, a dropped binary may indicate an adversary infiltrated into your container.   TRC-10 K8S TLS Certificate Theft Detected Kubernetes TLS certificate theft was detected. TLS certificates are used to establish trust between systems, the kubernetes certificate is used to to enable secured communication between kubernetes components, like the kubelet, scheduler, controller and API server. An adversary may steal a kubernetes certificate on a compromised system to impersonate kuberentes components within the cluster.   TRC-11 Container Device Mount Detected Container device filesystem mount detected. A mount of a host device filesystem can be exploited by adversaries to perform container escape.   TRC-12 Illegitimate Shell A program on your server spawned a shell program. Shell is the linux command-line program, server programs usually don't run shell programs, so this alert might indicate an adversary is exploiting a server program to spawn a shell on your server.   TRC-13 Kubernetes API server connection detected A connection to the kubernetes API server was detected. The K8S API server is the brain of your K8S cluster, adversaries may try and communicate with the K8S API server to gather information/credentials, or even run more containers and laterally expand their grip on your systems.   TRC-14 CGroups Release Agent File Modification An Attempt to modify CGroups release agent file was detected. CGroups are a Linux kernel feature which can change a process's resource limitations. Adversaries may use this feature for container escaping.   TRC-15 Override system call table entries Usage of kernel modules to hook system calls     <p>Note</p> <p>And, obviously, you can create your signatures in golang, rego and go-cel.</p>","title":"Available Rules"},{"location":"events/format/","text":"","title":""},{"location":"events/format/#intro","text":"<p> - one sentence description of the event","title":"Intro"},{"location":"events/format/#description","text":"<p>Detailed description of the event. Should include: * What is the purpose of the event? * Are there any edge-cases, drawbacks or advantages of using it?</p>","title":"Description"},{"location":"events/format/#arguments","text":"<ul> <li><code>&lt;arg#1&gt;</code>:<code>&lt;type&gt;</code>[] - short description of the argument value. If the type or value might change (like with the <code>parse-arguments</code> flag) it should be elaborated here. <li><code>&lt;arg#2&gt;</code>:<code>&lt;type&gt;</code>[] - ...","title":"Arguments"},{"location":"events/format/#available-tags","text":"<ul> <li>K - Originated from kernel-space.</li> <li>U - Originated from user space (for example, pointer to user space memory used to get it)</li> <li>TOCTOU - Vulnerable to TOCTOU (time of check, time of use)</li> <li>OPT - Optional argument - might not always be available</li> </ul>","title":"Available Tags"},{"location":"events/format/#hooks","text":"","title":"Hooks"},{"location":"events/format/#_2","text":"","title":""},{"location":"events/format/#type","text":"<p>Type of probes or hooks used to hook this function. If include more than one, should be in the form of  + .","title":"Type"},{"location":"events/format/#purpose","text":"<p>Why was this function hooked?</p>","title":"Purpose"},{"location":"events/format/#_3","text":"","title":"<p>...</p>"},{"location":"events/format/#example-use-case","text":"<p>Example of a case where this event could be used.  </p>","title":"Example Use Case"},{"location":"events/format/#issues","text":"<p>If there is an issue with this event, this is the place to write it.</p>","title":"Issues"},{"location":"events/format/#related-events","text":"<p>Events connected by logic or interesting to be used in the context of the event.</p>","title":"Related Events"},{"location":"events/lsm_hooks/security_socket_setsockopt/","text":"","title":"security_socket_setsockopt"},{"location":"events/lsm_hooks/security_socket_setsockopt/#intro","text":"<p>security_socket_setsockopt - check permissions before setting the options associated with socket</p>","title":"Intro"},{"location":"events/lsm_hooks/security_socket_setsockopt/#description","text":"<p>The event marks that an attempt to set a socket option occurred, probably by the <code>setsockopt</code> syscall. The event is triggered by the permissions check for the operation, as LSM hook. The event gives insight to the socket details (which differs from the <code>setsockopt</code> syscall event, that only pass the socket fd). However, unlike the <code>setsockopt</code> syscall event, the option value isn't passed.</p>","title":"Description"},{"location":"events/lsm_hooks/security_socket_setsockopt/#arguments","text":"<ul> <li><code>sockfd</code>:<code>int</code>[K] - the file descriptor of the socket.</li> <li><code>level</code>:<code>int</code>[K] - the level that the option should apply to. If the <code>parse-arguments</code> option is on, will be transformed to a string with the level name.</li> <li><code>optname</code>:<code>int</code>[K] - the option that is set. If the <code>parse-arguments</code> option is on, will be transformed to a string with the option name.</li> <li><code>local_addr</code>:<code>struct socketaddr*</code>[K] - the details of the socket (like socket type, local IP and port for TCP/UDP sockets, etc.).</li> </ul>","title":"Arguments"},{"location":"events/lsm_hooks/security_socket_setsockopt/#hooks","text":"","title":"Hooks"},{"location":"events/lsm_hooks/security_socket_setsockopt/#security_socket_setsockopt_1","text":"","title":"security_socket_setsockopt"},{"location":"events/lsm_hooks/security_socket_setsockopt/#type","text":"<p>LSM Hook</p>","title":"Type"},{"location":"events/lsm_hooks/security_socket_setsockopt/#purpose","text":"<p>The LSM hook of the <code>setsockopt</code> syscall implementation.</p>","title":"Purpose"},{"location":"events/lsm_hooks/security_socket_setsockopt/#related-events","text":"<p><code>setsockopt</code>, <code>getsockopt</code></p>","title":"Related Events"},{"location":"events/security_alerts/magic_write/","text":"","title":"magic_write"},{"location":"events/security_alerts/magic_write/#intro","text":"<p>magic_write - write operation to a file which changed the file's headers</p>","title":"Intro"},{"location":"events/security_alerts/magic_write/#description","text":"<p>An event marking that a new file is written, or an existing file header changed. The event occurs whenever a write operation to a file in offset 0 is done. The purpose of the event is to give the user information about the file's type and other meta-data needed to understand if the file is a threat.</p>","title":"Description"},{"location":"events/security_alerts/magic_write/#note","text":"<p>The event doesn't occur for FIFO files or other files with no persistent offsets, to reduce spam events.</p>","title":"Note"},{"location":"events/security_alerts/magic_write/#arguments","text":"<ul> <li><code>pathname</code>:<code>const char*</code>[K] - the path of the file written.</li> <li><code>bytes</code>:<code>bytes</code>[U,TOCTOU] - the first 20 bytes of the file.</li> <li><code>dev</code>:<code>dev_t</code>[K] - the device the file resides in.</li> <li><code>inode</code>:<code>unsigned long</code>[K] - the inode of the file in the FS.</li> </ul>","title":"Arguments"},{"location":"events/security_alerts/magic_write/#hooks","text":"","title":"Hooks"},{"location":"events/security_alerts/magic_write/#vfs_write","text":"","title":"vfs_write"},{"location":"events/security_alerts/magic_write/#type","text":"<p>kprobe + kretprobe</p>","title":"Type"},{"location":"events/security_alerts/magic_write/#purpose","text":"<p>Catch write operations to a file using the <code>write</code> syscall</p>","title":"Purpose"},{"location":"events/security_alerts/magic_write/#vfs_writev","text":"","title":"vfs_writev"},{"location":"events/security_alerts/magic_write/#type_1","text":"<p>kprobe + kretprobe</p>","title":"Type"},{"location":"events/security_alerts/magic_write/#purpose_1","text":"<p>Catch write operations to a file using the <code>writev</code> syscall</p>","title":"Purpose"},{"location":"events/security_alerts/magic_write/#__kernel_write","text":"","title":"__kernel_write"},{"location":"events/security_alerts/magic_write/#type_2","text":"<p>kprobe + kretprobe</p>","title":"Type"},{"location":"events/security_alerts/magic_write/#purpose_2","text":"<p>Catch write operations to a file from within the kernel (written buffer resides in kernel space)</p>","title":"Purpose"},{"location":"events/security_alerts/magic_write/#example-use-case","text":"","title":"Example Use Case"},{"location":"events/security_alerts/magic_write/#issues","text":"","title":"Issues"},{"location":"events/security_alerts/magic_write/#related-events","text":"<p>write, writev, vfs_write, vfs_writev, __kernel_write, security_file_open</p>","title":"Related Events"},{"location":"events/security_alerts/symbols_loaded/","text":"","title":"symbols_loaded"},{"location":"events/security_alerts/symbols_loaded/#intro","text":"<p>symbols_loaded - a shared object which exports a watched symbol was loaded.</p>","title":"Intro"},{"location":"events/security_alerts/symbols_loaded/#description","text":"<p>An event marking that a shared object, which export symbols configured to be watched, was loaded to current process. This event can help in identifying some shared object usage in the system, or inform on the occasion that a shared object tries to override some symbol of another library.</p>","title":"Description"},{"location":"events/security_alerts/symbols_loaded/#configuring-the-event","text":"<p>The event is configured using arguments filtering. For each argument, a filter can be used to configure the operation:</p>","title":"Configuring the event"},{"location":"events/security_alerts/symbols_loaded/#symbols","text":"<p>Configure the watched symbols by the event. Specify the full name of the symbol for each symbol. The use is only with the <code>=</code> operator, and wildcards aren't supported.</p>","title":"symbols"},{"location":"events/security_alerts/symbols_loaded/#library_path","text":"<p>Whitelist for shared object paths prefixes. The path can be absolute, or just a library name. If only a name is given, then any shared object inside the known libraries directories which starts with the prefix will be whitelisted. The use is only with the <code>!=</code> operator, and wildcards aren't supported.</p>","title":"library_path"},{"location":"events/security_alerts/symbols_loaded/#arguments","text":"<ul> <li><code>library_path</code>:<code>const char*</code>[K] - the path of the shared object file loaded.</li> <li><code>symbols</code>:<code>const char*const*</code>[U,TOCTOU] - the watched symbols exported by the shared object.</li> </ul>","title":"Arguments"},{"location":"events/security_alerts/symbols_loaded/#dependency-events","text":"","title":"Dependency Events"},{"location":"events/security_alerts/symbols_loaded/#shared_object_loaded","text":"<p>The event of shared object loading triggers this event, and supplies the information on the shared object necessary to examine its shared objects.</p>","title":"shared_object_loaded"},{"location":"events/security_alerts/symbols_loaded/#sched_process_exec","text":"<p>Used by tracee to maintain mount NS cache, used in this event to get to processes file system</p>","title":"sched_process_exec"},{"location":"events/security_alerts/symbols_loaded/#example-use-case","text":"<p>To catch SO which tries to override the <code>fopen</code> function of <code>libc</code>, we can use the event in the following way:</p> <p><code>./dist/tracee-ebpf -t e=symbols_load -t symbols_load.symbols=fopen symbols_load.library_path!=libc</code></p>","title":"Example Use Case"},{"location":"events/security_alerts/symbols_loaded/#issues","text":"<p>Because the event is implemented in uesr-mode, it needs to open and read files. This means that the event is not very performance efficient (although it uses some optimizations). It also means that until the SO file is opened, it could be altered or removed.</p>","title":"Issues"},{"location":"events/security_alerts/symbols_loaded/#related-events","text":"<p>shared_object_loaded</p>","title":"Related Events"},{"location":"installing/docker/","text":"<p>Tracee, as a runtime detection tool, is built and distributed as a docker container. Tracee, as an introspection tool, can either be used as a docker image, binary artifacts or OS packages.</p> <p>Check Getting Started for how to run tracee.</p>","title":"Docker"},{"location":"installing/getting/","text":"<p>You're able to use tracee by any of these means:</p> <ol> <li>docker hub container image</li> <li>distributed binaries (<code>tracee.tar.gz</code>).</li> <li>building from the source</li> <li>building environment</li> <li>building container images</li> <li>building OS packages</li> </ol>","title":"Getting Tracee"},{"location":"installing/headers/","text":"<p>Note</p> <p>The default image is lightweight and portable. It is supposed to support different kernel versions without having to build source code. If the host kernel does not support BTF then you may use the full container image. The full container will compile an eBPF object during startup, if you do not have one already cached in /tmp/tracee.</p>  <p>When running <code>tracee:full</code> container image, in order to compile the kernel version specific eBPF object, Tracee needs some Linux kernel headers. Depending on your Linux distribution, there may be different ways to obtain them.  </p> <ul> <li>Ubuntu/Debian/Arch/Manjaro: install <code>linux-headers</code> package.</li> <li>CentOS/Fedora: install <code>kernel-headers</code> and <code>kernel-devel</code> packages.</li> <li>macOS: follow the Building on OSX guidelines.</li> </ul> <p>Normally the files will be installed in <code>/lib/modules/${kernel_version}/build</code> which is where Tracee expects them. If you have the headers elsewhere, you can set the <code>KERN_HEADERS</code> environment variable with the correct location.</p>  <p>Note</p> <p>It's important that the kernel headers match the exact version of the kernel you are running. To check the current kernel version, run the command <code>uname -r</code>. To install a specific kernel headers version append the version to the package name: <code>linux-headers-$(uname -r)</code>.</p>   <p>Warning</p> <p>More often than not the kernel headers files contains filesystem links to other files in other directories. Therefore, when passing the kernel headers to Tracee docker container, make sure all the necessary directories are mounted. This is why the quickstart example mounts <code>/usr/src</code> in addition to <code>/lib/modules</code>.</p>","title":"Linux Headers"},{"location":"installing/kubernetes/","text":"<p>In the deploy/kubernetes directory you will find Yaml files to deploy Tracee in a Kubernetes environment. These files will deploy Tracee as a DaemonSet alongside a message routing application (Postee) that will help you consume the detections in your preferred way (e.g. Slack, E-mail, JIRA and more). </p>  <p>Note</p> <p>Although not optimal, you may consume tracee detections through daemonset/tracee logs with <code>kubectl logs -f daemonset/tracee</code>.</p>   <p>Tip</p> <p>The preferred way to deploy tracee is through its Helm chart!</p>  <ol> <li> <p>Install Tracee using Helm</p> <ol> <li> <p>Clone the Helm chart:</p> <pre><code>$ git clone --depth 1 --branch v0.8.1 https://github.com/aquasecurity/tracee.git\n$ cd tracee\n</code></pre> </li> <li> <p>Install the Helm chart from a local directory:</p> <pre><code>$ helm repo add aqua-charts https://aquasecurity.github.io/helm-charts\n$ helm dependency update ./deploy/helm/tracee\n$ helm install tracee ./deploy/helm/tracee \\\n    --namespace tracee-system --create-namespace \\\n    --set hostPID=true \\\n    --set postee.enabled=true\n</code></pre> </li> </ol> </li> <li> <p>Install Tracee Manually</p> <p>To install Tracee with Postee, simply run:</p> <pre><code>$ kubectl create \\\n    -f https://raw.githubusercontent.com/aquasecurity/postee/main/deploy/kubernetes/postee.yaml \\\n    -f https://raw.githubusercontent.com/aquasecurity/tracee/v0.8.1/deploy/kubernetes/tracee-postee/tracee.yaml\n</code></pre> </li> <li> <p>After Installation</p> <p>In order to choose how to make Postee deliver detection events from Tracee, you may edit the <code>postee-config</code> configMap. Follow this example.</p> <p>You can also use the Postee UI to configure integrations.</p> </li> </ol>","title":"Install Tracee on Kubernetes"},{"location":"installing/kubernetes/#platform-support","text":"<p>This approach assumes that host nodes have either BTF available or kernel headers available under conventional location. See Tracee's prerequisites for more info. For the major Kubernetes platforms this should work out-of-the-box, including GKE, EKS, AKS, minikube.</p>","title":"Platform Support"},{"location":"installing/prerequisites/","text":"<p>A longterm supported kernel: 5.4, 5.10, 5.15, 5.18, 5.19. Check kernel.org for current supported kernels.</p>  <p>Note</p> <p>Most distributions longterm supported kernels are supported as well, including CentOS8 4.18 kernel.</p>  <ol> <li> <p>For tracee:v0.8.1 docker image, you should have one of the two:</p> <ol> <li>A kernel that has <code>/sys/kernel/btf/vmlinux</code> file available</li> <li>A kernel supported through BTFHUB <p>see libbpf CO-RE documentation for more info</p>  </li> </ol> </li> <li> <p>For tracee:full docker image:</p> <ol> <li>kernel readers (most distros provide packages)</li> <li>clang (12 or 13)</li> <li>golang (1.17)</li> <li>libelf and libelf-dev (or elfutils-libelf and elfutils-libelf-devel)</li> <li>zlib1g and lib1g-dev (or zlib and zlib-devel)</li> </ol> </li> </ol>","title":"Prerequisites for running Tracee"},{"location":"installing/prerequisites/#permissions","text":"<p>For using the eBPF Linux subsystem, Tracee needs to run with sufficient capabilities:</p> <ul> <li>Manage eBPF maps limits (<code>CAP_SYS_RESOURCE</code>)</li> <li>Load and Attach eBPF programs:<ol> <li><code>CAP_BPF</code>+<code>CAP_PERFMON</code> for recent kernels (&gt;=5.8) where the kernel perf paranoid value in <code>/proc/sys/kernel/perf_event_paranoid</code> is equal to 3 or less</li> <li>or <code>CAP_SYS_ADMIN</code> otherwise</li> </ol> </li> <li><code>CAP_SYS_PTRACE</code> (to collect information about processes upon startup)</li> <li><code>CAP_NET_ADMIN</code> (to use tc for packets capture)</li> <li><code>CAP_SETPCAP</code> (if given - used to reduce bounding set capabilities)</li> <li><code>CAP_SYSLOG</code> (to access kernel symbols through /proc/kallsyms)</li> <li>On some environments (e.g. Ubuntu) <code>CAP_IPC_LOCK</code> might be required as well.</li> <li>On cgroup v1 environments, <code>CAP_SYS_ADMIN</code> is recommended if running from a   container in order to allow tracee to mount the cpuset cgroup controller.</li> </ul>  <p>Alternatively, run as <code>root</code> or with the <code>--privileged</code> flag of Docker.</p>   <p>Attention</p> <p>Check how to override capabilities drop if you're facing errors.</p>","title":"Permissions"},{"location":"installing/distros/fedora/","text":"<p>Tracee does not provide Fedora packages out-of-the-box, but there is a quick way to build a Fedora package.</p>","title":"Fedora Packages"},{"location":"installing/distros/nix-nixos/","text":"<p>If installing tracee via nix please ensure you're running a kernel with libbpf CO-RE support, see Tracee's prerequisites for more info.</p> <p>Direct issues installing tracee via nix through the channels mentioned here (non-CO-RE not supported)</p> <p><code>nix-env --install -A nixpkgs.tracee</code></p> <p>Or through your configuration as usual</p> <p>NixOS:</p> <pre><code>  # your other config ...\n  environment.systemPackages = with pkgs; [\n    # your other packages ...\n    tracee\n  ];\n</code></pre> <p>home-manager:</p> <pre><code>  # your other config ...\n  home.packages = with pkgs; [\n    # your other packages ...\n    tracee\n  ];\n</code></pre>","title":"Nix/NixOS (Community)"},{"location":"installing/distros/ubuntu/","text":"<p>Tracee does not provide Ubuntu packages out-of-the-box, but there is a quick way to build an Ubuntu package.</p>","title":"Ubuntu Packages"},{"location":"integrating/container-engines/","text":"<p>Tracee is capable of extracting information about running containers. It does that by tracking container namespaces creation kernel events and enriching those events by communicating with the relevant container's runtime and SDK.</p>  <p>Experimental</p> <p>This feature is experimental and should be explicitly enabled in tracee-ebpf, by using the <code>--container</code> flag OR, if running tracee container image, setting the <code>CONTAINERS_ENRICHMENT</code> environment flag (see example bellow).</p>  <ol> <li> <p>Running tracee-ebpf (with or without tracee-rules) manually</p> <p>If running tracee-ebpf directly (not in a container), it will automatically search for known supported runtimes in their socket's default locations.</p> </li> <li> <p>Running tracee using a docker container</p> <p>When running tracee from a container, the runtime sockets must be manually mounted in order for the enrichment features to work.</p> <p>Using containerd as our runtime for example, this can be done by running tracee like:</p> <pre><code>$ docker run \\\n    --name tracee --rm -it \\\n    --pid=host --cgroupns=host --privileged \\\n    -v /etc/os-release:/etc/os-release-host:ro \\\n    -v /var/run/containerd:/var/run/containerd \\\n    -e LIBBPFGO_OSRELEASE_FILE=/etc/os-release-host \\\n    -e CONTAINERS_ENRICHMENT=1 \\\n    aquasec/tracee:v0.8.1\n</code></pre> <p>Most container runtimes have their sockets installed by default in <code>/var/run</code>. If your system includes multiple container runtimes, tracee can track them all, however one should mount either all their runtime sockets or <code>/var/run</code> in it's entirety to do so.</p> </li> </ol>","title":"Tracee Events Container Enrichment"},{"location":"integrating/container-engines/#supported-container-runtime-engines","text":"<p>Currently, tracee will look in the following paths for autodiscovering the listed runtimes:</p> <ol> <li> <p>Docker:     <code>/var/run/docker.sock</code></p> </li> <li> <p>Containerd: <code>/var/run/containerd/containerd.sock</code></p> </li> <li> <p>CRI-O:      <code>/var/run/crio/crio.sock</code></p> </li> </ol>  <p>Tip</p> <p>Nested environments are somewhat tricky with this feature as evidenced by the docker mounting instructions. Tracee does not auto-discover this nesting and so sockets must be appropriately mounted and set up for tracee to enrich all containers correctly.</p>","title":"Supported Container Runtime Engines"},{"location":"integrating/falcosidekick/","text":"<p>Falcosidekick</p> <p>Falcosidekick is a useful webhook server that can be configured to connect to various \"outputs\" such as: Slack, Mattermost, Teams, Datadog, Prometheus, StatsD, Email, Elasticsearch, Loki, PagerDuty, OpsGenie, and many more.</p>  <p>To use Tracee with Falcosidekick:</p> <ol> <li> <p>Obtain connection credentials to the system you want to integrate with.</p> <ol> <li>Consult the system's documentation and look for how to configure an    incoming webhook.</li> </ol> </li> <li> <p>Start the Falcosidekick container, configured with the obtained output    credentials:</p> <ol> <li>See the Falcosidekick Readme for full documentation.</li> </ol> </li> <li> <p>Start Tracee while configuring it to post detections to the Falcosidekick endpoint.</p> <ol> <li>If using Docker, you can use the simple link flag to allow the    containers to communicate</li> <li>Use the webhook flag to point to the Falcosidekick container's endpoint</li> <li>Tracee ships with a built-in template for Falcosidekick</li> </ol> </li> </ol>  <p>Example</p> <ol> <li> <p>Start Falcosidekick configured to post to Slack:</p> <pre><code>docker run --name falcosidekick -p 2801:2801 \\\n  -e SLACK_WEBHOOKURL=https://hooks.slack.com/services/XXX/YYY/ZZZ \\\n  falcosecurity/falcosidekick\n</code></pre> </li> <li> <p>Start Tracee, linking it to the Falcosidekick container, and configuring it    to call it on detections:</p> <pre><code>$ docker run \\\n    --name tracee --rm -it \\\n    --pid=host --cgroupns=host --privileged \\\n    -v /etc/os-release:/etc/os-release-host:ro \\\n    -e LIBBPFGO_OSRELEASE_FILE=/etc/os-release-host \\\n    --link falcosidekick aquasec/tracee:0.8.1 \\\n    --webhook-template /tracee/templates/falcosidekick.tmpl \\\n    --webhook-content-type application/json \\\n    --webhook http://FALCOSIDEKICK:2801\n</code></pre> </li> </ol>   <p>Also</p> <ol> <li>Deliver using a Webhook</li> <li>Deliver using Postee</li> </ol>","title":"Detections: Deliver using Falcosidekick"},{"location":"integrating/go-templates/","text":"","title":"Detections: Output Format"},{"location":"integrating/go-templates/#configuring","text":"<p>When a detection is made by any of the loaded signatures, it will always be printed to stdout. You can customize this output format using a go template.</p> <pre><code>$ ./dist/tracee-rules --output-template /path/to/my.tmpl\n</code></pre>  <p>Go-templates</p> <p>The following Go templates are included in the Tracee container image and are available for use under the <code>/tracee/templates/</code> directory in the container:</p>    File name Description Content-Type Source     rawjson.tmpl Dumps the Finding object as raw JSON <code>application/json</code> source   falcosidekick.tmpl For compatibility with [falcosidekick] <code>application/json</code> source     <ol> <li> <p>Basic Example: Raw JSON stdout</p> <p>The following example configures Tracee to output detections to stdout as raw JSON:</p> <pre><code>$ docker run \\\n    --name tracee --rm -it \\\n    --pid=host --cgroupns=host --privileged \\\n    -v /etc/os-release:/etc/os-release-host:ro \\\n    -e LIBBPFGO_OSRELEASE_FILE=/etc/os-release-host \\\n    aquasec/tracee:0.8.1 \\\n    --output-template /tracee/templates/rawjson.tmpl\n</code></pre>  <p>Postee</p> <p>Tracee default delivery mechanism, using Helm, is through Postee and uses the <code>rawjson.tmpl</code> go template.</p>  </li> <li> <p>Deliver using a Webhook</p> </li> <li> <p>Deliver using Postee</p> </li> <li> <p>Deliver using Falcosidekick</p> </li> </ol>","title":"Configuring"},{"location":"integrating/go-templates/#authoring","text":"<p>When authoring a Go template for either stdout or webhook, you have Tracee's <code>types.Finding</code> struct as the data source:</p> <pre><code>// Finding is the main output of a signature. It represents a match result for\n// the signature business logic.\n\ntype Finding struct {\n    SigMetadata SignatureMetadata // information about the signature that made the detection\n    Context     Event // the raw event that triggered the detection\n    Data        map[string]interface{} // detection specific information\n}\n</code></pre> <p>The Go template can utilize helper functions from Sprig.</p> <p>For example templates, see tracee/cmd/tracee-rules/templates.</p>","title":"Authoring"},{"location":"integrating/postee/","text":"<p>Postee integration is the default experience when using helm deployment.</p>  <p>Also</p> <ol> <li>Deliver using a Webhook</li> <li>Deliver using Falcosidekick</li> </ol>","title":"Detections: Deliver using Postee"},{"location":"integrating/prometheus/","text":"<p>Integrating with Prometheus</p>  <p>Performance</p> <p>Current Prometheus integration targets performance numbers for event production, consumption and detection. It does not target the detections themselves.</p>  <p>Tracee is enabled for prometheus scraping by default. Scraping can be done through the following URLs:</p> <ol> <li>tracee-ebpf can be scraped through <code>:3366/metrics</code></li> <li>tracee-rules can be scraped through <code>:4466/metrics</code></li> </ol>  <p>Metrics addresses can be changed through tracee-ebpf command line arguments <code>metrics</code> and <code>metrics-addr</code>, check <code>--help</code> for more information.</p>   <p>Tip</p> <p>Check this tutorial for more information as well.</p>","title":"Prometheus"},{"location":"integrating/webhook/","text":"<p>In addition, Tracee can notify a web service when a detection is made using a custom webhook:</p> <pre><code>tracee-rules --webhook http://my.webhook/endpoint \\\n    --webhook-template /path/to/my.tmpl \\\n    --webhook-content-type application/json\n</code></pre>  <p>Also</p> <ol> <li>Deliver using Postee</li> <li>Deliver using Falcosidekick</li> </ol>","title":"Detections: Deliver using a Webhook"},{"location":"tracing/","text":"<p>Note</p> <p>This entire section is about running tracee-ebpf only, without piping events to tracee-rules.</p>  <p>In some cases, you might want to leverage Tracee event collection capabilities only, without involving the detection engine. You may, or may not, choose to capture artifacts while tracing.</p> <p>This might be useful for:</p> <ol> <li>debugging</li> <li>troubleshooting</li> <li>analysing executions</li> <li>security research</li> <li>education</li> </ol> <p>In this case you can use Tracee's eBPF collector component (tracee-ebpf), which will start dumping raw data directly into standard output.</p> <p>Watch a quick video demo of Tracee's eBPF tracing capabilities</p>","title":"Getting Started with Tracing"},{"location":"tracing/#using-tracee-ebpf","text":"<p>Before you proceed, make sure you follow the prerequisites.</p> <pre><code>$ docker run \\\n    --name tracee --rm -it \\\n    --pid=host --cgroupns=host --privileged \\\n    -v /etc/os-release:/etc/os-release-host:ro \\\n    -e LIBBPFGO_OSRELEASE_FILE=/etc/os-release-host \\\n    -e TRACEE_EBPF_ONLY=1 \\\n    aquasec/tracee:0.8.1\n</code></pre> <p>Here, we are running the <code>aquasec/tracee</code> container, but with the <code>TRACEE_EBPF_ONLY=1</code> environment variable set, which will start just a raw trace (Tracee-eBPF), without the detection engine tracee-rules. Here's a sample output of running with no additional arguments:</p> <pre><code>TIME(s)        UID    COMM             PID     TID     RET             EVENT                ARGS\n176751.746515  1000   zsh              14726   14726   0               execve               pathname: /usr/bin/ls, argv: [ls]\n176751.746772  1000   zsh              14726   14726   0               security_bprm_check  pathname: /usr/bin/ls, dev: 8388610, inode: 777\n176751.747044  1000   ls               14726   14726  -2               access               pathname: /etc/ld.so.preload, mode: R_OK\n176751.747077  1000   ls               14726   14726   0               security_file_open   pathname: /etc/ld.so.cache, flags: O_RDONLY|O_LARGEFILE, dev: 8388610, inode: 533737\n...\n</code></pre>  <p>Note</p> <p>There are 2 ways to enable tracing only: 1. To export a TRACEE_EBPF_ONLY=1 env variable to docker. 2. To provide a <code>trace</code> 1st argument to docker container.  </p>  <p>Each line is a single event collected by Tracee-eBPF, with the following information:</p> <ol> <li>TIME    event time relative to system boot time in seconds</li> <li>UID    real user id of the calling process (in host userns)</li> <li>COMM    name of the calling process</li> <li>PID    pid of the calling process</li> <li>TID    tid of the calling thread</li> <li>RET    value returned by the function</li> <li>EVENT    identifies the event (e.g. syscall name)</li> <li>ARGS    list of arguments given to the function</li> </ol>  <p>Note</p> <p>Use the <code>--help</code> flag to see a full description of available options. Some flags have specific help sections that can be accessed by passing <code>help</code> to the flag, for example <code>--output help</code>. This section covers some of the more common options.</p>   <p>Check the existing output options for other output options. Check the existing output format for other output formats.</p> <p>Follow getting tracee in order to get tracee-ebpf.</p>","title":"Using Tracee-eBPF"},{"location":"tracing/event-filtering/","text":"<pre><code>$ sudo ./dist/tracee-ebpf --trace help\n$ sudo ./dist/tracee-ebpf --trace xxx\n</code></pre> <p>Tracing output might become too hard to consume when tracing all the events from a system. Luckily, Tracee has a powerful mechanism to accurately trace just the information that is relevant to the user, the <code>--trace</code> flag.</p> <p>With <code>--trace</code> command line flag you define expressions that tells tracee-ebpf what you are interested in based on event metadata filtering capabilities. Only events that match given criteria will be traced.</p>  <p>Tip</p> <p>You can filter events by most of the visible fields from Tracee events.</p>","title":"Tracing Event Filtering"},{"location":"tracing/event-filtering/#initial-example","text":"<p>All the examples bellow this item can be executed with the following tracee-ebpf prefix command:</p> <pre><code>$ sudo ./dist/tracee-ebpf \\\n    --output json \\\n    --trace comm=bash \\\n    --trace follow\n    --output option:parse-arguments \\\n    &lt;rest of filters&gt;\n</code></pre> <p>This will allow you to test the filtering rules by executing a new process in any running shell and might serve as a good indicative if your filter works as expected.</p>","title":"Initial Example"},{"location":"tracing/event-filtering/#filters-and-operators","text":"<ol> <li> <p>Event <code>(Operators: =, != and \"follow\". Prefix/Suffix: *)</code></p> <pre><code>1) --trace event=openat\n2) --trace event=execve,open\n3) --trace event=open*\n4) --trace event!=open*,dup*\n5) --trace follow\n</code></pre>  <p>Note</p> <p>The \"follow\" operator will make tracee to follow all newly created processes, that are being filtered for, childs.</p>  </li> <li> <p>Event Arguments <code>(Operators: =, !=. Prefix/Suffix: *)</code></p> <pre><code>1) --trace event=openat --trace openat.pathname=/etc/shadow\n2) --trace event=openat --trace openat.pathname=/tmp*\n3) --trace event=openat --trace openat.pathname!=/tmp/1,/bin/ls\n</code></pre>  <p>Note</p> <p>Multiple values are ORed if used with = operator But ANDed if used with any other operator.</p>  </li> <li> <p>Event Return Code <code>(Operators: =, !=, &lt;, &gt;)</code></p> <pre><code>1) --trace event=openat --trace openat.pathname=/etc/shadow --trace \"openat.retval&gt;0\"\n2) --trace event=openat --trace openat.pathname=/etc/shadow --trace \"openat.retval&lt;0\"\n</code></pre>  <p>Tip</p> <p>Try <code>cat /etc/shadow</code> as a regular use and filter for <code>retval&lt;0</code>.</p>  </li> <li> <p>Event Sets <code>(Operators: =, !=)</code></p> <pre><code>1) --trace set=fs\n2) --trace set=lsm_hooks,network_events\n</code></pre>  <p>Note</p> <p>Selects a set of events to tracee according to pre-defined sets which can be listed by using <code>--list</code> command line argument.</p>  </li> <li> <p>Container <code>(Operators: =, != and \"new\". Boolean)</code></p> <pre><code>1) --trace container # all container events\n2) --trace '!container' # events from the host only\n3) --trace container=new # containers created after tracee-ebf execution\n4) --trace container=3f93da58be3c --trace event=openat\n5) --trace container=new --trace event=openat --trace openat.pathname=\"/etc/shadow\"\n</code></pre>  <p>Note</p> <p>The new flag allows to trace newly created containers only.  </p>  </li> <li> <p>Command <code>(Operators: =, !=)</code></p> <pre><code>1) --trace comm=cat,vim,ping\n2) --trace comm!=ping\n</code></pre>  <p>Note</p> <p>Do not use given command prefix for these examples as they're filtering by command name as well.</p>  </li> <li> <p>PID <code>(Operators: =, !=, &lt;, &gt; and \"new\")</code></p> <pre><code>1) --trace pid=new # newly created events (after tracee-ebpf execution)\n2) --trace pid=510,1709 # # pids 510 and 1709\n3) --trace 'pid&gt;0' --trace pid 'pid&lt;1000'\n4) --trace pid=2578238 --trace event=openat --trace openat.pathname=/etc/shadow --trace follow\n</code></pre> </li> <li> <p>Process Tree</p> <pre><code>1) --trace tree=476165 # events descending from process 476165\n2) --trace tree!=5023 # events that do not descend from process 5023\n</code></pre> </li> <li> <p>UID <code>(Operators: =, !=, &lt;, &gt;)</code></p> <pre><code>1) --trace uid=0\n2) --trace 'uid&gt;0'\n3) --trace 'uid&gt;0' --trace uid!=1000 # do not trace root and uid=1000\n</code></pre> </li> <li> <p>Network Interface</p> <pre><code>1) -trace comm=nc,ping -trace event=net_packet -trace net=docker0\n2) -trace event=dns_request,dns_response -trace net=docker0\n</code></pre>  <p>Attention</p> <p>Do not forget to provide the interface to be traced with \"net=name\"</p>  </li> <li> <p>UTS Namespace (hostnames) <code>(Operators: =, !=)</code></p> <pre><code>1) --trace uts!=ab356bc4dd554 \n</code></pre> </li> <li> <p>PID Namespace <code>(Operators: =, !=, &lt;, &gt;)</code></p> <pre><code>1) --trace pidns!=4026531836\n</code></pre> </li> <li> <p>MOUNT Namespace <code>(Operators: =, !=, &lt;, &gt;)</code></p> <pre><code>1) --trace mntns=4026531840\n</code></pre> </li> </ol>","title":"Filters and Operators"},{"location":"tracing/output-formats/","text":"<p>In order to check latest output options you may execute:</p> <pre><code>$ sudo ./dist/tracee-ebpf --output help\n$ sudo ./dist/tracee-ebpf --output format:xxx\n</code></pre> <p>Tracee supports different output formats for detected events:</p> <ol> <li> <p>Table</p> <pre><code>$ sudo ./dist/tracee-ebpf --output table --trace comm=bash --trace follow --trace event=openat\nTIME             UID    COMM             PID     TID     RET              EVENT                ARGS\n11:21:51:254199  1000   exa              1639459 1639459 3                openat               dirfd: -100, pathname: /etc/ld.so.cache, flags: O_RDONLY|O_CLOEXEC, mode: 0\n11:21:51:254285  1000   exa              1639459 1639459 3                openat               dirfd: -100, pathname: /lib/x86_64-linux-gnu/libgcc_s.so.1, flags: O_RDONLY|O_CLOEXEC, mode: 0\n11:21:51:254418  1000   exa              1639459 1639459 3                openat               dirfd: -100, pathname: /lib/x86_64-linux-gnu/libm.so.6, flags: O_RDONLY|O_CLOEXEC, mode: 0\n\nEnd of events stream\nStats: {EventCount:6 NetEvCount:0 ErrorCount:0 LostEvCount:0 LostWrCount:0 LostNtCount:0}\n</code></pre> </li> <li> <p>Table (Verbose)</p> <pre><code>$ sudo ./dist/tracee-ebpf --output table-verbose --trace comm=bash --trace follow --trace event=openat\nTIME             UTS_NAME         CONTAINER_ID  MNT_NS       PID_NS       UID    COMM             PID     TID     PPID    RET              EVENT                ARGS\n11:22:16:970700  fujitsu                        4026531840   4026531836   1000   exa              1643836 1643836 3795408 3                openat               dirfd: -100, pathname: /etc/ld.so.cache, flags: 524288, mode: 0\n11:22:16:970783  fujitsu                        4026531840   4026531836   1000   exa              1643836 1643836 3795408 3                openat               dirfd: -100, pathname: /lib/x86_64-linux-gnu/libgcc_s.so.1, flags: 524288, mode: 0\n11:22:16:970913  fujitsu                        4026531840   4026531836   1000   exa              1643836 1643836 3795408 3                openat               dirfd: -100, pathname: /lib/x86_64-linux-gnu/libm.so.6, flags: 524288, mode: 0\n\nEnd of events stream\nStats: {EventCount:6 NetEvCount:0 ErrorCount:0 LostEvCount:0 LostWrCount:0 LostNtCount:0}\n</code></pre> </li> <li> <p>JSON</p> <pre><code>$ sudo ./dist/tracee-ebpf --output json --trace comm=bash --trace follow --trace event=openat\n</code></pre> <pre><code>{\"timestamp\":1657290245020855990,\"threadStartTime\":615325807626168,\"processorId\":22,\"processId\":1664936,\"cgroupId\":1,\"threadId\":1664936,\"parentProcessId\":3795408,\"hostProcessId\":1664936,\"hostThreadId\":1664936,\"hostParentProcessId\":3795408,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"exa\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"257\",\"eventName\":\"openat\",\"argsNum\":4,\"returnValue\":3,\"stackAddresses\":null,\"args\":[{\"name\":\"dirfd\",\"type\":\"int\",\"value\":-100},{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"/etc/ld.so.cache\"},{\"name\":\"flags\",\"type\":\"int\",\"value\":524288},{\"name\":\"mode\",\"type\":\"mode_t\",\"value\":0}]}\n{\"timestamp\":1657290245020940791,\"threadStartTime\":615325807626168,\"processorId\":22,\"processId\":1664936,\"cgroupId\":1,\"threadId\":1664936,\"parentProcessId\":3795408,\"hostProcessId\":1664936,\"hostThreadId\":1664936,\"hostParentProcessId\":3795408,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"exa\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"257\",\"eventName\":\"openat\",\"argsNum\":4,\"returnValue\":3,\"stackAddresses\":null,\"args\":[{\"name\":\"dirfd\",\"type\":\"int\",\"value\":-100},{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"/lib/x86_64-linux-gnu/libgcc_s.so.1\"},{\"name\":\"flags\",\"type\":\"int\",\"value\":524288},{\"name\":\"mode\",\"type\":\"mode_t\",\"value\":0}]}\n</code></pre>  <p>Tip</p> <p>A good tip is to pipe tracee-ebpf json output to jq tool, this way you can select fields, rename them, filter values, and many other things:</p>  <pre><code>sudo ./dist/tracee-ebpf -o format:json -o option:parse-arguments -o\noption:detect-syscall -trace comm=ping -capture net=lo | jq -c '. |\n{eventId, hostName,processName,hostProcessId,UserId}'\n</code></pre>   </li> <li> <p>GOB</p> <pre><code>$ sudo ./dist/tracee-ebpf --output json --trace comm=bash --trace follow --trace event=openat\n</code></pre>  <p>The output is binary (optimizes performance when piping tracee-ebpf events to tracee-rules, for signature patterns detections).</p>  </li> <li> <p>GOTEMPLATE</p> <p>Check integrations page for more info.</p> </li> </ol>","title":"Tracing Output Formats"},{"location":"tracing/output-formats/#output-files","text":"<p>Tracee gives user the option to select which files they want to use as standard output and standard error:</p> <ol> <li> <p>Output file</p>  <p>Tip</p> <p>User might use different output formats combined with output file option</p>  <pre><code>$ sudo ./dist/tracee-ebpf --output json --trace comm=bash --trace follow --trace event=openat --output out-file:/tmp/tracee.log\n\n$ cat /tmp/tracee.log | jq -c\n</code></pre> <pre><code>{\"timestamp\":1657291487418386000,\"threadStartTime\":616568205378363,\"processorId\":11,\"processId\":1893369,\"cgroupId\":1,\"threadId\":1893369,\"parentProcessId\":3795408,\"hostProcessId\":1893369,\"hostThreadId\":1893369,\"hostParentProcessId\":3795408,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"exa\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"257\",\"eventName\":\"openat\",\"argsNum\":4,\"returnValue\":3,\"stackAddresses\":null,\"args\":[{\"name\":\"dirfd\",\"type\":\"int\",\"value\":-100},{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"/etc/ld.so.cache\"},{\"name\":\"flags\",\"type\":\"int\",\"value\":524288},{\"name\":\"mode\",\"type\":\"mode_t\",\"value\":0}]}\n{\"timestamp\":1657291487418510000,\"threadStartTime\":616568205378363,\"processorId\":11,\"processId\":1893369,\"cgroupId\":1,\"threadId\":1893369,\"parentProcessId\":3795408,\"hostProcessId\":1893369,\"hostThreadId\":1893369,\"hostParentProcessId\":3795408,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"exa\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"257\",\"eventName\":\"openat\",\"argsNum\":4,\"returnValue\":3,\"stackAddresses\":null,\"args\":[{\"name\":\"dirfd\",\"type\":\"int\",\"value\":-100},{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"/lib/x86_64-linux-gnu/libgcc_s.so.1\"},{\"name\":\"flags\",\"type\":\"int\",\"value\":524288},{\"name\":\"mode\",\"type\":\"mode_t\",\"value\":0}]}\n</code></pre> </li> <li> <p>Error file</p> <p>Redirect errors to your log files if needed:</p> <pre><code>$ sudo TRACEE_BPF_FILE=do-not-exist ./dist/tracee-ebpf --output json --trace comm=bash --trace follow --trace event=openat --output out-file:/tmp/tracee.log --output err-file:/tmp/tracee.err\n</code></pre> </li> </ol>","title":"Output Files"},{"location":"tracing/output-options/","text":"<p>In order to check latest output options you may execute:</p> <pre><code>$ sudo ./dist/tracee-ebpf --output help\n$ sudo ./dist/tracee-ebpf --output option:xxx\n</code></pre> <p>Tracee supports different output options for detected events:</p> <ol> <li> <p>option:stack-addresses </p> <p>Pick stack memory address from each event</p> <pre><code>$ sudo ./dist/tracee-ebpf --output json --trace comm=bash --trace follow --trace event=openat --output option:stack-addresses\n</code></pre> <pre><code>{\"timestamp\":1657291777566819000,\"threadStartTime\":616858353946737,\"processorId\":9,\"processId\":1948212,\"cgroupId\":1,\"threadId\":1948212,\"parentProcessId\":3795408,\"hostProcessId\":1948212,\"hostThreadId\":1948212,\"hostParentProcessId\":3795408,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"exa\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"257\",\"eventName\":\"openat\",\"argsNum\":4,\"returnValue\":3,\"stackAddresses\":[140395297729336,140395297614210],\"args\":[{\"name\":\"dirfd\",\"type\":\"int\",\"value\":-100},{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"/etc/ld.so.cache\"},{\"name\":\"flags\",\"type\":\"int\",\"value\":524288},{\"name\":\"mode\",\"type\":\"mode_t\",\"value\":0}]}\n</code></pre> </li> <li> <p>option:detect-syscall</p> <p>If you are filtering for an event that is not a syscall (\"security_file_open\", for example), which sometimes is needed to avoid TOCTOU, you may opt to also detect which syscal has generated that event.</p> <pre><code>$ sudo ./dist/tracee-ebpf --output json --trace comm=bash --trace follow --trace event=security_file_open --output option:detect-syscall\n</code></pre> <pre><code>{\"timestamp\":1657291989963764000,\"threadStartTime\":617070752926681,\"processorId\":11,\"processId\":1986397,\"cgroupId\":1,\"threadId\":1986397,\"parentProcessId\":3795408,\"hostProcessId\":1986397,\"hostThreadId\":1986397,\"hostParentProcessId\":3795408,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"bash\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"722\",\"eventName\":\"security_file_open\",\"argsNum\":7,\"returnValue\":0,\"stackAddresses\":null,\"args\":[{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"/usr/bin/exa\"},{\"name\":\"flags\",\"type\":\"int\",\"value\":32800},{\"name\":\"dev\",\"type\":\"dev_t\",\"value\":271581185},{\"name\":\"inode\",\"type\":\"unsigned long\",\"value\":2493759},{\"name\":\"ctime\",\"type\":\"unsigned long\",\"value\":1653730234432691500},{\"name\":\"syscall_pathname\",\"type\":\"const char*\",\"value\":\"\"},{\"name\":\"syscall\",\"type\":\"int\",\"value\":59}]}\n{\"timestamp\":1657291989963871500,\"threadStartTime\":617070752926681,\"processorId\":11,\"processId\":1986397,\"cgroupId\":1,\"threadId\":1986397,\"parentProcessId\":3795408,\"hostProcessId\":1986397,\"hostThreadId\":1986397,\"hostParentProcessId\":3795408,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"bash\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"722\",\"eventName\":\"security_file_open\",\"argsNum\":7,\"returnValue\":0,\"stackAddresses\":null,\"args\":[{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2\"},{\"name\":\"flags\",\"type\":\"int\",\"value\":32800},{\"name\":\"dev\",\"type\":\"dev_t\",\"value\":271581185},{\"name\":\"inode\",\"type\":\"unsigned long\",\"value\":2752590},{\"name\":\"ctime\",\"type\":\"unsigned long\",\"value\":1653730015033811700},{\"name\":\"syscall_pathname\",\"type\":\"const char*\",\"value\":\"\"},{\"name\":\"syscall\",\"type\":\"int\",\"value\":59}]}\n</code></pre> <p>Observe that the event now has the following extra argument:</p> <pre><code>{\"name\":\"syscall\",\"type\":\"int\",\"value\":59}\n</code></pre> <p>Which means the event that has generated that event was <code>sys_execve</code> (syscall 59 in amd64 architecture).</p>  <p>Tip</p> <p>If you pay attention to previous outputs, we have raw event data in many places. Like the syscall example above, where we have to find out which syscall it was referring to. Check parse-arguments option below to improve your experience.</p>  </li> <li> <p>option:parse-arguments</p> <p>In order to have a better experience with the output provided by tracee-ebpf, you may opt to parse event arguments to a human *readable format.</p> <p><pre><code>$ sudo ./dist/tracee-ebpf --output json --trace comm=bash --trace follow --trace event=security_file_open --output option:detect-syscall --output option:parse-arguments\n</code></pre> <pre><code>{\"timestamp\":1657292314817581101,\"threadStartTime\":617395606682013,\"processorId\":9,\"processId\":2045288,\"cgroupId\":1,\"threadId\":2045288,\"parentProcessId\":3795408,\"hostProcessId\":2045288,\"hostThreadId\":2045288,\"hostParentProcessId\":3795408,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"bash\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"722\",\"eventName\":\"security_file_open\",\"argsNum\":7,\"returnValue\":0,\"stackAddresses\":null,\"args\":[{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"/usr/bin/exa\"},{\"name\":\"flags\",\"type\":\"string\",\"value\":\"O_RDONLY|O_LARGEFILE\"},{\"name\":\"dev\",\"type\":\"dev_t\",\"value\":271581185},{\"name\":\"inode\",\"type\":\"unsigned long\",\"value\":2493759},{\"name\":\"ctime\",\"type\":\"unsigned long\",\"value\":1653730234432691496},{\"name\":\"syscall_pathname\",\"type\":\"const char*\",\"value\":\"\"},{\"name\":\"syscall\",\"type\":\"int\",\"value\":\"execve\"}]}\n{\"timestamp\":1657292314817690279,\"threadStartTime\":617395606682013,\"processorId\":9,\"processId\":2045288,\"cgroupId\":1,\"threadId\":2045288,\"parentProcessId\":3795408,\"hostProcessId\":2045288,\"hostThreadId\":2045288,\"hostParentProcessId\":3795408,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"bash\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"722\",\"eventName\":\"security_file_open\",\"argsNum\":7,\"returnValue\":0,\"stackAddresses\":null,\"args\":[{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2\"},{\"name\":\"flags\",\"type\":\"string\",\"value\":\"O_RDONLY|O_LARGEFILE\"},{\"name\":\"dev\",\"type\":\"dev_t\",\"value\":271581185},{\"name\":\"inode\",\"type\":\"unsigned long\",\"value\":2752590},{\"name\":\"ctime\",\"type\":\"unsigned long\",\"value\":1653730015033811838},{\"name\":\"syscall_pathname\",\"type\":\"const char*\",\"value\":\"\"},{\"name\":\"syscall\",\"type\":\"int\",\"value\":\"execve\"}]}\n</code></pre></p> <p>As you can see now, the syscall that generated the event security_file_open was indeed execve:</p> <pre><code>{\"name\":\"syscall\",\"type\":\"int\",\"value\":\"execve\"}\n</code></pre> </li> <li> <p>option:exec-env</p> <p>Sometimes it is also important to know the execution environment variables whenever an event is detected, specially when deteting execve event.</p> <pre><code>$ sudo ./dist/tracee-ebpf --output json --trace comm=bash --trace follow --trace event=execve --output option:parse-arguments --output option:exec-env\n</code></pre> <pre><code>{\"timestamp\":1657294974430672155,\"threadStartTime\":620055219867435,\"processorId\":11,\"processId\":2531912,\"cgroupId\":1,\"threadId\":2531912,\"parentProcessId\":2490011,\"hostProcessId\":2531912,\"hostThreadId\":2531912,\"hostParentProcessId\":2490011,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"bash\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"59\",\"eventName\":\"execve\",\"argsNum\":3,\"returnValue\":0,\"stackAddresses\":null,\"args\":[{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"/bin/ls\"},{\"name\":\"argv\",\"type\":\"const char*const*\",\"value\":[\"ls\"]},{\"name\":\"envp\",\"type\":\"const char*const*\",\"value\":[\"SHELL=/bin/bash\",\"COLORTERM=truecolor\",\"LESS=-RF --mouse\",\"HISTCONTROL=ignoreboth\",\"HISTSIZE=1000000\",\"DEBFULLNAME=Rafael David Tinoco\",\"EDITOR=nvim\",\"PWD=/home/rafaeldtinoco/work/ebpf/tracee\",\"LOGNAME=rafaeldtinoco\",\"DEB_BUILD_PROFILES=parallel=36 nocheck nostrip noudeb doc\",\"LINES=82\",\"HOME=/home/rafaeldtinoco\",\"LANG=C.UTF-8\",\"COLUMNS=106\",\"MANROFFOPT=-c\",\"DEBEMAIL=rafaeldtinoco@ubuntu.com\",\"LC_TERMINAL=iTerm2\",\"PROMPT_COMMAND=echo -ne \\\"\\\\033]0;$what\\\\007\\\"; history -a\",\"BAT_THEME=GitHub\",\"TERM=screen-256color\",\"USER=rafaeldtinoco\",\"GIT_PAGER=batcat --theme=\\\"GitHub\\\" -p --pager=less --tabs 0\",\"MANPAGER=bash -c 'col -bx | batcat --theme=\\\"GitHub\\\" -l man -p'\",\"LC_TERMINAL_VERSION=3.5.0beta5\",\"DEB_BUILD_OPTIONS=parallel=36 nocheck nostrip noudeb doc\",\"SHLVL=2\",\"PAGER=batcat --theme=\\\"GitHub\\\" -p --pager=less --tabs 0\",\"BAT_STYLE=plain\",\"PROMPT_DIRTRIM=2\",\"SYSTEMD_PAGER=batcat --theme=\\\"GitHub\\\" -p --pager=less --tabs 0\",\"LC_CTYPE=C.UTF-8\",\"LESS_HISTFILE=/dev/null\",\"PS1=\\\\u@\\\\h \\\\w $ \",\"PATH=/home/rafaeldtinoco/bin:/home/rafaeldtinoco/go/bin:.:/sbin:/bin:/usr/sbin:/usr/bin:/snap/bin:/snap/sbin:/usr/local/bin:/usr/local/sbin:/usr/games/\",\"HISTFILESIZE=1000000\",\"DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus\",\"SSH_TTY=/dev/pts/3\",\"OLDPWD=/home/rafaeldtinoco\",\"_=/bin/ls\"]}]}\n</code></pre> <p>As  you can see, from the execve event we can also see the process environment variables in place:</p> <pre><code>{\"name\":\"envp\",\"type\":\"const char*const*\",\"value\":[\"SHELL=/bin/bash\",\"COLORTERM=truecolor\",\"LESS=-RF --mouse\",\"HISTCONTROL=ignoreboth\",\"HISTSIZE=1000000\",\"DEBFULLNAME=Rafael David Tinoco\",\"EDITOR=nvim\",\"PWD=/home/rafaeldtinoco/work/ebpf/tracee\",\"LOGNAME=rafaeldtinoco\",\"DEB_BUILD_PROFILES=parallel=36 nocheck nostrip noudeb doc\",\"LINES=82\",\"HOME=/home/rafaeldtinoco\",\"LANG=C.UTF-8\",\"COLUMNS=106\",\"MANROFFOPT=-c\",\"DEBEMAIL=rafaeldtinoco@ubuntu.com\",\"LC_TERMINAL=iTerm2\",\"PROMPT_COMMAND=echo -ne \\\"\\\\033]0;$what\\\\007\\\"; history -a\",\"BAT_THEME=GitHub\",\"TERM=screen-256color\",\"USER=rafaeldtinoco\",\"GIT_PAGER=batcat --theme=\\\"GitHub\\\" -p --pager=less --tabs 0\",\"MANPAGER=bash -c 'col -bx | batcat --theme=\\\"GitHub\\\" -l man -p'\",\"LC_TERMINAL_VERSION=3.5.0beta5\",\"DEB_BUILD_OPTIONS=parallel=36 nocheck nostrip noudeb doc\",\"SHLVL=2\",\"PAGER=batcat --theme=\\\"GitHub\\\" -p --pager=less --tabs 0\",\"BAT_STYLE=plain\",\"PROMPT_DIRTRIM=2\",\"SYSTEMD_PAGER=batcat --theme=\\\"GitHub\\\" -p --pager=less --tabs 0\",\"LC_CTYPE=C.UTF-8\",\"LESS_HISTFILE=/dev/null\",\"PS1=\\\\u@\\\\h \\\\w $ \",\"PATH=/home/rafaeldtinoco/bin:/home/rafaeldtinoco/go/bin:.:/sbin:/bin:/usr/sbin:/usr/bin:/snap/bin:/snap/sbin:/usr/local/bin:/usr/local/sbin:/usr/games/\",\"HISTFILESIZE=1000000\",\"DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus\",\"SSH_TTY=/dev/pts/3\",\"OLDPWD=/home/rafaeldtinoco\",\"_=/bin/ls\"]}\n</code></pre> </li> <li> <p>option:exec-hash</p> <p>This is a special output option for sched_process_exec so user can get the file hash and process ctime (particularly interesting if you would like to compare executed binaries from a list of known hashes, for example).</p> <pre><code>$ sudo ./dist/tracee-ebpf --output json --trace comm=bash --trace follow --trace event=sched_process_exec --output option:parse-arguments --output option:exec-hash\n</code></pre> <pre><code>{\"timestamp\":1657295236470126167,\"threadStartTime\":620317257297855,\"processorId\":3,\"processId\":2578324,\"cgroupId\":1,\"threadId\":2578324,\"parentProcessId\":2578238,\"hostProcessId\":2578324,\"hostThreadId\":2578324,\"hostParentProcessId\":2578238,\"userId\":1000,\"mountNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"exa\",\"hostName\":\"fujitsu\",\"containerId\":\"\",\"containerImage\":\"\",\"containerName\":\"\",\"podName\":\"\",\"podNamespace\":\"\",\"podUID\":\"\",\"eventId\":\"707\",\"eventName\":\"sched_process_exec\",\"argsNum\":14,\"returnValue\":0,\"stackAddresses\":null,\"args\":[{\"name\":\"cmdpath\",\"type\":\"const char*\",\"value\":\"/bin/exa\"},{\"name\":\"pathname\",\"type\":\"const char*\",\"value\":\"/usr/bin/exa\"},{\"name\":\"argv\",\"type\":\"const char**\",\"value\":[\"exa\",\"--color=auto\"]},{\"name\":\"dev\",\"type\":\"dev_t\",\"value\":271581185},{\"name\":\"inode\",\"type\":\"unsigned long\",\"value\":2493759},{\"name\":\"invoked_from_kernel\",\"type\":\"int\",\"value\":0},{\"name\":\"ctime\",\"type\":\"unsigned long\",\"value\":1653730234432691496},{\"name\":\"stdin_type\",\"type\":\"string\",\"value\":\"S_IFCHR\"},{\"name\":\"inode_mode\",\"type\":\"umode_t\",\"value\":33261},{\"name\":\"interp\",\"type\":\"const char*\",\"value\":\"/bin/exa\"},{\"name\":\"interpreter_pathname\",\"type\":\"const char*\",\"value\":\"/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2\"},{\"name\":\"interpreter_dev\",\"type\":\"dev_t\",\"value\":271581185},{\"name\":\"ineterpreter_inode\",\"type\":\"unsigned long\",\"value\":2752590},{\"name\":\"sha256\",\"type\":\"const char*\",\"value\":\"\"}]}\n</code></pre> <p>At the end of the event, you will also get information about the loader </p> </li> </ol>","title":"Tracing Output Options"},{"location":"tutorials/deploy-grafana-dashboard/","text":"<p>Grafana is a visualization tools for exported metrics and logs, most commomly used alongside prometheus.</p> <p>Since version 0.7.0, tracee exports useful runtime metrics to prometheus.</p> <p>These metrics exports are enabled by default in all docker images and can be enabled using the <code>--metrics</code> flag in both tracee-ebpf and tracee-rules.</p> <p>By using grafana and the new metrics from tracee, we can deploy a simple dashboard which tracks your tracee's instance performance and outputs.</p>","title":"Deploy Grafana Dashboard"},{"location":"tutorials/deploy-grafana-dashboard/#prequisites","text":"<p>The following tools must be available for use, they can all be installed either through docker or installed/built on your machine.</p> <ul> <li>Tracee</li> <li>Prometheus</li> <li>Grafana</li> </ul>","title":"Prequisites"},{"location":"tutorials/deploy-grafana-dashboard/#run-tracee-with-metrics-enabled","text":"<p>Tracee can be most easily deployed with metrics enabled by default and port forwarded through the following commands:</p> <pre><code>$ docker run \\\n    --name tracee --rm --pid=host \\\n    --cgroupns=host --privileged \\\n    -v /tmp/tracee:/tmp/tracee  \\\n    -v /etc/os-release:/etc/os-release-host:ro \\\n    -e LIBBPFGO_OSRELEASE_FILE=/etc/os-release-host \\\n    -it -p 3366:3366 -p 4466:4466 aquasec/tracee:v0.8.1\n</code></pre> <p>Of course, the forwarded metrics ports can be changed, but you should note that some of the later instructions depend on these ports.</p> <p>If running Tracee locally through built binaries, the metrics address may be overriden with the <code>--metrics-addr</code> flag in both tracee-ebpf and tracee-rules.</p>","title":"Run Tracee with Metrics Enabled"},{"location":"tutorials/deploy-grafana-dashboard/#run-prometheus-and-configure-it-to-scrape-tracee","text":"<p>Install prometheus or pull it's docker image. Then create the following configuration file, call it <code>prometheus.yml</code> to scrape Tracee:</p> <pre><code># A scrape configuration containing exactly one endpoint to scrape:\n# Here it's Tracee.\nscrape_configs:\n  # The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.\n  - job_name: 'prometheus'\n\n    # Override the global default and scrape targets from this job every 5 seconds.\n    scrape_interval: 5s\n\n    #Scrape tracee-ebpf's and tracee-rules's default metrics hosts.\n    #If forwarding different ports make sure to change these addresses.\n    static_configs:\n      - targets: ['localhost:3366', 'localhost:4466']\n</code></pre> <p>We must then start prometheus with the following command:</p> <pre><code>prometheus --config.file=/path/to/prometheus.yml\n</code></pre> <p>Or alternatively with docker:</p> <pre><code>docker run -p 9090:9090 -v /path/to/config:/etc/prometheus prom/prometheus\n</code></pre> <p>Then, try to access prometheus through <code>http://localhost:9090</code>. If succesful, move to the next step, otherwise consult with prometheus documentation.</p>","title":"Run Prometheus and Configure it to Scrape Tracee"},{"location":"tutorials/deploy-grafana-dashboard/#run-grafana-to-display-tracees-prometheus-metrics","text":"<p>After succesfuly deploying Tracee and Prometheus we may now run Grafana to visualize it's metrics.</p> <p>Install grafana using their instructions and enter the now available grafana website (by default it's usually through http://localhost:3000).</p> <p>After entering the website, logging in with username and password <code>admin</code> (and changing your password if you wish), you should see the homepage:</p> <p></p> <p>Add your data source by hovering the configuration tab (the gear icon), selecting \"Data Sources\" and pressing \"Add Data Source\" at the top left. Create a Prometheus Data Source and point it's URL to the relevant location (usually http://localhost:9090)</p> <p>You may now either create your own Dashboard or import our default dashboard.</p>","title":"Run Grafana to display Tracee's Prometheus Metrics"},{"location":"tutorials/deploy-grafana-dashboard/#import-tracees-default-dashboard","text":"<p>First download our Grafana Dashboard's json here.</p> <p>After adding the data source hover on the plus icon in the sidebar and select \"Import\". Press \"Upload JSON File\" at the top of the page and select the downloaded json from your file browser. Change the name and Dashboard UID if you wish and press \"Import\" to finish. </p> <p>Finally you will be redirected to the dashboard \ud83e\udd73</p>","title":"Import Tracee's Default Dashboard"},{"location":"tutorials/setup-development-machine-with-vagrant/","text":"<p>HashiCorp Vagrant leverages a declarative configuration file, which describes all software requirements, packages, operating system configuration, and users to provide the same development environment for everyone.</p> <p>The Vagrantfile describes the type of machine required to build Tracee from source and follow the Getting Started guides. This allows developers involved in the project to check out the code, run <code>vagrant up</code>, and be on their way.</p>","title":"Setup Development Machine with Vagrant"},{"location":"tutorials/setup-development-machine-with-vagrant/#prerequisites","text":"<ul> <li>Vagrant</li> <li>Hypervisor supported by Vagrant, such as VirtualBox.</li> </ul>","title":"Prerequisites"},{"location":"tutorials/setup-development-machine-with-vagrant/#create-development-machine","text":"<p>Clone and change directory to Tracee Git repository:</p> <pre><code>git clone --branch v0.8.1 https://github.com/aquasecurity/tracee.git\ncd tracee\n</code></pre> <p>Create and configure development machine according to the <code>Vagrantfile</code>:</p> <pre><code>vagrant up\n</code></pre> <p>If everything goes well, you can SSH into a running development machine and access its shell:</p> <pre><code>$ vagrant ssh\nWelcome to Ubuntu 21.10 (GNU/Linux 5.13.0-35-generic x86_64)\n\n * Documentation:  https://help.ubuntu.com\n * Management:     https://landscape.canonical.com\n * Support:        https://ubuntu.com/advantage\n\n  System information as of Sat Mar 26 18:08:08 UTC 2022\n\n  System load:  0.94               Processes:                153\n  Usage of /:   14.7% of 38.71GB   Users logged in:          1\n  Memory usage: 59%                IPv4 address for docker0: 172.17.0.1\n  Swap usage:   0%                 IPv4 address for enp0s3:  10.0.2.15\n\n\n9 updates can be applied immediately.\n9 of these updates are standard security updates.\nTo see these additional updates run: apt list --upgradable\n\n\nLast login: Sat Mar 26 17:14:16 2022 from 10.0.2.2\nvagrant@ubuntu-impish:~$\n</code></pre>  <p>Tip</p> <p>Provisioning from scratch take time, but once created you can reuse the machine with <code>vagrant halt</code> and <code>vagrant up</code> commands. If something goes wrong with your machine, there's also the <code>vagrant destroy</code> to destroy it and start over again.</p>  <p>Synced folders enable Vagrant to sync a folder on the host machine to the development machine, allowing you to continue working on your project's files on your host machine, but use the resources in the development machine to compile or run Tracee.</p> <p>By default, Vagrant will share Tracee project directory (the directory with the <code>Vagrantfile</code>) to <code>/vagrant</code>. To get started, change directory to <code>/vagrant</code> and list files:</p> <pre><code>$ ls -l\ntotal 204\ndrwxr-xr-x 1 vagrant vagrant    224 Mar 17 14:31 3rdparty\n-rw-r--r-- 1 vagrant vagrant   3474 Mar 17 14:31 CONTRIBUTING.md\n-rw-r--r-- 1 vagrant vagrant  11358 Mar 17 14:31 LICENSE\n-rw-r--r-- 1 vagrant vagrant  16529 Mar 25 07:46 Makefile\n-rw-r--r-- 1 vagrant vagrant    133 Mar 17 14:31 NOTICE\n-rw-r--r-- 1 vagrant vagrant   2116 Mar 26 16:41 RELEASING.md\n-rw-r--r-- 1 vagrant vagrant   4097 Mar 17 14:31 Readme.md\n-rw-r--r-- 1 vagrant vagrant   2732 Mar 26 16:41 Vagrantfile\ndrwxr-xr-x 1 vagrant vagrant    384 Mar 26 16:41 builder\ndrwxr-xr-x 1 vagrant vagrant    128 Dec 14 15:27 cmd\ndrwxr-xr-x 1 vagrant vagrant     96 Dec  8 14:20 deploy\ndrwxr-xr-x 1 vagrant vagrant    288 Mar 25 10:51 dist\ndrwxr-xr-x 1 vagrant vagrant    448 Mar 26 16:44 docs\n-rw-r--r-- 1 vagrant vagrant    164 Mar 17 14:31 embedded-ebpf.go\n-rw-r--r-- 1 vagrant vagrant    101 Mar 17 14:31 embedded.go\n-rw-r--r-- 1 vagrant vagrant   4382 Mar 24 14:13 go.mod\n-rw-r--r-- 1 vagrant vagrant 129439 Mar 24 14:13 go.sum\n-rw-r--r-- 1 vagrant vagrant   1546 Mar 26 18:20 mkdocs.yml\ndrwxr-xr-x 1 vagrant vagrant    256 Mar 22 14:08 packaging\ndrwxr-xr-x 1 vagrant vagrant    416 Mar 24 14:13 pkg\ndrwxr-xr-x 1 vagrant vagrant    192 Dec 14 13:02 signatures\ndrwxr-xr-x 1 vagrant vagrant    160 Mar 24 14:13 tests\ndrwxr-xr-x 1 vagrant vagrant    224 Mar 24 11:59 types\n</code></pre> <p>As you can see the <code>/vagrant</code> directory contains source code of Tracee cloned from GitHub.</p>","title":"Create Development Machine"},{"location":"tutorials/setup-development-machine-with-vagrant/#build-and-run-tracee-ebpf-and-tracee-rules","text":"<p>To build tracee-ebpf and tracee-rules executable binaries, run the default make target:</p> <pre><code>make\n</code></pre> <p>Build targets are saved in the <code>/vagrant/dist</code> directory:</p> <pre><code>$ ls -l dist/\ntotal 47972\ndrwxr-xr-x 1 vagrant vagrant       96 Mar 25 10:45 btfhub\ndrwxr-xr-x 1 vagrant vagrant      224 Mar 25 10:45 libbpf\ndrwxr-xr-x 1 vagrant vagrant      512 Mar 25 10:46 rules\n-rwxr-xr-x 1 vagrant vagrant 17876784 Mar 26 18:32 tracee-ebpf\n-rwxr-xr-x 1 vagrant vagrant 26982352 Mar 25 10:45 tracee-rules\ndrwxr-xr-x 1 vagrant vagrant      544 Mar 26 18:31 tracee.bpf\n-rw-r--r-- 1 vagrant vagrant  4232032 Mar 26 18:31 tracee.bpf.core.o\n</code></pre> <p>You can now run Tracee-eBPF and see raw events printed to the standard output in a tabular format:</p> <pre><code>$ sudo ./dist/tracee-ebpf\nTIME             UID    COMM             PID     TID     RET              EVENT                ARGS\n18:39:43:781824  0      mkdocs           1       19      0                stat                 pathname: /docs/docs, statbuf: 0x7f851365eb20\n18:39:43:782125  0      mkdocs           1       19      0                security_file_open   pathname: /docs/docs, flags: O_RDONLY|O_LARGEFILE|O_DIRECTORY, dev: 43, inode: 47, ctime: 1648313072000000000\n18:39:43:782008  0      mkdocs           1       19      6                open                 pathname: /docs/docs, flags: O_RDONLY|O_LARGEFILE|O_DIRECTORY|O_CLOEXEC, mode: 0\n18:39:43:783200  0      mkdocs           1       19      464              getdents64           fd: 6, dirp: 0x7f8513d8e0b8, count: 2048\n18:39:43:783232  0      mkdocs           1       19      0                getdents64           fd: 6, dirp: 0x7f8513d8e0b8, count: 2048\n18:39:43:783259  0      mkdocs           1       19      0                close                fd: 6\n18:39:43:783271  0      mkdocs           1       19      0                stat                 pathname: /docs/docs/architecture.md, statbuf: 0x7f851365e9b0\n18:39:43:783734  0      mkdocs           1       19      0                stat                 pathname: /docs/docs/install, statbuf: 0x7f851365e9b0\n18:39:43:784163  0      mkdocs           1       19      0                stat                 pathname: /docs/docs/images, statbuf: 0x7f851365e9b0\n18:39:43:784589  0      mkdocs           1       19      0                stat                 pathname: /docs/docs/integrations.md, statbuf: 0x7f851365e9b0\n18:39:43:784906  0      mkdocs           1       19      0                stat                 pathname: /docs/docs/faq.md, statbuf: 0x7f851365e9b0\n</code></pre> <p>To analyze collected events and see detections printed to the standard output, run tracee-ebpf and pipe it with tracee-rules:</p> <pre><code>$ sudo ./dist/tracee-ebpf \\\n  --output=format:gob \\\n  --output=option:parse-arguments \\\n  | ./dist/tracee-rules \\\n  --input-tracee=file:stdin \\\n  --input-tracee=format:gob\nLoaded 14 signature(s): [TRC-1 TRC-13 TRC-2 TRC-14 TRC-3 TRC-11 TRC-9 TRC-4 TRC-5 TRC-12 TRC-8 TRC-6 TRC-10 TRC-7]\n\n*** Detection ***\nTime: 2022-03-26T18:48:00Z\nSignature ID: TRC-2\nSignature: Anti-Debugging\nData: map[]\nCommand: strace\nHostname: ubuntu-impish\n</code></pre> <p>In this example, we run <code>strace ls</code> to trigger Anit-Debugging signature detection.</p>","title":"Build and Run Tracee-eBPF and Tracee-Rules"},{"location":"tutorials/setup-development-machine-with-vagrant/#switch-between-co-re-and-non-co-re-linux-distribution","text":"<p>By default, the development machine is running Ubuntu Linux 21.10 Impish Indri. You can see that it has a BTF-enabled kernel by checking the existence of the <code>/sys/kernel/btf/vmlinux</code> file.</p> <pre><code>Vagrant.configure(\"2\") do |config|\n  # config.vm.box = \"ubuntu/focal64\"     # Ubuntu 20.04 Focal Fossa (non CO-RE)\n  # config.vm.box = \"ubuntu/hirsute64\"   # Ubuntu 21.04 Hirsute Hippo (CO-RE)\n  config.vm.box = \"ubuntu/impish64\"      # Ubuntu 21.10 Impish Indri (CO-RE)\nend\n</code></pre> <p>Sometimes you may want to test Tracee with a non CO-RE distribution. You can do that by editing the Vagrantfile and modifying the <code>config.vm.box</code> property. For example, you can switch to Ubuntu Linux 20.04 Focal Fossa as follows:</p> <pre><code>Vagrant.configure(\"2\") do |config|\n  config.vm.box = \"ubuntu/focal64\"       # Ubuntu 20.04 Focal Fossa (non CO-RE)\n  # config.vm.box = \"ubuntu/hirsute64\"   # Ubuntu 21.04 Hirsute Hippo (CO-RE)\n  # config.vm.box = \"ubuntu/impish64\"    # Ubuntu 21.10 Impish Indri (CO-RE)\nend\n</code></pre> <p>This change requires reprovisioning the development machine:</p> <pre><code>vagrant destroy\nvagrant up\n</code></pre>  <p>Attention</p> <p>Ubuntu Focal distribution has introduced BTF information to their recent kernels, allowing eBPF CO-RE capable code to run. If you're willing to test non CO-RE kernels, make sure to use an older kernel that does not provide the <code>/sys/kernel/btf/vmlinux</code> file.</p>","title":"Switch Between CO-RE and non CO-RE Linux Distribution"},{"location":"tutorials/setup-development-machine-with-vagrant/#deploy-tracee-with-postee-on-kubernetes","text":"<p>The development machine described by Vagrantfile preinstalls MicroK8s Kubernetes cluster, which is suitable for testing Tracee.</p> <pre><code>$ microk8s status\nmicrok8s is running\nhigh-availability: no\n  datastore master nodes: 127.0.0.1:19001\n  datastore standby nodes: none\n</code></pre> <p>There's also the kubectl command installed and configured to communicate with the cluster:</p> <pre><code>$ kubectl get nodes -o wide\nNAME            STATUS   ROLES    AGE    VERSION                    INTERNAL-IP   EXTERNAL-IP   OS-IMAGE       KERNEL-VERSION      CONTAINER-RUNTIME\nubuntu-impish   Ready    &lt;none&gt;   139m   v1.23.4-2+98fc2022f3ad3e   10.0.2.15     &lt;none&gt;        Ubuntu 21.10   5.13.0-35-generic   containerd://1.5.9\n</code></pre> <p>Create a new namespace called <code>tracee-system</code>:</p> <pre><code>kubectl create ns tracee-system\n</code></pre> <p>Create Postee Persistent Volumes and StatefulSet in the <code>tracee-system</code> namespace:</p> <pre><code>kubectl apply -n tracee-system \\\n  -f https://raw.githubusercontent.com/aquasecurity/postee/v2.2.0/deploy/kubernetes/hostPath/postee-pv.yaml \\\n  -f https://raw.githubusercontent.com/aquasecurity/postee/v2.2.0/deploy/kubernetes/postee.yaml\n</code></pre> <p>Create Tracee DaemonSet in the <code>tracee-system</code>, which is preconfigured to print detections to the standard output and send them over to Postee webhook on http://postee-svc:8082:</p> <pre><code>kubectl apply -n tracee-system -f deploy/kubernetes/tracee-postee/tracee.yaml\n</code></pre>  <p>Tip</p> <p>To test code that hasn't been released yet do the following:</p> <ol> <li>Build the <code>tracee:latest</code> container image from the current Git revision:    <pre><code>make -f builder/Makefile.tracee-container build-tracee\n</code></pre></li> <li>Import the container image to MicroK8s registry:    <pre><code>docker image save -o /tmp/tracee-latest.tar tracee:latest\nmicrok8s ctr images import /tmp/tracee-latest.tar\nrm /tmp/tracee-latest.tar\n</code></pre></li> <li>Create Tracee DaemonSet using <code>tracee:latest</code> as container image:    <pre><code>kubectl apply -n tracee-system -k deploy/kubernetes/tracee-postee\n</code></pre></li> </ol>  <p>While Tracee pod is running, run <code>strace ls</code> command and observe detection printed to the standard output.</p> <pre><code>$ kubectl logs n tracee-system -f daemonset/tracee\nINFO: probing tracee-ebpf capabilities...\nINFO: starting tracee-ebpf...\nINFO: starting tracee-rules...\nLoaded 14 signature(s): [TRC-1 TRC-13 TRC-2 TRC-14 TRC-3 TRC-11 TRC-9 TRC-4 TRC-5 TRC-12 TRC-8 TRC-6 TRC-10 TRC-7]\nServing metrics endpoint at :3366\n\n*** Detection ***\nTime: 2022-03-29T08:26:32Z\nSignature ID: TRC-2\nSignature: Anti-Debugging\nData: map[]\nCommand: strace\nHostname: ubuntu-impish\n</code></pre> <p>If everything is configured properly, you can find the same detection in Postee logs:</p> <pre><code>$ kubectl -n tracee-system logs -f postee-0\n2022/03/29 08:26:32 {\"Data\":null,\"Context\":{\"timestamp\":1648542392170684298,\"processorId\":1,\"processId\":90731,\"threadId\"\n:90731,\"parentProcessId\":90729,\"hostProcessId\":90731,\"hostThreadId\":90731,\"hostParentProcessId\":90729,\"userId\":1000,\"mou\nntNamespace\":4026531840,\"pidNamespace\":4026531836,\"processName\":\"strace\",\"hostName\":\"ubuntu-impish\",\"containerId\":\"\",\"ev\nentId\":\"101\",\"eventName\":\"ptrace\",\"argsNum\":4,\"returnValue\":0,\"stackAddresses\":null,\"args\":[{\"name\":\"request\",\"type\":\"st\nring\",\"value\":\"PTRACE_TRACEME\"},{\"name\":\"pid\",\"type\":\"pid_t\",\"value\":0},{\"name\":\"addr\",\"type\":\"void*\",\"value\":\"0x0\"},{\"n\name\":\"data\",\"type\":\"void*\",\"value\":\"0x0\"}]},\"SigMetadata\":{\"ID\":\"TRC-2\",\"Version\":\"0.1.0\",\"Name\":\"Anti-Debugging\",\"Descr\niption\":\"Process uses anti-debugging technique to block debugger\",\"Tags\":[\"linux\",\"container\"],\"Properties\":{\"MITRE ATT\\\nu0026CK\":\"Defense Evasion: Execution Guardrails\",\"Severity\":3}}}\n</code></pre> <p>As an alternative to static deployment descriptors you can install Tracee and Postee with Helm:</p> <pre><code>helm repo add aqua-charts https://aquasecurity.github.io/helm-charts\nhelm dependency update ./deploy/helm/tracee\nhelm install tracee ./deploy/helm/tracee \\\n  --namespace tracee-system --create-namespace \\\n  --set hostPID=true \\\n  --set postee.enabled=true\n</code></pre>","title":"Deploy Tracee with Postee on Kubernetes"},{"location":"tutorials/setup-development-machine-with-vagrant/#access-kubernetes-dashboard","text":"<p>Use the following command to get the token required to log in to the Kubernetes Dashboard:</p> <pre><code>kubectl -n kube-system describe secret \\\n  $(kubectl -n kube-system get secret | grep default-token | cut -d \" \" -f1)\n</code></pre> <p>Forward port 10443 in the development machine to the Kubernetes Dashboard's pod:</p> <pre><code>kubectl port-forward --address 0.0.0.0 -n kube-system service/kubernetes-dashboard 10443:443\n</code></pre> <p>Since port 10443 is forwarded to port 10443 on your host, you can open your browser to https://localhost:10443 and access Kubernetes Dashboard.</p>  <p>Warning</p> <p>Modern browser usually block insecure localhost TLS connections. For Google Chrome you may allow insecure TLS connections at chrome://flags/#allow-insecure-localhost.</p>","title":"Access Kubernetes Dashboard"},{"location":"tutorials/setup-development-machine-with-vagrant/#preview-tracee-documentation","text":"<p>You can run MkDocs server and preview documentation on your host:</p> <pre><code>make -f builder/Makefile.mkdocs\n</code></pre> <p>The development machine is running the MkDocs server listening on port 8000, which is forwarded to port 8000 on your host. Therefore, you can open your browser to http://localhost:8000 and access documentation pages.</p>","title":"Preview Tracee Documentation"}]}